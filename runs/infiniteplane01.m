%{
filename history:
A201808080131_radialcomp.m
A201808081235_radialcomp.m
A201808081253_surfaceswitchcheck.m
A201808081431_surfaceswitchcheck.m
A201808081443_surfaceswitchcheck.m
A201808091000_radialwithcheck.m
A201808091206_implicitintervention.m
A201808101237_implicitintervention.m
A201808101237r_implicitintervention.m
A201808131129_energyabsorbingtestbed.m
A201808141202_energyabsorbingtestbed.m
A201808141353_energyabsorbingtestbed.m
A201808141528_addingBCdamping.m
A201808161121_addingBCdamping.m
A201808161209_highdamping.m
A201808161302_negateloadweight.m
A201808161532_variablesize.m
A201808171611_lvarnotdone.m
A201808171612_lvarnotdone.m
A201808211557.m
A201808182107.m
A201808212240.m
A201808221012.m
A201808222034.m
A201808222100.m
A201808222226.m
A201808222243.m
A201808222354.m
A201808230152.m
A201808230353.m
A201808271153.m
A201808271529.m
A201808271534_prototype.m
A201808271656.m
A201808281513r.m
A201808291226.m
A201808291608.m
A201808311706.m
A201808311824.m
A201808311837.m
A201809031006.m
A201809031615.m
A201809031627.m
A201809032217.m
A201809041034.m
A201809041319.m
A201809041432.m
A201809041828.m
A201809042049.m
A201809050037.m
A201809051048.m
A201809051117.m
A201809051358.m
A201809051638.m
A201809051638r.m
A201809060946.m
A201809061129.m
A201809061228.m
A201809061533.m
A201809071154.m
A201809071234.m
A201809071300.m
A201809100120.m
A201809101209.m
A201809101224.m
A201809110935.m
A201809110959.m
A201809111400.m
A201809121500.m
A201809121519.m
A201809121708.m
A201809131706.m
A201809131722.m
A201809131726.m
A201809141041.m
A201809141214.m
A201809141319.m
A201809141634.m
A201809151714.m
A201809151902.m
A201809151902test.m
A201809151902test2.m
A201809181043errtrack.m
A201809181053.m
A201809181103.m
A201809182008.m
A201809182039.m
A201809182102.m
A201809191329.m
A201809191408.m
A201809191520.m
A201809191612.m double knots
A201809201734.m
A201809210941.m MPM beef up
A201809211059.m MPM beef up
A201809211556.m less aggressive alpha widening
A201809240925.m substepped implicit multisurface
A201809251447.m MPM beefed up max, less disp
A201809251504.m CPDI multiknot fine
A201809260947.m
A201809261239.m
A201809261253.m
A201809261323test.m
A201809261357test.m
A201809261402test.m
A201809261453test.m
A201809261512test.m
A201809261556.m
A201809261627.m
A201809261707.m
A201809261723.m
A201809261723r.m
A201809261825.m
A201809261929.m
A201809262145.m
A201809270017.m
A201809271053.m
A201809271245.m
A201809271328.m
A201809281319.m
A201809281530.m
A201809281619.m
A201810011356.m
A201810011554.m
A201810021303.m
A201810021351.m
A201810021626.m
A201810022107.m
A201810022112.m
A201810022112s.m
A201810030928.m
A201810031010.m
A201810031343.m
A201810031343r.m
A201810031419.m
A201810031602.m
A201810031602r.m
A201810031732.m
A201810031542.m
A201810051542.m
A201810051634.m
A201810081106.m
A201810081505.m
A201810081555.m
A201810081628.m
A201810081705.m
A201810080952.m
A201810081009.m
A201810091050.m
A201810091056.m
A201810091512.m
A201810101007.m
A201810101436.m
A201810101510.m
A201810101702.m
A201810111247.m
A201810121045.m
A201810142323.m
A201810151157.m
A201810151222_stacktest.m
A201810151637.m
A201810152136.m
A201810152146.m
A201810161435.m
A201810161849.m
A201810201837.m
A201810220946.m
A201810221000.m
A201810221017.m
A201810221039.m
A201810221039d.m
A201810231005a.m
A201810261503.m
A201810282119.m
A201810291550.m
A201810300950.m
A201810301007.m
A201810301254.m
A201810311918.m
A201810311918b.m
A201810312112.m
A201811011101.m
A201811011152.m
A201811011205.m
A201811011618.m
A201811011643.m
A201811012016.m
A201811020717.m
A201811042146.m
A201811042314.m
A201811051929.m
A201811061124.m
A201811062004.m
A201811062035.m
A201811062100.m
A201811070924.m
A201811071424.m
A201811071424b.m
A201811071424c.m
A201811071528.m
A201811071528b.m
A201811071953.m
A201811072003.m
A201811072003b.m
A201811072142.m
A201811081015.m
A201811081440.m
A201811081623.m
A201811091407.m
A201811091407b.m
A201811131153.m
A201811132228.m
A201811140929.m
A201811140929b.m
A201811140929c.m
A201811150053.m
A201811150938.m
A201811161454.m
A201811231516.m
A201811231516r.m
A201811231517.m
A201811262259.m
A201811270836.m
A201811301927.m
A201811301927sp.m
A201812031254.m
A201812031450.m
A201812040909.m
A201812040909r.m
A201812041055.m
A201812041219r.m
A201812041350.m
A201812041406.m
A201812041412.m
A201812041419.m
A201812041706.m
A201812041930.m
A201812042222.m
A201812050718.m
A201812051001.m
A201812051347.m
A201812071009.m
A201812071100.m
A201812091848.m
A201812091930.m
A201812092308.m
A201812092318.m
A201812100017.m
A201812101339.m
A201812101339u.m
A201812131734.m
A201812211723.m
A201812211723b.m
A201812211723c.m
A201812211723d.m
A201812311458.m
A201812311720.m
A201901020929.m
A201901021709.m
A201901032044.m
A201901041406.m
A201901041409.m
A201901041434.m
A201901082234.m
A201901082234b.m
A201901091054.m
A201901101121.m
A201901171748.m
A201901281623.m
A201901291500.m
A201901292050.m
A201901292112.m
A201901292120.m
zz1902022104.m
zz1902022104b.m
zz1902022155.m
zz1902041658.m
zz1902041931.m
zz1902050956.m
zz1902051009.m
zz1902051013.m
zz1902051022.m
zz1902051047.m
zz1902051105.m
zz1902051106.m
zz1902051116.m
zz1902051125.m
zz1902051232.m
zz1902051624.m
zz1902051851.m
zz1902051951.m
zz1902052132.m
zz1902052221.m
zz1902061151.m
zz1902061443.m
zz1902061506.m
zz1902061613.m
zz1902061935.m
zz1902061950.m successful one crack crackparticles only
zz1902062058.m start trying tracking crack surfaces
zz1902062104.m
zz1902062218.m
zz1902062247.m
zz1902111654.m
zz1902112016.m
zz1902112217.m
zz1902121052.m
zz1902121216.m
zz1902121751.m
zz1902122004.m
zz1902122103.m
zz1902122213.m
zz1902122223.m
zz1902122254.m
zz1902122304.m
zz1902130721.m
zz1902130816.m
zz1902192203.m
zz1902201635.m
zz1902201732.m
zz1902211108.m
zz1902211220.m
zz1902211232.m
zz1902211237.m
zz1902211246.m
zz1902211508.m
zz1902211610.m
zz1902211621.m
zz1902211628.m
zz1902211723.m
zz1902211734.m
zz1902211738.m
zz1902221308.m
zz1902221720.m
zz1902232223.m
zz1902232223b.m
zz1902232231.m
zz1902232329.m
zz1902251139.m
zz1902251230.m
zz1902251627.m
zz1902251724.m
zz1902251808.m
zz1902251835.m
zz1902251848.m
zz1902252014.m
zz1902252026.m
zz1902252111.m
zz1902252121.m
zz1902252322.m
zz1902252326.m
zz1902260108.m - open for 90 degs, shrink all directions
zz1902261208.m - open for 90 degs, shrink x only
zz1902261235.m - ramp shrink xy
zz1892261256.m - ramp shrink x only
zz1902261657.m - ramp shrink xy small initial (case 71)
zz1902261936.m - J central adjustable
zz1902261952.m - J central adjustable 1.4 shorter
zz1902262324.m - J central adjustable shrink xy very small initial
zz1902271135.m - field split error investigation
zz1902271233.m - field split error handled, bottom still roller, plot both with/without crack
zz1902271301.m - field split error handled, bottom fixed, plot both with/without crack (wrong bottom fixing)
zz1902271432.m - bottom fixed properly
zz1903031617.m - crack initiation stress roller bottom
zz1903031714.m - crack initiation stress roller bottom create x_crack
zz1903041235.m - fixing things up
zz1903041241.m
zz1903041253.m
zz1903041336.m
zz1903061744.m
zz1903061758.m
zz1903071256.m
zz1903071452.m
zz1903071722.m
zz1903071858.m
zz1903081146.m
zz1903081214.m
zz1903081239.m
zz1903081531.m
zz1903081755.m
zz1903081807.m
zz1903081817.m
zz1903081904.m
zz1903081930.m
zz1903111237.m - trying 9 particles
zz1903111301.m - outputting f_final_vect for cracked particles
zz1903111441.m - diagonal crack investigation (code gutted)
zz1903111747.m - proper direction identification
zz1903120006.m - retrying ParticlePull with proper h
zz1903121027.m - extracting inputs for particlepull
zz1903121056.m - extracting inputs for particlepull
zz1903121118.m - retrying ParticlePull from faulty input
zz1903121551.m - angled, it's just how it is, plot sx and sy please
zz1903121604.m - tt start simulation and tt start plotting
zz1903121618.m - investigate spurious with point pull again
zz1903121805.m - 2 particles per cell, plane stress
zz1903121825.m - plane strain, no damping
zz1903131252.m - initial discrete crack, Q propagation
zz1903131704.m - particle just cracked list
zz1903131842.m - averaging and propagating
zz1903131843.m - averaging and propagating
zz1903131844.m - averaging and propagating
zz1903150109.m - running from start again
zz1903150110.m - running from start again
zz1903150111.m
zz1903150112.m
zz1903150337.m
zz1903181513.m
zz1903181759.m
zz1903181842.m
zz1903181843.m
zz1903181844.m
zz1903181845.m
zz1903191659.m
zz1903191818.m
zz1903221549.m
zz1903221550.m
zz1903251803.m
zz1903251830.m
zz1903252115.m
zz1903252302.m
zz1903271338.m
zz1903271407.m
zz1893271700.m
zz1903271700.m
zz1903271725.m
zz1903271849.m
zz1903271954.m
zz1903272005.m
zz1903272035.m
zz1903272053.m
zz1903281506.m
zz1903281644.m
zz1903281659.m
zz1903281723.m
zz1903281731.m
zz1903281901.m
zz1903281905.m
zz1903281945.m
zz1903281945b.m - field split investigation
zz1903281945c.m - field split investigation
zz1903282057.m
zz1904011223.m
zz1904022301.m
zz1904081354.m
zz1904081718.m
zz1904081734.m
zz1904081846.m
zz1904091154.m
zz1904091344.m
zz1904091443.m
zz1904091527.m
zz1904091902.m
zz1904091908.m
zz1904091910.m
zz1904092008.m
zz1904092120.m
zz1904092203.m
zz1904092215.m
zz1904101330.m
zz1904101635.m
zz1904101705.m
zz1904101713.m
zz1904101733.m
zz1904101737.m
zz1904101807.m
zz1904101939.m
zz1904101939b.m
zz19041012002.m
zz19041012038.m
zz19041012038b.m
zz1904102104.m
zz1904102134.m
zz1904102208.m
zz1904102234.m
zz1904102347.m
zz1904111257.m
zz1904111652.m
zz1904111704.m
zz1904111735.m
zz1904111747.m
zz1904112005.m
zz1904112132.m
zz1904112132b.m
zz1904112236.m
zz1904112314.m
zz1904112315.m
zz1904121053.m
zz1904121618.m
zz1904121647.m
zz1904121926.m
zz1904122012.m
zz1904131822.m
zz1904151212.m
zz1904151212b.m
zz1904151212c.m
zz1904151212d.m
zz1904151212e.m
zz1904151614.m
zz1904151615.m
zz1904151616.m
zz1904151617.m
zz1904151618.m
zz1904151619.m
zz1904151620.m
zz1904160051.m
zz1904160112.m
zz1904160112b.m
zz1904161308.m
zz1904161309.m
zz1904161310.m
zz1904161311.m
zz1904161312.m
zz1904161313.m
zz1904161314.m
zz1904161314b.m
zz1904161314c.m
zz1904161314d.m
zz1904171323.m
zz1904171324.m
zz1904171325.m
zz1904171651.m
zz1904171652.m
zz1904171653.m
zz1904171654.m
zz1904171655.m
zz1904171656.m
zz1904172242.m
zz1904172242b.m
zz1904181331.m
zz1904181649.m
zz1904182007.m
zz1904182233.m
zz1904190010.m
zz1904191228.m
zz1904191748.m
zz1904191749.m
zz1904191750.m
zz1904191751.m
zz1904231852.m
zz1904231853.m
zz1904231854.m
zz1904231855.m
zz1904241226.m
zz1904241227.m
zz1904241227p.m
zz1904251505.m
zz1904251516.m
zz1904251700.m
zz1904251714.m
zz1904251715.m
zz1904252212.m
zz1904252318.m
zz1904252319.m
zz1904252320.m
zz1904252321.m
zz1904252322.m
zz1904252323.m
zz1904252324.m
zz1904291659.m
zz1904301319.m
zz1904302107.m
zz1905021642.m
zz1905021713.m
zz1905021756.m
zz1905021758.m
zz1905021817.m
zz1905022102.m
zz1905061348.m
zz1905061714.m
zz1905061743.m
zz1905071307.m
zz1905071308.m
zz1905071309.m %retrieving sigmainf
zz1905071310.m %retrieving sigmainf
zz1905071634.m
zz1905080010.m
zz1905080011.m
zz1905080012.m
zz1905080013.m
zz1905080014.m
zz1905080015.m
zz1905101323.m
zz1905101324.m
zz1905101325.m
zz1905101326.m
zz1905132236.m
zz1905132300.m
zz1905141832.m
zz1905141832main.m

insert new file history here
%}
%{
function ParticlePull()
	dESP=[0.001 0;0 0.00];
	sigma_global_big=[ 0, 0, 0, 0, 0, 0];
	e_t_global_big=[ 0, 0, 0, 0, 0, 0];
	e_pl_global_big=[ 0, 0, 0, 0, 0, 0];
	alpha_in=[ 0, 0, 0, 0, 0, 0, 0];
	xdirletter='t';
	ydirletter='r';
	zdirletter='l';
	xydirletter='tr';
	yzdirletter='rl';
	xzdirletter='tl';
    dudx_rtl=dESP;
	
	%input override from the real one
    %{
	dESP=[                0.0000092273517047498537947810767767542, -0.000000000000000000029876886326961723138418417955969; -0.000000000000000000029876886326961723138418417955969,                0.0000022292111761709296263646740837716];
	sigma_global_big=[ 2.627556919609589591857456980506, 0.92505782873414932332423177285818, 1.5986766367546838552016197354533, -0.00000000000000015427464434694612636524586431389, 0, 0];
	e_t_global_big=[ 0.0055397858013045749719927002274744, -0.00039292443354643563028366637368549, 0, -0.0000000000000000038568661086736565487678487293823, 0, 0];
	e_pl_global_big=[ 0, -0.0000000000000000011384122811097796557078254409134, -0.000000000000000000099083023677830163349792639533181, -3.0814879110195773648895647081359e-33, 0, 0];
	alpha_in=[ 0, 0, 0, 0, 0, 0, 0];
	dudx_rtl=[                0.0036774742874255972324704089260194, 0.000000000000000020968140727901620878357464091193; -0.000000000000000028536079657031517936656558982959,              -0.0022579939820457362031902448507026];
	xdirletter =    't'
	ydirletter =    'r'
	zdirletter =    'l'
	xydirletter =    'tr'
	yzdirletter =    'rl'
	xzdirletter =    'tl'
    %}
	%end of input override from the real one
	
	ftl=65.5;
	ftr=3.75;
	ftt=2.79;
	fcl=-50.3;
	fcr=-2.75;
	fct=-5;
	fvrt=1.83;
	fvrl=6.34;
	fvtl=5.34;
	Er=820;
	Et=430;
	El=13200;
	Grt=40;
	Gtl=730;
	Grl=660;
	nurt=0.24;
	nutl=0.45;
	nurl=0.45;
	kappa1=0.00001;
	kappa2=1.2;
	kappa3=0.00001;
	kappa4=1.2;
	kappa5=0.00001;
	kappa6=0.7;
	kappa7=1.0;
	Gftl=1.65;
	Gfcl=50.0;
	Gftr=0.3;
	Gftt=0.3;
	Gfcr=9.0909090909090909090909090909091;
	Gfct=9.0909090909090909090909090909091;
	GII=0.3;
	Hld=15.0;
	Hrd=2.0;
	Htd=2.0;
	lc=8.3333333333333333333333333333333;
	alpha2dnounit=0.1;
	alpha2maxnounit=0.75;
	alpha4dnounit=0.1;
	alpha4maxnounit=0.75;
	alpha6dnounit=0.5;
	alpha6maxnounit=0.75;
	alpha7dnounit=1.0;
	alpha7maxnounit=1.5;
	CasetoRun=-99;
	t=0;
	dt=0.00019462473604038075625059789341975;
	spid=1;
	Debugging.Active= 0;
	Debugging.Case= 25;
	Debugging.FileName= 'A201810121045-GerhardMultiManualEllipse-ms=100-Dump.mat';
	Debugging.Time= 5.2234;
	Debugging.Particle= 2649;
	Debugging.DesignatedStopRepeater= 158;
    
    for i=1:inf
        [s_sp,e_pl,sigma_global_big,e_t_global_big,e_pl_global_big,alpha_out,f_final_vect,surfacewithfmax,sigma_local_big,evaltimes,thetacrackrtl,Ktangent_global,Ktangent_global_2D,Ktangent_global_tens,Ktangent_global_tens_2D,activesurfacelist,AbeforeQ_rtl,lambdamin,thetamin]= ...
            Wood_Schmidt17(dESP,sigma_global_big,e_t_global_big,e_pl_global_big,alpha_in,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,t,dt,spid,Debugging,NaN,dudx_rtl);
        alpha_in=alpha_out;
		%{
		if i==5
			dESP=dESP/10;
		end
		if i==10
			dESP=dESP/10;
		end
		if i==14
			dESP=dESP/10;
		end
		%}
        disp(['s_sp=' num2str(s_sp)]);
		disp(['i=' num2str(i)]);
        Ktangent_global_2D;
        lambdamin;
        thetamin;
        disp(['lambdamin=' num2str(lambdamin) ', thetacrackrtl=' num2str(thetacrackrtl*180/pi) ' degrees']);
		%pause
        1;
		L=dESP/dt;
		dudx_rtl=dudx_rtl+L*dt;
    end
end
%}
%{
function MainHandler()
	spCount=[];
	%uiload;
	for i=2:2:100 
		newindex=length(spCount)+1;
		refinementfactor=i;
		[spCount(newindex) sigmainf(newindex) TimeStampedNameBasic pforce_sp{newindex} stressnorm(newindex) dispnorm(newindex) gridsize(newindex) G(newindex) Ga(newindex) Grelativeerror(newindex)]=Main(refinementfactor);
		stressnormpersigmainf(newindex)=stressnorm(newindex)/sigmainf(newindex);
		save([TimeStampedNameBasic '-MainHandler.mat'],'-v7.3',...
		'spCount', ...
		'sigmainf', ...
		'pforce_sp', ...
		'stressnorm', ...
		'stressnormpersigmainf', ...
		'dispnorm', ...
		'gridsize', ...
		'G', ...
		'Ga', ...
		'Grelativeerror');
		1;
	end
end
%}

function [spCount sigmainf TimeStampedNameBasic pforce_sp stressnorm dispnorm gridsize G Ga Grelativeerror]=Main(refinemenfactorinput)
close all;
Debugging.Active=0;
Debugging.Case=111;
Debugging.FileName='zz1904252320-111_CTSpecimen-ms=100-Dump.mat';
Debugging.Time=0.32206501319960556539712115409202;
Debugging.Particle=265;
Debugging.DesignatedStopRepeater=1;

ttstart=1;
%clear all;
%tic;
%{
addpath('SubFunctions/Cores');
addpath('SubFunctions/Constitutive_Models');
addpath('SubFunctions/CPDI_solvers');
addpath('SubFunctions/MPM_solvers');
addpath('SubFunctions/TLS_MPM_solvers');
addpath('SubFunctions/TLS_CPDI_solvers');
addpath('SubFunctions/TLS');
addpath('Particle_generation_input');
%}

%Remark='FlexiBeamLRTlocalstress';
casenamelist{1}='R_comp_MassScale';
casenamelist{2}='T_comp_by_rotation_MassScale';
casenamelist{3}='Radial_Fine';
casenamelist{4}='Connection_TnSignored';
casenamelist{5}='3-point_SEN';
casenamelist{6}='3-point_SEN_touch';
casenamelist{7}='Energy_Absorb';
casenamelist{8}='3-point_SEN_lvar';
casenamelist{9}='3-point_SEN_touch_lvar';
casenamelist{10}='R_tension_dampnignore';
casenamelist{11}='GerhardTensKnot';
casenamelist{12}='StevenCompKnotCPDIFine';
casenamelist{13}='GerhardMultiKnotFine';
casenamelist{14}='GerhardCoreTest';
casenamelist{15}='GerhardMultiKnotChopedOffFine';
casenamelist{16}='StevenCompKnotOffsetFine';
casenamelist{17}='RadialOldPerfectPlastic_EvalCounter';
casenamelist{18}='StevenOffsetNoWeakening';
casenamelist{19}='Radial_Elasticer';
casenamelist{20}='GerhardMultiManualOrient';
casenamelist{21}='Radial_Hover';
casenamelist{22}='Radial_QuickHardening';
casenamelist{23}='StevenOffNoWeakQuickHrdnig';
casenamelist{24}='Radial_SlowHardening';
casenamelist{25}='GerhardMultiManualEllipse';
casenamelist{26}='Radial_RefineTest';
casenamelist{27}='Radial_Scheduling_Test';
casenamelist{28}='Radial_f_switcheroo';
casenamelist{29}='Radial_f_switcheroo66';
casenamelist{30}='Radial_f_noswitchRT36';
casenamelist{31}='Radial_f_poissonedit';
casenamelist{32}='GerhardTedManual';
casenamelist{33}='Radial_CoarseTestBed';
casenamelist{34}='Radial_fcMiksic';
casenamelist{35}='GerhardTedManual_mfMiksic';
casenamelist{36}='GerhardMoreOvalMiksic';
casenamelist{37}='GerhardOvalSchmidt';
casenamelist{38}='Steven_Birch';
casenamelist{39}='Radial_Miksic_vreduced';
casenamelist{40}='Radial_Miksic_widetop';
casenamelist{41}='Steven_Birch_adjust';
casenamelist{42}='Radial_MkcWide_ftrless';
casenamelist{43}='Steven_Birch_AllowxMoveAtBot';
casenamelist{44}='Steven_Birch_AllowxMoveAtTop';
casenamelist{45}='Radial_MkcWide_fvHardeningIsBack';
casenamelist{46}='Steven_Birch_normalshearhardening';
casenamelist{47}='Steven_Birch_stronger_ftt';
casenamelist{48}='Radial_MkcWide_ftrless_fttmore';
casenamelist{49}='Steven_Birch_fclDown_ftlDownfcrUp';
casenamelist{50}='Steven_Birch_ShearSoftening';
casenamelist{51}='Steven_Birch_LinearScaling';
casenamelist{52}='Radial_WideTop_Repositioned';
casenamelist{53}='Steven_Birch_LinScale_xbotfree';
casenamelist{54}='Radial_WideTop_Repositioned2_linearloading';
casenamelist{55}='Gerhard_squishyball_2ndway_ortho2';
casenamelist{56}='Gerhard_squishyball_3rdway_ortho2';
casenamelist{57}='Gerhard_squishyball_1stway_ortho2';
casenamelist{58}='Gerhard_squishyball_1stway_ortextreme';
casenamelist{59}='Gerhard_squishyball_2ndway_ortextreme';
casenamelist{60}='Gerhard_squishyball_3rdway_ortextreme';
casenamelist{61}='Gerhard_squishyball_1stway_ortex2';
casenamelist{62}='Gerhard_squishyball_2ndway_ortex2';
casenamelist{63}='Gerhard_squishyball_3ndway_ortex2';
casenamelist{64}='CRAMP Double Beam';
casenamelist{65}='CRAMP_Double_Beam_Asymmetrical';
casenamelist{66}='CRAMP_Double_Beam_Long';
casenamelist{67}='ShrinkingBlob';
casenamelist{68}='XYShrinkThickBlob';
casenamelist{69}='CRAMP_Double_Beam_Force';
casenamelist{70}='CRAMP_Double_Beam_Asymmetrical';
casenamelist{71}='XYShrinkThinInitial';
casenamelist{72}='XYShrinkThickInitiation';
casenamelist{73}='XYShrinkAcousticInitiation';
casenamelist{74}='XYShrinkDiscreteandQ';
casenamelist{77}='Forceatcrackparticles';
casenamelist{78}='XYShrinkDiscreteandQ_steel';
casenamelist{79}='XYShrinkDiscreteandQ_steel_asym';
casenamelist{80}='XYShrinkNairnQavg_steel_asym';
casenamelist{81}='XYShrinkDiscreteandQ_steel'; %78 but refined
casenamelist{82}='XYShrinkNairnQavg_steel_sym'; %80 but symmetrical initial crack
casenamelist{83}='ShrinkNoSteelAvgQ_MultiCrackFail';
casenamelist{84}='ShrinkNoSteelAvgQ_MultiCrackTestBed'; %2 crack cross split
casenamelist{85}='SmallSpecimenDoubleCracks';
casenamelist{86}='MediumSpecimenDoubleCracks';
casenamelist{87}='MediumSpecimenDoubleCrackshalf';
casenamelist{88}='ShrinkDoubleCrackSteel';
casenamelist{89}='MediumSpecimenSingleCrackshalf';
casenamelist{90}='MediumSpecimenDoubleCracksEdge';
casenamelist{91}='MediumSpecimenDoubleCracksHalfnOut';
casenamelist{92}='MediumSpecimenDoubleCracksHalfnOutCross';
casenamelist{93}='MPMCheckupFrom92';
casenamelist{94}='MediumSpecimenDoubleCracksHalfnEdge';
casenamelist{95}='MediumSpecimenDoubleCracksHalfnHalf';
casenamelist{96}='ShrinkBranchCrackSteel';
casenamelist{97}='MediumSpecimenDoubleCracksCellCut';
casenamelist{98}='DoubleCrackPropagate';
casenamelist{99}='MediumSpecimenDoubleCracksEights';
casenamelist{100}='XYShrinkNairnQavg_steel_sym_multi'; %80 but symmetrical initial crack
casenamelist{101}='XYShrinkNairnQavg_singlecrack_multioptimized'; %100 but using quan's and optimized
casenamelist{102}='XYShrinkNairnQavg_triplecrack_optimized';
casenamelist{103}='DoubleCrackEdgeTest';
casenamelist{104}='NoInitialCrack';
casenamelist{105}='SingleInitialRefined'; %101 but refined
casenamelist{106}='XYShrinkNairnQavg_doublecrack_optimized';
casenamelist{107}='XYShrinkNairnQavg_doublecrackequal';
casenamelist{108}='NoInitialCrack_randomtop';
casenamelist{109}='SingleInitialFlippityFlop';
casenamelist{110}='NoInitialRandomRefined';
casenamelist{111}='CTSpecimen';
casenamelist{112}='CantileverBeam';
casenamelist{113}='CTSpecimen_slow';
casenamelist{114}='NoInitialNoRandomNoSideroller';
casenamelist{115}='InfinitePlate';
casenamelist{116}='InfinitePlate2x2';
casenamelist{117}='InfinitePlate2x2CrackParticleTest';
casenamelist{118}='DanasPlate';
casenamelist{119}='InfinitePlate2x2Norms';


for i=1:length(casenamelist)
    disp(['Case ' num2str(i) ': ' casenamelist{i}]);
end

if exist('refinemenfactorinput')
	CasetoRun=119;
elseif Debugging.Active==0
    CasetoRun=input('CasetoRun=');
else
    CasetoRun=Debugging.Case;
    disp(['CasetoRun=' num2str(Debugging.Case)]);
end
if exist('refinemenfactorinput')
	refinementfactor=refinemenfactorinput;
elseif CasetoRun==26 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
    refinementfactor=input('refinementfactor=');
end

% Case 1: L Compression
% Case 2: Connection
casename=casenamelist{CasetoRun};

if exist('refinemenfactorinput')
	runorjustplot=0;
elseif Debugging.Active==0
    runorjustplot=input('Run (0) or just plot (1) or just plot last (2)? ');
else
    runorjustplot=0;
    disp('Run (0) or just plot (1) or just plot last (2)? ');
end    
if CasetoRun==14
    numberofcores=input('Number of Cores? ');
end
if runorjustplot==0
    simulationbreaksignal=0;
elseif runorjustplot==1 || runorjustplot==2
    simulationbreaksignal=1;
end
% Unit
% Newton - seconds - metre
% Unit Change In Progress: to N-mm-s

%% Please select the versions of MPM!!!!!!!!!!!!!!!!!
% Original MPM: 'MPM'
% CPDI: 'CPDI'
% Taylor least square MPM: 'TLS_MPM' 
% Taylor least square CPDI: 'TLS_CPDI'

% Please remember to change the output video file!!
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==8 || CasetoRun==9 || CasetoRun==10 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
    Version = 'CPDI';
else
    Version = 'MPM';
end

%% Constutitive model
% Linear_Elastic

% Neo_Hookean_Elastic
% Mises
% Mises_Softening
CModel = 'Wood_Schmidt17';
%CModel = 'Linear_Elastic';
%% Material porperties
if CasetoRun==64 || CasetoRun==66 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
    E                   = 400            ;
elseif CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113
	E                   = 8000      ;
elseif CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==8 || CasetoRun==9 || CasetoRun==10 || CasetoRun==11 || CasetoRun==12 || CasetoRun==13 || CasetoRun==14 || CasetoRun==15 || CasetoRun==16 || CasetoRun==17 || CasetoRun==18 || CasetoRun==19 || CasetoRun==20 || CasetoRun==21 || CasetoRun==22 || CasetoRun==23 || CasetoRun==24 || CasetoRun==25 || CasetoRun==26 || CasetoRun==27 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==32 || CasetoRun==33 || CasetoRun==34 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==38 || CasetoRun==39 || CasetoRun==40 || CasetoRun==41 || CasetoRun==42 || CasetoRun==43 || CasetoRun==44 || CasetoRun==45 || CasetoRun==46 || CasetoRun==47 || CasetoRun==48 || CasetoRun==49 || CasetoRun==50 || CasetoRun==51 || CasetoRun==52 || CasetoRun==53 || CasetoRun==54 || CasetoRun==55 || CasetoRun==56 || CasetoRun==57 || CasetoRun==58 || CasetoRun==59 || CasetoRun==60 || CasetoRun==61 || CasetoRun==62 || CasetoRun==63 || CasetoRun==69
    E                   = 200e3          ;                  % Young modulus of steel 200 GPa = 200e3 MPa = 200e3 N/mm2
end
%psp                     = 8e-7*1000            ;                  % solid density 800 kg/m3 = 800/1e9 kg/mm3 = 8e-7; scaled by the factor of 1000
nu                      = 0.3           ;                  % Poison ratio
g                       = 0            ;                  % gravity acceleration
b_sp                    = [0 0];                                % body force

if CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    ftl_spruce=65.5;
    fcl_spruce=-50.3;
    fcl=-47.6;
    ftl=ftl_spruce/fcl_spruce*fcl;
else
    ftl=65.5;
    fcl=-50.3;
end
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==37 || CasetoRun==23
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    fcr=-6;
    fct=-6;
elseif CasetoRun==28
    ftr=2.79;
    ftt=3.75;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    fcr=-3;
    fct=-6;
elseif CasetoRun==29
    ftr=2.79;
    ftt=3.75;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    fcr=-6;
    fct=-6;
elseif CasetoRun==30
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    fcr=-3;
    fct=-6;
elseif CasetoRun==31
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    fcr=-6;
    fct=-6;
elseif CasetoRun==33
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    %fcr=-5.333333333333333333333333333333;
    %fct=-4;
    fcr=-3;
    fct=-6;
elseif CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==39 || CasetoRun==35 || CasetoRun==36 || CasetoRun==45
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    %fcr=-3;
    %fct=-6;
    fcr=-(1.5+4)/2;
    fct=-5;
elseif CasetoRun==42
    ftr=3.75*0.7;
    ftt=2.79;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    %fcr=-3;
    %fct=-6;
    fcr=-(1.5+4)/2;
    fct=-5;
elseif CasetoRun==4
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83; %replacereplacereplace
    fvrl=6.34; %replacereplacereplace
    fvtl=5.34; %replacereplacereplace
    fcr=-6;
    fct=-6;
elseif CasetoRun==5 || CasetoRun==6
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83; %replacereplacereplace
    fvrl=6.34; %replacereplacereplace
    fvtl=5.34; %replacereplacereplace
    fcr=-6;
    fct=-6;
elseif CasetoRun==7
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83; %replacereplacereplace
    fvrl=6.34; %replacereplacereplace
    fvtl=5.34; %replacereplacereplace
    fcr=-6;
    fct=-6;
elseif CasetoRun==8 || CasetoRun==9
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83; %replacereplacereplace
    fvrl=6.34; %replacereplacereplace
    fvtl=5.34; %replacereplacereplace
    fcr=-6;
    fct=-6;
elseif CasetoRun==10
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    fcr=-6;
    fct=-3;
elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==15 || CasetoRun==14
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    fcr=-6;
    fct=-3;
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    fcr=-6;
    fct=-3;
elseif CasetoRun==38 || CasetoRun==50 || CasetoRun==46
    ftr_spruce=3.75;
    ftt_spruce=2.79;
    ftper_spruce=(ftr_spruce+ftt_spruce)/2;
    fvrt_spruce=1.83/1; %replacereplacereplace
    fvrl_spruce=6.34/1; %replacereplacereplace
    fvtl_spruce=5.34/1; %replacereplacereplace
    fcr_spruce=-(1.5+4)/2;
    fct_spruce=-5;
    fcper_spruce=(fcr_spruce+fct_spruce)/2;
    
    
    fcl_yellow=-144;
    fcper_yellow=-6.7;
    fcr_yellow=fcper_yellow/fcper_spruce*fcr_spruce;
    fct_yellow=fcper_yellow/fcper_spruce*fct_spruce;
    
    fcr=fcl/fcl_yellow*fcr_yellow;
    fct=fcl/fcl_yellow*fct_yellow;
    
    fvrt=fcl/fcl_spruce*fvrt_spruce;
    fvrl=fcl/fcl_spruce*fvrl_spruce;
    fvtl=fcl/fcl_spruce*fvtl_spruce;
    
    ftper_yellow=6.3;
    ftr_yellow=ftr_spruce/ftper_spruce*ftper_yellow;
    ftt_yellow=ftt_spruce/ftper_spruce*ftper_yellow;
    
    ftr=ftr_yellow/fcl_yellow*fcl;
    ftt=ftt_yellow/fcl_yellow*fcl;
elseif CasetoRun==51 || CasetoRun==53
    ftr_spruce=3.75;
    ftt_spruce=2.79;
    fvrt_spruce=1.83/1; %replacereplacereplace
    fvrl_spruce=6.34/1; %replacereplacereplace
    fvtl_spruce=5.34/1; %replacereplacereplace
    fcr_spruce=-(1.5+4)/2;
    fct_spruce=-5;
    fcl=47.6;
    fcr=fcl/fcl_spruce*fcr_spruce;
    fct=fcl/fcl_spruce*fct_spruce;
    ftl=fcl/fcl_spruce*ftl_spruce;
    ftr=fcl/fcl_spruce*ftr_spruce;
    ftt=fcl/fcl_spruce*ftt_spruce;
    fvrt=fcl/fcl_spruce*fvrt_spruce;
    fvrl=fcl/fcl_spruce*fvrl_spruce;
    fvtl=fcl/fcl_spruce*fvtl_spruce;
elseif CasetoRun==49
    ftr_spruce=3.75;
    ftt_spruce=2.79;
    ftper_spruce=(ftr_spruce+ftt_spruce)/2;
    fvrt_spruce=1.83/1; %replacereplacereplace
    fvrl_spruce=6.34/1; %replacereplacereplace
    fvtl_spruce=5.34/1; %replacereplacereplace
    fcr_spruce=-(1.5+4)/2;
    fct_spruce=-5;
    fcper_spruce=(fcr_spruce+fct_spruce)/2;
    
    
    fcl_yellow=-144;
    fcper_yellow=-6.7;
    fcr_yellow=fcper_yellow/fcper_spruce*fcr_spruce;
    fct_yellow=fcper_yellow/fcper_spruce*fct_spruce;
    
    fcr=fcl/fcl_yellow*fcr_yellow;
    fct=fcl/fcl_yellow*fct_yellow;
    
    fvrt=fcl/fcl_spruce*fvrt_spruce;
    fvrl=fcl/fcl_spruce*fvrl_spruce;
    fvtl=fcl/fcl_spruce*fvtl_spruce;
    
    ftper_yellow=6.3;
    ftr_yellow=ftr_spruce/ftper_spruce*ftper_yellow;
    ftt_yellow=ftt_spruce/ftper_spruce*ftper_yellow;
    
    ftr=ftr_yellow/fcl_yellow*fcl;
    ftt=ftt_yellow/fcl_yellow*fcl;
    fcr=fcr*1.3;
    ftl=ftl*0.7;

elseif CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    ftr_spruce=3.75;
    ftt_spruce=2.79;
    ftper_spruce=(ftr_spruce+ftt_spruce)/2;
    fvrt_spruce=1.83/1; %replacereplacereplace
    fvrl_spruce=6.34/1; %replacereplacereplace
    fvtl_spruce=5.34/1; %replacereplacereplace
    fvrltl_spruce=(fvrl_spruce+fvtl_spruce)/2;
    
    fcr_spruce=-(1.5+4)/2;
    fct_spruce=-5;
    fcper_spruce=(fcr_spruce+fct_spruce)/2;
    
    fvrltl_yellow=13;
    fvrl_yellow=fvrltl_yellow/fvrltl_spruce*fvrl_spruce;
    fvtl_yellow=fvrltl_yellow/fvrltl_spruce*fvtl_spruce;
    fvrt_yellow=fvrltl_yellow/fvrltl_spruce*fvrt_spruce;
    
    fcl_yellow=-144;
    fcper_yellow=-6.7;
    fcr_yellow=fcper_yellow/fcper_spruce*fcr_spruce;
    fct_yellow=fcper_yellow/fcper_spruce*fct_spruce;
    
    fcr=fcl/fcl_yellow*fcr_yellow;
    fct=fcl/fcl_yellow*fct_yellow;
    
    fvrt=fcl/fcl_yellow*fvrt_yellow;
    fvrl=fcl/fcl_yellow*fvrl_yellow;
    fvtl=fcl/fcl_yellow*fvtl_yellow;
    
    ftper_yellow=6.3;
    ftr_yellow=ftr_spruce/ftper_spruce*ftper_yellow;
    ftt_yellow=ftt_spruce/ftper_spruce*ftper_yellow;
    
    ftr=ftr_yellow/fcl_yellow*fcl;
    ftt=ftt_yellow/fcl_yellow*fcl;
elseif CasetoRun==47
    ftr_spruce=3.75;
    ftt_spruce=2.79;
    ftper_spruce=(ftr_spruce+ftt_spruce)/2;
    fvrt_spruce=1.83/1; %replacereplacereplace
    fvrl_spruce=6.34/1; %replacereplacereplace
    fvtl_spruce=5.34/1; %replacereplacereplace
    fcr_spruce=-(1.5+4)/2;
    fct_spruce=-5;
    fcper_spruce=(fcr_spruce+fct_spruce)/2;
    
    
    fcl_yellow=-144;
    fcper_yellow=-6.7;
    fcr_yellow=fcper_yellow/fcper_spruce*fcr_spruce;
    fct_yellow=fcper_yellow/fcper_spruce*fct_spruce;
    
    fcr=fcl/fcl_yellow*fcr_yellow;
    fct=fcl/fcl_yellow*fct_yellow;
    
    fvrt=fcl/fcl_spruce*fvrt_spruce;
    fvrl=fcl/fcl_spruce*fvrl_spruce;
    fvtl=fcl/fcl_spruce*fvtl_spruce;
    
    ftper_yellow=6.3;
    ftr_yellow=ftr_spruce/ftper_spruce*ftper_yellow;
    ftt_yellow=ftt_spruce/ftper_spruce*ftper_yellow;
    
    ftr=ftr_yellow/fcl_yellow*fcl;
    ftt=ftt_yellow/fcl_yellow*fcl;
    ftt=ftt*1.5;
elseif CasetoRun==48
    ftr=3.75;
    ftt=2.79*1.6;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    %fcr=-3;
    %fct=-6;
    fcr=-(1.5+4)/2;
    fct=-5;
elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    %fcr=-3;
    %fct=-6;
    fcr=-(1.5+4)/2;
    fct=-5;
else
    ftr=3.75;
    ftt=2.79;
    fvrt=1.83/1; %replacereplacereplace
    fvrl=6.34/1; %replacereplacereplace
    fvtl=5.34/1; %replacereplacereplace
    %fcr=-3;
    %fct=-6;
    fcr=-(1.5+4)/2;
    fct=-5;
end

if CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    El=14804;
    Et=0.050*El;
    Er=0.078*El;
    Grt=0.074*El;
    Gtl=0.068*El;
    Grl=0.017*El;
else
    Er=820/1; %replacereplacereplace
    Et=430/1; %replacereplacereplace
    El=13200/1; %replacereplacereplace
    Grt=40/1; %replacereplacereplace
    Gtl=730/1; %replacereplacereplace
    Grl=660/1; %replacereplacereplace
end
if CasetoRun==19 || CasetoRun==21
    ReductionFactor=1;
    Er=820/ReductionFactor; %replacereplacereplace
    Et=430/ReductionFactor; %replacereplacereplace
    El=13200/ReductionFactor; %replacereplacereplace
    Grt=40/ReductionFactor; %replacereplacereplace
    Gtl=730/ReductionFactor; %replacereplacereplace
    Grl=660/ReductionFactor; %replacereplacereplace
end

if CasetoRun==31 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
    nurt=0.24;
    nutl=0.47;
    nurl=0.42;
elseif CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    nurt=0.426;
    nutl=0.451;
    nurl=0.426;
else
    nurt=0.24;
    nutl=0.45;
    nurl=0.45;
end

%Er=El;
%Et=El;
%Grt=Grl;
%Gtl=Grl;
%nurt=nurl;
%nutl=nurl;

kappa1=0.00001;
kappa2=1.2;
kappa3=0.00001;
kappa4=1.2;
kappa5=0.00001;
kappa6=0.7;
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    kappa7=1.0;
elseif CasetoRun==39 || CasetoRun==50
    kappa7=0.2;
else
    kappa7=1.2;
end

Gftl=1650/1000;
Gfcl=50000/1000;
Gftr=300/1000;
Gftt=Gftr;
Gfcr=Gftr/Gftl*Gfcl;
Gfct=Gfcr;
GII=300/1000;

Hld=15;
Hrd=2;
Htd=Hrd;

lccrit=El*Gftl/abs(ftl);
%lc=lccrit/100;
%lc=10;



if CasetoRun==22 || CasetoRun==23
    alpha2dnounit=0.1;
    alpha2maxnounit=0.2;
    alpha4dnounit=0.1;
    alpha4maxnounit=0.2;
    alpha6dnounit=0.1;
    alpha6maxnounit=0.2;
elseif CasetoRun==24
    alpha2dnounit=0.5;
    alpha2maxnounit=0.75;
    alpha4dnounit=0.5;
    alpha4maxnounit=0.75;
    alpha6dnounit=0.5;
    alpha6maxnounit=0.75;
else
    alpha2dnounit=0.1;
    alpha2maxnounit=0.75;
    alpha4dnounit=0.1;
    alpha4maxnounit=0.75;
    alpha6dnounit=0.5;
    alpha6maxnounit=0.75;
end
if CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==8 || CasetoRun==9 || CasetoRun==10 || CasetoRun==11 || CasetoRun==17 || CasetoRun==45 || CasetoRun==46
    %the default value
    alpha7dnounit=0.1;
    alpha7maxnounit=0.75;
elseif CasetoRun==4
    alpha7dnounit=0.05;
    alpha7maxnounit=0.1;
elseif CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==49 || CasetoRun==47 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    alpha7dnounit=1.0;
    alpha7maxnounit=1.5;
elseif CasetoRun==39 || CasetoRun==50
    alpha7dnounit=inf;
    alpha7maxnounit=inf;
elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
    alpha7dnounit=0.1;
    alpha7maxnounit=0.75;
else
    alpha7dnounit=0.1;
    alpha7maxnounit=0.75;
end

%Intended specimen: L = 10 cm, t = 2 cm, delta_u = 1 cm

if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
    %% Structured Grid input
    if CasetoRun==26
    elseif CasetoRun==33 || CasetoRun==34 || CasetoRun==39
        refinementfactor      = 1;
    else
        refinementfactor      = 2;
    end
    NN(1)                 = (11-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (17-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 10;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==4
    %% Structured Grid input
    NN(1)                 = 15;%33;                               % number of nodes in X direction
    NN(2)                 = 22;%13;                               % number of nodes in Y direction
    le(1)                 = 10;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
    le_base=10;
elseif CasetoRun==5 || CasetoRun==6
     NN(1)                = 24;
     NN(2)                = 14;
     le_base              = 6.25;
     le(1)                = le_base;
     le(2)                = le(1);
     lc=le(1);
elseif CasetoRun==7
    %% Structured Grid input
    NN(1)                 = 11;%33;                               % number of nodes in X direction
    NN(2)                 = 17;%13;                               % number of nodes in Y direction
    le_base               = 12;
    le(1)                 = le_base;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==8 || CasetoRun==9
    le_base              = 6.25;
    notchwidth=le_base/5;
    for i=1:11
        le_x(i)=le_base;
        le_x(i+14)=le_base;
    end
    le_x(12)=(le_base-notchwidth)/2;
    le_x(13)=notchwidth;
    le_x(14)=le_x(12);
    for i=1:6
        le_y(i)=le_base;
    end
    le_y(7)=notchwidth;
    le_y(8)=le_base-notchwidth;
    for j=9:14
        le_y(j)=le_base;
    end
    NN(1)                = length(le_x)+1;
    NN(2)                = length(le_y)+1;
    le(1)                = le_base;
    le(2)                = le(1);
    lc=le(1);
elseif CasetoRun==10
    %% Structured Grid input
    NN(1)                 = 11;%33;                               % number of nodes in X direction
    NN(2)                 = 19;%13;                               % number of nodes in Y direction
    le_base               = 12;
    le(1)                 = le_base;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==11
    %% Structured Grid input
    refinementfactor=1;
    NN(1)                 = (10-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (23-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 25;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    %% Structured Grid input
    refinementfactor=2;
    NN(1)                 = (11-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (23-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 15;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    %% Structured Grid input
    refinementfactor=3;
    NN(1)                 = (10-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (23-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 25;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==64 || CasetoRun==65 || CasetoRun==70
    %% Structured Grid input
    refinementfactor=1;
    NN(1)                 = (11-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (12-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 10;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==66 || CasetoRun==69
    %% Structured Grid input
    refinementfactor=1;
    NN(1)                 = (16-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (12-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 10;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==67
    %% Structured Grid input
    refinementfactor=1;
    NN(1)                 = (25-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (9-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 5;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==68 || CasetoRun==71 || CasetoRun==74 || CasetoRun==78 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==110 || CasetoRun==96
    %% Structured Grid input
	if CasetoRun==105 || CasetoRun==110
		refinementfactor=2;
	else
		refinementfactor=1;
	end
    NN(1)                 = (25-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (13-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 5;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==111 || CasetoRun==113
    %% Structured Grid input
	refinementfactor=1;
    NN(1)                 = (20-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (21-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 3;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==115
    %% Structured Grid input
	%refinementfactor=1;
    NN(1)                 = (8-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (8-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 3;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==116 || CasetoRun==119 || CasetoRun==117
    %% Structured Grid input
	%refinementfactor=1;
    NN(1)                 = (7-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (7-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 5;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==118
    NN(1)                 = (7-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (7-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 1;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==112
    %% Structured Grid input
	refinementfactor=1;
    NN(1)                 = (17-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (18-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 5;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==84
    %% Structured Grid input
    refinementfactor=1;
    NN(1)                 = (26-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (14-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 5;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==90 || CasetoRun==89
    %% Structured Grid input
    refinementfactor=1;
    NN(1)                 = (12-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (11-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 10;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==93
    %% Structured Grid input
    refinementfactor=1;
    NN(1)                 = (12-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (11-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 10;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==85
    %% Structured Grid input
    refinementfactor=1;
    NN(1)                 = (5-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (5-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 10;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==81
    %% Structured Grid input
    refinementfactor=2;
    NN(1)                 = (25-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (13-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 5;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
elseif CasetoRun==72 || CasetoRun==73
    %% Structured Grid input
    refinementfactor=1;
    NN(1)                 = (26-1)*refinementfactor+1;%33;                               % number of nodes in X direction
    NN(2)                 = (13-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
    le_base               = 5;
    le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
    le(2)                 = le(1);                          % size of element in Y direction
    lc=le(1);
end

%% Grid generation
le_c=[];
LOCX=[];
LOCY=[];
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    [LOC,LOCC,cellCount,nodeCount] = Grid_Generation(NN,le);
elseif CasetoRun==8 || CasetoRun==9
    [LOC,LOCC,cellCount,nodeCount,LOCX,LOCY,le_c] = Grid_Generation_var(NN,le_x,le_y);
    %x_p=le_base*11;
    %y_p=le_base*6;
    %[thecell, thenodes]= ...
    %    identifycellsandnodes([x_p y_p],LOCX,LOCY,[],[],[1 1 0 0]);
elseif CasetoRun==10
    [LOC,LOCC,cellCount,nodeCount] = Grid_Generation(NN,le);
else
    [LOC,LOCC,cellCount,nodeCount] = Grid_Generation(NN,le); %Case 64 goes here so far 190128
end


% nodeCount: total number of nodes
% cellCount: total number of elements
% LOC(n,1:2): localtion coordinate of node "n" in x(1) and y(2) direction
% LOCC(e,1:2): localtion coordinate of element centroid "e" in x(1) and y(2) direction

%% Nodes with predefined velocities (conveyer)
NumberofNodeswithPredXVel=0;
NodeswithPredXVel=[];

NumberofNodeswithPredYVel=0;
NodeswithPredYVel=[];

NumberofNodeswithPredYVel2=0;
NodeswithPredYVel2=[];


if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
    for i=1:size(LOC,1)
        if LOC(i,2)>le_base*10-1e-3 & LOC(i,2)<le_base*10+1e-3
            NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
            NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        end
        %if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
        %    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
        %    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        %end
    end
elseif CasetoRun==21
    for i=1:size(LOC,1)
        if LOC(i,2)>le_base*10+2*le(2)-1e-3 & LOC(i,2)<le_base*10+2*le(2)+1e-3
            NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
            NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        end
        %if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
        %    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
        %    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        %end
    end    
elseif CasetoRun==4
    for i=1:size(LOC,1)
        %if (LOC(i,1)-90)^2<1e-6 | (LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-110)^2<1e-6 | (LOC(i,1)-120)^2<1e-6 | (LOC(i,1)-130)^2<1e-6 | (LOC(i,1)-140)^2<1e-6
        %    NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
        %    NodeswithPredXVel(NumberofNodeswithPredXVel)=i;
        %end
        if (LOC(i,2)-170)^2<1e-6
            NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
            NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        end
    end
elseif CasetoRun==5 || CasetoRun==6
    for i=1:size(LOC,1)
        if LOC(i,2)>le_base*10-1e-3 & LOC(i,2)<le_base*10+1e-3
            NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
            NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        end
        %if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
        %    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
        %    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        %end
    end
elseif CasetoRun==7
    for i=1:size(LOC,1)
        if LOC(i,2)>le_base*10-1e-3 & LOC(i,2)<le_base*10+1e-3
            NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
            NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        end
        %if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
        %    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
        %    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        %end
    end
elseif CasetoRun==8 || CasetoRun==9
    for i=1:size(LOC,1)
        if LOC(i,2)>le_base*10-1e-3 & LOC(i,2)<le_base*10+1e-3
            NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
            NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        end
        %if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
        %    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
        %    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        %end
    end
elseif CasetoRun==10
    for i=1:size(LOC,1)
        if LOC(i,2)>le_base*11-1e-3 & LOC(i,2)<le_base*11+1e-3
            NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
            NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        end
        %if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
        %    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
        %    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        %end
    end
elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    for i=1:size(LOC,1)
        if CasetoRun==15
            if LOC(i,2)>le_base*16-1e-3 & LOC(i,2)<le_base*16+1e-3
                NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
                NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
            end            
        else
            if LOC(i,2)>le_base*19-1e-3 & LOC(i,2)<le_base*19+1e-3
                NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
                NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
            end
            %if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
            %    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
            %    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
            %end
        end
    end
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    for i=1:size(LOC,1)
        if LOC(i,2)>le_base*18-1e-3 & LOC(i,2)<le_base*18+1e-3
            NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
            NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        end
        %if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
        %    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
        %    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        %end
    end
elseif CasetoRun==64 || CasetoRun==66
    for i=1:size(LOC,1)
        if CloseEnough(LOC(i,2),9*le_base,1e-3,1) || CloseEnough(LOC(i,2),10*le_base,1e-3,1)
            NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
            NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        elseif CloseEnough(LOC(i,2),2*le_base,1e-3,1) || CloseEnough(LOC(i,2),1*le_base,1e-3,1)
            NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
            NodeswithPredYVel2(NumberofNodeswithPredYVel2)=i;
        end
    end
elseif CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77 || CasetoRun==69 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96
elseif CasetoRun==111 || CasetoRun==113 
    for i=1:size(LOC,1)
        if CloseEnough(LOC(i,2),13*le_base,1e-3,1) && CloseEnough(LOC(i,1),6*le_base,1e-3,1)
            NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
            NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        elseif CloseEnough(LOC(i,2),7*le_base,1e-3,1) && CloseEnough(LOC(i,1),6*le_base,1e-3,1)
            NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
            NodeswithPredYVel2(NumberofNodeswithPredYVel2)=i;
        end
    end
elseif CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
elseif CasetoRun==84
    for i=1:size(LOC,1)
		if CloseEnough(LOC(i,1),22*le_base)
			NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
			NodeswithPredXVel(NumberofNodeswithPredXVel)=i;
		end
		if CloseEnough(LOC(i,2),10*le_base)
			NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
			NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
		end
	end
elseif CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89
    for i=1:size(LOC,1)
		if CloseEnough(LOC(i,1),7*le_base)
			NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
			NodeswithPredXVel(NumberofNodeswithPredXVel)=i;
		end
		if CloseEnough(LOC(i,2),7*le_base)
			NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
			NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
		end
	end
elseif CasetoRun==94
    for i=1:size(LOC,1)
		if CloseEnough(LOC(i,1),8*le_base)
			NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
			NodeswithPredXVel(NumberofNodeswithPredXVel)=i;
		end
		if CloseEnough(LOC(i,2),7*le_base)
			NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
			NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
		end
	end
elseif CasetoRun==85

elseif CasetoRun==65 || CasetoRun==70
    for i=1:size(LOC,1)
        if CloseEnough(LOC(i,2),8*le_base,1e-3,1) || CloseEnough(LOC(i,2),9*le_base,1e-3,1) || CloseEnough(LOC(i,2),10*le_base,1e-3,1)
            NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
            NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
        end
    end
end

%%Defining Double-Velocity Nodes
%definingprocessgoeshere

%% Time
%c                       = sqrt(E/psp);
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
    %ftime                   = 20*2+25;
    loadtime                = 15;
    pausetime               = 2;
    repetition              = 1;
    dispload                = -1.25*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 
    %ftime                   = 20*2+25;
    loadtime                = 20;
    pausetime               = 2;
    repetition              = 1;
    dispload                = -20;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==21
    loadtime                = 15;
    pausetime               = 2;
    repetition              = 1;
    dispload                = -1*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==4
    ftime                   = 12;
elseif CasetoRun==5 || CasetoRun==6
    loadtime                = 20;
    pausetime               = 1;
    repetition              = 2;
    dispload                = -1.25*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==7
    loadtime                = 1;
    pausetime               = 15;
    repetition              = 1;
    dispload                = -1*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==8 || CasetoRun==9
    loadtime                = 4;
    pausetime               = 1;
    repetition              = 10;
    dispload                = -0.25*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==10
    %ftime                   = 20*2+25;
    loadtime                = 10;
    pausetime               = 1;
    repetition              = 1;
    dispload                = 0.2*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==11
    %ftime                   = 20*2+25;
    loadtime                = 5;
    pausetime               = 2;
    repetition              = 1;
    dispload                = 1*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    %ftime                   = 20*2+25;
    loadtime                = 5;
    pausetime               = 2;
    repetition              = 1;
    dispload                = -1.5*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    %ftime                   = 20*2+25;
    loadtime                = 5;
    pausetime               = 2;
    repetition              = 1;
    dispload                = 1*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==65 || CasetoRun==70
    %ftime                   = 20*2+25;
    loadtime                = 3;
    pausetime               = 2;
    repetition              = 1;
	if CasetoRun==65 || CasetoRun==70
		dispload                = 2*le_base;
	elseif CasetoRun==64 || CasetoRun==66
		dispload                = le_base;
	end
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==69
    %ftime                   = 20*2+25;
    loadtime                = 1;
    pausetime               = 999999;
    repetition              = 1;
	dispload                = 0;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==110 || CasetoRun==96
    loadtime                = 9999;
    pausetime               = 0;
    repetition              = 1;
	dispload                = 0*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==111
    loadtime                = 1;
    pausetime               = 5;
    repetition              = 1;
	dispload                = 1*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
    loadtime                = 1;
    pausetime               = 5; %not used for CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
    repetition              = 1;
	sigmainfmax             = 5; %MPa
	%dispload                = 1*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==113
    loadtime                = 20;
    pausetime               = 5;
    repetition              = 1;
	dispload                = 1*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==112
    loadtime                = 1;
    pausetime               = 10;
    repetition              = 1;
	dispload                = -4*le_base;
    ftime                   = (loadtime+pausetime)*repetition;
elseif CasetoRun==84 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
	loadtime=1;
	pausetime=1;
	repetition=1;
	dispload=1*le_base;
	ftime=(loadtime+pausetime)*repetition;
end

if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
    dtoverride              = 1;
    if CasetoRun==33 || CasetoRun==34 || CasetoRun==39
        massscalingfactor       = 1000;
    else
        massscalingfactor       = 100;
    end
elseif CasetoRun==111 || CasetoRun==113
	dtoverride              = 0.5;
    massscalingfactor        = 100;
elseif CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
	dtoverride              = 0.25;
    massscalingfactor        = 100;
elseif CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==8 || CasetoRun==9 || CasetoRun==10 || CasetoRun==11
    dtoverride              = 0;
	%dtoverride: 0=target time step size; 1=target mass scaling factor, take the more critical; 0.5: calc time step based on mass scaled wood, calc steel mass scaling based on time step; 0.25: mass-scale steel by 100, calc time step, then use time step to calc wood mass scaling.
end

dt                      = 0.001;
ndt                     = round(ftime/dt) +1;
t                       = 0;
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
    t0_plane                = 40;
elseif CasetoRun==4
    t0_plane=100;
elseif CasetoRun==5 || CasetoRun==6
    t0_plane=25;
elseif CasetoRun==7
    t0_plane=50;
elseif CasetoRun==8 || CasetoRun==9
    t0_plane=25;
elseif CasetoRun==10
    t0_plane = 10;
elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    t0_plane                = 44;
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    t0_plane                = 40;
elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
    t0_plane=10;
end

Emax1=max([Er El Et]);
Emax2=E;
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
    k=0.1;
elseif CasetoRun==4
    k=0.5;
elseif CasetoRun==5 || CasetoRun==6
    k=0.25;
elseif CasetoRun==7
    k=0.25;
elseif CasetoRun==8 || CasetoRun==9
    k=0.25;
elseif CasetoRun==10
    k=0.25;
elseif CasetoRun==11
    k=0.5;
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    k=0.5;
elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    k=0.5;
elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
    k=0.5;
end

if dtoverride==0 || dtoverride==1
	psp_min1=dt^2*Emax1/(k^2*lc^2);
	psp_min2=dt^2*Emax2/(k^2*lc^2);

	if dtoverride
		psp_min1=0;
		psp_min2=0;
	end
	psp1=max([psp_min1 8e-7]);
	psp2=max([psp_min2 7e-6]);
	if dtoverride
		psp1=psp1*massscalingfactor; %wood
		psp2=psp2*massscalingfactor; %steel
		dt=k*lc*sqrt(min([psp1/Emax1 psp2/Emax2]));
	end
elseif dtoverride==0.5
	psp1=(8e-7)*massscalingfactor;;
	dt=k*lc*sqrt(psp1/Emax1);
	psp_min2=dt^2*Emax2/(k^2*lc^2);
	psp2=max([psp_min2 7e-6]);
	disp('dtoverride=0.5 implemented');
	1;
elseif dtoverride==0.25
	psp2=(7e-6)*massscalingfactor; %steel
	dt=k*lc*sqrt(psp2/Emax2);
	psp_min1=dt^2*Emax1/(k^2*lc^2);
	psp1=max([psp_min1 8e-7]); %wood
	disp('dtoverride=0.25 implemented');
	1;
end

if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
    %% Boundary nodes
    % Boundary coordination
    x_min = 0;
    x_max = 10*le_base;
    y_min = 2*le_base;
    y_max = 16*le_base;
elseif CasetoRun==21
    %% Boundary nodes
    % Boundary coordination
    x_min = 0;
    x_max = 10*le_base;
    y_min = 2*le_base-le(2);
    y_max = 16*le_base;
elseif CasetoRun==4
    %% Boundary nodes
    % Boundary coordination
    x_min = 20;
    x_max = 140;
    y_min = 20;
    y_max = 210;
elseif CasetoRun==5 || CasetoRun==6
    x_min=-1*le_base;
    x_max=(23+1)*le_base;
    if CasetoRun==5
        y_min=-le_base;
    elseif CasetoRun==6
        y_min=-2*le_base;
    end
    y_max=(13+1)*le_base;
elseif CasetoRun==7
    x_min = 0;
    x_max = 10*le_base;
    y_min = 0;
    y_max = 16*le_base;
elseif CasetoRun==8 || CasetoRun==9
    x_min=0;
    x_max=23*le_base;
    if CasetoRun==8
        y_min=le_base;
    elseif CasetoRun==9
        y_min=2*le_base;
    end
    y_max=13*le_base;
elseif CasetoRun==10
    %% Boundary nodes
    % Boundary coordination
    x_min = 0;
    x_max = 10*le_base;
    y_min = 0*le_base;
    y_max = 18*le_base;
elseif CasetoRun==11
    %% Boundary nodes
    % Boundary coordination
    x_min = 0;
    x_max = 9*le_base;
    y_min = 2*le_base;
    y_max = 22*le_base;
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    %% Boundary nodes
    % Boundary coordination
    x_min = 0;
    x_max = 10*le_base;
    y_min = 0*le_base;
    y_max = 22*le_base;
elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    %% Boundary nodes
    % Boundary coordination
    x_min = 0*le_base;
    x_max = 9*le_base;
    y_min = 0*le_base;
    y_max = 22*le_base;
elseif CasetoRun==64
    x_min=0*le_base;
    x_max=8*le_base;
    y_min=0*le_base;
    y_max=11*le_base;
elseif CasetoRun==66 || CasetoRun==69
    x_min=0*le_base;
    x_max=13*le_base;
    y_min=0*le_base;
    y_max=11*le_base;
elseif CasetoRun==67
    x_min=2*le_base;
    x_max=22*le_base;
    y_min=0*le_base; % energy absorbing will be deployed instead
    y_max=8*le_base;
elseif CasetoRun==68 || CasetoRun==71 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==110 || CasetoRun==96
    x_min=2*le_base;
    x_max=22*le_base;
    y_min=2*le_base; % energy absorbing will not be deployed
    y_max=12*le_base;
elseif CasetoRun==114
    x_min=0*le_base;
    x_max=24*le_base;
    y_min=2*le_base; % energy absorbing will not be deployed
    y_max=12*le_base;
elseif CasetoRun==111 || CasetoRun==113
    x_min=0*le_base;
    x_max=19*le_base;
    y_min=0*le_base; % energy absorbing will not be deployed
    y_max=20*le_base;
elseif CasetoRun==115
    x_min=2*le_base;
    x_max=7*le_base;
    y_min=0*le_base; % energy absorbing will not be deployed
    y_max=7*le_base;
elseif CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
    x_min=2*le_base;
    x_max=6*le_base;
    y_min=0*le_base; % energy absorbing will not be deployed
    y_max=6*le_base;
elseif CasetoRun==112
    x_min=0*le_base;
    x_max=16*le_base;
    y_min=0*le_base; % energy absorbing will not be deployed
    y_max=17*le_base;
elseif CasetoRun==84
    x_min=2*le_base;
    x_max=25*le_base;
    y_min=2*le_base; % energy absorbing will not be deployed
    y_max=13*le_base;
elseif CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89
    x_min=2*le_base;
    x_max=10*le_base;
    y_min=2*le_base; % energy absorbing will not be deployed
    y_max=10*le_base;
elseif CasetoRun==94
    x_min=2*le_base;
    x_max=11*le_base;
    y_min=2*le_base; % energy absorbing will not be deployed
    y_max=10*le_base;
elseif CasetoRun==85
    x_min=0*le_base;
    x_max=4*le_base;
    y_min=0*le_base;
    y_max=4*le_base;
elseif CasetoRun==72 || CasetoRun==73
    x_min=2*le_base;
    x_max=23*le_base;
    y_min=2*le_base; % energy absorbing will not be deployed
    y_max=12*le_base;
elseif CasetoRun==65 || CasetoRun==70
    x_min=0*le_base;
    x_max=8*le_base;
    y_min=1*le_base;
    y_max=11*le_base;
end

[nfbcx,nfbcy,fbcx,fbcy]=Compute_Boundary_Nodes(nodeCount,LOC,x_max,x_min,y_max,y_min);
% nfbcx: number of boundary nodes in X direction
% nfbcy: number of boundary nodes in Y direction
% fbcx: index of all boundary nodes in X direction
% fbcy: index of all boundary nodes in Y direction

% Specimen's Extra restraint
ynodedamped=[];
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
    for n=1:nodeCount
        if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) || ((LOC(n,2)<=10*le_base+1e-3 & LOC(n,2)>=10*le_base-1e-3))
            nfbcx = nfbcx+1;
            fbcx = [fbcx n];
        end
    end
elseif CasetoRun==21
    for n=1:nodeCount
        if ((LOC(n,2)<=2*le_base-le(2)+1e-3 & LOC(n,2)>=2*le_base-le(2)-1e-3)) || ((LOC(n,2)<=10*le_base+2*le(2)+1e-3 & LOC(n,2)>=10*le_base+2*le(2)-1e-3))
            nfbcx = nfbcx+1;
            fbcx = [fbcx n];
        end
    end
elseif CasetoRun==4
    for n=1:nodeCount
        %if (LOC(n,1)<=140+1e-3 & LOC(n,1)>=40-1e-3) & (LOC(n,2)<=50+1e-3 & LOC(n,2)>=50-1e-3)
        %    nfbcy = nfbcy+1;
        %    fbcy = [fbcy n];
        %end
        %if (LOC(n,1)<=40+1e-3 & LOC(n,1)>=40-1e-3) & (LOC(n,2)<=150+1e-3 & LOC(n,2)>=140-1e-3)
        %    nfbcy = nfbcy+1;
        %    fbcy = [fbcy n];
        %end
    end
elseif CasetoRun==5 || CasetoRun==6
    for n=1:nodeCount
        if CasetoRun==5
            if ((LOC(n,2)<=10*le_base+1e-3 && LOC(n,2)>=10*le_base-1e-3)) && ((LOC(n,1)<=13*le_base+1e-3 && LOC(n,1)>=10*le_base-1e-3))
                nfbcx = nfbcx+1;
                fbcx = [fbcx n];
            end
            if ((LOC(n,2)<=1*le_base+1e-3 & LOC(n,2)>=1*le_base-1e-3)) && ((LOC(n,1)<=5*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3) || (LOC(n,1)<=21*le_base+1e-3 & LOC(n,1)>=18*le_base-1e-3))
                ynodedamped=[ynodedamped n];
            end
        elseif CasetoRun==6
            if ((LOC(n,2)<=10*le_base+1e-3 && LOC(n,2)>=10*le_base-1e-3)) && ((LOC(n,1)<=13*le_base+1e-3 && LOC(n,1)>=10*le_base-1e-3))
                nfbcx = nfbcx+1;
                fbcx = [fbcx n];
            end
            if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=5*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3) || (LOC(n,1)<=21*le_base+1e-3 & LOC(n,1)>=18*le_base-1e-3))
                ynodedamped=[ynodedamped n];
            end
        end
    end
elseif CasetoRun==7
    for n=1:nodeCount
        if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) || ((LOC(n,2)<=10*le_base+1e-3 & LOC(n,2)>=10*le_base-1e-3))
            nfbcx = nfbcx+1;
            fbcx = [fbcx n];
        end
        if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=7*le_base+1e-3 & LOC(n,1)>=3*le_base-1e-3))
            ynodedamped=[ynodedamped n];
        end
    end
elseif CasetoRun==8 || CasetoRun==9
    for n=1:nodeCount
        if CasetoRun==8
            if ((LOC(n,2)<=10*le_base+1e-3 && LOC(n,2)>=10*le_base-1e-3)) && ((LOC(n,1)<=13*le_base+1e-3 && LOC(n,1)>=10*le_base-1e-3))
                nfbcx = nfbcx+1;
                fbcx = [fbcx n];
            end        
        elseif CasetoRun==9
            if ((LOC(n,2)<=10*le_base+1e-3 && LOC(n,2)>=10*le_base-1e-3)) && ((LOC(n,1)<=13*le_base+1e-3 && LOC(n,1)>=10*le_base-1e-3))
                nfbcx = nfbcx+1;
                fbcx = [fbcx n];
            end        
        end
    end
elseif CasetoRun==10
    for n=1:nodeCount
        %wheres it holding?
        if ((LOC(n,2)<=14*le_base+1e-3 && LOC(n,2)>=14*le_base-1e-3)) || ((LOC(n,2)<=2*le_base+1e-3 && LOC(n,2)>=2*le_base-1e-3))
            nfbcx = nfbcx+1;
            fbcx = [fbcx n];
        end
        if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=7*le_base+1e-3 & LOC(n,1)>=3*le_base-1e-3))
            ynodedamped=[ynodedamped n];
        end

    end
elseif CasetoRun==11
    for n=1:nodeCount
        if ((LOC(n,2)<=19*le_base+1e-3 & LOC(n,2)>=19*le_base-1e-3)) && ((LOC(n,2)<=4*le_base+1e-3 & LOC(n,2)>=4*le_base-1e-3))
            nfbcx = nfbcx+1;
            fbcx = [fbcx n];
        end
        %if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=7*le_base+1e-3 & LOC(n,1)>=3*le_base-1e-3))
        %    ynodedamped=[ynodedamped n];
        %end
    end
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41
    for n=1:nodeCount
        if ((LOC(n,2)<=18*le_base+1e-3 & LOC(n,2)>=18*le_base-1e-3) || (LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
            nfbcx = nfbcx+1;
            fbcx = [fbcx n];
        end
        if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
            ynodedamped=[ynodedamped n];
        end
    end
elseif CasetoRun==53
    for n=1:nodeCount
        if ((LOC(n,2)<=18*le_base+1e-3 & LOC(n,2)>=18*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
            nfbcx = nfbcx+1;
            fbcx = [fbcx n];
        end
        if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
            ynodedamped=[ynodedamped n];
        end
    end    
elseif CasetoRun==43
    for n=1:nodeCount
        if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
            nfbcx = nfbcx+1;
            fbcx = [fbcx n];
        end
        if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
            ynodedamped=[ynodedamped n];
        end
    end
elseif CasetoRun==44
    for n=1:nodeCount
        if ((LOC(n,2)<=18*le_base+1e-3 & LOC(n,2)>=18*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
            nfbcx = nfbcx+1;
            fbcx = [fbcx n];
        end
        if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
            ynodedamped=[ynodedamped n];
        end
    end
elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    for n=1:nodeCount
        if CasetoRun==15
            if ((LOC(n,2)<=16*le_base+1e-3 & LOC(n,2)>=16*le_base-1e-3)) && ((LOC(n,1)<=4*le_base+1e-3 & LOC(n,1)>=4*le_base-1e-3))
                nfbcx = nfbcx+1;
                fbcx = [fbcx n];
            end
            if ((LOC(n,2)<=5*le_base+1e-3 & LOC(n,2)>=5*le_base-1e-3)) && ((LOC(n,1)<=7*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
                ynodedamped=[ynodedamped n];
            end
        else
            if ((LOC(n,2)<=19*le_base+1e-3 & LOC(n,2)>=19*le_base-1e-3)) && ((LOC(n,1)<=4*le_base+1e-3 & LOC(n,1)>=4*le_base-1e-3))
                nfbcx = nfbcx+1;
                fbcx = [fbcx n];
            end
            if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=7*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
                ynodedamped=[ynodedamped n];
            end
        end
    end
elseif CasetoRun==64
    for n=1:nodeCount
		if ((LOC(n,2)<=7*le_base+1e-3 & LOC(n,2)>=4*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=8*le_base-1e-3))
			ynodedamped=[ynodedamped n];
		end
    end
elseif CasetoRun==66 || CasetoRun==68
	%{
    for n=1:nodeCount
		if ((LOC(n,2)<=7*le_base+1e-3 & LOC(n,2)>=4*le_base-1e-3)) && ((LOC(n,1)<=13*le_base+1e-3 & LOC(n,1)>=13*le_base-1e-3))
			ynodedamped=[ynodedamped n];
		end
    end
	%}
elseif CasetoRun==71
    for n=1:nodeCount
		if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=22*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
			nfbcx = nfbcx+1;
			fbcx = [fbcx n];
		end
    end
elseif CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77
%{
    for n=1:nodeCount
		if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=23*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
			nfbcx = nfbcx+1;
			fbcx = [fbcx n];
		end
    end
	%}
elseif CasetoRun==111 || CasetoRun==113
	for n=1:nodeCount
		if ((LOC(n,2)<=7*le_base+1e-3 & LOC(n,2)>=7*le_base-1e-3) || (LOC(n,2)<=13*le_base+1e-3 & LOC(n,2)>=13*le_base-1e-3)) && ((LOC(n,1)<=6*le_base+1e-3 & LOC(n,1)>=6*le_base-1e-3))
			nfbcx = nfbcx+1;
			fbcx = [fbcx n];
		end
    end
elseif CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
elseif CasetoRun==112
    for n=1:nodeCount
		if ((LOC(n,2)<=16*le_base+1e-3 & LOC(n,2)>=12*le_base-1e-3)) && ((LOC(n,1)<=2*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
			nfbcy = nfbcy+1;
			fbcy = [fbcy n];
			nfbcx = nfbcx+1;
			fbcx = [fbcx n];
		end
    end
elseif CasetoRun==69
    for n=1:nodeCount
		if ((LOC(n,2)<=8*le_base+1e-3 & LOC(n,2)>=4*le_base-1e-3)) && ((LOC(n,1)<=13*le_base+1e-3 & LOC(n,1)>=13*le_base-1e-3))
			nfbcy = nfbcy+1;
			fbcy = [fbcy n];
		end
    end
elseif CasetoRun==65 || CasetoRun==70
    for n=1:nodeCount
		if ((LOC(n,2)<=5*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=8*le_base-1e-3))
			ynodedamped=[ynodedamped n];
		end
    end
elseif CasetoRun==67
    for n=1:nodeCount
		if ((LOC(n,2)>=2*le_base-1e-3) && (LOC(n,2)<=2*le_base+1e-3)) && ((LOC(n,1)>=8*le_base-1e-3) && (LOC(n,1)<=8*le_base+1e-3))
			ynodedamped=[ynodedamped n];
		end
    end
end

troubleshotparticles=[];
xdirletter{1}=[];
ydirletter{1}=[];
zdirletter{1}=[];
xydirletter{1}=[];
yzdirletter{1}=[];
xzdirletter{1}=[];
thetacrackrtl=[];

yparticledamped=[];
ignoremomentum=[];
Rdisplayedparticles=[];
x_crack=[];
x_cracktop=[];
x_crackbot=[];

rampedyforceparticle1=[];
rampedyforceparticle2=[];
pforcemax=0;

ncforce_cracktop=[];
ncforce_crackbot=[];
ParticleswithPredYVel=[];
ParticlePredYVel=[];

tractionededge=[];
tractionedcorner=[];
x_defaultcracktip=[];

if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
    if CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
        woodcentral_x=3*le_base-5;
        woodcentral_y=2*le_base+40/12*10;
    elseif CasetoRun==52
        woodcentral_x=3*le_base+48.6600;
        woodcentral_y=2*le_base+80-34.5920;
    elseif CasetoRun==54
        woodcentral_x=3*le_base+47.09408825978351;
        woodcentral_y=2*le_base+41.43213988343047;
    end
    %% Particle generation
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=3*le_base;
    x_end=7*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if y_trial<2*le_base
                continue;
            elseif y_trial<10*le_base
                if x_trial<3*le_base
                    continue;
                elseif x_trial>7*le_base
                    continue;
                end
            elseif ((y_trial<11.5*le_base && (CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17)) ...
                    || (y_trial<12*le_base && (CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39))) %related to steel head height
                if ~(x_trial>3*le_base || (x_trial>2*le_base && (CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45)))
                    continue;
                elseif ~(x_trial<7*le_base || (x_trial<8*le_base && (CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45)))
                    continue;
                end
            else
                continue;
            end
            sp=sp+1;
            if x_trial>=x_start && x_trial<=x_end && y_trial>=y_start && y_trial<=y_end
                x_number=round((x_trial-x_start-lp(1)/2)/lp(1)+1);
                y_number=round((y_trial-y_start-lp(2)/2)/lp(2)+1);
                layer(x_number,y_number)=sp;
            end
            %if sp>spCount
            %    disp('spCount wrong!');
            %    pause;
            %end
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            if y_trial<10*le_base
                matmodel(sp)=1; % wood schmidt
                p_sp(sp,1)             = psp1;                % Density
                xdirletter{sp}='r';
                ydirletter{sp}='t';
                zdirletter{sp}='l';
                xydirletter{sp}='rt';
                yzdirletter{sp}='tl';
                xzdirletter{sp}='rl';
            elseif ((y_trial<11.5*le_base && (CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17)) ...
                    || (y_trial<12*le_base && (CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39))) %related to steel head height
                matmodel(sp)=2; %steel
                p_sp(sp,1)             = psp2;                % Density
            end
            if matmodel(sp)==1 || matmodel(sp)==3
                plotignore(sp)=0;
            elseif matmodel(sp)==2
                plotignore(sp)=1;
            end
            weakeningfactor_sp(sp)=0;
            if CasetoRun==1
                orientationoffset(sp)=0;  %counterclockwise in xy plane
            elseif CasetoRun==2
                orientationoffset(sp)=pi/2;  %counterclockwise in xy plane
            elseif CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
                deltax=x_trial-woodcentral_x;
                deltay=y_trial-woodcentral_y;
                orientationoffset(sp)=reliableatan(deltax,deltay);
                %if x_trial<woodcentral_x && x_trial>woodcentral_x-le(1) && y_trial>40 && y_trial<40+le(2)
                %    1;
                %end
            end
            if y_trial<10*le_base & y_trial>(10*le_base-lp(1))
                sp_predvelnum=sp_predvelnum+1;
                displacementmonitoredparticles(sp_predvelnum)=sp;
            end
            %if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
            %    troubleshotparticles=[troubleshotparticles sp];
            %end
        end
    end

elseif CasetoRun==21
    woodcentral_x=3*le_base-5;
    woodcentral_y=2*le_base+40/12*10+le(2);        

    %% Particle generation
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
  
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if y_trial<2*le_base-le(2)
                continue;
            elseif y_trial<2*le_base
                if x_trial<2*le_base
                    continue;
                elseif x_trial>8*le_base
                    continue;
                end
            elseif y_trial<2*le_base+le(2)
                continue;
            elseif y_trial<10*le_base+le(2)
                if x_trial<3*le_base
                    continue;
                elseif x_trial>7*le_base
                    continue;
                end
            elseif y_trial<10*le_base+2*le(2)
                continue;
            elseif y_trial<10*le_base+2*le(2)+le_base
                if x_trial<2*le_base
                    continue;
                elseif x_trial>8*le_base
                    continue;
                end
            else
                continue;
            end
            sp=sp+1;
            %if sp>spCount
            %    disp('spCount wrong!');
            %    pause;
            %end
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            if y_trial>2*le_base+le(2)/2 && y_trial<10*le_base+le(2)+le(2)/2
                matmodel(sp)=1; % wood schmidt
                p_sp(sp,1)             = psp1;                % Density
                xdirletter{sp}='r';
                ydirletter{sp}='t';
                zdirletter{sp}='l';
                xydirletter{sp}='rt';
                yzdirletter{sp}='tl';
                xzdirletter{sp}='rl';
            else
                matmodel(sp)=2; %steel
                p_sp(sp,1)             = psp2;                % Density
            end
            if matmodel(sp)==1 || matmodel(sp)==3
                plotignore(sp)=0;
            elseif matmodel(sp)==2
                plotignore(sp)=1;
            end
            weakeningfactor_sp(sp)=0;
            if CasetoRun==1
                orientationoffset(sp)=0;  %counterclockwise in xy plane
            elseif CasetoRun==2
                orientationoffset(sp)=pi/2;  %counterclockwise in xy plane
            elseif CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
                deltax=x_trial-woodcentral_x;
                deltay=y_trial-woodcentral_y;
                orientationoffset(sp)=reliableatan(deltax,deltay);
                %if x_trial<woodcentral_x && x_trial>woodcentral_x-le(1) && y_trial>40 && y_trial<40+le(2)
                %    1;
                %end
            end
            if y_trial<10*le_base+le(2) & y_trial>(10*le_base+le(2)-lp(1))
                sp_predvelnum=sp_predvelnum+1;
                displacementmonitoredparticles(sp_predvelnum)=sp;
            end
            %if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
            %    troubleshotparticles=[troubleshotparticles sp];
            %end
        end
    end
    

elseif CasetoRun==4
    %% Particle generation
    particle_per_cell       = 4;
    %spCount                 = 10*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction
    %x_sp                    = zeros(spCount,1);
    %d_sp                    = zeros(spCount,2);
    %E_acc                   = zeros(spCount,1);
    %epsilonshrinkdot_sp     = zeros(spCount,1);
    %pforce_sp               = zeros(spCount,2);


    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        if y_trial<20
            continue;
        elseif y_trial>190
            continue;
        end
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if x_trial<20
                continue;
            end
            if y_trial<70
                if x_trial>120
                    continue;
                end
            elseif y_trial<190
                if x_trial>70
                    continue;
                end
            end
            sp=sp+1;
            %if sp>spCount
            %    disp('spCount wrong!');
            %    pause;
            %end
            x_sp(sp,1:2)=[x_trial y_trial];
            matmodel(sp)=1;
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;  %counterclockwise in xy plane
            if y_trial<70
                xdirletter{sp}='l';
                ydirletter{sp}='r';
                zdirletter{sp}='t';
                xydirletter{sp}='lr';
                yzdirletter{sp}='rt';
                xzdirletter{sp}='lt';
            elseif y_trial<190
                xdirletter{sp}='r';
                ydirletter{sp}='l';
                zdirletter{sp}='t';
                xydirletter{sp}='rl';
                yzdirletter{sp}='lt';
                xzdirletter{sp}='rt';
            end
            plotignore(sp)=0;
            if x_trial>20 & x_trial<70 & y_trial<70 & y_trial>(70-lp(2))
                sp_predvelnum=sp_predvelnum+1;
                displacementmonitoredparticles(sp_predvelnum)=sp;
            end
            p_sp(sp,1)             = psp1;                % Density
        end
    end
elseif CasetoRun==5 || CasetoRun==6
    %% Particle generation
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=21*le_base;
    y_start=4*le_base;
    y_end=8*le_base;
    
    if CasetoRun==5
        support(1).center_x=3.5*le_base;
        support(1).center_y=1.5*le_base;
        support(1).radius=1.5*le_base;

        support(2).center_x=19.5*le_base;
        support(2).center_y=1.5*le_base;
        support(2).radius=1.5*le_base;

        support(3).center_x=11.5*le_base;
        support(3).center_y=10.5*le_base;
        support(3).radius=1.5*le_base;
    elseif CasetoRun==6
        support(1).center_x=3.5*le_base;
        support(1).center_y=2.5*le_base;
        support(1).radius=1.5*le_base;

        support(2).center_x=19.5*le_base;
        support(2).center_y=2.5*le_base;
        support(2).radius=1.5*le_base;

        support(3).center_x=11.5*le_base;
        support(3).center_y=9.5*le_base;
        support(3).radius=1.5*le_base;
    end
    woodcentral_x=11.5*le_base;
    woodcentral_y=-4*le_base;
        
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if CasetoRun==5
                if y_trial<le_base
                    continue;
                elseif y_trial<4*le_base
                    if ((x_trial-support(1).center_x)^2+(y_trial-support(1).center_y)^2)<(support(1).radius)^2
                        % dont continue
                    elseif ((x_trial-support(2).center_x)^2+(y_trial-support(2).center_y)^2)<(support(2).radius)^2
                        % dont continue
                    else
                        continue;
                    end

                elseif y_trial<6*le_base
                    if x_trial<2*le_base
                        continue;
                    elseif x_trial>21*le_base
                        continue;
                    elseif x_trial>11*le_base && x_trial<12*le_base
                        continue;
                    %else
                        %dont continue
                    end                
                elseif y_trial<8*le_base
                    if x_trial<2*le_base
                        continue;
                    elseif x_trial>21*le_base
                        continue;
                    %else
                        %dont continue
                    end
                elseif y_trial<9*le_base+support(3).radius
                    if ((x_trial-support(3).center_x)^2+(y_trial-support(3).center_y)^2)<(support(3).radius)^2
                        %dont continue
                    else
                        continue;
                    end
                elseif y_trial<12.5*le_base
                    if ((x_trial-support(3).center_x)^2)<(support(3).radius)^2
                        %dont continue
                    else
                        continue;
                    end
                else
                    continue;
                end
            elseif CasetoRun==6
                if y_trial<2*le_base
                    continue;
                elseif y_trial<4*le_base
                    if ((x_trial-support(1).center_x)^2+(y_trial-support(1).center_y)^2)<(support(1).radius)^2
                        % dont continue
                    elseif ((x_trial-support(2).center_x)^2+(y_trial-support(2).center_y)^2)<(support(2).radius)^2
                        % dont continue
                    else
                        continue;
                    end

                elseif y_trial<6*le_base
                    if x_trial<2*le_base
                        continue;
                    elseif x_trial>21*le_base
                        continue;
                    elseif x_trial>11*le_base && x_trial<12*le_base
                        continue;
                    %else
                        %dont continue
                    end                
                elseif y_trial<8*le_base
                    if x_trial<2*le_base
                        continue;
                    elseif x_trial>21*le_base
                        continue;
                    %else
                        %dont continue
                    end
                elseif y_trial<8*le_base+support(3).radius
                    if ((x_trial-support(3).center_x)^2+(y_trial-support(3).center_y)^2)<(support(3).radius)^2
                        %dont continue
                    else
                        continue;
                    end
                elseif y_trial<12.5*le_base
                    if ((x_trial-support(3).center_x)^2)<(support(3).radius)^2
                        %dont continue
                    else
                        continue;
                    end
                else
                    continue;
                end
            end
            sp=sp+1;
            %if (x_trial>6*le_base && x_trial<6*le_base+lp(1)) && (y_trial>6*le_base && y_trial<6*le_base+lp(1))
            %    Rdisplayedparticles=[Rdisplayedparticles sp];
            %end
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            if y_trial>8*le_base
                ignoremomentum(sp,1)=1;
            else
                ignoremomentum(sp,1)=0;
            end
            if y_trial<4*le_base || y_trial>8*le_base
                matmodel(sp)=2;
                p_sp(sp,1)=psp2;
            else
                matmodel(sp)=1; % wood schmidt
                p_sp(sp,1)             = psp1;                % Density
                xdirletter{sp}='l';
                ydirletter{sp}='r';
                zdirletter{sp}='t';
                xydirletter{sp}='lr';
                yzdirletter{sp}='rt';
                xzdirletter{sp}='lt';
            end
            if matmodel(sp)==1 || matmodel(sp)==3
                plotignore(sp)=0;
            elseif matmodel(sp)==2
                plotignore(sp)=1;
            end
            orientationoffset(sp)=(x_trial-((21-2)/2+2)*le_base)/((21-2)*le_base)*2*(pi/3);
            deltax=x_trial-woodcentral_x;
            deltay=y_trial-woodcentral_y;
            orientationoffset(sp)=reliableatan(deltax,deltay)-pi/2;
            orientationoffset(sp)=0;
            weakeningfactor_sp(sp)=0;
            if x_trial>11*le_base && x_trial<12*le_base && y_trial>6*le_base && y_trial<7*le_base
                sp_predvelnum=sp_predvelnum+1;
                displacementmonitoredparticles(sp_predvelnum)=sp;
            end
            if CasetoRun==5
                if y_trial<1*le_base+lp(2) && y_trial>1*le_base && ((x_trial>2*le_base && x_trial<5*le_base) || (x_trial>18*le_base && x_trial<21*le_base))
                    yparticledamped=[yparticledamped sp];
                end
            elseif CasetoRun==6
                if y_trial<2*le_base+lp(2) && y_trial>2*le_base && ((x_trial>2*le_base && x_trial<5*le_base) || (x_trial>18*le_base && x_trial<21*le_base))
                    yparticledamped=[yparticledamped sp];
                end
            end
        end
    end
elseif CasetoRun==7
    %% Particle generation
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=3*le_base;
    x_end=7*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if y_trial<2*le_base
                continue;
            elseif y_trial<10*le_base
                if x_trial<3*le_base
                    continue;
                elseif x_trial >7*le_base
                    continue;
                end
            elseif y_trial<14*le_base
                if x_trial<2*le_base
                    continue;
                elseif x_trial>8*le_base
                    continue;
                end
            else
                continue;
            end
            sp=sp+1;
            ignoremomentum(sp,1)=0;
            if x_trial>=x_start && x_trial<=x_end && y_trial>=y_start && y_trial<=y_end
                x_number=round((x_trial-x_start-lp(1)/2)/lp(1)+1);
                y_number=round((y_trial-y_start-lp(2)/2)/lp(2)+1);
                layer(x_number,y_number)=sp;
            end
            %if sp>spCount
            %    disp('spCount wrong!');
            %    pause;
            %end
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            if y_trial<10*le_base
                matmodel(sp)=1; % wood schmidt
                p_sp(sp,1)             = psp1;                % Density
                xdirletter{sp}='r';
                ydirletter{sp}='t';
                zdirletter{sp}='l';
                xydirletter{sp}='rt';
                yzdirletter{sp}='tl';
                xzdirletter{sp}='rl';
            elseif y_trial<14*le_base
                matmodel(sp)=2; %steel
                ignoremomentum(sp,1)=1;
                p_sp(sp,1)             = psp2;                % Density
            end
            if matmodel(sp)==1 || matmodel(sp)==3
                plotignore(sp)=0;
            elseif matmodel(sp)==2
                plotignore(sp)=1;
            end
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;  %counterclockwise in xy plane
            if y_trial<14*le_base & y_trial>(14*le_base-lp(1))
                sp_predvelnum=sp_predvelnum+1;
                displacementmonitoredparticles(sp_predvelnum)=sp;
            end
            if y_trial<2*le_base+lp(2) && y_trial>2*le_base && x_trial>3*le_base && x_trial<7*le_base
                yparticledamped=[yparticledamped sp];
            end
            %if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
            %    troubleshotparticles=[troubleshotparticles sp];
            %end
        end
    end
elseif CasetoRun==8 || CasetoRun==9
    %% Particle generation
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    %lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    %lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=21*le_base;
    y_start=4*le_base;
    y_end=8*le_base;
    
    if CasetoRun==8
        support(1).center_x=3.5*le_base;
        support(1).center_y=1.5*le_base;
        support(1).radius=1.5*le_base;

        support(2).center_x=19.5*le_base;
        support(2).center_y=1.5*le_base;
        support(2).radius=1.5*le_base;

        support(3).center_x=11.5*le_base;
        support(3).center_y=10.5*le_base;
        support(3).radius=1.5*le_base;
    elseif CasetoRun==9
        support(1).center_x=3.5*le_base;
        support(1).center_y=2.5*le_base;
        support(1).radius=1.5*le_base;

        support(2).center_x=19.5*le_base;
        support(2).center_y=2.5*le_base;
        support(2).radius=1.5*le_base;

        support(3).center_x=11.5*le_base;
        support(3).center_y=9.5*le_base;
        support(3).radius=1.5*le_base;
    end
    
    for i=1:length(le_x)
        lp_trial_x=le_x(i)/sqrt(particle_per_cell);
        for j=1:length(le_y)
            lp_trial_y=le_y(j)/sqrt(particle_per_cell);
            for k=1:sqrt(particle_per_cell)
                x_trial=sum(le_x(1:i-1))+0.5*lp_trial_x+(k-1)*lp_trial_x;
                for l=1:sqrt(particle_per_cell)
                    y_trial=sum(le_y(1:j-1))+0.5*lp_trial_y+(l-1)*lp_trial_y;
                    if CasetoRun==8
                        if y_trial<le_base
                            continue;
                        elseif y_trial<4*le_base
                            if ((x_trial-support(1).center_x)^2+(y_trial-support(1).center_y)^2)<(support(1).radius)^2
                                % dont continue
                            elseif ((x_trial-support(2).center_x)^2+(y_trial-support(2).center_y)^2)<(support(2).radius)^2
                                % dont continue
                            else
                                continue;
                            end

                        elseif y_trial<6*le_base
                            if x_trial<2*le_base
                                continue;
                            elseif x_trial>21*le_base
                                continue;
                            elseif (x_trial-11.5*le_base)^2 < notchwidth^2
                                continue;
                            %else
                                %dont continue
                            end                
                        elseif y_trial<8*le_base
                            if x_trial<2*le_base
                                continue;
                            elseif x_trial>21*le_base
                                continue;
                            %else
                                %dont continue
                            end
                        elseif y_trial<9*le_base+support(3).radius
                            if ((x_trial-support(3).center_x)^2+(y_trial-support(3).center_y)^2)<(support(3).radius)^2
                                %dont continue
                            else
                                continue;
                            end
                        elseif y_trial<12*le_base
                            if ((x_trial-support(3).center_x)^2)<(support(3).radius)^2
                                %dont continue
                            else
                                continue;
                            end
                        else
                            continue;
                        end
                    elseif CasetoRun==9
                        if y_trial<2*le_base
                            continue;
                        elseif y_trial<4*le_base
                            if ((x_trial-support(1).center_x)^2+(y_trial-support(1).center_y)^2)<(support(1).radius)^2
                                % dont continue
                            elseif ((x_trial-support(2).center_x)^2+(y_trial-support(2).center_y)^2)<(support(2).radius)^2
                                % dont continue
                            else
                                continue;
                            end

                        elseif y_trial<6*le_base
                            if x_trial<2*le_base
                                continue;
                            elseif x_trial>21*le_base
                                continue;
                            elseif (x_trial-11.5*le_base)^2 < notchwidth^2
                                continue;
                            %else
                                %dont continue
                            end                
                        elseif y_trial<8*le_base
                            if x_trial<2*le_base
                                continue;
                            elseif x_trial>21*le_base
                                continue;
                            %else
                                %dont continue
                            end
                        elseif y_trial<8*le_base+support(3).radius
                            if ((x_trial-support(3).center_x)^2+(y_trial-support(3).center_y)^2)<(support(3).radius)^2
                                %dont continue
                            else
                                continue;
                            end
                        elseif y_trial<12*le_base
                            if ((x_trial-support(3).center_x)^2)<(support(3).radius)^2
                                %dont continue
                            else
                                continue;
                            end
                        else
                            continue;
                        end
                    end
                    sp=sp+1;
                    xdirletter{sp}=[];
                    ydirletter{sp}=[];
                    zdirletter{sp}=[];
                    xydirletter{sp}=[];
                    yzdirletter{sp}=[];
                    xzdirletter{sp}=[];
                    x_sp(sp,1:2)=[x_trial y_trial];
                    lp(sp,1:2)=[lp_trial_x lp_trial_y];
                    if y_trial<4*le_base || y_trial>8*le_base
                        matmodel(sp)=2;
                        p_sp(sp,1)=psp2;
                    else
                        matmodel(sp)=1; % wood schmidt
                        p_sp(sp,1)             = psp1;                % Density
                        xdirletter{sp}='l';
                        ydirletter{sp}='r';
                        zdirletter{sp}='t';
                        xydirletter{sp}='lr';
                        yzdirletter{sp}='rt';
                        xzdirletter{sp}='lt';
                    end
                    if matmodel(sp)==1 || matmodel(sp)==3
                        plotignore(sp)=0;
                    elseif matmodel(sp)==2
                        plotignore(sp)=1;
                    end
                    orientationoffset(sp)=0;
                    weakeningfactor_sp(sp)=0;
                    if x_trial>11*le_base && x_trial<12*le_base && y_trial>6*le_base && y_trial<7*le_base
                        sp_predvelnum=sp_predvelnum+1;
                        displacementmonitoredparticles(sp_predvelnum)=sp;
                    end
                end
            end
        end
    end
elseif CasetoRun==10

    %% Particle generation
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=3*le_base;
    x_end=7*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if y_trial<2*le_base
                continue;
            elseif y_trial<10*le_base
                if x_trial<3*le_base
                    continue;
                elseif x_trial >7*le_base
                    continue;
                end
            elseif y_trial<11*le_base
                if x_trial<3*le_base
                    continue;
                elseif x_trial>7*le_base
                    continue;
                end
            else
                continue;
            end
            sp=sp+1;
            if x_trial>=x_start && x_trial<=x_end && y_trial>=y_start && y_trial<=y_end
                x_number=round((x_trial-x_start-lp(1)/2)/lp(1)+1);
                y_number=round((y_trial-y_start-lp(2)/2)/lp(2)+1);
                layer(x_number,y_number)=sp;
            end
            if y_trial>10*le_base
                ignoremomentum(sp,1)=1;
            else
                ignoremomentum(sp,1)=0;
            end
            %if sp>spCount
            %    disp('spCount wrong!');
            %    pause;
            %end
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            if y_trial<10*le_base
                matmodel(sp)=1; % wood schmidt
                p_sp(sp,1)             = psp1;                % Density
                xdirletter{sp}='t';
                ydirletter{sp}='r';
                zdirletter{sp}='l';
                xydirletter{sp}='tr';
                yzdirletter{sp}='rl';
                xzdirletter{sp}='tl';
            elseif y_trial<14*le_base
                matmodel(sp)=2; %steel
                p_sp(sp,1)             = psp2;                % Density
            end
            if y_trial<2*le_base+lp(2) && y_trial>2*le_base && ((x_trial>3*le_base && x_trial<7*le_base))
                yparticledamped=[yparticledamped sp];
            end

            if matmodel(sp)==1 || matmodel(sp)==3
                plotignore(sp)=0;
            elseif matmodel(sp)==2
                plotignore(sp)=1;
            end
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;  %counterclockwise in xy plane
            if y_trial<10*le_base & y_trial>(10*le_base-lp(1))
                sp_predvelnum=sp_predvelnum+1;
                displacementmonitoredparticles(sp_predvelnum)=sp;
            end
            %if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
            %    troubleshotparticles=[troubleshotparticles sp];
            %end
        end
    end
    
elseif CasetoRun==11
    knot.x=4.5*le_base;
    knot.y=10*le_base;
    knot.r=0.5*le_base;
    knot.xaffect=2*le_base;
    knot.yaffect=3*le_base;
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=7*le_base;
    y_start=2*le_base;
    y_end=19*le_base;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if y_trial<2*le_base
                continue;
            elseif y_trial<18*le_base
                if x_trial<2*le_base
                    continue;
                elseif x_trial >7*le_base
                    continue;
                end
            elseif y_trial<19*le_base %related to steel head height
                if x_trial<2*le_base
                    continue;
                elseif x_trial>7*le_base
                    continue;
                end
            else
                continue;
            end
            knot.deltaxtocenter=x_trial-knot.x;
            knot.deltaytocenter=y_trial-knot.y;
            if (knot.deltaxtocenter^2+knot.deltaytocenter^2)<knot.r^2
                continue;
            end
            sp=sp+1;
            if x_trial>=x_start && x_trial<=x_end && y_trial>=y_start && y_trial<=y_end
                x_number=round((x_trial-x_start-lp(1)/2)/lp(1)+1);
                y_number=round((y_trial-y_start-lp(2)/2)/lp(2)+1);
                layer(x_number,y_number)=sp;
            end
            if y_trial>18*le_base
                ignoremomentum(sp,1)=1;
            else
                ignoremomentum(sp,1)=0;
            end
            %if sp>spCount
            %    disp('spCount wrong!');
            %    pause;
            %end
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            if y_trial<18*le_base
                matmodel(sp)=1; % wood schmidt
                p_sp(sp,1)             = psp1;                % Density
                xdirletter{sp}='t';
                ydirletter{sp}='l';
                zdirletter{sp}='r';
                xydirletter{sp}='tl';
                yzdirletter{sp}='lr';
                xzdirletter{sp}='tr';
            elseif y_trial<19*le_base %related to steel head height
                matmodel(sp)=2; %steel
                p_sp(sp,1)             = psp2;                % Density
            end
            if matmodel(sp)==1 || matmodel(sp)==3
                plotignore(sp)=0;
            elseif matmodel(sp)==2
                plotignore(sp)=1;
            end
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
            xside=0;
            yside=0;
            if x_trial>knot.x-knot.xaffect && x_trial<knot.x+knot.xaffect
                if x_trial<knot.x
                    xside=1;
                else
                    xside=2;
                end
            end
            if y_trial>knot.y-knot.yaffect && y_trial<knot.y+knot.yaffect
                if y_trial<knot.y
                    yside=1;
                else
                    yside=2;
                end
            end
            
            if xside==1
                knot.x_trial_relative=x_trial-(knot.x-knot.xaffect);
            elseif xside==2
                knot.x_trial_relative=(knot.x+knot.xaffect)-x_trial;
            end
            if yside==1
                knot.y_trial_relative=y_trial-(knot.y-knot.yaffect);
            elseif yside==2
                knot.y_trial_relative=(knot.y+knot.yaffect)-y_trial;
            end
            L0=knot.xaffect;
            L1=knot.xaffect-knot.x;
            A=2*L1/L0-1;
            h=knot.yaffect;
            if xside==1 && yside==1 || xside==2 && yside==2
                orientationoffset(sp)=-atan(-0.5*knot.x_trial_relative^2*(1-A)/L0*(0.5*pi/h)*sin(pi*knot.y_trial_relative/h));
            elseif xside==1 && yside==2 || xside==2 && yside==1
                orientationoffset(sp)=atan(-0.5*knot.x_trial_relative^2*(1-A)/L0*(0.5*pi/h)*sin(pi*knot.y_trial_relative/h));
            end                    
            if y_trial<10*le_base & y_trial>(10*le_base-lp(1))
                sp_predvelnum=sp_predvelnum+1;
                displacementmonitoredparticles(sp_predvelnum)=sp;
            end
            %if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
            %    troubleshotparticles=[troubleshotparticles sp];
            %end
            %if y_trial<2*le_base+lp(2) && y_trial>2*le_base && (x_trial>2*le_base && x_trial<7*le_base)
            %    yparticledamped=[yparticledamped sp];
            %end
        end
    end
        
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    if CasetoRun==12
        knot.x=5*le_base;
    elseif CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
        knot.x=2*le_base+(1/4*90);
    end
    knot.y=7*le_base;
    knot.r=0.5*le_base;
    knot.xaffect=2*le_base;
    knot.yaffect=3*le_base;
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=8*le_base;
    y_start=2*le_base;
    y_end=19.5*le_base;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if y_trial<2*le_base
                continue;
            elseif y_trial<18*le_base
                if x_trial<2*le_base
                    continue;
                elseif x_trial >8*le_base
                    continue;
                end
            elseif y_trial<19.5*le_base %related to steel head height
                if x_trial<2*le_base
                    continue;
                elseif x_trial>8*le_base
                    continue;
                end
            else
                continue;
            end
            knot.deltaxtocenter=x_trial-knot.x;
            knot.deltaytocenter=y_trial-knot.y;
            if (knot.deltaxtocenter^2+knot.deltaytocenter^2)<knot.r^2
                thisisknot=1;
            else
                thisisknot=0;
            end
            sp=sp+1;
            if x_trial>=x_start && x_trial<=x_end && y_trial>=y_start && y_trial<=y_end
                x_number=round((x_trial-x_start-lp(1)/2)/lp(1)+1);
                y_number=round((y_trial-y_start-lp(2)/2)/lp(2)+1);
                layer(x_number,y_number)=sp;
            end
            if y_trial>18*le_base
                ignoremomentum(sp,1)=1;
            else
                ignoremomentum(sp,1)=0;
            end
            %if sp>spCount
            %    disp('spCount wrong!');
            %    pause;
            %end
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            if y_trial<18*le_base
                matmodel(sp)=1; % wood schmidt
                p_sp(sp,1)             = psp1;                % Density
                xdirletter{sp}='t';
                ydirletter{sp}='l';
                zdirletter{sp}='r';
                xydirletter{sp}='tl';
                yzdirletter{sp}='lr';
                xzdirletter{sp}='tr';
            elseif y_trial<19.5*le_base %related to steel head height
                matmodel(sp)=2; %steel
                p_sp(sp,1)             = psp2;                % Density
            end
            if matmodel(sp)==1 || matmodel(sp)==3
                plotignore(sp)=0;
            elseif matmodel(sp)==2
                plotignore(sp)=1;
            end
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
            if thisisknot
                if CasetoRun==12
                    weakeningfactor_sp(sp)=0.7;
                    if x_trial>75 && x_trial<75+lp(1) && y_trial>112.5-lp(2) && y_trial<112.5
                        weakeningfactor_sp(sp)=0.95;
                    elseif x_trial>67.5 && x_trial<67.5+lp(1) && y_trial>105-lp(2) && y_trial<105
                        weakeningfactor_sp(sp)=0.95;
                    end
                elseif CasetoRun==16
                    weakeningfactor_sp(sp)=0.7;
                    if x_trial>52.5 && x_trial<52.5+lp(1) && y_trial>112.5-lp(2) && y_trial<112.5
                        weakeningfactor_sp(sp)=0.95;
                    elseif x_trial>45 && x_trial<45+lp(1) && y_trial>105-lp(2) && y_trial<105
                        weakeningfactor_sp(sp)=0.95;
                    end
                elseif CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
                    weakeningfactor_sp(sp)=0.7;
                end
                xdirletter{sp}='r';
                ydirletter{sp}='t';
                zdirletter{sp}='l';
                xydirletter{sp}='rt';
                yzdirletter{sp}='tl';
                xzdirletter{sp}='rl';
                orientationoffset(sp)=reliableatan(knot.deltaxtocenter,knot.deltaytocenter);
            else
                xside=0;
                yside=0;
                if x_trial>knot.x-knot.xaffect && x_trial<knot.x+knot.xaffect
                    if x_trial<knot.x
                        xside=1;
                    else
                        xside=2;
                    end
                end
                if y_trial>knot.y-knot.yaffect && y_trial<knot.y+knot.yaffect
                    if y_trial<knot.y
                        yside=1;
                    else
                        yside=2;
                    end
                end

                if xside==1
                    knot.x_trial_relative=x_trial-(knot.x-knot.xaffect);
                elseif xside==2
                    knot.x_trial_relative=(knot.x+knot.xaffect)-x_trial;
                end
                if yside==1
                    knot.y_trial_relative=y_trial-(knot.y-knot.yaffect);
                elseif yside==2
                    knot.y_trial_relative=(knot.y+knot.yaffect)-y_trial;
                end
                L0=knot.xaffect;
                L1=knot.xaffect-knot.r;
                A=2*L1/L0-1;
                h=knot.yaffect;
                %if xside==1 && yside==1 || xside==2 && yside==2
                %    orientationoffset(sp)=-atan(-0.5*knot.x_trial_relative^2*(1-A)/L0*(0.5*pi/h)*sin(pi*knot.y_trial_relative/h));
                %elseif xside==1 && yside==2 || xside==2 && yside==1
                %    orientationoffset(sp)=atan(-0.5*knot.x_trial_relative^2*(1-A)/L0*(0.5*pi/h)*sin(pi*knot.y_trial_relative/h));
                %end                    
                if y_trial<18*le_base & y_trial>(18*le_base-lp(1))
                    sp_predvelnum=sp_predvelnum+1;
                    displacementmonitoredparticles(sp_predvelnum)=sp;
                end
                if xside>0 && yside>0
                    knot.deltax=x_trial-knot.x;
                    knot.deltay=y_trial-knot.y;
                    if knot.deltax>0 && knot.deltay>0
                        1;
                    end
                    %dxdy=1/(-1/(-sign(x_trial-knot.x)*((pi*sin((knot.deltay*pi)/h)*((knot.deltax-L0) - knot.r + ((knot.deltax-L0)^2*((L0 - 2*knot.r)/L0 - 1))/(2*L0) - ((knot.deltax-L0)*(L0 - 2*knot.r))/L0))/(2*h))));
                    dxdy=(sign(knot.deltax)*((pi*sin((knot.deltay*pi)/h)*((abs(knot.deltax)-L0) - knot.r + ((abs(knot.deltax)-L0)^2*((L0 - 2*knot.r)/L0 - 1))/(2*L0) - ((abs(knot.deltax)-L0)*(L0 - 2*knot.r))/L0))/(2*h)));
                    dydx=1/dxdy;
                    tantheta=-1/dydx;
                    %knot.deltax=knot.deltax-L0;
                    %orientationoffset(sp)=-atan((pi*sin((knot.deltay*pi)/h)*(knot.deltax - knot.r + (knot.deltax^2*((L0 - 2*knot.r)/L0 - 1))/(2*L0) - (knot.deltax*(L0 - 2*knot.r))/L0))/(2*h));
                    %orientationoffset(sp)=atan(-sign(x_trial-knot.x)*((pi*sin((knot.deltay*pi)/h)*((knot.deltax-L0) - knot.r + ((knot.deltax-L0)^2*((L0 - 2*knot.r)/L0 - 1))/(2*L0) - ((knot.deltax-L0)*(L0 - 2*knot.r))/L0))/(2*h)));
                    orientationoffset(sp)=atan(tantheta);
                    
                end
                %if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
                %    troubleshotparticles=[troubleshotparticles sp];
                %end
                if y_trial<2*le_base+lp(2) && y_trial>2*le_base && (x_trial>2*le_base && x_trial<8*le_base)
                    yparticledamped=[yparticledamped sp];
                end
            end
        end
    end
        
elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    
    if CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
        knot(1).x=72+2*le_base;
        knot(1).y=10*le_base-20;
        knot(1).rx=7.625;
        knot(1).ry=7.625;
        knot(1).theta=0;
        knot(1).xaffect=2.5*knot(1).rx;
        knot(1).yaffect=5*knot(1).rx;
        knot(2).x=28.8+2*le_base;
        knot(2).y=10*le_base+20;
        knot(2).rx=14;
        knot(2).ry=8.5;
        knot(2).theta=atan(-1/5.5);
        knot(2).xaffect=[];
        knot(2).yaffect=[];
    else
        knot(1).x=72+2*le_base;
        knot(1).y=10*le_base-20;
        knot(1).r=7.625;
        knot(1).xaffect=2.5*knot(1).r;
        knot(1).yaffect=5*knot(1).r;
        knot(2).x=28.8+2*le_base;
        knot(2).y=10*le_base+20;
        knot(2).r=10.875;
        knot(2).xaffect=2.5*knot(2).r;
        knot(2).yaffect=5*knot(2).r;
    end
    if CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
        Xobservedrelative=[0 5 10 15 20 25 30 35 40 45 50 55];
        Yobservedrelative=[140 110 105 100 95 90 85 80 75 70 50];
        Xbigknotobserved=28.5;
        Ybigknotobserved=93;
        Xshift=knot(2).x-Xbigknotobserved;
        Yshift=knot(2).y-Ybigknotobserved;
        Xlist=Xobservedrelative+Xshift;
        Ylist=Yobservedrelative+Yshift;
        oneovertanthetalist=[1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99;
            1e99    -8  -6  -3  -2.5    -2  -1.5    -2  -2.8    -3.1    -6  1e99;
            1e99    -10 -4.5    -2.5    -1  -1/12   -1/1.5  -1.25   -1.25   -2  -6  1e99;
            1e99    -19 -9.5    -1.5    -1/5.5  1/4 1/2.5   1/2 1/1.3   -3  -13 1e99;
            1e99    1e99    -8  -3  -4  5   1/4 3.5 1/1.5   3.5 1e99    1e99;
            1e99	7   1/2 1   1/2 1/4 -1/2.5  -1  -8  1e99    12	1e99;
            1e99	7	5.2	2	1/2	1/6	1/17.5	-1/10	-1/2	-1	-4.5    1e99;
            1e99	9	7	4.5	1.8	1/2	1/1.8	1/3	1.5	-7	-15 1e99;
            1e99    8   8   4.2 1.5 1/1.5   1/1.3   1.1 2   3   10  1e99;
            1e99    8   4   2.5 1.7 1.2 1.4 1.4 2.5 4   15  1e99;
            1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99];

        for i=1:size(oneovertanthetalist,1)
            for j=1:size(oneovertanthetalist,2)
                tanthetalist(i,j)=1/oneovertanthetalist(i,j);
                thetalist(i,j)=atan(tanthetalist(i,j));
            end
        end
    end
    %{
    knot(1).x=3.5*le_base;
    knot(1).y=(10.5+0.25)*le_base;
    knot(1).r=0*le_base;
    knot(1).xaffect=0*le_base;
    knot(1).yaffect=0*le_base;
    %}
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    if CasetoRun==15
        x_start=2*le_base;
        x_end=7*le_base;
        y_start=5*le_base;
        y_end=16*le_base;
    else
        x_start=2*le_base;
        x_end=7*le_base;
        y_start=2*le_base;
        y_end=19*le_base;
    end
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if CasetoRun==15
                if y_trial<5*le_base
                    continue;
                elseif y_trial<15*le_base
                    if x_trial<2*le_base
                        continue;
                    elseif x_trial >7*le_base
                        continue;
                    end
                elseif y_trial<16*le_base %related to steel head height
                    if x_trial<2*le_base
                        continue;
                    elseif x_trial>7*le_base
                        continue;
                    end
                else
                    continue;
                end
            else
                if y_trial<2*le_base
                    continue;
                elseif y_trial<18*le_base
                    if x_trial<2*le_base
                        continue;
                    elseif x_trial >7*le_base
                        continue;
                    end
                elseif y_trial<19*le_base %related to steel head height
                    if x_trial<2*le_base
                        continue;
                    elseif x_trial>7*le_base
                        continue;
                    end
                else
                    continue;
                end
            end
            continuesignal=0;
            for knotnum=1:length(knot)
                if CasetoRun==25 || CasetoRun==32 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
                    if ((x_trial-knot(knotnum).x)*cos(knot(knotnum).theta)+(y_trial-knot(knotnum).y)*sin(knot(knotnum).theta))^2/knot(knotnum).rx^2+((x_trial-knot(knotnum).x)*sin(knot(knotnum).theta)-(y_trial-knot(knotnum).y)*cos(knot(knotnum).theta))^2/knot(knotnum).ry^2<1
                        continuesignal=1;
                    end
                elseif CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61
                else 
                    knot_deltax=x_trial-knot(knotnum).x;
                    knot_deltay=y_trial-knot(knotnum).y;
                    if (knot_deltax^2+knot_deltay^2)<knot(knotnum).r^2
                        continuesignal=1;
                    end
                end
            end
            if continuesignal==1
                continue;
            end
            sp=sp+1;
            if x_trial>=x_start && x_trial<=x_end && y_trial>=y_start && y_trial<=y_end
                x_number=round((x_trial-x_start-lp(1)/2)/lp(1)+1);
                y_number=round((y_trial-y_start-lp(2)/2)/lp(2)+1);
                layer(x_number,y_number)=sp;
            end
            if CasetoRun==15
                if y_trial>15*le_base
                    ignoremomentum(sp,1)=1;
                else
                    ignoremomentum(sp,1)=0;
                end
            else
                if y_trial>18*le_base
                    ignoremomentum(sp,1)=1;
                else
                    ignoremomentum(sp,1)=0;
                end
            end
            %if sp>spCount
            %    disp('spCount wrong!');
            %    pause;
            %end
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            if CasetoRun==15
                if y_trial<15*le_base
                    matmodel(sp)=1; % wood schmidt
                    p_sp(sp,1)             = psp1;                % Density
                    xdirletter{sp}='t';
                    ydirletter{sp}='l';
                    zdirletter{sp}='r';
                    xydirletter{sp}='tl';
                    yzdirletter{sp}='lr';
                    xzdirletter{sp}='tr';
                elseif y_trial<16*le_base %related to steel head height
                    matmodel(sp)=2; %steel
                    p_sp(sp,1)             = psp2;                % Density
                end
            elseif CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
                if y_trial<18*le_base
                    if CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63
                        itsasquishyball=0;
                        for knotnum=1:length(knot)
                            if ((x_trial-knot(knotnum).x)*cos(knot(knotnum).theta)+(y_trial-knot(knotnum).y)*sin(knot(knotnum).theta))^2/knot(knotnum).rx^2+((x_trial-knot(knotnum).x)*sin(knot(knotnum).theta)-(y_trial-knot(knotnum).y)*cos(knot(knotnum).theta))^2/knot(knotnum).ry^2<1
                                itsasquishyball=1;
                            end
                        end
                        if itsasquishyball
                            matmodel(sp)=3;
                            p_sp(sp,1)=psp1;
                        else
                            matmodel(sp)=1; % wood schmidt
                            p_sp(sp,1)             = psp1;                % Density
                            xdirletter{sp}='l';
                            ydirletter{sp}='t';
                            zdirletter{sp}='r';
                            xydirletter{sp}='lt';
                            yzdirletter{sp}='tr';
                            xzdirletter{sp}='lr';
                        end
                    else
                        matmodel(sp)=1; % wood schmidt
                        p_sp(sp,1)             = psp1;                % Density
                        xdirletter{sp}='l';
                        ydirletter{sp}='t';
                        zdirletter{sp}='r';
                        xydirletter{sp}='lt';
                        yzdirletter{sp}='tr';
                        xzdirletter{sp}='lr';
                    end
                elseif y_trial<19*le_base %related to steel head height
                    matmodel(sp)=2; %steel
                    p_sp(sp,1)             = psp2;                % Density
                end
            else
                if y_trial<18*le_base
                    if CasetoRun==57 || CasetoRun==58 || CasetoRun==61
                        itsasquishyball=0;
                        for knotnum=1:length(knot)
                            if ((x_trial-knot(knotnum).x)*cos(knot(knotnum).theta)+(y_trial-knot(knotnum).y)*sin(knot(knotnum).theta))^2/knot(knotnum).rx^2+((x_trial-knot(knotnum).x)*sin(knot(knotnum).theta)-(y_trial-knot(knotnum).y)*cos(knot(knotnum).theta))^2/knot(knotnum).ry^2<1
                                itsasquishyball=1;
                            end
                        end
                        if itsasquishyball
                            matmodel(sp)=3;
                            p_sp(sp,1)=psp1;
                        else
                            matmodel(sp)=1; % wood schmidt
                            p_sp(sp,1)             = psp1;                % Density
                            xdirletter{sp}='t';
                            ydirletter{sp}='l';
                            zdirletter{sp}='r';
                            xydirletter{sp}='tl';
                            yzdirletter{sp}='lr';
                            xzdirletter{sp}='tr';
                        end
                    else
                        matmodel(sp)=1; % wood schmidt
                        p_sp(sp,1)             = psp1;                % Density
                        xdirletter{sp}='t';
                        ydirletter{sp}='l';
                        zdirletter{sp}='r';
                        xydirletter{sp}='tl';
                        yzdirletter{sp}='lr';
                        xzdirletter{sp}='tr';
                    end
                elseif y_trial<19*le_base %related to steel head height
                    matmodel(sp)=2; %steel
                    p_sp(sp,1)             = psp2;                % Density
                end
            end
            if matmodel(sp)==1 || matmodel(sp)==3
                plotignore(sp)=0;
            elseif matmodel(sp)==2
                plotignore(sp)=1;
            end
            weakeningfactor_sp(sp)=0;
            if CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61
                orientationoffset(sp)=0;
                for knotnum=1:1
                    if abs(x_trial-knot(knotnum).x)<=knot(knotnum).xaffect && abs(y_trial-knot(knotnum).y)<=knot(knotnum).yaffect
                        knot_deltax=x_trial-knot(knotnum).x;
                        knot_deltay=y_trial-knot(knotnum).y;
                        L0=knot(knotnum).xaffect;
                        L1=knot(knotnum).xaffect-knot(knotnum).x;
                        h=knot(knotnum).yaffect;
                        if CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
                            dxdy=(sign(knot_deltax)*((pi*sin((knot_deltay*pi)/h)*((abs(knot_deltax)-L0) - knot(knotnum).rx + ((abs(knot_deltax)-L0)^2*((L0 - 2*knot(knotnum).rx)/L0 - 1))/(2*L0) - ((abs(knot_deltax)-L0)*(L0 - 2*knot(knotnum).rx))/L0))/(2*h)));
                        else
                            dxdy=(sign(knot_deltax)*((pi*sin((knot_deltay*pi)/h)*((abs(knot_deltax)-L0) - knot(knotnum).r + ((abs(knot_deltax)-L0)^2*((L0 - 2*knot(knotnum).r)/L0 - 1))/(2*L0) - ((abs(knot_deltax)-L0)*(L0 - 2*knot(knotnum).r))/L0))/(2*h)));
                        end
                        orientationoffset(sp)=atan(-dxdy);
                    end
                end
                if x_trial>min(Xlist) && x_trial<max(Xlist) && y_trial>min(Ylist) && y_trial<max(Ylist)
                    orientationoffset(sp)=interp2(Xlist,Ylist,thetalist,x_trial,y_trial);
                end
                
                if y_trial<18*le_base & y_trial>(18*le_base-lp(1))
                    sp_predvelnum=sp_predvelnum+1;
                    displacementmonitoredparticles(sp_predvelnum)=sp;
                end
                %if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
                %    troubleshotparticles=[troubleshotparticles sp];
                %end
            elseif CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
                if plotignore(sp)
                    orientationoffset(sp)=0;
                elseif matmodel(sp)==3
                    orientationoffset(sp)=0;
                elseif y_trial<=13*le_base && y_trial>=7*le_base
                    %orientationoffset(sp)=gerhardangles(2*le_base,7*le_base,x_trial,y_trial);
                    %orientationoffset(sp)=gerhardanglesellipseonly(x_trial,y_trial,knot);
                    orientationoffset(sp)=gerhardanglescombined(2*le_base,7*le_base,x_trial,y_trial,knot,CasetoRun);
                    if orientationoffset(sp)<0 || orientationoffset(sp)>pi
                        disp('angle inccorect')
                        pause
                        1;
                    end
                else
                    orientationoffset(sp)=pi/2;
                end
            else
                dxdy=0;
                for knotnum=1:length(knot)
                    if abs(x_trial-knot(knotnum).x)<=knot(knotnum).xaffect && abs(y_trial-knot(knotnum).y)<=knot(knotnum).yaffect
                        knot_deltax=x_trial-knot(knotnum).x;
                        knot_deltay=y_trial-knot(knotnum).y;
                        L0=knot(knotnum).xaffect;
                        L1=knot(knotnum).xaffect-knot(knotnum).x;
                        h=knot(knotnum).yaffect;
                        dxdy=dxdy+(sign(knot_deltax)*((pi*sin((knot_deltay*pi)/h)*((abs(knot_deltax)-L0) - knot(knotnum).r + ((abs(knot_deltax)-L0)^2*((L0 - 2*knot(knotnum).r)/L0 - 1))/(2*L0) - ((abs(knot_deltax)-L0)*(L0 - 2*knot(knotnum).r))/L0))/(2*h)));
                    end
                end
                orientationoffset(sp)=atan(-dxdy);
                %if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
                %    troubleshotparticles=[troubleshotparticles sp];
                %end
            end
            if y_trial<18*le_base & y_trial>(18*le_base-lp(1))
                sp_predvelnum=sp_predvelnum+1;
                displacementmonitoredparticles(sp_predvelnum)=sp;
            end
            if CasetoRun==15
                if y_trial<5*le_base+lp(2) && y_trial>5*le_base && (x_trial>2*le_base && x_trial<7*le_base)
                    yparticledamped=[yparticledamped sp];
                end
            else
                if y_trial<2*le_base+lp(2) && y_trial>2*le_base && (x_trial>2*le_base && x_trial<7*le_base)
                    yparticledamped=[yparticledamped sp];
                end
            end
        end
    end
elseif CasetoRun==64
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=8*le_base;
    y_start=2*le_base;
    y_end=9*le_base;
	x_crack(1,1)=20;
	x_crack(1,2)=55;
	x_crack(2,1)=22;
	x_crack(2,2)=55;
	x_crack(3,1)=32;
	x_crack(3,2)=55;
	x_crack(4,1)=42;
	x_crack(4,2)=55;
	x_crack(5,1)=51;
	x_crack(5,2)=55;
	x_crack(6,1)=52;
	x_crack(6,2)=55;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
                continue;
            elseif x_trial<x_start+le_base
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            elseif x_trial<x_end
                if y_trial<y_start+2*le_base
                    continue;
                elseif y_trial>y_end-2*le_base
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            matmodel(sp)=2; %elastic (can be steel rubber or whatever)
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
            
			if x_trial>7*le_base+lp(1);
				yparticledamped=[yparticledamped sp];
			end

            
        end
    end
elseif CasetoRun==66
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=13*le_base;
    y_start=2*le_base;
    y_end=9*le_base;
	x_crack(1,1)=20;
	x_crack(1,2)=55;
	x_crack(2,1)=22;
	x_crack(2,2)=55;
	x_crack(3,1)=32;
	x_crack(3,2)=55;
	x_crack(4,1)=42;
	x_crack(4,2)=55;
	x_crack(5,1)=51;
	x_crack(5,2)=55;
	x_crack(6,1)=52;
	x_crack(6,2)=55;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
                continue;
            elseif x_trial<x_start+le_base
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            elseif x_trial<x_end
                if y_trial<y_start+2*le_base
                    continue;
                elseif y_trial>y_end-2*le_base
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            matmodel(sp)=2; %elastic (can be steel rubber or whatever)
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
            
%			if x_trial>12*le_base+lp(1);
%				yparticledamped=[yparticledamped sp];
%			end

            
        end
    end
elseif CasetoRun==69
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=13*le_base;
    y_start=4*le_base;
    y_end=8*le_base;
	%{
	x_crack(1,1)=20;
	x_crack(1,2)=55;
	x_crack(2,1)=22;
	x_crack(2,2)=55;
	x_crack(3,1)=32;
	x_crack(3,2)=55;
	x_crack(4,1)=42;
	x_crack(4,2)=55;
	x_crack(5,1)=51;
	x_crack(5,2)=55;
	x_crack(6,1)=52;
	x_crack(6,2)=55;
	%}
	x_crack(1,1)=2*le_base;
	x_crack(1,2)=6*le_base;
	x_crack(2,1)=5*le_base;
	x_crack(2,2)=6*le_base;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
	pforcemax=10;
	
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
                continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            matmodel(sp)=2; %elastic (can be steel rubber or whatever)
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
			if x_trial<x_start+lp(1) && y_trial<y_start+lp(2)
				rampedyforceparticle1=[rampedyforceparticle1 sp];
			elseif x_trial<x_start+lp(1) && y_trial>y_end-lp(2)
				rampedyforceparticle2=[rampedyforceparticle2 sp];
			end
            
%			if x_trial>12*le_base+lp(1);
%				yparticledamped=[yparticledamped sp];
%			end

            
        end
    end
elseif CasetoRun==68
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	x_crack(1,1)=60;
	x_crack(1,2)=55;
	x_crack(2,1)=60;
	x_crack(2,2)=41;
	x_crack(3,1)=60;
	x_crack(3,2)=40;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            matmodel(sp)=2; %elastic (can be steel rubber or whatever)
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end

elseif CasetoRun==71
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	x_crack(1,1)=60;
	x_crack(1,2)=55;
	x_crack(2,1)=60;
	x_crack(2,2)=50;
	x_crack(3,1)=60;
	x_crack(3,2)=49.5;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            matmodel(sp)=2; %elastic (can be steel rubber or whatever)
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
			thetacrackrtl(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end
elseif CasetoRun==72
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=23*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	x_notch_start=12*le_base;
	x_notch_end=13*le_base;
	y_notch_tip=8*le_base;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_notch_start
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            elseif x_trial<x_notch_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_notch_tip
                    continue;
                end
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            matmodel(sp)=2; %elastic (can be steel rubber or whatever)
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end
elseif CasetoRun==73
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=23*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	x_notch_start=12*le_base;
	x_notch_end=13*le_base;
	y_notch_tip=8*le_base;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_notch_start
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            elseif x_trial<x_notch_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_notch_tip
                    continue;
                end
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
            matmodel(sp)=1; %wood_schmidt7
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end
elseif CasetoRun==74
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack(1,1)=60;
	x_crack(1,2)=55;
	x_crack(2,1)=60;
	x_crack(2,2)=46;
	x_crack(3,1)=60;
	x_crack(3,2)=41;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
            matmodel(sp)=1; %wood_schmidt7
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end
elseif CasetoRun==78 || CasetoRun==81 || CasetoRun==82
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack(1,1)=60;
	x_crack(1,2)=55;
	x_crack(2,1)=60;
	x_crack(2,2)=46;
	x_crack(3,1)=60;
	x_crack(3,2)=41;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			else
				matmodel(sp)=1; %wood_schmidt7
				orientationoffset(sp)=0;
			end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end
elseif CasetoRun==83
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack{1}(1,1)=40;
	x_crack{1}(1,2)=55;
	x_crack{1}(2,1)=40;
	x_crack{1}(2,2)=46;
	x_crack{1}(3,1)=40;
	x_crack{1}(3,2)=41;
	
	x_crack{2}(1,1)=80;
	x_crack{2}(1,2)=55;
	x_crack{2}(2,1)=80;
	x_crack{2}(2,2)=46;
	x_crack{2}(3,1)=80;
	x_crack{2}(3,2)=41;
	
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			else
				matmodel(sp)=1; %wood_schmidt7
				orientationoffset(sp)=0;
			end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end
elseif CasetoRun==84
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack{1}(1,1)=60;
	x_crack{1}(1,2)=62.5;
	x_crack{1}(2,1)=60;
	x_crack{1}(2,2)=40;
	x_crack{1}(3,1)=60;
	x_crack{1}(3,2)=20;
	x_crack{1}(4,1)=60;
	x_crack{1}(4,2)=2.5;
	
	x_crack{2}(1,1)=2.5;
	x_crack{2}(1,2)=30;
	x_crack{2}(2,1)=50;
	x_crack{2}(2,2)=30;
	x_crack{2}(3,1)=70;
	x_crack{2}(3,2)=30;
	x_crack{2}(4,1)=122.5;
	x_crack{2}(4,2)=30;
	
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			%if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			%else
			%	matmodel(sp)=1; %wood_schmidt7
			%	orientationoffset(sp)=0;
			%end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			%epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end
elseif CasetoRun==88 || CasetoRun==98 || CasetoRun==96
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	if CasetoRun==88
		x_crack{1}(:,2)=transpose(57.5:-pi:40);
		x_crack{1}(:,1)=80;
	
		x_crack{2}=x_crack{1};
		x_crack{2}(:,1)=40;
	elseif CasetoRun==98
		x_crack{1}(:,2)=transpose(57.5:-pi:35);
		x_crack{1}(:,1)=80;
	
		x_crack{2}(:,2)=transpose(57.5:-pi:40);
		x_crack{2}(:,1)=40;
	elseif CasetoRun==96
		x_crack{1}(:,2)=transpose(57.5:-pi:35);
		branchingpoint=size(x_crack{1},1);
		x_crack{1}(branchingpoint,2)=35;
		x_crack{1}(:,1)=60;
		movingindex=0;
		for y_crack_trial=x_crack{1}(branchingpoint,2)-pi:-pi:20
			movingindex=movingindex+1;
			x_crack{1}(branchingpoint+movingindex,2)=y_crack_trial;
			x_crack{1}(branchingpoint+movingindex,1)=60+pi/2*movingindex;
		end
		x_crack{2}=x_crack{1}(branchingpoint:size(x_crack{1},1),:);
		x_crack{2}(:,1)=60-(x_crack{2}(:,1)-60);
	end
	%{
	x_crack{1}(1,1)=80;
	x_crack{1}(1,2)=55;
	x_crack{1}(2,1)=80;
	x_crack{1}(2,2)=46;
	x_crack{1}(3,1)=80;
	x_crack{1}(3,2)=41;

	x_crack{2}(1,1)=40;
	x_crack{2}(1,2)=55;
	x_crack{2}(2,1)=40;
	x_crack{2}(2,2)=46;
	x_crack{2}(3,1)=40;
	x_crack{2}(3,2)=41;
	%}
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			else
				if CasetoRun==98
					matmodel(sp)=1; %wood_schmidt7
					orientationoffset(sp)=0;
				else
					matmodel(sp)=2; %steel
					orientationoffset(sp)=NaN; %steel-steel for now
				end
			end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end
elseif CasetoRun==100 || CasetoRun==101 || CasetoRun==105
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack{1}(1,1)=60;
	x_crack{1}(1,2)=55;
	x_crack{1}(2,1)=60;
	x_crack{1}(2,2)=46;
	x_crack{1}(3,1)=60;
	x_crack{1}(3,2)=41;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			else
				matmodel(sp)=1; %wood_schmidt7
				orientationoffset(sp)=0;
			end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end	
elseif CasetoRun==109
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack{1}(1,1)=60;
	x_crack{1}(1,2)=55;
	x_crack{1}(2,1)=60;
	x_crack{1}(2,2)=46;
	x_crack{1}(3,1)=60;
	x_crack{1}(3,2)=41;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='r';
            ydirletter{sp}='t';
            zdirletter{sp}='l';
            xydirletter{sp}='rt';
            yzdirletter{sp}='tl';
            xzdirletter{sp}='rl';
            x_sp(sp,1:2)=[x_trial y_trial];
			if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			else
				matmodel(sp)=1; %wood_schmidt7
				orientationoffset(sp)=pi/2;
			end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end	
elseif CasetoRun==102
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack{1}(1,1)=40;
	x_crack{1}(1,2)=55;
	x_crack{1}(2,1)=40;
	x_crack{1}(2,2)=46;
	x_crack{1}(3,1)=40;
	x_crack{1}(3,2)=41;

	x_crack{2}(1,1)=60;
	x_crack{2}(1,2)=55;
	x_crack{2}(2,1)=60;
	x_crack{2}(2,2)=46;
	x_crack{2}(3,1)=60;
	x_crack{2}(3,2)=41;

	x_crack{3}(1,1)=70;
	x_crack{3}(1,2)=55;
	x_crack{3}(2,1)=70;
	x_crack{3}(2,2)=46;
	x_crack{3}(3,1)=70;
	x_crack{3}(3,2)=41;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			else
				matmodel(sp)=1; %wood_schmidt7
				orientationoffset(sp)=0;
			end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end	
elseif CasetoRun==106
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack{1}(:,2)=transpose(57.5:-pi:35);
	x_crack{1}(:,1)=80;

	x_crack{2}(:,2)=transpose(57.5:-pi:40);
	x_crack{2}(:,1)=40;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			else
				matmodel(sp)=1; %wood_schmidt7
				orientationoffset(sp)=0;
			end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end	
elseif CasetoRun==107
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack{1}(:,2)=transpose(57.5:-pi:40);
	x_crack{1}(:,1)=80;

	x_crack{2}(:,2)=transpose(57.5:-pi:40);
	x_crack{2}(:,1)=40;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			else
				matmodel(sp)=1; %wood_schmidt7
				orientationoffset(sp)=0;
			end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end	
elseif CasetoRun==103
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack{1}(1,1)=60;
	x_crack{1}(1,2)=41;
	x_crack{1}(2,1)=60;
	x_crack{1}(2,2)=36;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			else
				matmodel(sp)=1; %wood_schmidt7
				orientationoffset(sp)=0;
			end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end	
elseif CasetoRun==104 || CasetoRun==114
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack{1}(1,1)=1;
	x_crack{1}(1,2)=1;
	x_crack{1}(2,1)=1;
	x_crack{1}(2,2)=2;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			else
				matmodel(sp)=1; %wood_schmidt7
				orientationoffset(sp)=0;
			end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end	
elseif CasetoRun==108 || CasetoRun==110
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack{1}(1,1)=1;
	x_crack{1}(1,2)=1;
	x_crack{1}(2,1)=1;
	x_crack{1}(2,2)=2;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
	
	weakeningfactorcounter=0;
	weakeningfactorlist=[0.00288151222434182 0.00766816007402974 0.00819039114023511 0.00206492725892124 0.00550087229560278 0.00886610423295293 0.00271950803658363 0.00443702800163524 0.00941825156270763 0.00894423010348648 0.00571706432219782 0.00452053528811982 0.00167950736922723 0.00658014158621619 0.00846529684305844 0.00872439936759172 0.00846977684943388 0.00415260028628463 0.00502644146389766 0.00484150020418957 0.00187037971504438 0.00985947663837137 0.00289289872951303 0.000362044440089581 0.00303547310853137 0.00887375733748427 0.00192453208682581 0.00964888027067501 0.00791975845733582 0.00154541079076149 0.00529942189752767 0.00933693229143841 0.00978590745016202 0.00130750919289898 0.00686437069493387 0.00714991523231083 0.00103735466840257 0.00858819451675231 0.0079271329202272 0.00541936047566576 0.00652560397777236 0.00562448490332467 0.00330743732616964 0.00313379933617871 0.00709201739693978 0.00299051922312481 0.00932478809593775 0.00748362337780803 0.00531391396137042 0.0016958372338974 0.00517668132633026 0.00247342262797549 0.00699004862424677 0.00902714773653955 0.00944425392442729 0.00610135553603108 0.00182221157448127 0.000606461848265278 0.0019302177937423 0.00965688752409669 0.00346658832860904 0.00706319537603954 0.00963911544608514 0.00336156933121046 0.0099069389540077 0.00674555349925084 0.00338014016027076 0.00243160971239059 0.00919480902754352 0.00875235227644536 0.00999743954283944 0.00255743988087225 0.00803813897931835 0.00279163058646554 0.00402384241996415 0.00347113995562023 0.00447186258577744 0.00718688421503438 3.01039226423994E-06 0.0050185688529129 0.000711319832713989 0.00180146420933763 0.00651523374606015 0.00210395840673967 0.00525048438044075 0.00048255185000101 0.00306716274538377 0.00188922913948279 0.00968808365423962 0.00752112575444415 0.00341613831273792 0.00309143545727035 0.0033406072131505 0.00021153188192593 0.00133175354519212 0.00871365100470319 0.00672474092194059 0.000673813327952691 0.00764332327817865 0.00329429518638246 0.00270424341584231 0.00941066602601188 0.00286175394485562 0.00521835858259539 0.00469851201649738 0.00877488596244973 0.00905124423794886 0.00503536836177755 0.0097766299530509 0.00413010208800381 0.00531853354924132 0.00736649928139957 0.00931143033300578 0.000616355263154424 0.00233193456956093 0.00247148996314264 0.000671375154289947 0.00385162013296107 0.00545482773350906 0.00359362966897553 0.00243661178553081 0.00817887378453148 0.000299151843915149 0.00898913157279223 0.00921857812156791 0.00711994953969055 0.00660048033836392 0.008599383303583 0.00279165860375161 0.00736841621438943 0.00998526708330981 0.0015826881720091 0.00628321513135645 0.00120051164320441 0.00967202738175216 0.005817414523798 0.00494438807082617 0.00437688013412547 0.00597462802208307 0.0064215168162815 0.00415520487631298 0.00528947537216599 0.00951926264586612 0.0022295267628736 0.000113061800611495 0.00662590908224851 0.00748900887229356 0.00521380434083576 0.00787829770455287 0.00132112758696115 0.00499031109142165 0.00832729030759734];

    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			else
				matmodel(sp)=1; %wood_schmidt7
				orientationoffset(sp)=0;
			end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
			if y_trial>10*le_base-lp(2);
				weakeningfactorcounter=weakeningfactorcounter+1;
				weakeningfactor_sp(sp)=weakeningfactorlist(weakeningfactorcounter);
			else
				weakeningfactor_sp(sp)=0;
			end
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end
elseif CasetoRun==111 || CasetoRun==113
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=3.5*le_base;
	x_mid=8.5*le_base;
    x_end=16*le_base;
    y_start=4*le_base;
	y_mid1=9*le_base;
	y_mid2=11*le_base;
    y_end=16*le_base;
	steelcirclecenter=[6 7;
	                    6 13]*le_base;
	steelcircleradius=[1;1]*le_base;
	ncircle=size(steelcirclecenter,2);
	
	x_crack{1}=[7 10;
	            11 10]*le_base;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
	
	
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if x_trial<x_start
				continue;
            elseif x_trial<x_mid
                if y_trial<y_start
                    continue;
				elseif y_trial<y_mid1
				elseif y_trial<y_mid2
					continue;
                elseif y_trial<y_end
				else
                    continue;
                end
            elseif x_trial<x_end
				if y_trial<y_start
					continue;
				elseif y_trial<y_end
				else
					continue;
				end
			else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			insidecircle=0;
			for icircle=1:ncircle
				if sqrt((x_trial-steelcirclecenter(icircle,1))^2+(y_trial-steelcirclecenter(icircle,2))^2)<steelcircleradius(icircle);
					insidecircle=1;
					break;
				end
			end
			if insidecircle
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
				plotignore(sp)=1;
			else
				matmodel(sp)=1; %wood_schmidt7
				orientationoffset(sp)=0;
				plotignore(sp)=0;
			end
			if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
				ParticleswithPredYVel(1)=sp;
			end
			if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
				ParticleswithPredYVel(2)=sp;
			end
            p_sp(sp,1)=psp2;
			weakeningfactor_sp(sp)=0;
        end
    end
elseif CasetoRun==115
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=5*le_base;
    y_start=2*le_base;
    y_end=5*le_base;
	
	x_crack{1}=[0.5 3.5;
	            3.5-pi*1e-5 3.5]*le_base;
	x_defaultcracktip=[3.5 3.5]*le_base;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
	
	steelstrength=5; %MPa
	
	
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
				if y_trial<y_start
					continue;
				elseif y_trial<y_end
				else
					continue;
				end
			else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			matmodel(sp)=2; %steel
			orientationoffset(sp)=NaN;
			plotignore(sp)=0;
			
			if x_trial>5*le_base-lp(1)
				if y_trial>5*le_base-lp(2)
					tractionedcorner=[tractionedcorner sp];
					normalcorner{length(tractionedcorner)}=[1 0;
															0 1];
				elseif y_trial<2*le_base+lp(2)
					tractionedcorner=[tractionedcorner sp];
					normalcorner{length(tractionedcorner)}=[1 0;
															0 -1];
				else
					tractionededge=[tractionededge sp];
					normaledge(length(tractionededge),:)=[1 0];
				end
			elseif y_trial>5*le_base-lp(2)
				tractionededge=[tractionededge sp];
				normaledge(length(tractionededge),:)=[0 1];
			elseif y_trial<2*le_base+lp(2)
				tractionededge=[tractionededge sp];
				normaledge(length(tractionededge),:)=[0 -1];
			end
			
			%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
			%	ParticleswithPredYVel(1)=sp;
			%end
			%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
			%	ParticleswithPredYVel(2)=sp;
			%end
            p_sp(sp,1)=psp2;
			weakeningfactor_sp(sp)=0;
        end
    end
elseif CasetoRun==116 || CasetoRun==119 || CasetoRun==117
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=4*le_base;
    y_start=2*le_base;
    y_end=4*le_base;
	
	x_crack{1}=[0.5 3;
	            3-pi*1e-5 3]*le_base;
	
	if CasetoRun==117
		x_crack{1}=[0.5 3;
					3-pi*1e-5 3-pi*1e-5;
			3-pi*1e-5+2.5 3]*le_base;
	end
	x_defaultcracktip=[3 3]*le_base;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
	
	steelstrength=5; %MPa
	
	
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
				if y_trial<y_start
					continue;
				elseif y_trial<y_end
				else
					continue;
				end
			else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			matmodel(sp)=2; %steel
			orientationoffset(sp)=NaN;
			plotignore(sp)=0;
			
			if x_trial>4*le_base-lp(1)
				if y_trial>4*le_base-lp(2)
					tractionedcorner=[tractionedcorner sp];
					normalcorner{length(tractionedcorner)}=[1 0;
															0 1];
				elseif y_trial<2*le_base+lp(2)
					tractionedcorner=[tractionedcorner sp];
					normalcorner{length(tractionedcorner)}=[1 0;
															0 -1];
				else
					tractionededge=[tractionededge sp];
					normaledge(length(tractionededge),:)=[1 0];
				end
			elseif y_trial>4*le_base-lp(2)
				tractionededge=[tractionededge sp];
				normaledge(length(tractionededge),:)=[0 1];
			elseif y_trial<2*le_base+lp(2)
				tractionededge=[tractionededge sp];
				normaledge(length(tractionededge),:)=[0 -1];
			end
			
			%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
			%	ParticleswithPredYVel(1)=sp;
			%end
			%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
			%	ParticleswithPredYVel(2)=sp;
			%end
            p_sp(sp,1)=psp2;
			weakeningfactor_sp(sp)=0;
        end
    end
elseif CasetoRun==118
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=4*le_base;
    y_start=2*le_base;
    y_end=4*le_base;
	
	x_crack{1}=[0.33 0.371;0.4843 0.5235]+[2 2;2 2];
	x_crack{2}=[0.2706 0.8233; 0.4120 0.9933]+[2 2;2 2];
	x_crack{3}=[0.3115 1.5362; 0.4883 1.7130]+[2 2;2 2];
	x_crack{4}=[0.9106 0.4681; 1.0908 0.3494]+[2 2;2 2];
	x_crack{5}=[0.8329 0.9064; 1.0876 0.9599]+[2 2;2 2];
	x_crack{6}=[0.7134 1.3365; 0.6068 1.5130]+[2 2;2 2];
	x_crack{7}=[1.4393 0.3678; 1.6253 0.4967]+[2 2;2 2];
	x_crack{8}=[1.5926 0.8224; 1.4581 0.9953]+[2 2;2 2];
	x_crack{9}=[1.6752 1.2320; 1.5203 1.4134]+[2 2;2 2];
	x_crack{10}=[1.1323 1.5215; 1.3586 1.6957]+[2 2;2 2];
	
	if CasetoRun==117
		x_crack{1}=[0.5 3;
					3-pi*1e-5 3-pi*1e-5;
			3-pi*1e-5+2.5 3]*le_base;
	end
	x_defaultcracktip=[3 3]*le_base;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
	
	steelstrength=5; %MPa
	
	
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
				if y_trial<y_start
					continue;
				elseif y_trial<y_end
				else
					continue;
				end
			else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			matmodel(sp)=2; %steel
			orientationoffset(sp)=NaN;
			plotignore(sp)=0;
			
			if x_trial>4*le_base-lp(1)
				if y_trial>4*le_base-lp(2)
					tractionedcorner=[tractionedcorner sp];
					normalcorner{length(tractionedcorner)}=[1 0;
															0 1];
				elseif y_trial<2*le_base+lp(2)
					tractionedcorner=[tractionedcorner sp];
					normalcorner{length(tractionedcorner)}=[1 0;
															0 -1];
				else
					tractionededge=[tractionededge sp];
					normaledge(length(tractionededge),:)=[1 0];
				end
			elseif y_trial>4*le_base-lp(2)
				tractionededge=[tractionededge sp];
				normaledge(length(tractionededge),:)=[0 1];
			elseif y_trial<2*le_base+lp(2)
				tractionededge=[tractionededge sp];
				normaledge(length(tractionededge),:)=[0 -1];
			end
			
			%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
			%	ParticleswithPredYVel(1)=sp;
			%end
			%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
			%	ParticleswithPredYVel(2)=sp;
			%end
            p_sp(sp,1)=psp2;
			weakeningfactor_sp(sp)=0;
        end
    end
elseif CasetoRun==112
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=12*le_base;
    y_start=13*le_base;
    y_end=15*le_base;
	
	x_crack{1}=[0.5 0.25;
	            0.5 0.75]*le_base;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
	iParticleswithPredYVel=0;
	
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
				if y_trial<y_start
					continue;
				elseif y_trial<y_end
				else
					continue;
				end
			else
                continue;
            end
            
            sp=sp+1;
			
			if x_trial>11*le_base && x_trial<11*le_base+lp(1) && y_trial>14*le_base && y_trial<14*le_base+lp(2)
				iParticleswithPredYVel=iParticleswithPredYVel+1;
				ParticleswithPredYVel(iParticleswithPredYVel)=sp;
			end
			
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			matmodel(sp)=2; %steel
			orientationoffset(sp)=NaN;
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
			weakeningfactor_sp(sp)=0;
			pforce_sp(sp,:)=[0 0];
        end
    end
elseif CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
	if CasetoRun==94
		x_end=8*le_base;
	else
		x_end=7*le_base;
	end
    y_start=2*le_base;
    y_end=7*le_base;
	
	movingindex=0;
	if CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90
		crackparticlespacing=pi/10; %relative to le_base
	elseif CasetoRun==89
		crackparticlespacing=1; %relative to le_base
	end
	if CasetoRun==86 || CasetoRun==87 || CasetoRun==89 || CasetoRun==90 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99
		crackparticleend=9.5;
	elseif CasetoRun==91
		crackparticleend=8.5;
	end
	for movingcoordinate=0.5:crackparticlespacing:crackparticleend
		movingindex=movingindex+1;
		
		x_crack{1}(movingindex,1)=movingcoordinate*le_base;
		if CasetoRun==86
			x_crack{1}(movingindex,2)=(4+7/8)*le_base;
		elseif CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==89
			x_crack{1}(movingindex,2)=(4+1/2)*le_base;
		elseif CasetoRun==97
			x_crack{1}(movingindex,2)=(4)*le_base;
		elseif CasetoRun==99
			x_crack{1}(movingindex,2)=(4+1/8)*le_base;		
		elseif CasetoRun==90
			x_crack{1}(movingindex,2)=(6+1/8)*le_base;
		else
			disp('CasetoRun Error! 1904101734');
			pause;
			1;
		end
		
		if CasetoRun==86
			x_crack{2}(movingindex,1)=(4+7/8)*le_base;
		elseif CasetoRun==87 || CasetoRun==95
			x_crack{2}(movingindex,1)=(4+1/2)*le_base;
		elseif CasetoRun==97
			x_crack{2}(movingindex,1)=(4)*le_base;
		elseif CasetoRun==99
			x_crack{2}(movingindex,1)=(4+1/8)*le_base;
		elseif CasetoRun==91
			x_crack{2}(movingindex,1)=(9+1/2)*le_base;
		elseif CasetoRun==92
			x_crack{2}(movingindex,1)=(9+1/2)*le_base;
		elseif CasetoRun==94
			x_crack{2}(movingindex,1)=(6.5)*le_base;
        elseif CasetoRun==93
			x_crack{2}(movingindex,1)=(10+1/2)*le_base;
		elseif CasetoRun==90
			x_crack{2}(movingindex,1)=(6+1/8)*le_base;
		elseif CasetoRun==89
		else
			disp('CasetoRun Error! 1904101735');
			pause;
			1;
		end
		
		if CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90
			x_crack{2}(movingindex,2)=movingcoordinate*le_base;
		elseif CasetoRun==89
		else
			disp('CasetoRun Error! 1904101939');
			pause;
			1;
		end
	end
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			%if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			%else
			%	matmodel(sp)=1; %wood_schmidt7
			%	orientationoffset(sp)=0;
			%end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			%epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end
elseif CasetoRun==85
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=1*le_base;
    x_end=3*le_base;
    y_start=1*le_base;
    y_end=3*le_base;
	
	x_crack{1}(1,1)=0.5*le_base;
	x_crack{1}(1,2)=15/8*le_base;
	x_crack{1}(2,1)=3.5*le_base;
	x_crack{1}(2,2)=15/8*le_base;
	
	x_crack{2}(1,1)=15/8*le_base;
	x_crack{2}(1,2)=3.5*le_base;
	x_crack{2}(2,1)=15/8*le_base;
	x_crack{2}(2,2)=0.5*le_base;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			%if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			%else
			%	matmodel(sp)=1; %wood_schmidt7
			%	orientationoffset(sp)=0;
			%end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			%epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end
elseif CasetoRun==79 || CasetoRun==80
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	x_crack(1,1)=60+le_base/2;
	x_crack(1,2)=55;
	x_crack(2,1)=60+le_base/2;
	x_crack(2,2)=46;
	x_crack(3,1)=60+le_base/2;
	x_crack(3,2)=41;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
			if y_trial<4*le_base
				matmodel(sp)=2; %steel
				orientationoffset(sp)=NaN;
			else
				matmodel(sp)=1; %wood_schmidt7
				orientationoffset(sp)=0;
			end
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
        end
    end
elseif CasetoRun==77
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=10*le_base;
	
	
	x_crack(:,2)=transpose([57.5:-1.25:2.5]);
	x_crack(:,1)=60;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
	
	ncforce_cracktop=zeros(size(x_crack));
	ncforce_crackbot=zeros(size(x_crack));
	%ncforce_cracktop(8:38,1)=100*(le(2)/4);
	%ncforce_crackbot=-ncforce_cracktop;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            thetacrackrtl(sp)=NaN;
            xdirletter{sp}='t';
            ydirletter{sp}='r';
            zdirletter{sp}='l';
            xydirletter{sp}='tr';
            yzdirletter{sp}='rl';
            xzdirletter{sp}='tl';
            x_sp(sp,1:2)=[x_trial y_trial];
            matmodel(sp)=1; %wood_schmidt7
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
            %{
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end
			%}
			%{
			if y_trial>4*le_base
				epsilonshrinkdotx_sp(sp,1)=-0.02;
				%epsilonshrinkdoty_sp(sp,1)=-0.01;
			else
				epsilonshrinkdotx_sp(sp,1)=0;
				%epsilonshrinkdoty_sp(sp,1)=0;
			end
			%}
			epsilonshrinkdot_sp(sp,1)=0;
        end
    end
elseif CasetoRun==67
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=22*le_base;
    y_start=2*le_base;
    y_end=6*le_base;
	x_crack(1,1)=60.1;
	x_crack(1,2)=30.1;
	x_crack(2,1)=60.1;
	x_crack(2,2)=21.1;
	x_crack(3,1)=60.1;
	x_crack(3,2)=20.1;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
				continue;
            elseif x_trial<x_end
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            matmodel(sp)=2; %elastic (can be steel rubber or whatever)
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
            
			if y_trial<2*le_base+lp(2);
				yparticledamped=[yparticledamped sp];
			end

			epsilonshrinkdot_sp(sp,1)=-0.02;
            
        end
    end
elseif CasetoRun==65 || CasetoRun==70
    particle_per_cell       = 4;
    %spCount                 = 5*4*particle_per_cell;
    %spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
    lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
    lp(2)                   = lp(1);                              % size of particle in Y direction

    sp=0;
    sp_predvelnum=0;
    displacementmonitoredparticles=[];
    
    x_start=2*le_base;
    x_end=8*le_base;
    y_start=1*le_base;
    y_end=8*le_base;
	x_crack(1,1)=20;
	x_crack(1,2)=37;
	x_crack(2,1)=22;
	x_crack(2,2)=37;
	x_crack(3,1)=32;
	x_crack(3,2)=37;
	x_crack(4,1)=42;
	x_crack(4,2)=37;
	x_crack(5,1)=51;
	x_crack(5,2)=37;
	x_crack(6,1)=52;
	x_crack(6,2)=37;
	
	x_cracktop=x_crack;
	x_crackbot=x_crack;
    
    for i=1:(NN(2)-1)*sqrt(particle_per_cell);
        y_trial=(lp(2)/2)+(i-1)*lp(2);
        for j=1:(NN(1)-1)*sqrt(particle_per_cell);
            x_trial=(lp(1)/2)+(j-1)*lp(1);
            %if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
            if x_trial<x_start
                continue;
            elseif x_trial<x_start+1*le_base
                if y_trial<y_start
                    continue;
                elseif y_trial>y_end
                    continue;
                end
            elseif x_trial<x_end
                if y_trial<y_start+1*le_base
                    continue;
                elseif y_trial>y_end-3*le_base
                    continue;
                end
            else
                continue;
            end
            
            sp=sp+1;
            
            xdirletter{sp}=[];
            ydirletter{sp}=[];
            zdirletter{sp}=[];
            xydirletter{sp}=[];
            yzdirletter{sp}=[];
            xzdirletter{sp}=[];
            x_sp(sp,1:2)=[x_trial y_trial];
            matmodel(sp)=2; %elastic (can be steel rubber or whatever)
            p_sp(sp,1)=psp2;
            plotignore(sp)=0;
            weakeningfactor_sp(sp)=0;
            orientationoffset(sp)=0;
            
			if x_trial>7*le_base+lp(1);
				yparticledamped=[yparticledamped sp];
			end
            
        end
    end
end

spCount=sp;

d_sp                    = zeros(spCount,2);
E_acc                   = zeros(spCount,1);
if exist('epsilonshrinkdot_sp')
else
	epsilonshrinkdot_sp     = zeros(spCount,1);
end
if exist('epsilonshrinkdotx_sp')
else
	epsilonshrinkdotx_sp     = zeros(spCount,1);
end
if exist('epsilonshrinkdoty_sp')
else
	epsilonshrinkdoty_sp     = zeros(spCount,1);
end
if exist('pforce_sp')
else
	pforce_sp               = zeros(spCount,2);
end
%evaltimes_accummulated  = zeros(spCount,1);

%{
for i=1:6
    for j=1:30
        %if (j>7 & j<24) & (i==1|i==6)
        %    continue;
        %end
        sp=sp+1;
        if sp>spCount
            disp('spCount wrong!');
            pause;
        end
        x_sp(sp,1:2)= [4*le(1,1)+0.5*lp(1,1)+(j-1)*lp(1,1) 4*le(1,2)+0.5*lp(1,2)+(i-1)*lp(1,2)];
        if j==15
            sp_predvelnum=sp_predvelnum+1;
            displacementmonitoredparticles(sp_predvelnum)=sp;
        end
        xdirletter{sp}='l';
        ydirletter{sp}='r';
        zdirletter{sp}='t';
        xydirletter{sp}='lr';
        yzdirletter{sp}='rt';
        xzdirletter{sp}='lt';
    end
end
%}
% x_sp: Vector, position of MPs
% spCount: total number of MPs

%DELTAt=k*DELTAt_critical


%% Plot initial condition
if Debugging.Active==0
    if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==7 || CasetoRun==5 || CasetoRun==6
        initial_figure = Plot_Initial(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp);
    elseif CasetoRun==10
        initial_figure = Plot_Initial_sp(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp);
    elseif CasetoRun==8 || CasetoRun==9
        initial_figure = Plot_Initial_var(x_sp,LOC,LOCX,LOCY,orientationoffset,xdirletter,ydirletter,lp);
    elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==56 || CasetoRun==60 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
        initial_figure = Plot_Initial_linehighlighted(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp);
    elseif CasetoRun==61 || CasetoRun==62 || CasetoRun==63
        if runorjustplot==0
            initial_figure = Plot_Initial_squishy(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,matmodel);
        else
            initial_figure = Plot_Initial_squishy2(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,matmodel);
        end
    elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
        initial_figure = Plot_Initial_linehighlighted2(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp);
    elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
        initial_figure = Plot_Initial(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp);
	elseif CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
        initial_figure = Plot_Initial_crackmulti(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,x_crack,CasetoRun);
    end
end

%% Particle variables
dparticle               = lp(1)*lp(2);                          % area of particle domain
x_spo                   = x_sp;                                 % initial position
d_sp                    = zeros(spCount,2);                     % displacement
s_sp                    = zeros(spCount,3);                     % Stress tensor
ds_sp                   = zeros(spCount,3);                     % Stress increment
v_ssp                   = zeros(spCount,2);                     % velocty
e_sp                    = zeros(spCount,3);                     % Strain tensor
de_sp                   = zeros(spCount,3);                     % Strain increment
ptraction_sp            = zeros(spCount,2);                     % traction
F_sp                    = cell(spCount,1);                      % Gradient deformation
r1_sp                   = zeros(spCount,2);
r2_sp                   = zeros(spCount,2);
e_pl_sp                 = zeros(spCount,3);
sigma_global_big        = zeros(spCount,6);
e_t_global_big          = zeros(spCount,6);
e_pl_global_big         = zeros(spCount,6);
alphahp                 = zeros(spCount,7);
if CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
	v_crack             = cell(size(x_crack));
	for i=1:length(x_crack)
		v_crack{i}      = zeros(size(x_crack{i}));
	end
else
	v_crack             = zeros(size(x_crack));
end
dudx_sp                 = zeros(spCount,4); %11, 12, 21, 22
W_sp                    = zeros(spCount,1);

%% Initial condition
% Gradient deformation
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==10 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
    for sp = 1:spCount
        r1_sp(sp,:) = [lp(1,1)/2 0];
        r2_sp(sp,:) = [0 lp(1,2)/2];
        F_sp{sp} = [1 0; 0 1];
    end
	for spcrack=1:size(x_crack,1)
        r1crack_sp(spcrack,:) = [lp(1,1)/2 0];
        r2crack_sp(spcrack,:) = [0 lp(1,2)/2];
        Fcrack_sp{spcrack} = [1 0; 0 1];		
	end
elseif CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
	for sp = 1:spCount
		r1_sp(sp,:) = [lp(1,1)/2 0];
		r2_sp(sp,:) = [0 lp(1,2)/2];
		F_sp{sp} = [1 0; 0 1];
	end
	for ncrack=1:length(x_crack)
		for spcrack=1:size(x_crack{ncrack},1)
			r1crack_sp{ncrack}(spcrack,:) = [lp(1,1)/2 0];
			r2crack_sp{ncrack}(spcrack,:) = [0 lp(1,2)/2];
			Fcrack_sp{ncrack}{spcrack} = [1 0; 0 1];		
		end
	end
elseif CasetoRun==8 || CasetoRun==9
    for sp = 1:spCount
        r1_sp(sp,:) = [lp(sp,1)/2 0];
        r2_sp(sp,:) = [0 lp(sp,2)/2];
        F_sp{sp} = [1 0; 0 1];
    end
end
r10_sp = r1_sp;
r20_sp = r2_sp;
%A_sp                    = zeros(spCount,1);
t_sp                    = ones(spCount,1)*t0_plane;
A_sp                    = 4.*abs(r1_sp(:,1).*r2_sp(:,2)-r1_sp(:,2).*r2_sp(:,1)); 
A_spo                   = A_sp;
t_spo                   = t_sp;
m_sp                    = p_sp.*A_sp.*t_sp;                           % mass

% Traction
%{
for sp=1:spCount
    if x_sp(sp,1)>1.01
        ptraction_sp(sp,1) = 0;
    end
end
%}

if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
    %dmax=-4*le_base;
    %{
    dmax=-0.2680*le_base;
    %dmax=-0.3*le_base;
    %t1=20*2;
    t1=4;
    t2=6;
    t3=10;
    t4=12;
    t5=16;
    %}
    %pforce_maxpres=-30;
    %pforce_max=pforce_maxpres*10/2;
elseif CasetoRun==4
    dmax=-20;
    t1=10;
    
    pforce_maxpres=-30;
    pforce_max=pforce_maxpres*10/2;
elseif CasetoRun==5 || CasetoRun==6
elseif CasetoRun==7
elseif CasetoRun==8 || CasetoRun==9
elseif CasetoRun==10
elseif CasetoRun==11
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
end


%{
while sp<spCount+0.0001
    for i=1:6
        for j=1:24
            if j==24
                sp_predvelnum=sp_predvelnum+1;
                particleswithpredeterminedvelocities(sp_predvelnum)=sp;
                predeterminedvelocityvalueref(sp_predvelnum,:)=[1 0]; 
                %ptraction_sp(sp_predvelnum,1)=1000000;
            end
            sp=sp+1;
        end
    end
end
%}
%% start the algorithm
% video
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
    videofps=60;                              % video output fps
    timescale=0.5;                      % video speed-up factor
elseif CasetoRun==4
    videofps=60;                              % video output fps
    timescale=1;                      % video speed-up factor
elseif CasetoRun==5 || CasetoRun==6
    videofps=60;                              % video output fps
    timescale=0.5;                      % video speed-up factor
elseif CasetoRun==7
    videofps=60;                              % video output fps
    timescale=0.5;                      % video speed-up factor
elseif CasetoRun==8 || CasetoRun==9
    videofps=60;                              % video output fps
    timescale=0.5;                      % video speed-up factor
elseif CasetoRun==10
    videofps=60;                              % video output fps
    timescale=0.5;                      % video speed-up factor
elseif CasetoRun==11
    videofps=60;                              % video output fps
    timescale=0.5;                      % video speed-up factor
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    videofps=60;                              % video output fps
    timescale=0.5;                      % video speed-up factor
elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    videofps=60;                              % video output fps
    timescale=0.5;                      % video speed-up factor
elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
    videofps=60;                              % video output fps
    timescale=0.1;                      % video speed-up factor
end
timestep = videofps*ftime/timescale;     % number of frame to save
%r=timestep/ftime;      % number of frame per second video ~200s
autosavetimeinterval=2.5;
autosaveruntimeinterval=60*10; %autosave run-time interval in secodns
disp(['Running ' mfilename '-' num2str(CasetoRun)]);
if exist('refinemenfactorinput')
	disp(['refinementfactor=' num2str(refinementfactor)]);
	%uiload;
elseif Debugging.Active==0
    uiload;
else
    load(Debugging.FileName);
    disp([Debugging.FileName ' loaded']);
end

if runorjustplot==1
    ttstart=1;
	ttstart=input('new ttstart? (default is 1) ');
elseif runorjustplot==2
    ttstart=tt;
end
justloadedyo=1;
if CasetoRun==14
    sourcefilename=TimeStampedName;
end

TimeStampedNameNew=[mfilename '-' num2str(CasetoRun) '_' casename];
TimeStampedNameBasic=TimeStampedNameNew;
if dtoverride
    TimeStampedNameNew=[TimeStampedNameNew '-ms=' num2str(massscalingfactor)];
end
if CasetoRun==14
    TimeStampedNameNew=[TimeStampedNameNew '-cores=' num2str(numberofcores)];
elseif CasetoRun==19 || CasetoRun==21
    TimeStampedNameNew=[TimeStampedNameNew '-RF=' num2str(ReductionFactor)];
elseif CasetoRun==26 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
    TimeStampedNameNew=[TimeStampedNameNew '-RefLvl=' num2str(refinementfactor)];
elseif CasetoRun==27
    currentgcp=gcp;
    TimeStampedNameNew=[TimeStampedNameNew '-cores=' num2str(currentgcp.NumWorkers)];
end
if exist('refinemenfactorinput')
	try
		load([TimeStampedNameNew '-Master.mat']);
	catch
	end
end
if exist('tt')
    if exist('IsItDump')
        clear IsItDump;
    else
		if exist('refinemenfactorinput')
		else
			tt=input('New tt? (type tt for no change) ');
		end
        load([TimeStampedName '\\' num2str(tt) '.mat']);
    end
    if CompareTexts(TimeStampedName,TimeStampedNameNew)==0;
        copyfile([TimeStampedName '-Master.mat'],[TimeStampedNameNew '-Master.mat']);
        mkdir(TimeStampedNameNew);
        if CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==17
            mkdir([TimeStampedNameNew '\\evaltimes']);
        end
        if CasetoRun==27
            mkdir([TimeStampedNameNew '\\scheduleotf']); %put up top
        end
        
        for i=1:tt
            try
                copyfile([TimeStampedName '\\' num2str(i) '.mat'],TimeStampedNameNew);
            catch
                1;
            end
        end
    end

else
    tt=1;
    TLD=[];
    mkdir(TimeStampedNameNew)
    if CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==17
        mkdir([TimeStampedNameNew '\\evaltimes']);
    end
    if CasetoRun==27
        mkdir([TimeStampedNameNew '\\scheduleotf']);
    end
end
TimeStampedName=TimeStampedNameNew;
%autosavetimemodprev=0;
AccummulatedTocReductor=0;
if exist('DispPump')==0
    DispPump=0;
end
if CasetoRun==14
    tic;
    elapsedtime=[];
    starttimestep=[];
     endtimestep=[];
end
    while tt<=timestep
        
    1;
    1;
    1;
    1;
    1;
    %{
    simulationbreaksignal=1;
    simulationbreaksignal=1;
    simulationbreaksignal=1;
    %}
    if CasetoRun==5
        if tt==2399+1
            simulationbreaksignal=1;
        end
    end
    if simulationbreaksignal
        tt=tt+1;
        break
    end
        
    ft              = ftime/timestep*tt;
%     ft=ftime;

 while t<ft+0.0000000001
    justloadedyo=0;

    
    PredXVel=0;
    PredXAcc=0;
    PredYVel=0;
    PredYAcc=0;
    PredYVel2=0;
	ParticlePredYVel=0;
	sigmainf=[];
    if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
        if mod(t,(loadtime+pausetime))<=loadtime
            PredYVel=(dispload*pi*sin((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime);
            PredYAcc=(dispload*pi^2*cos((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
        else
            PredYVel=0;
            PredYAcc=0;
        end            
        DispPump=DispPump+PredYVel*dt;
    elseif CasetoRun==54
        if mod(t,(loadtime+pausetime))<=loadtime
            PredYVel=dispload/loadtime;
            PredYAcc=0;
        else
            PredYVel=0;
            PredYAcc=0;
        end
        DispPump=DispPump+PredYVel*dt;
    elseif CasetoRun==4
        if t<=t1
            PredYVel=(dmax*pi*sin((pi*t)/t1))/(2*t1);
            PredYAcc=(dmax*pi^2*cos((pi*t)/t1))/(2*t1^2);
        else
            PredYVel=0;
            PredYAcc=0;
        end
        DispPump=DispPump+PredYVel*dt;
    elseif CasetoRun==5 || CasetoRun==6
        if mod(t,(loadtime+pausetime))<=loadtime
            PredYVel=(dispload*pi*sin((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime);
            PredYAcc=(dispload*pi^2*cos((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
        else
            PredYVel=0;
            PredYAcc=0;
        end            
        DispPump=DispPump+PredYVel*dt;
    elseif CasetoRun==7
        if mod(t,(loadtime+pausetime))<=loadtime
            PredYVel=(dispload*pi*sin((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime);
            PredYAcc=(dispload*pi^2*cos((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
        else
            PredYVel=0;
            PredYAcc=0;
        end            
        DispPump=DispPump+PredYVel*dt;
    elseif CasetoRun==8 || CasetoRun==9
        if mod(t,(loadtime+pausetime))<=loadtime
            PredYVel=(dispload*pi*sin((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime);
            PredYAcc=(dispload*pi^2*cos((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
        else
            PredYVel=0;
            PredYAcc=0;
        end            
        DispPump=DispPump+PredYVel*dt;
    elseif CasetoRun==10
        if mod(t,(loadtime+pausetime))<=loadtime
            PredYVel=(dispload*pi*sin((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime);
            PredYAcc=(dispload*pi^2*cos((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
        else
            PredYVel=0;
            PredYAcc=0;
        end            
        DispPump=DispPump+PredYVel*dt;
    elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
        if mod(t,(loadtime+pausetime))<=loadtime
            PredYVel=(dispload*pi*sin((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime);
            PredYAcc=(dispload*pi^2*cos((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
        else
            PredYVel=0;
            PredYAcc=0;
        end            
        DispPump=DispPump+PredYVel*dt;
    elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
        if mod(t,(loadtime+pausetime))<=loadtime
            PredYVel=(dispload*pi*sin((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime);
            PredYAcc=(dispload*pi^2*cos((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
        else
            PredYVel=0;
            PredYAcc=0;
        end            
        DispPump=DispPump+PredYVel*dt;
    elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==65 || CasetoRun==70
        if mod(t,(loadtime+pausetime))<=loadtime
            PredYVel=(dispload*pi*sin((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime);
            PredYVel2=-PredYVel;
            PredYAcc=(dispload*pi^2*cos((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
            PredYAcc2=-PredYAcc;
        else
            PredYVel=0;
            PredYAcc=0;
        end            
        DispPump=DispPump+PredYVel*dt;        
	elseif CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==110 || CasetoRun==96
		ncforce_cracktop=zeros(size(x_crack));
		ncforce_crackbot=zeros(size(x_crack));
	elseif CasetoRun==111 || CasetoRun==113
		ncforce_cracktop=zeros(size(x_crack));
		ncforce_crackbot=zeros(size(x_crack));
        if mod(t,(loadtime+pausetime))<=loadtime
    		ParticlePredYVel(1)=(dispload*pi*sin((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime);
        else
            ParticlePredYVel(1)=0;
        end
		ParticlePredYVel(2)=-ParticlePredYVel(1);
		PredYVel=ParticlePredYVel(1);
		PredYVel2=ParticlePredYVel(2);
	elseif CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
		if CasetoRun==115
			if mod(t,(loadtime+pausetime))<=loadtime
				rampfactor=(0.5-0.5*cos(pi*mod(t,(loadtime+pausetime))));
			else
				rampfactor=1;
			end
		elseif CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
			if t<loadtime/2
				rampfactor=0.5-0.5*cos(pi/loadtime*t);
			else
				rampfactor=0.5+pi*(t-(loadtime/2))/(2*loadtime);
			end
		end
		sigmainf=sigmainfmax*rampfactor;
		S=sigmainf;
		if CasetoRun==115
			x_central=[2 3.5]*le_base;
			a=1.5*le_base;
		elseif CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
			x_central=[2 3]*le_base;
			a=1*le_base;
		end
		for nsp=1:length(tractionededge)
			sp=tractionededge(nsp);
			x=x_sp(sp,1)-x_central(1);
			y=x_sp(sp,2)-x_central(2);
			sigmay=real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 + (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2;
			sigmax = - real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 - (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2 + S*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1);
			sigmaxy = imag(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2;
			sigma_inxysystem=[sigmax sigmaxy;sigmaxy sigmay];
			pforce_sp(sp,:)=normaledge(nsp,:)*sigma_inxysystem*lp(1)*t0_plane; %assuming lp(1)=lp(2)
		end
		for nsp=1:length(tractionedcorner)
			sp=tractionedcorner(nsp);
			x=x_sp(sp,1)-x_central(1);
			y=x_sp(sp,2)-x_central(2);
			sigmay=real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 + (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2;
			sigmax = - real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 - (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2 + S*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1);
			sigmaxy = imag(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2;
			sigma_inxysystem=[sigmax sigmaxy;sigmaxy sigmay];
			pforce_sp(sp,:)=(normalcorner{nsp}(1,:)*sigma_inxysystem+normalcorner{nsp}(2,:)*sigma_inxysystem)*lp(1)*t0_plane; %assuming lp(1)=lp(2)
		end
		%implementing sigmainf to traction
		%K1=sigmainf;
		%{
		for nsp=1:length(tractionededge)
			sp=tractionededge(nsp);
			delta_x=x_sp(sp,:)-x_defaultcracktip;
			r=sqrt(dot(delta_x,delta_x));
			theta=reliableatan(delta_x(1),delta_x(2));
			sigmathetatheta=K1/sqrt(2*pi*r)*(3/4*cos(theta/2)+1/4*cos(3*theta/2));
			sigmartheta=K1/sqrt(2*pi*r)*(1/4*sin(theta/2)+1/4*sin(3*theta/2));
			sigmarr=K1/sqrt(2*pi*r)*(5/4*cos(theta/2)-1/4*cos(3*theta/2));
			sigma_inrthetasystem=[sigmarr sigmartheta;
								  sigmartheta sigmathetatheta];
			n1old=[cos(theta) sin(theta)];
			sigma_inxysystem=rotatetensorfromold(sigma_inrthetasystem,n1old);
			pforce_sp(sp,:)=normaledge(nsp,:)*sigma_inxysystem;
		end
		for nsp=1:length(tractionedcorner)
			sp=tractionedcorner(nsp);
			delta_x=x_sp(sp,:)-x_defaultcracktip;
			r=sqrt(dot(delta_x,delta_x));
			theta=reliableatan(delta_x(1),delta_x(2));
			sigmathetatheta=K1/sqrt(2*pi*r)*(3/4*cos(theta/2)+1/4*cos(3*theta/2));
			sigmartheta=K1/sqrt(2*pi*r)*(1/4*sin(theta/2)+1/4*sin(3*theta/2));
			sigmarr=K1/sqrt(2*pi*r)*(5/4*cos(theta/2)-1/4*cos(3*theta/2));
			sigma_inrthetasystem=[sigmarr sigmartheta;
								  sigmartheta sigmathetatheta];
			n1old=[cos(theta) sin(theta)];
			sigma_inxysystem=rotatetensorfromold(sigma_inrthetasystem,n1old);
			pforce_sp(sp,:)=normalcorner{nsp}(1,:)*sigma_inxysystem+normalcorner{nsp}(2,:)*sigma_inxysystem;
		end
		%}
	elseif CasetoRun==112
		ncforce_cracktop=zeros(size(x_crack));
		ncforce_crackbot=zeros(size(x_crack));
        if mod(t,(loadtime+pausetime))<=loadtime
    		ParticlePredYVel=(dispload*pi*sin((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime);
        else
            ParticlePredYVel=0;
        end
	elseif CasetoRun==83
		for ncrack=1:length(x_crack)
			ncforce_cracktop=zeros(size(x_crack));
			ncforce_crackbot=zeros(size(x_crack));
		end
	elseif CasetoRun==84 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
        if mod(t,(loadtime+pausetime))<=loadtime
            PredYVel=(dispload*pi*sin((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime);
            PredYAcc=(dispload*pi^2*cos((pi*mod(t,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
        else
            PredYVel=0;
            PredYAcc=0;
        end
		PredXVel=PredYVel;
		PredXAcc=PredYAcc;
		for ncrack=1:length(x_crack)
			ncforce_cracktop=zeros(size(x_crack));
			ncforce_crackbot=zeros(size(x_crack));
		end
		DispPump=DispPump+PredYVel*dt;
	elseif CasetoRun==77
		if t<1
			crackpressure=100*(0.5-0.5*cos(pi/1*t));
		else
			crackpressure=100;
		end
		ncforce_cracktop(8:38,1)=crackpressure*(le(2)/4);
		ncforce_crackbot=-ncforce_cracktop;
	elseif CasetoRun==69 % currently not designed for repetitions
		if t<=loadtime
			pforcecurrent=pforcemax*(0.5-0.5*cos(pi*t/loadtime));
		else
			pforcecurrent=pforcemax;
		end
		for nsp=1:length(rampedyforceparticle1)
			pforce_sp(rampedyforceparticle1(nsp),2)=-pforcecurrent;
		end
		for nsp=1:length(rampedyforceparticle2)
			pforce_sp(rampedyforceparticle2(nsp),2)=pforcecurrent;
		end
    end
    if tt==389
        1;
    end
    if CloseEnough(t,Debugging.Time)
        1;
    end
    if CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77
        %disp(['max(max(f_final_vect))=' num2str(max(max(f_final_vect)))]);
		crackedparticle=length(thetacrackrtl)-sum(isnan(thetacrackrtl));
		disp(['n_cracked=' num2str(crackedparticle)]);
		for i=1:length(thetacrackrtl)		
			if isnan(thetacrackrtl(i))
			else
				disp(['f_final_vect(' num2str(i) ',:)=' num2str(f_final_vect(i,:))]);
			end
		end
	elseif CasetoRun==119
    end
    1; % pause here % break here
%    if CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77
%        if isnan(min(thetacrackrtl))
%        else
%            disp('go to line 4525, add a breakpoint')
%            pause
%            1;
%        end
%    end
    if 1==0
        IsItDump=1;
        save([TimeStampedName '-Dump.mat'],'-v7.3', ...
            'tt', ...
            't', ...
            'v_ssp', ...
            'x_sp', ...
            'F_sp', ...
            'A_sp', ...
            't_sp', ...
            's_sp', ...
            'p_sp', ...
            'r1_sp', ...
            'r2_sp', ...
            'F_rollerX', ...
            'F_rollerY', ...
            'E_acc', ...
            'e_pl_sp', ...
            'sigma_global_big', ...
            'e_t_global_big', ...
            'e_pl_global_big', ...
            'alphahp', ...
            'f_final_vect', ...
            'surfacewithfmax', ...
            'sigma_local_big', ...
            'DispPump', ...
            'TimeStampedName', ...
            'TLD', ...
            'IsItDump', ...
            'evaltimes', ...
            'stackvars', ...
            'duration', ...
            'ttstart', ...
			'x_crack', ...
			'x_cracktop', ...
			'x_crackbot', ...
			'dudx_sp', ...
			'W_sp', ...
			'thetacrackrtl', ...
			'thetacrack', ...
			'pforce_sp', ...
			'sigmainf', ...
			'G', ...
			'Ga', ...
			'Grelativeerror');
        clear IsItDump
    end
    
    if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==8 || CasetoRun==9 || CasetoRun==10 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==64 || CasetoRun==66 || CasetoRun==65 || CasetoRun==70 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 
        disp(['t=' num2str(t) ', DispPump=' num2str(DispPump) '=' num2str(DispPump/le_base) '*le_base']);
	elseif CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
        disp(['refinement=' num2str(refinementfactor) ', t=' num2str(t) ', sigmainf=' num2str(sigmainf)]);
	elseif CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77
        disp(['t=' num2str(t)]);
	elseif CasetoRun==69
        disp(['t=' num2str(t) ', pforcecurrent=' num2str(pforcecurrent)]);
    end
    [G,thetac,v_ssp,x_sp,F_sp,A_sp,t_sp,s_sp,p_sp,r1_sp,r2_sp,F_rollerX,F_rollerY,E_acc,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,Fyignore,evaltimes,stackvars,duration,x_crack,x_cracktop,x_crackbot,dudx_sp,W_sp,thetacrackrtl,thetacrack] = ...
        Generic_Solver_Predvel(refinementfactor,ParticleswithPredYVel,ParticlePredYVel,Version,CModel,nodeCount,spCount,cellCount,x_sp,x_spo,d_sp,le,NN,LOC,b_sp,A_sp,t_sp,ptraction_sp,v_ssp,s_sp,m_sp,p_sp,nfbcx,nfbcy,fbcx,fbcy,E,nu,F_sp,A_spo,t_spo,dt,r1_sp,r10_sp,r2_sp,r20_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2,E_acc,epsilonshrinkdot_sp,epsilonshrinkdotx_sp,epsilonshrinkdoty_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,pforce_sp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,troubleshotparticles,matmodel,weakeningfactor_sp,orientationoffset,ynodedamped,yparticledamped,t0_plane,psp1,ignoremomentum,le_c,LOCX,LOCY,Rdisplayedparticles,t,Debugging,x_crack,x_cracktop,x_crackbot,dudx_sp,W_sp,thetacrackrtl,ncforce_cracktop,ncforce_crackbot);
	
	stressnorm=0;
	dispnorm=0;
	
	if CasetoRun==115 || CasetoRun==116 || CasetoRun==118 || CasetoRun==117
		sigmamaxprinc=zeros(spCount,1);
		for sp=1:spCount
			sigmamaxprinc(sp)=0.5*(s_sp(sp,1)+s_sp(sp,2))+sqrt((0.5*(s_sp(sp,1)-s_sp(sp,2)))^2+s_sp(sp,3)^2);
		end
		if max(sigmamaxprinc)>steelstrength
			disp(['Material Failure!, spCount=' num2str(spCount) ', simgainf=' num2str(sigmainf) ', sp=' num2str(FindMax(sigmamaxprinc)) ', x_sp=[' num2str(x_sp(sp),1) ',' num2str(x_sp(sp),2) ']']);
			if exist('refinemenfactorinput')
				return;
			else
				pause;
			end
		end
	elseif CasetoRun==119
		if sigmainf>0.5 && exist('refinemenfactorinput')
			SIGMAmxstressnorm=0;
			SIGMAm=0;
			for sp=1:spCount
				x=x_sp(sp,1)-x_central(1);
				y=x_sp(sp,2)-x_central(2);
				sigmay=real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 + (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2;
				sigmax = - real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 - (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2 + S*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1);
				sigmaxy = imag(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2;
				sigmaerror=s_sp(sp,:)-[sigmax sigmay sigmaxy];
				SIGMAmxstressnorm=SIGMAmxstressnorm+m_sp(sp)*sqrt(dot(sigmaerror,sigmaerror));
				SIGMAm=SIGMAm+m_sp(sp);
			end
			stressnorm=SIGMAmxstressnorm/SIGMAm;
			gridsize=le(1); %assuming size in x and in y are the same
			return;
		end
		K1=sigmainf*sqrt(3.1415926536*a);
		Ga=K1^2*(1-nu^2)/E;
		Grelativeerror=abs(G-Ga)/Ga;
		disp(['Ga=' num2str(Ga) ', G=' num2str(G) ', thetac=' num2str(thetac*180/3.1415926536) ' degrees']);
        1;
	end
    if CasetoRun==3 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==17
		save([TimeStampedName '\\evaltimes\\t=' char(vpa(t)) '.mat'],'-v7.3','evaltimes');
    end
	
    if CasetoRun==27
        for j=1:size(stackvars,1)
            if stackvars(j,2)==0
                stackvars(j,3)=stackvars(size(stackvars,1),2)/1000;
            else
                stackvars(j,3)=0;
            end
        end
        StressProfile=figure;
        hold on;
        set(StressProfile,'visible','off');
        set(StressProfile,'Position',[0 0 720 1280]);
        currentgcp=gcp;
        title(['cores=' num2str(currentgcp.NumWorkers) ', tt= ' num2str(i) ', t=' char(vpa(t))]);
        %xlim([0 xupperlimit]);

        BarProfile=barh(stackvars,'stacked');
        set(BarProfile,{'FaceColor'},{'none';'k';'r'},'EdgeColor','none','BarWidth',1);
        %set(BarProfile,'BarWidth',1);
        saveas(StressProfile,[TimeStampedName '\\scheduleotf\\tt=' num2str(tt) ', t=' char(vpa(t)) '.png']);
        %frame = getframe(StressProfile);
        %writeVideo(writerObj,frame);
        hold off;
        close(StressProfile);
    end
    %if CloseEnough(t,0.857)
    %    return
    %end
    if CasetoRun==14
        elapsedtime=[elapsedtime toc];
        starttimestep=[starttimestep t];
    end
     % Update time and step 
     t=t+dt;
     if CasetoRun==14
        endtimestep=[endtimestep t];
        save([TimeStampedName '-timehistory.mat'],'-v7.3','elapsedtime','starttimestep','endtimestep','numberofcores','sourcefilename');
     end
 end

 %% Plot the result
 
 F=zeros(1,2);
 D=zeros(1,2);
 for i=1:sp_predvelnum
     for j=1:2
        D(j)=D(j)+(x_sp(displacementmonitoredparticles(i),j)-x_spo(displacementmonitoredparticles(i),j));
     end
 end

 for i=1:length(F_rollerX)
     F(1)=F(1)+F_rollerX(i);
 end
 for i=1:length(F_rollerY)
     F(2)=F(2)+F_rollerY(i);
 end

 %{
 for i=1:2
     F(i)=sum(pforce_sp(:,i));
 end
 %}

 D=D/sp_predvelnum;
 if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==64 || CasetoRun==66 || CasetoRun==65 || CasetoRun==70
     TLD(size(TLD,1)+1,:)=[t F(2) D(2)];
elseif CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==69
 elseif CasetoRun==4
     TLD(size(TLD,1)+1,:)=[t F(2) D(2)];
 elseif CasetoRun==5 || CasetoRun==6
     TLD(size(TLD,1)+1,:)=[t F(2)-sum(Fyignore) D(2)];
 elseif CasetoRun==7
     TLD(size(TLD,1)+1,:)=[t F(2)-sum(Fyignore) D(2)];
 elseif CasetoRun==8 || CasetoRun==9
     TLD(size(TLD,1)+1,:)=[t F(2) D(2)];
 elseif CasetoRun==10
     TLD(size(TLD,1)+1,:)=[t F(2) D(2)];
 elseif CasetoRun==11
     TLD(size(TLD,1)+1,:)=[t F(2) D(2)];
 elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
     TLD(size(TLD,1)+1,:)=[t F(2) D(2)];
 elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
     TLD(size(TLD,1)+1,:)=[t F(2) D(2)];
 end
 %predeterminedvelocityvalue
 %for i=1:length(particleswithpredeterminedvelocities)
     %disp(['v(' num2str(particleswithpredeterminedvelocities(i)) ')=[' num2str(v_ssp(particleswithpredeterminedvelocities(i),1)) ' ' num2str(v_ssp(particleswithpredeterminedvelocities(i),2)) ']']);
     %disp(['d(' num2str(particleswithpredeterminedvelocities(i)) ')=[' num2str(x_sp(particleswithpredeterminedvelocities(i),1)-x_spo(particleswithpredeterminedvelocities(i),1)) ' ' num2str(x_sp(particleswithpredeterminedvelocities(i),2)-x_spo(particleswithpredeterminedvelocities(i),2)) ']']);
 %end

 %autosavetimemodnew=mod(t,autosavetimeinterval);
 if justloadedyo==1
     justloadedyo=0;
 else
     %ttstart=516; % define ttstart here
     disp(['Saving, tt=' num2str(tt)]);
     save([TimeStampedName '-Master.mat'],'-v7.3', ...
         'tt', ...
         'TimeStampedName', ...
         'TLD', ...
         'ttstart');
     save([TimeStampedName '\\' num2str(tt) '.mat'],'-v7.3', ...
        'tt', ...
        't', ...
        'v_ssp', ...
        'x_sp', ...
        'F_sp', ...
        'A_sp', ...
        't_sp', ...
        's_sp', ...
        'p_sp', ...
        'r1_sp', ...
        'r2_sp', ...
        'F_rollerX', ...
        'F_rollerY', ...
        'E_acc', ...
        'e_pl_sp', ...
        'sigma_global_big', ...
        'e_t_global_big', ...
        'e_pl_global_big', ...
        'alphahp', ...
        'f_final_vect', ...
        'surfacewithfmax', ...
        'sigma_local_big', ...
        'DispPump', ...
        'evaltimes', ...
        'stackvars', ...
        'duration', ...
		'x_crack', ...
		'x_cracktop', ...
		'x_crackbot', ...
		'dudx_sp', ...
		'W_sp', ...
		'thetacrackrtl', ...
		'thetacrack', ...
		'pforce_sp', ...
		'sigmainf', ...
		'G', ...
		'Ga', ...
		'Grelativeerror');

 end
 %autosavetimemodprev=autosavetimemodnew;

tt=tt+1;
end
tt=tt-1;    
%{
    close(StressProfile1);
    close(StressProfile2);
    close(StressProfile4);
%}  
    if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
    elseif CasetoRun==4
        loadplot=TLD(:,2)/1000;
        for i=1:length(TLD(:,3))
            dispplot(i)=1+TLD(i,3)/50;
        end
    elseif CasetoRun==5 || CasetoRun==6
    elseif CasetoRun==7
    elseif CasetoRun==8 || CasetoRun==9
    elseif CasetoRun==10
    elseif CasetoRun==11
    elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    end

    % Start Printing TLD Video
    if exist('layer')==0
        layer=[];
    end
    if CasetoRun==5
        tt=min(tt,2399);
    end
    parfor switcher=1:4
        PrintResults_parfor(switcher,TimeStampedName,videofps,tt,ttstart,DispPump,CModel,LOC,le,d_sp,e_sp,v_ssp,spCount,E_acc,TLD,plotignore,matmodel,lp,layer,CasetoRun,orientationoffset,xdirletter,ydirletter,x_spo, ...
            ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,thetacrackrtl);
    end
    
    
    %plot(TLD(:,3),TLD(:,2));
    %uisave
    disp(['Look for: ' TimeStampedName]);
    close all;
    if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
    elseif CasetoRun==4
        plot(dispplot,loadplot);
        hold on;
        set(gca,'color','none');
        hold off;
    elseif CasetoRun==5 || CasetoRun==6
    elseif CasetoRun==7
    elseif CasetoRun==8 || CasetoRun==9
    elseif CasetoRun==10
    elseif CasetoRun==11
    elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    end
    soundplay
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [thecell, thenodes, cellcentralcoordinates, cellnodescoordinates]=identifycellsandnodes_reg(x_sp,LOC,LOCC,outputrequest)
	LOCX=[0:1:NN(1)]*le(1);
	LOCY=[0:1:NN(2)]*le(2);
    xindex=0;
    yindex=0;
    for i=1:length(LOCX)
        if x_sp(1)<LOCX(i)
            xindex=i-1;
            break;
        end
    end
    for i=1:length(LOCY)
        if x_sp(2)<LOCY(i)
            yindex=i-1;
            break;
        end
    end
    if outputrequest(1)==1
        thecell=(yindex-1)*(length(LOCX)-1)+xindex;
    end
    if outputrequest(2)==1
        thenodes(1)=(yindex-1)*(length(LOCX))+xindex;
        thenodes(2)=thenodes(1)+1;
        thenodes(3)=thenodes(1)+length(LOCX);
        thenodes(4)=thenodes(3)+1;
    end
    if outputrequest(3)==1
        cellcentralcoordinates(1,:)=LOCC(thecell,:);
    end
    if outputrequest(4)==1
        for i=1:4
            cellnodescoordinates(i,:)=LOC(thenodes(i),:);
        end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [thecell, thenodes, cellcentralcoordinates, cellnodescoordinates]=identifycellsandnodes(x_sp,LOCX,LOCY,LOC,LOCC,outputrequest)
    xindex=0;
    yindex=0;
    for i=1:length(LOCX)
        if x_sp(1)<LOCX(i)
            xindex=i-1;
            break;
        end
    end
    for i=1:length(LOCY)
        if x_sp(2)<LOCY(i)
            yindex=i-1;
            break;
        end
    end
    if outputrequest(1)==1
        thecell=(yindex-1)*(length(LOCX)-1)+xindex;
    end
    if outputrequest(2)==1
        thenodes(1)=(yindex-1)*(length(LOCX))+xindex;
        thenodes(2)=thenodes(1)+1;
        thenodes(3)=thenodes(1)+length(LOCX);
        thenodes(4)=thenodes(3)+1;
    end
    if outputrequest(3)==1
        cellcentralcoordinates(1,:)=LOCC(thecell,:);
    end
    if outputrequest(4)==1
        for i=1:4
            cellnodescoordinates(i,:)=LOC(thenodes(i),:);
        end
    end
end

function[G,thetac,v_ssp_out,x_sp_out,F_sp,A_sp,t_sp,s_sp,p_sp,r1_sp,r2_sp,F_rollerX,F_rollerY,E_acc,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,Fyignore,evaltimes,stackvars,duration,x_crack,x_cracktop,x_crackbot,dudx_sp,W_sp,thetacrackrtl,thetacrack] = ...
    Generic_Solver_Predvel(refinementfactor,ParticleswithPredYVel,ParticlePredYVel,Version,CModel,nodeCount,spCount,cellCount,x_sp,x_spo,d_sp,le,NN,LOC,b_sp,A_sp,t_sp,ptraction_sp,v_ssp,s_sp,m_sp,p_sp,nfbcx,nfbcy,fbcx,fbcy,E,nu,F_sp,A_spo,t_spo,dt,r1_sp,r10_sp,r2_sp,r20_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2,E_acc,epsilonshrinkdot_sp,epsilonshrinkdotx_sp,epsilonshrinkdoty_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,pforce_sp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,troubleshotparticles,matmodel,weakeningfactor_sp,orientationoffset,ynodedamped,yparticledamped,t0_plane,psp1,ignoremomentum,le_c,LOCX,LOCY,Rdisplayedparticles,t,Debugging,x_crack,x_cracktop,x_crackbot,dudx_sp,W_sp,thetacrackrtl,ncforce_cracktop,ncforce_crackbot)
     
%% Store particles into cell
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==10 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
    if CompareTexts(Version,'CPDI')
        [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix,CONNECTpn] = Compute_Interpolator_CPDI(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
    elseif CompareTexts(Version,'MPM')
        [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix] = Compute_Interpolator_MPM(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
    else
        disp('Invalid Version Input');
    end
elseif CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
    if CompareTexts(Version,'CPDI')
        [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,CONNECTpn] = Compute_Interpolator_CPDI_optimized(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
    elseif CompareTexts(Version,'MPM')
		disp('Optimized MPM for patrticles not available yet! 1904122119')
		pause;
		1;
        %[N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix] = Compute_Interpolator_MPM(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
    else
        disp('Invalid Version Input! 1904122120');
		pause;
		1;
    end
elseif CasetoRun==8 || CasetoRun==9
    if CompareTexts(Version,'CPDI')
        [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix] = Compute_Interpolator_CPDI_var(spCount,cellCount,x_sp,le_c,NN,LOC,r1_sp,r2_sp,A_sp,LOCX,LOCY);
    elseif CompareTexts(Version,'MPM')
        disp(['MPM not available for CasetoRun=' num2str(CasetoRun)]);
    else
        disp('Invalid Version Input');
    end
end

if CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
	if (CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==77) && length(x_crack)==0
	else
		sp_crack_count=size(x_crack,1);
		sp_cracktop_count=size(x_cracktop,1);
		sp_crackbot_count=size(x_crackbot,1);
		
		[N_crack,dN_crack,CONNECT_crack,spElems_crack,mspoints_crack,NODES_crack,Nmatrix_crack,dNxmatrix_crack,dNymatrix_crack,CONNECTpn_crack] = Compute_Interpolator_MPM(sp_crack_count,cellCount,x_crack,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
		[N_cracktop,dN_cracktop,CONNECT_cracktop,spElems_cracktop,mspoints_cracktop,NODES_cracktop,Nmatrix_cracktop,dNxmatrix_cracktop,dNymatrix_cracktop,CONNECTpn_cracktop] = Compute_Interpolator_MPM(sp_cracktop_count,cellCount,x_cracktop,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
		[N_crackbot,dN_crackbot,CONNECT_crackbot,spElems_crackbot,mspoints_crackbot,NODES_crackbot,Nmatrix_crackbot,dNxmatrix_crackbot,dNymatrix_crackbot,CONNECTpn_crackbot] = Compute_Interpolator_MPM(sp_crackbot_count,cellCount,x_crackbot,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);

		[TheFieldSplit,Nmatrix,dNxmatrix,dNymatrix,Nmatrixtop,Nmatrixbot,NmatrixAll] = SplitField(LOC,x_sp,CONNECT,CONNECTpn,x_crack,CONNECT_crack,CONNECTpn_crack,Nmatrix,dNxmatrix,dNymatrix,t);
	end
elseif CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
	if length(x_crack)==0;
	else
		for ncrack=length(x_crack):-1:1;
			sp_crack_count=size(x_crack{ncrack},1);
			sp_cracktop_count=size(x_cracktop{ncrack},1);
			sp_crackbot_count=size(x_crackbot{ncrack},1);
			
			[N_crack{ncrack},dN_crack{ncrack},CONNECT_crack{ncrack},spElems_crack{ncrack},mspoints_crack{ncrack},NODES_crack{ncrack},Nmatrix_crack{ncrack},dNxmatrix_crack{ncrack},dNymatrix_crack{ncrack},CONNECTpn_crack{ncrack}] = Compute_Interpolator_MPM(sp_crack_count,cellCount,x_crack{ncrack},le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
			[N_cracktop{ncrack},dN_cracktop{ncrack},CONNECT_cracktop{ncrack},spElems_cracktop{ncrack},mspoints_cracktop{ncrack},NODES_cracktop{ncrack},Nmatrix_cracktop{ncrack},dNxmatrix_cracktop{ncrack},dNymatrix_cracktop{ncrack},CONNECTpn_cracktop{ncrack}] = Compute_Interpolator_MPM(sp_cracktop_count,cellCount,x_cracktop{ncrack},le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
			[N_crackbot{ncrack},dN_crackbot{ncrack},CONNECT_crackbot{ncrack},spElems_crackbot{ncrack},mspoints_crackbot{ncrack},NODES_crackbot{ncrack},Nmatrix_crackbot{ncrack},dNxmatrix_crackbot{ncrack},dNymatrix_crackbot{ncrack},CONNECTpn_crackbot{ncrack}] = Compute_Interpolator_MPM(sp_crackbot_count,cellCount,x_crackbot{ncrack},le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
			% please optimize later by:
			% eliminating unneccessary output variables (suspected: only Nmatrix is needed)
			% prealocating cells for variables that do matter
		end
		
		for ncrack=length(x_crack):-1:1;
			%[TheFieldSplit_crack{ncrack},Nmatrix_crack{ncrack},dNxmatrix_crack{ncrack},dNymatrix_crack{ncrack},NmatrixAll_crack{ncrack}] = SplitFieldMulti_crack(LOC,x_crack{ncrack},CONNECT_crack{ncrack},CONNECTpn_crack{ncrack},x_crack,CONNECT_crack,CONNECTpn_crack,Nmatrix_crack{ncrack},dNxmatrix_crack{ncrack},dNymatrix_crack{ncrack},t,ncrack,1);
			[TheFieldSplit_cracktop{ncrack},Nmatrix_cracktop{ncrack},dNxmatrix_cracktop{ncrack},dNymatrix_cracktop{ncrack},NmatrixAll_cracktop{ncrack}] = SplitFieldMulti_crack(LOC,x_cracktop{ncrack},CONNECT_cracktop{ncrack},CONNECTpn_cracktop{ncrack},x_crack,CONNECT_crack,CONNECTpn_crack,Nmatrix_cracktop{ncrack},dNxmatrix_cracktop{ncrack},dNymatrix_cracktop{ncrack},t,ncrack,2);
			[TheFieldSplit_crackbot{ncrack},Nmatrix_crackbot{ncrack},dNxmatrix_crackbot{ncrack},dNymatrix_crackbot{ncrack},NmatrixAll_crackbot{ncrack}] = SplitFieldMulti_crack(LOC,x_crackbot{ncrack},CONNECT_crackbot{ncrack},CONNECTpn_crackbot{ncrack},x_crack,CONNECT_crack,CONNECTpn_crack,Nmatrix_crackbot{ncrack},dNxmatrix_crackbot{ncrack},dNymatrix_crackbot{ncrack},t,ncrack,3);

		end

		[TheFieldSplit,Nmatrix,dNxmatrix,dNymatrix,NmatrixAll] = SplitFieldMulti(LOC,x_sp,CONNECT,CONNECTpn,x_crack,CONNECT_crack,CONNECTpn_crack,Nmatrix,dNxmatrix,dNymatrix,t);
	end
elseif CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
	if length(x_crack)==0;
	else
		for ncrack=length(x_crack):-1:1;
			sp_crack_count=size(x_crack{ncrack},1);
			sp_cracktop_count=size(x_cracktop{ncrack},1);
			sp_crackbot_count=size(x_crackbot{ncrack},1);
			
			%[N_crack{ncrack},dN_crack{ncrack},CONNECT_crack{ncrack},spElems_crack{ncrack},mspoints_crack{ncrack},NODES_crack{ncrack},Nmatrix_crack{ncrack},CONNECTpn_crack{ncrack}] = Compute_Interpolator_MPM_optimized(sp_crack_count,cellCount,x_crack{ncrack},le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
			
			[N_cracktop{ncrack},dN_cracktop{ncrack},CONNECT_cracktop{ncrack},spElems_cracktop{ncrack},mspoints_cracktop{ncrack},NODES_cracktop{ncrack},Nmatrix_cracktop{ncrack},CONNECTpn_cracktop{ncrack}] = Compute_Interpolator_MPM_optimized(sp_cracktop_count,cellCount,x_cracktop{ncrack},le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
			
			[N_crackbot{ncrack},dN_crackbot{ncrack},CONNECT_crackbot{ncrack},spElems_crackbot{ncrack},mspoints_crackbot{ncrack},NODES_crackbot{ncrack},Nmatrix_crackbot{ncrack},CONNECTpn_crackbot{ncrack}] = Compute_Interpolator_MPM_optimized(sp_crackbot_count,cellCount,x_crackbot{ncrack},le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
			
			% please optimize later by:
			% eliminating unneccessary output variables (suspected: only Nmatrix is needed)
			% prealocating cells for variables that do matter
		end
		
		for ncrack=length(x_crack):-1:1;
			[TheFieldSplitBase3_cracktop{ncrack}] = SplitFieldMulti_crackoptimized2(LOC,x_cracktop{ncrack},CONNECT_cracktop{ncrack},CONNECTpn_cracktop{ncrack},x_crack,ncrack,2,le);
			[TheFieldSplitBase3_crackbot{ncrack}] = SplitFieldMulti_crackoptimized2(LOC,x_crackbot{ncrack},CONNECT_crackbot{ncrack},CONNECTpn_crackbot{ncrack},x_crack,ncrack,3,le);
		end

		[TheFieldSplitBase3] = SplitFieldMultiOptimized2(LOC,x_sp,CONNECT,CONNECTpn,x_crack,t,le);
		
		ncrackpath=size(TheFieldSplitBase3,3);
		maplist(1,1,:)=ones(1,1,ncrackpath);
		[TheFieldSplit,maplist]=Base3Mapping(TheFieldSplitBase3,CONNECTpn,maplist);
		for icrackpath=ncrackpath:-1:1
			[TheFieldSplit_cracktop{icrackpath},maplist]=Base3Mapping(TheFieldSplitBase3_cracktop{icrackpath},CONNECTpn_cracktop{icrackpath},maplist);
			[TheFieldSplit_crackbot{icrackpath},maplist]=Base3Mapping(TheFieldSplitBase3_crackbot{icrackpath},CONNECTpn_crackbot{icrackpath},maplist);
		end
		fieldnumber=size(maplist,1);
		%{
		UniqueFieldSplit=unique(TheFieldSplit);
		for ncrack=1:length(x_crack)
			UniqueFieldSplit=[UniqueFieldSplit;unique(TheFieldSplit_cracktop{ncrack})];
			UniqueFieldSplit=[UniqueFieldSplit;unique(TheFieldSplit_crackbot{ncrack})];
		end
		UniqueFieldSplit=unique(UniqueFieldSplit);
		for i=1:size(TheFieldSplit,1)
			for sp=1:size(TheFieldSplit,2)
				TheFieldSplit(i,sp)=integermapping(TheFieldSplit(i,sp),UniqueFieldSplit);
			end
		end
		for ncrack=1:length(x_crack)
			for i=1:size(TheFieldSplit_cracktop{ncrack},1)
				for sp=1:size(TheFieldSplit_cracktop{ncrack},2)
					TheFieldSplit_cracktop{ncrack}(i,sp)=integermapping(TheFieldSplit_cracktop{ncrack}(i,sp),UniqueFieldSplit);
					TheFieldSplit_crackbot{ncrack}(i,sp)=integermapping(TheFieldSplit_crackbot{ncrack}(i,sp),UniqueFieldSplit);
				end
			end
        end
        fieldnumber=length(UniqueFieldSplit);
		%}
		%{
		ncrackpath=size(TheFieldSplitBase3,3);
		maplistcounter=1;
		maplist(1,1,:)=ones(1,1,ncrackpath);
		TheFieldSplit=ones(size(TheFieldSplitBase3,1),size(TheFieldSplitBase3,2));
		for i=1:length(CONNECTpn)
			for nsp=1:length(CONNECTpn{i});
				sp=CONNECTpn{i}(nsp);
				matchfound=0;
				for imaplist=1:size(maplist,1);
					if sum(maplist(imaplist,1,:)==TheFieldSplitBase3(i,sp,:))==ncrackpath;
						matchfound=1;
						TheFieldSplit(i,sp)=imaplist;
						break;
					end
				end
				if matchfound==0
					TheFieldSplit(i,sp)=size(maplist,1)+1;
					maplist(size(maplist,1)+1,1,:)=TheFieldSplitBase3(i,sp,:);
				end
			end
		end
		%}
	end
end
% N: Shape function
% dN: Gradient of shape function
% spElems(p): element index where "p" locates
% mspoints(e): all particles indexes where locate in the cell "e"
% CONNECT{sp}: list of node numbers connected to particle sp
% CONNECTpn{i}: list of particle numbers connected to node i

%numberofparticleswithpredeterminedvelocities=length(particleswithpredeterminedvelocities);

 %% Mapping from particle to nodes
 %pforce_sp               = [0*ones(spCount,1) 0*ones(spCount,1)];
 %for i=1:numberofparticleswithpredeterminedvelocities
 %    pforce_sp(particleswithpredeterminedvelocities(i),:)=[100000 0];
 %end
 %{
for i=1:numberofparticleswithpredeterminedvelocities
    for j=1:2
        v_ssp(particleswithpredeterminedvelocities(i),j)=predeterminedvelocityvalue(i,j);
    end
end
%}
%pforce_sp_boundaryonly
%v_ssp_out_boundaryonly
%deltav_ssp

if CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
	[nmass_si,nmomentum_si,niforce_si,neforce_si,traction_si,pforce_si,ncforce_si,~]=Interpolate_Particle_To_Grid_WithPredeterminedVelocity2_optimized(NODES,nodeCount,CONNECT,le,N,dN,spCount,b_sp,A_sp,t_sp,ptraction_sp,v_ssp,s_sp,m_sp,pforce_sp,TheFieldSplit,CasetoRun,fieldnumber);
else
	[nmass_si,nmomentum_si,niforce_si,neforce_si,traction_si,pforce_si,ncforce_si,~]=Interpolate_Particle_To_Grid_WithPredeterminedVelocity2(NODES,nodeCount,CONNECT,le,N,dN,spCount,b_sp,A_sp,t_sp,ptraction_sp,v_ssp,s_sp,m_sp,pforce_sp,Nmatrix,dNxmatrix,dNymatrix,ncforce_cracktop,ncforce_crackbot,Nmatrix_cracktop,Nmatrix_crackbot,TheFieldSplit,CasetoRun);
end
% nmass_si: nodal mass
% nmomentum_si: nodal momentum
% niforce_si: nodal internal force
% neforce_si: nodal external force
% traction_si: nodal traction

%% Update momentum
% Update force and momentum
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
    nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - 0.1*nmomentum_si; %legit damping
elseif CasetoRun==4
    nforce_si      = niforce_si + neforce_si + traction_si + pforce_si;
elseif CasetoRun==64 || CasetoRun==65 || CasetoRun==70
    Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
    for i=1:length(ynodedamped)
        Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:,1)+Nmatrix(ynodedamped(i),:,2)+Nmatrix(ynodedamped(i),:,3);
    end
    yparticledampedtowhichnode=zeros(1,length(yparticledamped));
    ydampingnodaldisplacement=zeros(1,length(ynodedamped));
    ydampingnodalvelocity=zeros(1,length(ynodedamped));
    for i=1:length(yparticledamped)
        yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
        ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
        ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
    end
    ynodalreactionforce=zeros(size(niforce_si));
    ydampedBCstiffness=le(1)*t0_plane*E/le(2);
    thalflife=0.5;
    k=log(2)/thalflife;
    dampingratio=0.1;
    ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
    ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
    for i=1:length(ydampingnodaldisplacement)
        ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
    end

    nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
elseif CasetoRun==66 || CasetoRun==69 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72
	nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + - 0.1*nmomentum_si; %legit damping
elseif CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
	nforce_si      = niforce_si + neforce_si + traction_si + pforce_si; %no damping
elseif CasetoRun==77
	nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ncforce_si; %no damping
elseif CasetoRun==67
    Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
    for i=1:length(ynodedamped)
        Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:,1)+Nmatrix(ynodedamped(i),:,2)+Nmatrix(ynodedamped(i),:,3);
    end
    yparticledampedtowhichnode=zeros(1,length(yparticledamped));
    ydampingnodaldisplacement=zeros(1,length(ynodedamped));
    ydampingnodalvelocity=zeros(1,length(ynodedamped));
    for i=1:length(yparticledamped)
        yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
        ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
        ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
    end
    ynodalreactionforce=zeros(size(niforce_si));
    ydampedBCstiffness=le(1)*t0_plane*E/le(2);
    thalflife=0.5;
    k=log(2)/thalflife;
    dampingratio=0.1;
    ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
    ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
    for i=1:length(ydampingnodaldisplacement)
        ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
    end

    nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
elseif CasetoRun==5 || CasetoRun==6
    ymomentumignore_prev=m_sp.*v_ssp(:,2).*ignoremomentum;
    Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
    for i=1:length(ynodedamped)
        Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:);
    end
    yparticledampedtowhichnode=zeros(1,length(yparticledamped));
    ydampingnodaldisplacement=zeros(1,length(ynodedamped));
    ydampingnodalvelocity=zeros(1,length(ynodedamped));
    for i=1:length(yparticledamped)
        yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
        ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
        ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
    end
    ynodalreactionforce=zeros(size(niforce_si));
    ydampedBCstiffness=le(1)*t0_plane*El/le(2);
    thalflife=0.5;
    k=log(2)/thalflife;
    dampingratio=0.1;
    ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
    ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
    for i=1:length(ydampingnodaldisplacement)
        ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
    end

    nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
elseif CasetoRun==7
    ymomentumignore_prev=m_sp.*v_ssp(:,2).*ignoremomentum;
    Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
    for i=1:length(ynodedamped)
        Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:);
    end
    yparticledampedtowhichnode=zeros(1,length(yparticledamped));
    ydampingnodaldisplacement=zeros(1,length(ynodedamped));
    ydampingnodalvelocity=zeros(1,length(ynodedamped));
    for i=1:length(yparticledamped)
        yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
        ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
        ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
    end
    ynodalreactionforce=zeros(size(niforce_si));
    ydampedBCstiffness=le(1)*t0_plane*El/le(2);
    thalflife=0.5;
    k=log(2)/thalflife;
    dampingratio=0.1;
    ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
    ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
    for i=1:length(ydampingnodaldisplacement)
        ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
    end

    nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
    %nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - 0.1*nmomentum_si; %legit damping
elseif CasetoRun==8 || CasetoRun==9
    nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - 0.1*nmomentum_si; %legit damping;
elseif CasetoRun==10
    ymomentumignore_prev=m_sp.*v_ssp(:,2).*ignoremomentum;
    Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
    for i=1:length(ynodedamped)
        Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:);
    end
    yparticledampedtowhichnode=zeros(1,length(yparticledamped));
    ydampingnodaldisplacement=zeros(1,length(ynodedamped));
    ydampingnodalvelocity=zeros(1,length(ynodedamped));
    for i=1:length(yparticledamped)
        yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
        ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
        ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
    end
    ynodalreactionforce=zeros(size(niforce_si));
    ydampedBCstiffness=le(1)*t0_plane*El/le(2);
    thalflife=0.5;
    k=log(2)/thalflife;
    dampingratio=0.1;
    ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
    ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
    for i=1:length(ydampingnodaldisplacement)
        ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
    end

    nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
 elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    ymomentumignore_prev=m_sp.*v_ssp(:,2).*ignoremomentum;
    Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
    for i=1:length(ynodedamped)
        Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:);
    end
    yparticledampedtowhichnode=zeros(1,length(yparticledamped));
    ydampingnodaldisplacement=zeros(1,length(ynodedamped));
    ydampingnodalvelocity=zeros(1,length(ynodedamped));
    for i=1:length(yparticledamped)
        yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
        ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
        ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
    end
    ynodalreactionforce=zeros(size(niforce_si));
    ydampedBCstiffness=le(1)*t0_plane*El/le(2);
    thalflife=0.5;
    k=log(2)/thalflife;
    dampingratio=0.1;
    ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
    ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
    for i=1:length(ydampingnodaldisplacement)
        ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
    end

    nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
    %nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - 0.1*nmomentum_si; %legit damping
 elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    ymomentumignore_prev=m_sp.*v_ssp(:,2).*ignoremomentum;
    Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
    for i=1:length(ynodedamped)
        Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:);
    end
    yparticledampedtowhichnode=zeros(1,length(yparticledamped));
    ydampingnodaldisplacement=zeros(1,length(ynodedamped));
    ydampingnodalvelocity=zeros(1,length(ynodedamped));
    for i=1:length(yparticledamped)
        yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
        ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
        ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
    end
    ynodalreactionforce=zeros(size(niforce_si));
    ydampedBCstiffness=le(1)*t0_plane*El/le(2);
    thalflife=0.5;
    k=log(2)/thalflife;
    dampingratio=0.1;
    ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
    ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
    for i=1:length(ydampingnodaldisplacement)
        ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
    end

    nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
    %nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - 0.1*nmomentum_si; %legit damping
 end

 nmomentum_si   = nmomentum_si + nforce_si*dt;

% Boundary condition
[nforce_si]     = Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,nforce_si); % Boundary condition for nodal force
[nmomentum_si]  = Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,nmomentum_si); % Boundary condition for nodal force

%nmomentum_si=nmomentum_si*(0.5^(1/1000)); %damping
if CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
	%fieldnumber=max(max(TheFieldSplit));
	
	F_rollerX=[];
	for i=1:length(NodeswithPredXVel)
		for j=1:1
			nmomentum_si_old=nmomentum_si(NodeswithPredXVel(i),j,:);
			for field=1:fieldnumber
				nmomentum_si(NodeswithPredXVel(i),j,field)=nmass_si(NodeswithPredXVel(i),field)*PredXVel;
			end
			F_rollerX(i)=sum((nmomentum_si(NodeswithPredXVel(i),j,:)-nmomentum_si_old(1,1,:)))/dt;
			%nforce_si(NodeswithPredVel(i),j)=0;
		end
		%F_roller(i,2)=0;
	end
	F_rollerY=[];
	for i=1:length(NodeswithPredYVel)
		for j=2:2
			nmomentum_si_old=nmomentum_si(NodeswithPredYVel(i),j,:);
			for field=1:fieldnumber
				nmomentum_si(NodeswithPredYVel(i),j,field)=nmass_si(NodeswithPredYVel(i),field)*PredYVel;
			end
			F_rollerY(i)=sum((nmomentum_si(NodeswithPredYVel(i),j,:)-nmomentum_si_old(1,1,:)))/dt;
			%nforce_si(NodeswithPredVel(i),j)=0;
		end
		%F_roller(i,2)=0;
	end

	for i=1:length(NodeswithPredYVel2)
		for j=2:2
			nmomentum_si_old=nmomentum_si(NodeswithPredYVel2(i),j,:);
			for field=1:fieldnumber
				nmomentum_si(NodeswithPredYVel2(i),j,field)=nmass_si(NodeswithPredYVel2(i),field)*PredYVel2;
			end
			%nforce_si(NodeswithPredVel(i),j)=0;
		end
		%F_roller(i,2)=0;
	end
else
	fieldnumber=size(Nmatrix,3);

	F_rollerX=[];
	for i=1:length(NodeswithPredXVel)
		for j=1:1
			nmomentum_si_old=nmomentum_si(NodeswithPredXVel(i),j,:);
			for field=1:fieldnumber
				nmomentum_si(NodeswithPredXVel(i),j,field)=nmass_si(NodeswithPredXVel(i),field)*PredXVel;
			end
			F_rollerX(i)=sum((nmomentum_si(NodeswithPredXVel(i),j,:)-nmomentum_si_old(1,1,:)))/dt;
			%nforce_si(NodeswithPredVel(i),j)=0;
		end
		%F_roller(i,2)=0;
	end
	F_rollerY=[];
	for i=1:length(NodeswithPredYVel)
		for j=2:2
			nmomentum_si_old=nmomentum_si(NodeswithPredYVel(i),j,:);
			for field=1:fieldnumber
				nmomentum_si(NodeswithPredYVel(i),j,field)=nmass_si(NodeswithPredYVel(i),field)*PredYVel;
			end
			F_rollerY(i)=sum((nmomentum_si(NodeswithPredYVel(i),j,:)-nmomentum_si_old(1,1,:)))/dt;
			%nforce_si(NodeswithPredVel(i),j)=0;
		end
		%F_roller(i,2)=0;
	end

	for i=1:length(NodeswithPredYVel2)
		for j=2:2
			nmomentum_si_old=nmomentum_si(NodeswithPredYVel2(i),j,:);
			for field=1:fieldnumber
				nmomentum_si(NodeswithPredYVel2(i),j,field)=nmass_si(NodeswithPredYVel2(i),field)*PredYVel2;
			end
			%nforce_si(NodeswithPredVel(i),j)=0;
		end
		%F_roller(i,2)=0;
	end
end

if CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
	[v_ssp_out,x_sp_out] = Update_Prtcl_Posn_WPredVOR_optmzd(Nmatrix,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2,TheFieldSplit);
else
	[v_ssp_out,x_sp_out] = Update_Particle_Position_WithPredVel2(Nmatrix,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2);
end

v_ssp_out=real(v_ssp_out);
x_sp_out=real(x_sp_out);

if CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
	if (CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77) && length(x_crack)==0
	elseif CasetoRun==84 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==96
		for ncrack=1:length(x_crack)
			[x_cracktop{ncrack}] = UpdateCrackPosition_multi(Nmatrix_cracktop{ncrack},NmatrixAll_cracktop{ncrack},dt,nmass_si,nmomentum_si,x_cracktop{ncrack});
			[x_crackbot{ncrack}] = UpdateCrackPosition_multi(Nmatrix_crackbot{ncrack},NmatrixAll_crackbot{ncrack},dt,nmass_si,nmomentum_si,x_crackbot{ncrack});
			for spcrack=1:size(x_crack{ncrack},1)
				x_crack{ncrack}(spcrack,:)=(x_cracktop{ncrack}(spcrack,:)+x_crackbot{ncrack}(spcrack,:))/2;
			end
		end
	elseif CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
		for ncrack=1:length(x_crack)
			[x_cracktop{ncrack}] = UpdateCrackPosition_multioptimized(N_cracktop{ncrack},NODES_cracktop{ncrack},CONNECT_cracktop{ncrack},dt,nmass_si,nmomentum_si,x_cracktop{ncrack},TheFieldSplit_cracktop{ncrack});
			[x_crackbot{ncrack}] = UpdateCrackPosition_multioptimized(N_crackbot{ncrack},NODES_crackbot{ncrack},CONNECT_crackbot{ncrack},dt,nmass_si,nmomentum_si,x_crackbot{ncrack},TheFieldSplit_crackbot{ncrack});
			for spcrack=1:size(x_crack{ncrack},1)
				x_crack{ncrack}(spcrack,:)=(x_cracktop{ncrack}(spcrack,:)+x_crackbot{ncrack}(spcrack,:))/2;
			end
		end
	else
		%[x_crack,x_cracktop,x_crackbot]=UpdateCrackPosition(x_crack,x_cracktop,x_crackbot,nmass_si,nmomentum_si,Nmatrix_crack,Nmatrix_cracktop,Nmatrix_crackbot,dt,Nmatrixtop,Nmatrixbot,v_ssp_out,m_sp);
		[x_crack,x_cracktop,x_crackbot]=UpdateCrackPosition2(x_crack,x_cracktop,x_crackbot,nmass_si,nmomentum_si,Nmatrix_crack,Nmatrix_cracktop,Nmatrix_crackbot,dt,Nmatrix,v_ssp_out,m_sp,nfbcx,nfbcy,fbcx,fbcy);
		% Nmatrix_crack: MPM Nmatrix for crack particles (green)
		% Nmatrix_cracktop: MPM Nmatrix for crack top surface particles (red)
		% Nmatrix_crackbot: MPM Nmatrix for crack bot surface particles (blue)
	end
end

Fyignore=[];
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
elseif CasetoRun==4
elseif CasetoRun==5 || CasetoRun==6
    ymomentumignore_new=m_sp.*v_ssp_out(:,2).*ignoremomentum;
    Fyignore=(ymomentumignore_new-ymomentumignore_prev)/dt;
elseif CasetoRun==7
    ymomentumignore_new=m_sp.*v_ssp_out(:,2).*ignoremomentum;
    Fyignore=(ymomentumignore_new-ymomentumignore_prev)/dt;
elseif CasetoRun==8 || CasetoRun==9
elseif CasetoRun==10
    ymomentumignore_new=m_sp.*v_ssp_out(:,2).*ignoremomentum;
    Fyignore=(ymomentumignore_new-ymomentumignore_prev)/dt;
elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    ymomentumignore_new=m_sp.*v_ssp_out(:,2).*ignoremomentum;
    Fyignore=(ymomentumignore_new-ymomentumignore_prev)/dt;
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    ymomentumignore_new=m_sp.*v_ssp_out(:,2).*ignoremomentum;
    Fyignore=(ymomentumignore_new-ymomentumignore_prev)/dt;
end
%{
[nvelo_si,L_si] = Interpolate_velocity_back(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp_out,N,dN,nmass_si);


for i=1:length(NodeswithPredVel)
    for j=1:2
        nforce_si(NodeswithPredVel(i),j)=nmass_si(NodeswithPredVel(i))*PredAcc(j);
        for k=1:2
            nforce_si(NodeswithPredVel(i),j)=nforce_si(NodeswithPredVel(i),j)+L_si(i,j,k)*nmomentum_si(NodeswithPredVel(i),k);
        end
    end
end
[v_ssp_out,x_sp_out] = Update_Particle_Position_WithPredVel(NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredVel,PredVel);
%}
%% Update solid particle velocity and position
% velocity particle: v_ssp
% position particle: x_sp
% displacement particle: d_sp
%{
for i=1:numberofparticleswithpredeterminedvelocities
    for j=1:2
        v_ssp_out(particleswithpredeterminedvelocities(i),j)=predeterminedvelocityvalue(i,j);
    end
end
%}
%{
for i=1:numberofparticleswithpredeterminedvelocities
    %v_ssp(particleswithpredeterminedvelocities(i),1)=predeterminedvelocityvalue(1);
    %v_ssp(particleswithpredeterminedvelocities(i),2)=predeterminedvelocityvalue(2);
    %x_sp_out(particleswithpredeterminedvelocities(i),1)=x_sp(particleswithpredeterminedvelocities(i),1)+predeterminedvelocityvalue(1)*dt;
    %x_sp_out(particleswithpredeterminedvelocities(i),2)=x_sp(particleswithpredeterminedvelocities(i),2)+predeterminedvelocityvalue(2)*dt;
end
%}
%% Mapping nodal velocity back to node
if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==10 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    if CompareTexts(Version,'CPDI')
        [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix,CONNECTpn] = Compute_Interpolator_CPDI(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
    elseif CompareTexts(Version,'MPM')
    else
        disp('Invalid Version Input');
    end
elseif CasetoRun==8 || CasetoRun==9
    if CompareTexts(Version,'CPDI')
        [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix] = Compute_Interpolator_CPDI_var(spCount,cellCount,x_sp,le_c,NN,LOC,r1_sp,r2_sp,A_sp,LOCX,LOCY);
    elseif CompareTexts(Version,'MPM')
    else
        disp('Invalid Version Input');
    end
elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
end


if CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
	[nvelo_si] = Interpolate_velocity_back_optimized(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp_out,N,dN,nmass_si,TheFieldSplit);
else
	[nvelo_si,~] = Interpolate_velocity_back(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp_out,N,dN,nmass_si,Nmatrix,dNxmatrix,dNymatrix);
end
% Boundary condition
[nvelo_si] = Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,nvelo_si); % Boundary condition for nodal force

%% Update effective stress
if CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
	[F_sp,A_sp,t_sp,s_sp,p_sp,E_acc,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,evaltimes,stackvars,duration,dudx_sp,W_sp,thetacrackrtl,thetacrack,justcracked,Qacoustic,h,RQ,QbackRback,AbeforeQ_rtl] = ...
		Update_Stress_par_optimized(CModel,NODES,dt,cellCount,mspoints,CONNECT,nvelo_si,dN,E,nu,F_sp,A_spo,t_spo,m_sp,s_sp,p_sp,A_sp,t_sp,E_acc,epsilonshrinkdot_sp,epsilonshrinkdotx_sp,epsilonshrinkdoty_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,troubleshotparticles,matmodel,weakeningfactor_sp,orientationoffset,Rdisplayedparticles,t,Debugging,spCount,dudx_sp,W_sp,thetacrackrtl,TheFieldSplit);
else
	[F_sp,A_sp,t_sp,s_sp,p_sp,E_acc,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,evaltimes,stackvars,duration,dudx_sp,W_sp,thetacrackrtl,thetacrack,justcracked,Qacoustic,h,RQ,QbackRback,AbeforeQ_rtl] = ...
		Update_Stress_par(CModel,NODES,dt,cellCount,mspoints,CONNECT,nvelo_si,dN,E,nu,F_sp,A_spo,t_spo,m_sp,s_sp,p_sp,A_sp,t_sp,E_acc,epsilonshrinkdot_sp,epsilonshrinkdotx_sp,epsilonshrinkdoty_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,troubleshotparticles,matmodel,weakeningfactor_sp,orientationoffset,Rdisplayedparticles,t,Debugging,Nmatrix,dNxmatrix,dNymatrix,spCount,dudx_sp,W_sp,thetacrackrtl);
end

f_nucleate=2;
if (CasetoRun==72) && length(x_crack)==0
	s_max_max=-inf;
	s_max_max_num=0;
	for sp=1:spCount
		theta=1/2*atan(2*s_sp(sp,3)/(s_sp(sp,1)-s_sp(sp,2)));
		s_first=(s_sp(sp,1)+s_sp(sp,2))/2+(s_sp(sp,1)-s_sp(sp,2))/2*cos(2*theta)+s_sp(sp,3)*sin(2*theta);
		s_second=(s_sp(sp,1)+s_sp(sp,2))/2-(s_sp(sp,1)-s_sp(sp,2))/2*cos(2*theta)-s_sp(sp,3)*sin(2*theta);
        if s_first>s_second
            thetamax(sp)=theta;
            thetamin(sp)=theta+pi/2;
        else
            thetamax(sp)=theta+pi/2;
            thetamin(sp)=theta;
        end
		s_max(sp)=max(s_first,s_second);
		s_min(sp)=min(s_first,s_second);
		s_shear(sp)=(s_max(sp)-s_min(sp))/2;
		if s_max(sp)>s_max_max
			s_max_max_num=sp;
			s_max_max=s_max(sp);
			s_max_theta=thetamin(sp);
		end
	end
	disp(['s_max_max=' num2str(s_max_max) ', s_max_theta=' num2str(s_max_theta) ', s_max_max_num=' num2str(s_max_max_num)]);
	if s_max_max>f_nucleate
        lp(1)=le(1)/2;
		s_max_theta=mod(s_max_theta+pi,pi)-pi;
		x_crack(2,:)=x_sp(s_max_max_num,:)-lp(1)/2*[cos(s_max_theta) sin(s_max_theta)];
		x_crack(3,:)=x_sp(s_max_max_num,:)+lp(1)/2*[cos(s_max_theta) sin(s_max_theta)];
		x_crack(1,:)=x_crack(2,:)-le(1)*[cos(s_max_theta) sin(s_max_theta)];
		x_cracktop=x_crack;
		x_crackbot=x_crack;
	end
elseif CasetoRun==73
elseif CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 %average and propagate
    if  sum(justcracked)>0
        justcrackedlist=zeros(sum(justcracked),1);
        justcrackedcounter=0;
        for sp=1:spCount
            if justcracked(sp)
                justcrackedcounter=justcrackedcounter+1;
                justcrackedlist(justcrackedcounter)=sp;
            end
        end
		justcrackedlist=CrackParticleClustering(x_sp,le(1),justcrackedlist);
		ntestedangle=size(Qacoustic{justcrackedlist{1}(1)},3);
		theta=zeros(ntestedangle,1);
        
        AbeforeQ=zeros(2,2,2,2,spCount);
		n=zeros(2,1);
		% grouping just done
		for crackgroup=1:length(justcrackedlist)
			justcrackedcounter=length(justcrackedlist{crackgroup});
			for nspcracked=1:justcrackedcounter;
				for i=1:2
				for j=1:2
				for k=1:2
				for l=1:2
				for p=1:2
				for q=1:2
				for m=1:2
				for nn=1:2
					AbeforeQ(i,j,k,l,justcrackedlist{crackgroup}(nspcracked))=AbeforeQ(i,j,k,l,justcrackedlist{crackgroup}(nspcracked))+QbackRback(i,p,justcrackedlist{crackgroup}(nspcracked))*QbackRback(j,q,justcrackedlist{crackgroup}(nspcracked))*QbackRback(k,m,justcrackedlist{crackgroup}(nspcracked))*QbackRback(l,nn,justcrackedlist{crackgroup}(nspcracked))*AbeforeQ_rtl(p,q,m,nn,justcrackedlist{crackgroup}(nspcracked));
				end
				end
				end
				end
				end
				end
				end
				end
				Qacoustic{justcrackedlist{crackgroup}(nspcracked)}=zeros(size(Qacoustic{justcrackedlist{crackgroup}(nspcracked)}));
				for itestedangle=1:ntestedangle
					theta(itestedangle)=itestedangle/ntestedangle*2*pi;
					n(1)=cos(theta(itestedangle));
					n(2)=sin(theta(itestedangle));
					for m=1:2
					for nn=1:2
					for o=1:2
					for p=1:2
						Qacoustic{justcrackedlist{crackgroup}(nspcracked)}(nn,o,itestedangle)=Qacoustic{justcrackedlist{crackgroup}(nspcracked)}(nn,o,itestedangle)+n(m)*AbeforeQ(m,nn,o,p,justcrackedlist{crackgroup}(nspcracked))*n(p);
					end
					end
					end
                    end
                end
			end
			x_justcrackedcenter=zeros(2,1);
			x_justcrackedcenter(1)=sum(x_sp(justcrackedlist{crackgroup},1))/justcrackedcounter;
			x_justcrackedcenter(2)=sum(x_sp(justcrackedlist{crackgroup},2))/justcrackedcounter;
			if CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 %case 80 uses Q average
				%ntestedangle=size(Qacoustic{justcrackedlist{crackgroup}(1)},3);
				lambda1_avg=zeros(ntestedangle,1);
				lambda2_avg=zeros(ntestedangle,1);
				%theta=zeros(ntestedangle,1);
				%n=zeros(2,1);
				h_avg=zeros(2,2,ntestedangle); %1st index: direction; 2nd index: which lambda; 3rd index: which
				%{
				for i=1:justcrackedcounter
					for j=1:ntestedangle
						Qacoustic{justcrackedlist{crackgroup}(i)}(:,:,j)=(QbackRback(:,:,justcrackedlist{crackgroup}(i)))*Qacoustic{justcrackedlist{crackgroup}(i)}(:,:,j)*transpose(QbackRback(:,:,justcrackedlist{crackgroup}(i)));
					end
				end
				%}
				for i=1:justcrackedcounter
					if i==1
						Qacoustic_avg=Qacoustic{justcrackedlist{crackgroup}(i)};
						dudx_avg=[dudx_sp(justcrackedlist{crackgroup}(i),1) dudx_sp(justcrackedlist{crackgroup}(i),2);dudx_sp(justcrackedlist{crackgroup}(i),3) dudx_sp(justcrackedlist{crackgroup}(i),4)];
						%h_avg=h{justcrackedlist{crackgroup}(i)};
					else
						Qacoustic_avg=Qacoustic_avg+Qacoustic{justcrackedlist{crackgroup}(i)};
						dudx_avg=dudx_avg+[dudx_sp(justcrackedlist{crackgroup}(i),1) dudx_sp(justcrackedlist{crackgroup}(i),2);dudx_sp(justcrackedlist{crackgroup}(i),3) dudx_sp(justcrackedlist{crackgroup}(i),4)];
						%h_avg=h_avg+h{justcrackedlist{crackgroup}(i)};
					end
				end
				Qacoustic_avg=Qacoustic_avg/justcrackedcounter;
				dudx_avg=dudx_avg/justcrackedcounter;
				%h_avg=h_avg/justcrackedcounter;
				for i=1:ntestedangle
					theta(i)=i/ntestedangle*2*pi;
					n(1)=cos(theta(i));
					n(2)=sin(theta(i));
					[h_eig,lambda_eig]=eig(Qacoustic_avg(:,:,i));
					h_avg(:,:,i)=h_eig;
					lambda1_avg(i)=lambda_eig(1,1);
					lambda2_avg(i)=lambda_eig(2,2);
				end
				lambdamin=min([lambda1_avg;lambda2_avg]);
				if length(lambdamin)>1
					disp('length(lamdabmin)>1!');
					pause;
					1;
				end
				lambdaminlessthanzero=1; % switcher for making sure the averaged acoustic tensor still has less than zero eigen value(s). firstly assumed that it is, unless proven otherwise below.
				if lambdamin>0
					disp('Warning, lamdamin>0 on avg(Q)!');
					disp('Ditching average acoustic tensor, switching to individual acoustic tensor');
					lambdaminlessthanzero=0;
					%pause;
					1;
                end
				if lambdaminlessthanzero==1
					localminima1index=[];
					localminima2index=[];
					for i=1:ntestedangle
						if lambda1_avg(i)<0 && lambda1_avg(i)<=lambda1_avg(mod((i-1)-1,ntestedangle)+1) && lambda1_avg(i)<=lambda1_avg(mod((i+1)-1,ntestedangle)+1)
						%if lambda1_avg(i)<=lambda1_avg(mod((i-1)-1,ntestedangle)+1) && lambda1_avg(i)<=lambda1_avg(mod((i+1)-1,ntestedangle)+1)
							localminima1index=[localminima1index i];
						end
						if lambda2_avg(i)<0 && lambda2_avg(i)<=lambda2_avg(mod((i-1)-1,ntestedangle)+1) && lambda2_avg(i)<=lambda2_avg(mod((i+1)-1,ntestedangle)+1)
						%if lambda2_avg(i)<=lambda2_avg(mod((i-1)-1,ntestedangle)+1) && lambda2_avg(i)<=lambda2_avg(mod((i+1)-1,ntestedangle)+1)
							localminima2index=[localminima2index i];
						end
					end
					nldudxhl=zeros(length(localminima1index)+length(localminima2index),1);
					h_localminima=zeros(2,length(localminima1index)+length(localminima2index));
					for i=1:length(localminima1index)
						n(1)=cos(theta(localminima1index(i)));
						n(2)=sin(theta(localminima1index(i)));
						nldudxhl(i)=transpose(n)*dudx_avg*h_avg(:,1,localminima1index(i));
						h_localminima(:,i)=h_avg(:,1,localminima1index(i));
					end
					for i=1:length(localminima2index)
						n(1)=cos(theta(localminima2index(i)));
						n(2)=sin(theta(localminima2index(i)));
						nldudxhl(i+length(localminima1index))=transpose(n)*dudx_avg*h_avg(:,2,localminima2index(i));
						h_localminima(:,i+length(localminima1index))=h_avg(:,2,localminima2index(i));
					end
					localminimaindex=[localminima1index localminima2index];
					FindMaxnldudxhl=FindMax(nldudxhl); %I put FindMax(nldudxhl) to a variable FindMaxnldudxhl as I need to call it twice. Better to save the result rather than calling the function twice.
					crackindex=localminimaindex(FindMaxnldudxhl);
					thetamin=theta(crackindex);
					thetacrack_avg=mod(thetamin+pi/2+pi/2,pi)-pi/2;
					1; %pause average Q calculation
					for i=1:justcrackedcounter
						thetacrack(justcrackedlist{crackgroup}(i))=thetacrack_avg;
						thetacrackrtl(justcrackedlist{crackgroup}(i))=thetacrack_avg-reliableatan(RQ(1,1,justcrackedlist{crackgroup}(i)),RQ(1,2,justcrackedlist{crackgroup}(i)));
					end
					thetajustcrackedcenter=thetacrack_avg;
					1;
				else
					for i=1:360
						theta(i)=(i-1)/360*pi;
						error(i)=0;
						for spc=1:justcrackedcounter
							error(i)=error(i)+(mod(thetacrack(justcrackedlist{crackgroup}(spc))-theta(i)+pi/2,pi)-pi/2)^2;
						end
					end
					thetajustcrackedcenter=theta(FindMin(error));
                    1;
				end
			else
				for i=1:360
					theta(i)=(i-1)/360*pi;
					error(i)=0;
					for spc=1:justcrackedcounter
						error(i)=error(i)+(mod(thetacrack(justcrackedlist{crackgroup}(spc))-theta(i)+pi/2,pi)-pi/2)^2;
					end
				end
				thetajustcrackedcenter=theta(FindMin(error));
			end
			if CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
				considered=ones(length(x_crack),2);
				distancelist=zeros(length(x_crack),2);
				thetapropagationlist=zeros(length(x_crack),2);
				for ncrack=length(x_crack):-1:1
					for whichtip=1:2
						if whichtip==1
							n_nairncrack1=size(x_crack{ncrack},1);
							n_nairncrack0=n_nairncrack1-1;
						elseif whichtip==2
							n_nairncrack1=1;
							n_nairncrack0=2;
						else
							disp('whichtip error! 1904151959');
							pause;
							1;
						end
						x_cracktip=x_crack{ncrack}(n_nairncrack1,:);
						thetatocrackcenter=reliableatan(x_justcrackedcenter(1)-x_cracktip(1),x_justcrackedcenter(2)-x_cracktip(2));
						theta_prev=reliableatan(x_crack{ncrack}(n_nairncrack1,1)-x_crack{ncrack}(n_nairncrack0,1),x_crack{ncrack}(n_nairncrack1,2)-x_crack{ncrack}(n_nairncrack0,2));
						deltatheta_tocrackvsprev=mod(thetatocrackcenter-theta_prev+pi,2*pi)-pi;
						if abs(deltatheta_tocrackvsprev)>pi
							disp('deltatheta_tocrackvsprev error! 1904112048');
							pause;
							1;
						end
						if abs(deltatheta_tocrackvsprev)>pi/2
							considered(ncrack,whichtip)=0;
							distancelist(ncrack,whichtip)=inf;
							continue;
						end
						propagationlength=sqrt((x_crack{ncrack}(n_nairncrack1,1)-x_justcrackedcenter(1))^2+(x_crack{ncrack}(n_nairncrack1,2)-x_justcrackedcenter(2))^2);
						if propagationlength>1.5*le(1)
							considered(ncrack,whichtip)=0;
							distancelist(ncrack,whichtip)=inf;
							continue;
						end
						distancelist(ncrack,whichtip)=propagationlength;
						for i=1:360
							theta(i)=(i-1)/360*2*pi;
							error(i)=(mod(thetajustcrackedcenter-theta(i)+pi/2,pi)-pi/2)^2+(mod(thetatocrackcenter-theta(i)+pi,2*pi)-pi)^2;
						end
						theta_crackpropagation=theta(FindMin(error));
						theta_crackpropagation=mod(theta_crackpropagation-theta_prev+pi,2*pi)+theta_prev-pi;
						thetapropagationlist(ncrack,whichtip)=theta_crackpropagation;
					end
				end
				if sum(sum(considered))>0
					ncrackandwhichtip=FindMinMatrix(distancelist);
					ncrack=ncrackandwhichtip(1);
					whichtip=ncrackandwhichtip(2);
					if whichtip==1
						n_nairncrack1=size(x_crack{ncrack},1);
					else
						n_nairncrack1=1;
					end
					propagationlength=distancelist(ncrack,whichtip);
					theta_crackpropagation=thetapropagationlist(ncrack,whichtip);
					idealpropagationlength=le(1)/4; %assuming lp(1)==lp(2)
					%propagationlengthreductionfactor=max([1 round(propagationlength/idealpropagationlength)]);
					propagationlengthreductionfactor=1;
					if whichtip==1
						for i=1:propagationlengthreductionfactor
							x_crack{ncrack}(n_nairncrack1+i,:)=[x_crack{ncrack}(n_nairncrack1,1)+i/propagationlengthreductionfactor*propagationlength*cos(theta_crackpropagation) x_crack{ncrack}(n_nairncrack1,2)+i/propagationlengthreductionfactor*propagationlength*sin(theta_crackpropagation)];
							x_cracktop{ncrack}(n_nairncrack1+i,:)=x_crack{ncrack}(n_nairncrack1+i,:);
							x_crackbot{ncrack}(n_nairncrack1+i,:)=x_crack{ncrack}(n_nairncrack1+i,:);
						end
					elseif whichtip==2
						for i=size(x_crack{ncrack},1):-1:1
							x_crack{ncrack}(i+propagationlengthreductionfactor,:)=x_crack{ncrack}(i,:);
							x_cracktop{ncrack}(i+propagationlengthreductionfactor,:)=x_cracktop{ncrack}(i,:);
							x_crackbot{ncrack}(i+propagationlengthreductionfactor,:)=x_crackbot{ncrack}(i,:);
						end
						n_nairncrack1=n_nairncrack1+propagationlengthreductionfactor;
						for i=1:propagationlengthreductionfactor
							x_crack{ncrack}(n_nairncrack1-i,:)=[x_crack{ncrack}(n_nairncrack1,1)+i/propagationlengthreductionfactor*propagationlength*cos(theta_crackpropagation) x_crack{ncrack}(n_nairncrack1,2)+i/propagationlengthreductionfactor*propagationlength*sin(theta_crackpropagation)];
							x_cracktop{ncrack}(n_nairncrack1-i,:)=x_crack{ncrack}(n_nairncrack1-i,:);
							x_crackbot{ncrack}(n_nairncrack1-i,:)=x_crack{ncrack}(n_nairncrack1-i,:);

						end
					else
						disp('which tip error! 1904151909')
						pause
						1;
					end
				else
					intheprevention=0;
					preventiondistance=le(1)/2;
					preventionangle=pi/4;
					for ncrack=1:length(x_crack);
						for spcrack=1:(size(x_crack{ncrack},1)-1)
							vector1a=[(x_justcrackedcenter(1)-x_crack{ncrack}(spcrack,1));(x_justcrackedcenter(2)-x_crack{ncrack}(spcrack,2))];
							vector1b=[(x_justcrackedcenter(1)-x_crack{ncrack}(spcrack+1,1));(x_justcrackedcenter(2)-x_crack{ncrack}(spcrack+1,2))];
							distance1a=sqrt(dot(vector1a,vector1a));
							distance1b=sqrt(dot(vector1b,vector1b));
							
							distance1a_old=sqrt((x_justcrackedcenter(1)-x_crack{ncrack}(spcrack,1))^2+(x_justcrackedcenter(2)-x_crack{ncrack}(spcrack,2))^2);
							distance1b_old=sqrt((x_justcrackedcenter(1)-x_crack{ncrack}(spcrack+1,1))^2+(x_justcrackedcenter(2)-x_crack{ncrack}(spcrack+1,2))^2);
							
							distance1=min([distance1a distance1b]);
							
							area2=abs(TriangleArea(x_justcrackedcenter,x_crack{ncrack}(spcrack,:),x_crack{ncrack}(spcrack+1,:)));
							
							inbetween2vector=[(x_crack{ncrack}(spcrack+1,1)-x_crack{ncrack}(spcrack,1));(x_crack{ncrack}(spcrack+1,2)-x_crack{ncrack}(spcrack,2))];
							
							inbetween2=sqrt(dot(inbetween2vector,inbetween2vector));
							
							inbetween2_old=sqrt((x_crack{ncrack}(spcrack+1,1)-x_crack{ncrack}(spcrack,1))^2+(x_crack{ncrack}(spcrack+1,2)-x_crack{ncrack}(spcrack,2))^2);
							distance2=area2/inbetween2;
							
							signcos1=dot(vector1a,inbetween2vector);
							signcos2=dot(vector1b,inbetween2vector);
							
							if signcos1*signcos2>0
								distance=distance1;
							else
								distance=distance2;
							end
							
							if distance<preventiondistance
								thetanairncrack=reliableatan(x_crack{ncrack}(spcrack+1,1)-x_crack{ncrack}(spcrack,1),x_crack{ncrack}(spcrack+1,2)-x_crack{ncrack}(spcrack,2));
								
								absdeltatheta=abs(mod(thetanairncrack-thetajustcrackedcenter+pi/2,pi)-pi/2);
								
								if absdeltatheta<preventionangle
									intheprevention=1;
								end
							end
							if intheprevention==1
								break;
							end
						end
						if intheprevention==1
							break;
						end
					end
					if intheprevention==0
						thetainitiate=mod(thetajustcrackedcenter-pi,pi)+pi; %always pointing down, pi<theta<2*pi
						ncrack=length(x_crack)+1;
						x_crack{ncrack}(2,2)=x_justcrackedcenter(2)+le(1)/2/2*sin(thetainitiate); %assuming le(1)=le(2);
						x_crack{ncrack}(2,1)=x_justcrackedcenter(1)+le(1)/2/2*cos(thetainitiate);
						x_crack{ncrack}(1,2)=x_justcrackedcenter(2)-le(1)/2/2*sin(thetainitiate);
						x_crack{ncrack}(1,1)=x_justcrackedcenter(1)-le(1)/2/2*cos(thetainitiate);
						x_cracktop{ncrack}=x_crack{ncrack};
						x_crackbot{ncrack}=x_crack{ncrack};
					end
					%soundplay
					1;
				end
				soundplay;
				1; %pause multi average and propagate here
			else
				n_nairncrack=size(x_crack,1);
				x_cracktip=x_crack(n_nairncrack,:);
				thetatocrackcenter=reliableatan(x_justcrackedcenter(1)-x_cracktip(1),x_justcrackedcenter(2)-x_cracktip(2));
				theta_prev=reliableatan(x_crack(n_nairncrack,1)-x_crack(n_nairncrack-1,1),x_crack(n_nairncrack,2)-x_crack(n_nairncrack-1,2));
				propagationlength=sqrt((x_crack(n_nairncrack,1)-x_justcrackedcenter(1))^2+(x_crack(n_nairncrack,2)-x_justcrackedcenter(2))^2);
				idealpropagationlength=le(1)/4; %assuming lp(1)==lp(2)
				propagationlengthreductionfactor=max([1 round(propagationlength/idealpropagationlength)]);
				for i=1:360
					theta(i)=(i-1)/360*2*pi;
					error(i)=(mod(thetajustcrackedcenter-theta(i)+pi/2,pi)-pi/2)^2+(mod(thetatocrackcenter-theta(i)+pi,2*pi)-pi)^2;
				end
				theta_crackpropagation=theta(FindMin(error));
				theta_crackpropagation=mod(theta_crackpropagation-theta_prev+pi,2*pi)+theta_prev-pi;
				for i=1:propagationlengthreductionfactor
					x_crack(n_nairncrack+i,:)=[x_crack(n_nairncrack,1)+i/propagationlengthreductionfactor*propagationlength*cos(theta_crackpropagation) x_crack(n_nairncrack,2)+i/propagationlengthreductionfactor*propagationlength*sin(theta_crackpropagation)];
					x_cracktop(n_nairncrack+i,:)=x_crack(n_nairncrack+i,:);
					x_crackbot(n_nairncrack+i,:)=x_crack(n_nairncrack+i,:);
				end
				1; %pause average and propagate here
			end
		end
		% grouping effect stops
    end
elseif CasetoRun==119
	%start function for calculating J integral
	K_sp=0.5*(p_sp.*(v_ssp_out(:,1).^2 + v_ssp_out(:,2).^2));
	n_tip=size(x_crack{1},1);
	x_tip=x_crack{1}(n_tip,:);
	ni_Jcenter=FindMax(Nmatrix_cracktop{1}(:,n_tip));
	if ncrack>1
		disp('too many ncrack! 1905132233');
		pause
		1;
	end
	if mod(refinementfactor,2)==0
	else
		disp('refinement factor has to be even! 1905132234');
		pause
		1;
	end
	expansion=0.5*refinementfactor;
	n_pointperside=2*expansion+1;
		
	%listing surrounding nodes in counter-clockwise order
	ni_list{4}(n_pointperside)=0;
	ni_list{3}(n_pointperside)=0;
	ni_list{2}(n_pointperside)=0;
	ni_list{1}(n_pointperside)=0;
	%ni_list index: 1 = left, 2 = bottom, 3 = right, 4 = top

	for i=1:n_pointperside
		ni_list{1}(i)=ni_Jcenter-expansion+expansion*NN(1)-(i-1)*NN(1);
		ni_list{2}(i)=ni_Jcenter-expansion*NN(1)-expansion+(i-1);
		ni_list{3}(i)=ni_Jcenter+expansion-expansion*NN(1)+(i-1)*NN(1);
		ni_list{4}(i)=ni_Jcenter+expansion*NN(1)+expansion-(i-1);
	end


	for toporbot=1:2
		sidebreaksignal=0;
		for crackline=(n_tip-1):-1:1
			for side=1:4
				for sideline=1:(length(ni_list{side})-1)
					if side==3 && sideline==2 && crackline==2
						1;
					end
					x1=LOC(ni_list{side}(sideline),:);
					x2=LOC(ni_list{side}(sideline+1),:);
					if toporbot==1
						x3=x_cracktop{1}(crackline,:);
						x4=x_cracktop{1}(crackline+1,:);
						[CrossDir,RelativeLocation]=FindCrossing(x1,x2,x3,x4);
					elseif toporbot==2
						x3=x_crackbot{1}(crackline,:);
						x4=x_crackbot{1}(crackline+1,:);
						[CrossDir,RelativeLocation]=FindCrossing(x1,x2,x3,x4);
					end
					if CrossDir>0
						sidebreaksignal=1;
						break;
					end
				end
				if sidebreaksignal==1
					break;
				end
			end
			if sidebreaksignal==1
				break;
			end
		end
		if toporbot==1
			crackline_top=crackline;
			side_top=side;
			sideline_top=sideline;
			CrossDir_top=CrossDir;
			RelativeLocation_top=RelativeLocation;
		elseif toporbot==2
			crackline_bot=crackline;
			side_bot=side;
			sideline_bot=sideline;
			CrossDir_bot=CrossDir;
			RelativeLocation_bot=RelativeLocation;
		end
	end
	nfield=3;
	nNodes=length(CONNECTpn);
	M_ni=zeros(nNodes,nfield);
	MW_ni=zeros(nNodes,nfield);
	Mdudx_ni=zeros(nNodes,4,nfield);
	Ms_ni=zeros(nNodes,3,nfield);
	MK_ni=zeros(nNodes,nfield);
	
	for sp=1:spCount
		for j=1:NODES(sp)
			npid                           = CONNECT{sp}(j);
			if N{sp}(j)==0 || m_sp(sp)==0
				continue
			end
			M_ni(npid,TheFieldSplitBase3(npid,sp))            = M_ni(npid,TheFieldSplitBase3(npid,sp)) + m_sp(sp)*N{sp}(j);
			MW_ni(npid,TheFieldSplitBase3(npid,sp))            = MW_ni(npid,TheFieldSplitBase3(npid,sp)) + (m_sp(sp)*W_sp(sp))*N{sp}(j);
			Mdudx_ni(npid,:,TheFieldSplitBase3(npid,sp))            = Mdudx_ni(npid,:,TheFieldSplitBase3(npid,sp)) + (m_sp(sp)*dudx_sp(sp,:))*N{sp}(j);
			Ms_ni(npid,:,TheFieldSplitBase3(npid,sp))            = Ms_ni(npid,:,TheFieldSplitBase3(npid,sp)) + (m_sp(sp)*s_sp(sp,:))*N{sp}(j);
			MK_ni(npid,TheFieldSplitBase3(npid,sp))            = MK_ni(npid,TheFieldSplitBase3(npid,sp)) + (m_sp(sp)*K_sp(sp))*N{sp}(j);
		end 
	end
	
	sidegap=mod(side_bot-side_top,4);
	J1=0;
	J2=0;
	hoopstress=[];
	hooptheta=[];
	hoopindex=0;
	for relativeside=0:4-sidegap
		side=mod(side_bot-1+relativeside,4)+1;
		startsidenode=1;
		endsidenode=(2*expansion)+1;
		if relativeside==0
			startsidenode=sideline_bot;
		elseif relativeside==4-sidegap
			endsidenode=sideline_top+1;
		end
		for sideline=startsidenode:endsidenode-1
			nodebefore=ni_list{side}(sideline);
			nodeafter=ni_list{side}(sideline+1);
			if relativeside==0 || relativeside==1
				sumsequence=1:2:3;
			elseif relativeside==(4-sidegap) || relativeside==(4-sidegap-1)
				sumsequence=1:2;
			else
				sumsequence=1:3;
			end
			M_before=sum(M_ni(nodebefore,sumsequence));
			if M_before==0
				W_ni_before=0;
				dudx_ni_before(1:4)=0;
				s_ni_before(1:3)=0;
				K_ni_before=0;
			else
				W_ni_before=sum(MW_ni(nodebefore,sumsequence))/M_before;
				K_ni_before=sum(MK_ni(nodebefore,:))/M_before;
				for index=1:4
					dudx_ni_before(index)=sum(Mdudx_ni(nodebefore,index,sumsequence))/M_before;
				end
				for index=1:3
					s_ni_before(index)=sum(Ms_ni(nodebefore,index,sumsequence))/M_before;
                end
			end
			M_after=sum(M_ni(nodeafter,sumsequence));
			if M_after==0
				W_ni_after=0;
				dudx_ni_after(1:4)=0;
				s_ni_after(1:3)=0;
				K_ni_after=0;
			else
				W_ni_after=sum(MW_ni(nodeafter,sumsequence))/M_after;
				K_ni_after=sum(MK_ni(nodeafter,:))/M_after;
				for index=1:4
					dudx_ni_after(index)=sum(Mdudx_ni(nodeafter,index,sumsequence))/M_after;
				end
				for index=1:3
					s_ni_after(index)=sum(Ms_ni(nodeafter,index,sumsequence))/M_after;
				end
			end
			if relativeside==0 && sideline==startsidenode
				hoopindex=hoopindex+1;
				currentnode=nodebefore;
				hooptheta(hoopindex)=reliableatan(LOC(currentnode,1)-x_crack{1}(n_tip,1),LOC(currentnode,2)-x_crack{1}(n_tip,2));
				Q=[cos(hooptheta(hoopindex)) sin(hooptheta(hoopindex));-sin(hooptheta(hoopindex)) cos(hooptheta(hoopindex))];
				oldsigma=[s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)];
				newsigma=Q*oldsigma*transpose(Q);
				hoopstress(hoopindex)=newsigma(2,2);
			end
			
			hoopindex=hoopindex+1;
			currentnode=nodeafter;
			hooptheta(hoopindex)=reliableatan(LOC(currentnode,1)-x_crack{1}(n_tip,1),LOC(currentnode,2)-x_crack{1}(n_tip,2));
			Q=[cos(hooptheta(hoopindex)) sin(hooptheta(hoopindex));-sin(hooptheta(hoopindex)) cos(hooptheta(hoopindex))];
			oldsigma=[s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)];
			newsigma=Q*oldsigma*transpose(Q);
			hoopstress(hoopindex)=newsigma(2,2);
			
			if side==1
				n(1,1)=-1;
				n(2,1)=0;
			elseif side==2
				n(1,1)=0;
				n(2,1)=-1;
			elseif side==3
				n(1,1)=1;
				n(2,1)=0;
			elseif side==4
				n(1,1)=0;
				n(2,1)=1;
			end
			
			F1before=(W_ni_before+K_ni_before)*n(1)-dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(1);dudx_ni_before(3)]);
			F2before=(W_ni_before+K_ni_before)*n(2)-dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(2);dudx_ni_before(4)]);
			
			F1after=(W_ni_after+K_ni_after)*n(1)-dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(1);dudx_ni_after(3)]);
			F2after=(W_ni_after+K_ni_after)*n(2)-dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(2);dudx_ni_after(4)]);
			
			W_ni_before_track(side,sideline)=W_ni_before;
			W_ni_after_track(side,sideline)=W_ni_after;
			W_ni_track(side,sideline)=(W_ni_before+W_ni_after)/2;
			
			K_ni_before_track(side,sideline)=K_ni_before;
			K_ni_after_track(side,sideline)=K_ni_after;
			K_ni_track(side,sideline)=(K_ni_before+K_ni_after)/2;
			
			n1(side,sideline)=n(1);
			n2(side,sideline)=n(2);
			
			indot1_before_track(side,sideline)=dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(1);dudx_ni_before(3)]);
			indot1_after_track(side,sideline)=dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(1);dudx_ni_after(3)]);
			indot1_track(side,sideline)=(indot1_before_track(side,sideline)+indot1_after_track(side,sideline))/2;
			
			s_ni_1_before_track(side,sideline)=s_ni_before(1);
			s_ni_2_before_track(side,sideline)=s_ni_before(2);
			s_ni_3_before_track(side,sideline)=s_ni_before(3);
			
			s_ni_1_after_track(side,sideline)=s_ni_after(1);
			s_ni_2_after_track(side,sideline)=s_ni_after(2);
			s_ni_3_after_track(side,sideline)=s_ni_after(3);
			
			dudx_ni_1_before_track(side,sideline)=dudx_ni_before(1);
			dudx_ni_2_before_track(side,sideline)=dudx_ni_before(2);
			dudx_ni_3_before_track(side,sideline)=dudx_ni_before(3);
			dudx_ni_4_before_track(side,sideline)=dudx_ni_before(4);
			
			dudx_ni_1_after_track(side,sideline)=dudx_ni_after(1);
			dudx_ni_2_after_track(side,sideline)=dudx_ni_after(2);
			dudx_ni_3_after_track(side,sideline)=dudx_ni_after(3);
			dudx_ni_4_after_track(side,sideline)=dudx_ni_after(4);
			
			dudx_ni_1_avg_track(side,sideline)=(dudx_ni_before(1)+dudx_ni_after(1))/2;
			dudx_ni_2_avg_track(side,sideline)=(dudx_ni_before(2)+dudx_ni_after(2))/2;
			dudx_ni_3_avg_track(side,sideline)=(dudx_ni_before(3)+dudx_ni_after(3))/2;
			dudx_ni_4_avg_track(side,sideline)=(dudx_ni_before(4)+dudx_ni_after(4))/2;
			
			s_ni_1_avg(side,sideline)=(s_ni_1_before_track(side,sideline)+s_ni_1_after_track(side,sideline))/2;
			s_ni_2_avg(side,sideline)=(s_ni_2_before_track(side,sideline)+s_ni_2_after_track(side,sideline))/2;
			s_ni_3_avg(side,sideline)=(s_ni_3_before_track(side,sideline)+s_ni_3_after_track(side,sideline))/2;
			
			indot2_before_track(side,sideline)=dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(2);dudx_ni_before(4)]);
			indot2_after_track(side,sideline)=dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(2);dudx_ni_after(4)]);
			indot2_track(side,sideline)=(indot2_before_track(side,sideline)+indot2_after_track(side,sideline))/2;
			
			W_ni_contributionto1(side,sideline)=W_ni_track(side,sideline)*n1(side,sideline);
			W_ni_contributionto2(side,sideline)=W_ni_track(side,sideline)*n2(side,sideline);
			
			K_ni_contributionto1(side,sideline)=K_ni_track(side,sideline)*n1(side,sideline);
			K_ni_contributionto2(side,sideline)=K_ni_track(side,sideline)*n2(side,sideline);
			
			if relativeside==0 && sideline==startsidenode
				F1before=F1before*(1-RelativeLocation_bot)+F1after*(RelativeLocation_bot);
				F2before=F2before*(1-RelativeLocation_bot)+F2after*(RelativeLocation_bot);
				deltai=(1-RelativeLocation_bot)*le(1); %assuming square grid
			elseif relativeside==4-sidegap && sideline==endsidenode-1
				F1after=F1before*(1-RelativeLocation_top)+F1after*(RelativeLocation_top);
				F2after=F2before*(1-RelativeLocation_top)+F2after*(RelativeLocation_top);
				deltai=RelativeLocation_top*le(1); %assuming square grid
			end
			
			F1before_store(side,sideline)=F1before;
			F2before_store(side,sideline)=F2before;
			F1after_store(side,sideline)=F1after;
			F2after_store(side,sideline)=F2after;
			
			J1=J1+(F1before+F1after)/2*deltai;
			J2=J2+(F2before+F2after)/2*deltai;
		end
	end
	deltax_crack=x_crack{1}(n_tip,1)-x_crack{1}(n_tip-1,1);
	deltay_crack=x_crack{1}(n_tip,2)-x_crack{1}(n_tip-1,2);
	
	
	thetacold=reliableatan(deltax_crack,deltay_crack);
	%thetac=reliableatan(J1,J2);
	%thetac=thetacold;
	%thetac=thetamin;
	maxhoopstresssofar=[];
	for i=1:length(hooptheta)
		deltathetac=mod((hooptheta(i)-thetacold)+pi,2*pi)-pi;
		if deltathetac<-pi/2 || deltathetac>pi/2
			continue;
		end
		if length(maxhoopstresssofar)==0
			maxhoopstresssofar=hoopstress(i);
			maxhoopstressnumsofar=i;
		else
			if hoopstress(i)>maxhoopstresssofar
				maxhoopstresssofar=hoopstress(i);
				maxhoopstressnumsofar=i;
			end
		end
	end
	thetac=hooptheta(maxhoopstressnumsofar);
	deltathetac=mod((thetac-thetacold)+pi,2*pi)-pi;
	newcrackdistance=sqrt(deltax_crack^2+deltay_crack^2);
	G=J1*cos(thetac)+J2*sin(thetac);
	%disp(['G=' num2str(G) ', thetac=' num2str(thetac*180/3.1415926536) ' degrees']);
else
	%start function for calculating J integral
	K_sp=0.5*(p_sp.*(v_ssp_out(:,1).^2 + v_ssp_out(:,2).^2));
	n_tip=size(x_crack,1);
	x_tip=x_crack(n_tip,:);
	ni_Jcenter=FindMax(Nmatrix_crack(:,n_tip));
	if CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || Cas
		for moveJcenterrepeate=0:999999
			if LOC(ni_Jcenter,2)>50-expansion*le(2)21862
				ni_Jcenter=ni_Jcenter-NN(1);
			elseif LOC(ni_Jcenter,2)<10+expansion*le(2)
				ni_Jcenter=ni_Jcenter+NN(1);etoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77
		expansion=2;
	elseif CasetoRun==69
		expansion=2;
	end
	if CasetoRun==71
			else
				break;
				1;
			end
		end
	elseif CasetoRun==72
		for moveJcenterrepeate=0:999999
			if LOC(ni_Jcenter,2)>40-expansion*le(2)
				ni_Jcenter=ni_Jcenter-NN(1);
			elseif LOC(ni_Jcenter,2)<10+expansion*le(2)
				ni_Jcenter=ni_Jcenter+NN(1);
			else
				break;
				1;
			end
		end
	end

	n_pointperside=2*expansion+1;
		
	%listing surrounding nodes in counter-clockwise order
	ni_list{4}(n_pointperside)=0;
	ni_list{3}(n_pointperside)=0;
	ni_list{2}(n_pointperside)=0;
	ni_list{1}(n_pointperside)=0;
	%ni_list index: 1 = left, 2 = bottom, 3 = right, 4 = top

	for i=1:n_pointperside
		ni_list{1}(i)=ni_Jcenter-expansion+expansion*NN(1)-(i-1)*NN(1);
		ni_list{2}(i)=ni_Jcenter-expansion*NN(1)-expansion+(i-1);
		ni_list{3}(i)=ni_Jcenter+expansion-expansion*NN(1)+(i-1)*NN(1);
		ni_list{4}(i)=ni_Jcenter+expansion*NN(1)+expansion-(i-1);
	end


	for toporbot=1:2
		sidebreaksignal=0;
		for crackline=(n_tip-1):-1:1
			for side=1:4
				for sideline=1:(length(ni_list{side})-1)
					if side==3 && sideline==2 && crackline==2
						1;
					end
					x1=LOC(ni_list{side}(sideline),:);
					x2=LOC(ni_list{side}(sideline+1),:);
					if toporbot==1
						x3=x_cracktop(crackline,:);
						x4=x_cracktop(crackline+1,:);
						[CrossDir,RelativeLocation]=FindCrossing(x1,x2,x3,x4);
					elseif toporbot==2
						x3=x_crackbot(crackline,:);
						x4=x_crackbot(crackline+1,:);
						[CrossDir,RelativeLocation]=FindCrossing(x1,x2,x3,x4);
					end
					if CrossDir>0
						sidebreaksignal=1;
						break;
					end
				end
				if sidebreaksignal==1
					break;
				end
			end
			if sidebreaksignal==1
				break;
			end
		end
		if toporbot==1
			crackline_top=crackline;
			side_top=side;
			sideline_top=sideline;
			CrossDir_top=CrossDir;
			RelativeLocation_top=RelativeLocation;
		elseif toporbot==2
			crackline_bot=crackline;
			side_bot=side;
			sideline_bot=sideline;
			CrossDir_bot=CrossDir;
			RelativeLocation_bot=RelativeLocation;
		end
	end
	for field=1:size(Nmatrix,3)
		M_ni(:,field)=Nmatrix(:,:,field)*m_sp;
		MW_ni(:,field)=Nmatrix(:,:,field)*(m_sp.*W_sp);
		Mdudx_ni(:,:,field)=Nmatrix(:,:,field)*(m_sp.*dudx_sp);
		Ms_ni(:,:,field)=Nmatrix(:,:,field)*(m_sp.*s_sp);
		MK_ni(:,:,field)=Nmatrix(:,:,field)*(m_sp.*K_sp);
	end
	sidegap=mod(side_bot-side_top,4);
	J1=0;
	J2=0;
	hoopstress=[];
	hooptheta=[];
	hoopindex=0;
	for relativeside=0:4-sidegap
		side=mod(side_bot-1+relativeside,4)+1;
		startsidenode=1;
		endsidenode=(2*expansion)+1;
		if relativeside==0
			startsidenode=sideline_bot;
		elseif relativeside==4-sidegap
			endsidenode=sideline_top+1;
		end
		for sideline=startsidenode:endsidenode-1
			nodebefore=ni_list{side}(sideline);
			nodeafter=ni_list{side}(sideline+1);
			if relativeside==0 || relativeside==1
				sumsequence=1:2:3;
			elseif relativeside==(4-sidegap) || relativeside==(4-sidegap-1)
				sumsequence=1:2;
			else
				sumsequence=1:3;
			end
			M_before=sum(M_ni(nodebefore,sumsequence));
			if M_before==0
				W_ni_before=0;
				dudx_ni_before(1:4)=0;
				s_ni_before(1:3)=0;
				K_ni_before=0;
			else
				W_ni_before=sum(MW_ni(nodebefore,sumsequence))/M_before;
				K_ni_before=sum(MK_ni(nodebefore,:))/M_before;
				for index=1:4
					dudx_ni_before(index)=sum(Mdudx_ni(nodebefore,index,sumsequence))/M_before;
				end
				for index=1:3
					s_ni_before(index)=sum(Ms_ni(nodebefore,index,sumsequence))/M_before;
				end
			end

			M_after=sum(M_ni(nodeafter,sumsequence));
			if M_after==0
				W_ni_after=0;
				dudx_ni_after(1:4)=0;
				s_ni_after(1:3)=0;
				K_ni_after=0;
			else
				W_ni_after=sum(MW_ni(nodeafter,sumsequence))/M_after;
				K_ni_after=sum(MK_ni(nodeafter,:))/M_after;
				for index=1:4
					if side==1 && sideline==1 && index==2
						1;
					end
					dudx_ni_after(index)=sum(Mdudx_ni(nodeafter,index,sumsequence))/M_after;
				end
				for index=1:3
					s_ni_after(index)=sum(Ms_ni(nodeafter,index,sumsequence))/M_after;
				end
			end
			if relativeside==0 && sideline==startsidenode
				hoopindex=hoopindex+1;
				currentnode=nodebefore;
				hooptheta(hoopindex)=reliableatan(LOC(currentnode,1)-x_crack(n_tip,1),LOC(currentnode,2)-x_crack(n_tip,2));
				Q=[cos(hooptheta(hoopindex)) sin(hooptheta(hoopindex));-sin(hooptheta(hoopindex)) cos(hooptheta(hoopindex))];
				oldsigma=[s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)];
				newsigma=Q*oldsigma*transpose(Q);
				hoopstress(hoopindex)=newsigma(2,2);
			end
			
			hoopindex=hoopindex+1;
			currentnode=nodeafter;
			hooptheta(hoopindex)=reliableatan(LOC(currentnode,1)-x_crack(n_tip,1),LOC(currentnode,2)-x_crack(n_tip,2));
			Q=[cos(hooptheta(hoopindex)) sin(hooptheta(hoopindex));-sin(hooptheta(hoopindex)) cos(hooptheta(hoopindex))];
			oldsigma=[s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)];
			newsigma=Q*oldsigma*transpose(Q);
			hoopstress(hoopindex)=newsigma(2,2);
			
			if side==1
				n(1,1)=-1;
				n(2,1)=0;
			elseif side==2
				n(1,1)=0;
				n(2,1)=-1;
			elseif side==3
				n(1,1)=1;
				n(2,1)=0;
			elseif side==4
				n(1,1)=0;
				n(2,1)=1;
			end
			
			F1before=(W_ni_before+K_ni_before)*n(1)-dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(1);dudx_ni_before(3)]);
			F2before=(W_ni_before+K_ni_before)*n(2)-dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(2);dudx_ni_before(4)]);

			F1after=(W_ni_after+K_ni_after)*n(1)-dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(1);dudx_ni_after(3)]);
			F2after=(W_ni_after+K_ni_after)*n(2)-dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(2);dudx_ni_after(4)]);
			%{
			W_ni_before_track(side,sideline)=W_ni_before;
			W_ni_after_track(side,sideline)=W_ni_after;
			W_ni_track(side,sideline)=(W_ni_before+W_ni_after)/2;
			
			K_ni_before_track(side,sideline)=K_ni_before;
			K_ni_after_track(side,sideline)=K_ni_after;
			K_ni_track(side,sideline)=(K_ni_before+K_ni_after)/2;
			
			n1(side,sideline)=n(1);
			n2(side,sideline)=n(2);
			
			indot1_before_track(side,sideline)=dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(1);dudx_ni_before(3)]);
			indot1_after_track(side,sideline)=dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(1);dudx_ni_after(3)]);
			indot1_track(side,sideline)=(indot1_before_track(side,sideline)+indot1_after_track(side,sideline))/2;
			
			s_ni_1_before_track(side,sideline)=s_ni_before(1);
			s_ni_2_before_track(side,sideline)=s_ni_before(2);
			s_ni_3_before_track(side,sideline)=s_ni_before(3);
			
			s_ni_1_after_track(side,sideline)=s_ni_after(1);
			s_ni_2_after_track(side,sideline)=s_ni_after(2);
			s_ni_3_after_track(side,sideline)=s_ni_after(3);
			
			dudx_ni_1_before_track(side,sideline)=dudx_ni_before(1);
			dudx_ni_2_before_track(side,sideline)=dudx_ni_before(2);
			dudx_ni_3_before_track(side,sideline)=dudx_ni_before(3);
			dudx_ni_4_before_track(side,sideline)=dudx_ni_before(4);
			
			dudx_ni_1_after_track(side,sideline)=dudx_ni_after(1);
			dudx_ni_2_after_track(side,sideline)=dudx_ni_after(2);
			dudx_ni_3_after_track(side,sideline)=dudx_ni_after(3);
			dudx_ni_4_after_track(side,sideline)=dudx_ni_after(4);
			
			dudx_ni_1_avg_track(side,sideline)=(dudx_ni_before(1)+dudx_ni_after(1))/2;
			dudx_ni_2_avg_track(side,sideline)=(dudx_ni_before(2)+dudx_ni_after(2))/2;
			dudx_ni_3_avg_track(side,sideline)=(dudx_ni_before(3)+dudx_ni_after(3))/2;
			dudx_ni_4_avg_track(side,sideline)=(dudx_ni_before(4)+dudx_ni_after(4))/2;
			
			s_ni_1_avg(side,sideline)=(s_ni_1_before_track(side,sideline)+s_ni_1_after_track(side,sideline))/2;
			s_ni_2_avg(side,sideline)=(s_ni_2_before_track(side,sideline)+s_ni_2_after_track(side,sideline))/2;
			s_ni_3_avg(side,sideline)=(s_ni_3_before_track(side,sideline)+s_ni_3_after_track(side,sideline))/2;
			
			indot2_before_track(side,sideline)=dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(2);dudx_ni_before(4)]);
			indot2_after_track(side,sideline)=dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(2);dudx_ni_after(4)]);
			indot2_track(side,sideline)=(indot2_before_track(side,sideline)+indot2_after_track(side,sideline))/2;
			
			W_ni_contributionto1(side,sideline)=W_ni_track(side,sideline)*n1(side,sideline);
			W_ni_contributionto2(side,sideline)=W_ni_track(side,sideline)*n2(side,sideline);
			
			K_ni_contributionto1(side,sideline)=K_ni_track(side,sideline)*n1(side,sideline);
			K_ni_contributionto2(side,sideline)=K_ni_track(side,sideline)*n2(side,sideline);
			%}
			if relativeside==0 && sideline==startsidenode
				F1before=F1before*(1-RelativeLocation_bot)+F1after*(RelativeLocation_bot);
				F2before=F2before*(1-RelativeLocation_bot)+F2after*(RelativeLocation_bot);
				deltai=(1-RelativeLocation_bot)*le(1); %assuming square grid
			elseif relativeside==4-sidegap && sideline==endsidenode-1
				F1after=F1before*(1-RelativeLocation_top)+F1after*(RelativeLocation_top);
				F2after=F2before*(1-RelativeLocation_top)+F2after*(RelativeLocation_top);
				deltai=RelativeLocation_top*le(1); %assuming square grid
			end
			J1=J1+(F1before+F1after)/2*deltai;
			J2=J2+(F2before+F2after)/2*deltai;
		end
		
	end
	deltax_crack=x_crack(n_tip,1)-x_crack(n_tip-1,1);
	deltay_crack=x_crack(n_tip,2)-x_crack(n_tip-1,2);

	%{
	nx_cell=ceil(x_crack(n_tip,1)/le(1));
	ny_cell=ceil(x_crack(n_tip,2)/le(2));
	ni_bl=nx_cell+(ny_cell-1)*NN(1);
	ni_br=ni_bl+1;
	ni_tl=ni_bl+NN(1);
	ni_tr=ni_tl+1;
	x_factor=(x_crack(n_tip,1)-LOC(ni_bl,1))/(LOC(ni_br,1)-LOC(ni_bl,1));
	y_factor=(x_crack(n_tip,2)-LOC(ni_bl,2))/(LOC(ni_tl,2)-LOC(ni_bl,2));


	M_ni_all=M_ni(:,1)+M_ni(:,2)+M_ni(:,3);
	Ms_ni_all=Ms_ni(:,:,1)+Ms_ni(:,:,2)+Ms_ni(:,:,3);

	s_ni_bl=Ms_ni_all(ni_bl,:)/M_ni_all(ni_bl);
	s_ni_br=Ms_ni_all(ni_br,:)/M_ni_all(ni_br);
	s_ni_tl=Ms_ni_all(ni_tl,:)/M_ni_all(ni_tl);
	s_ni_tr=Ms_ni_all(ni_tr,:)/M_ni_all(ni_tr);

	s_ni_tip=(s_ni_bl*(1-x_factor)+s_ni_br*x_factor)*(1-y_factor)+(s_ni_tl*(1-x_factor)+s_ni_tr*x_factor)*y_factor;

	thetaprinc=1/2*atan(2*s_ni_tip(1,3)/(s_ni_tip(1,1)-s_ni_tip(1,2)));
	s_ni_tip_first=(s_ni_tip(1,1)+s_ni_tip(1,2))/2+(s_ni_tip(1,1)-s_ni_tip(1,2))/2*cos(2*thetaprinc)+s_ni_tip(1,3)*sin(2*thetaprinc);
	s_ni_tip_second=(s_ni_tip(1,1)+s_ni_tip(1,2))/2-(s_ni_tip(1,1)-s_ni_tip(1,2))/2*cos(2*thetaprinc)-s_ni_tip(1,3)*sin(2*thetaprinc);

	if s_ni_tip_first>s_ni_tip_second
		thetamin=thetaprinc+pi/2;
	else
		thetamin=thetaprinc;
	end

	thetamin=mod(thetamin+pi/2,pi)-pi/2;
	%}
	thetacold=reliableatan(deltax_crack,deltay_crack);
	%thetac=reliableatan(J1,J2);
	%thetac=thetacold;
	%thetac=thetamin;
	maxhoopstresssofar=[];
	for i=1:length(hooptheta)
		deltathetac=mod((hooptheta(i)-thetacold)+pi,2*pi)-pi;
		if deltathetac<-pi/2 || deltathetac>pi/2
			continue;
		end
		if length(maxhoopstresssofar)==0
			maxhoopstresssofar=hoopstress(i);
			maxhoopstressnumsofar=i;
		else
			if hoopstress(i)>maxhoopstresssofar
				maxhoopstresssofar=hoopstress(i);
				maxhoopstressnumsofar=i;
			end
		end
	end
	thetac=hooptheta(maxhoopstressnumsofar);
	deltathetac=mod((thetac-thetacold)+pi,2*pi)-pi;
	newcrackdistance=sqrt(deltax_crack^2+deltay_crack^2);
	G=J1*cos(thetac)+J2*sin(thetac);
	disp(['G=' num2str(G) ', thetac=' num2str(thetac*180/3.1415926536) ' degrees']);
	if CasetoRun==64 || CasetoRun==65 || CasetoRun==70 || CasetoRun==66 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72
		Gcnow=0.14;
		if CasetoRun==68
			Gcnow=0.5;
		end
		if G>Gcnow && deltathetac<pi && deltathetac>-pi
			newx_crack=x_crack(n_tip,:)+newcrackdistance*[cos(thetac) sin(thetac)]
			x_crack=[x_crack;newx_crack]
			x_cracktop=[x_cracktop;newx_crack];
			x_crackbot=[x_crackbot;newx_crack];
			1;
		end
	end
end

%{
disp('intersection found!')
disp(['crackline=' num2str(crackline) ' out of ' num2str(n_tip-1)]);
disp(['side=' num2str(side)]);
disp(['sideline=' num2str(sideline) ' out of ' num2str(length(ni_list{side})-1)]);
disp(['CrossDir=' num2str(CrossDir)]);
disp(['RelativeLocation=' num2str(RelativeLocation)]);
AbsoluteLocation=LOC(ni_list{side}(sideline),:)+LOC(ni_list{side}(sideline+1),:)*RelativeLocation;
disp(['Absolute Coordinate = (' num2str(AbsoluteLocation,1) ',' num2str(AbsoluteLocation,2) ')']);

pause
1;
%}

%end function for calculating J



	
%% Update the topology of particles
%if CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
%else
    [r1_sp,r2_sp] = Update_topology(spCount,F_sp,r1_sp,r10_sp,r2_sp,r20_sp);
    r1_sp=real(r1_sp);
    r2_sp=real(r2_sp);
%end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit,Nmatrix,dNxmatrix,dNymatrix,Nmatrixtop,Nmatrixbot,NmatrixAll] = SplitField(LOC,x_sp,CONNECT,CONNECTpn,x_crack,CONNECT_crack,CONNECTpn_crack,Nmatrix,dNxmatrix,dNymatrix,t)
	NmatrixAll=Nmatrix;
	Nmatrixtop=zeros(size(NmatrixAll));
	Nmatrixbot=zeros(size(NmatrixAll));
	Nmatrix(1,1,3)=0;
	dNxmatrix(1,1,3)=0;
	dNymatrix(1,1,3)=0;
	TheFieldSplit=ones(length(CONNECTpn),length(CONNECT));
	%for SuspectedNodeCounter=1:length(CONNECTpn_crack)
	Area=zeros(4,1);
	for sp=1:length(CONNECT)
		for ni=1:length(CONNECT{sp})
			Field2Counter=0;
			Field3Counter=0;
			for crack_p_counter=1:(size(x_crack,1)-1)
				i=CONNECT{sp}(ni);
				x1=x_sp(sp,:);
				x2=LOC(i,:);
				x3=x_crack(crack_p_counter,:);
				x4=x_crack(crack_p_counter+1,:);
				Area(1)=TriangleArea(x1,x2,x3);
				Area(2)=TriangleArea(x1,x2,x4);
				Area(3)=TriangleArea(x3,x4,x1);
				Area(4)=TriangleArea(x3,x4,x2);
				if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
                    %{
                    if sp==220 && ni==8 && CloseEnough(x1(1),58.740308582876274101636226987466)
                        1;
                        plot(x1(1),x1(2),'o','DisplayName','particle')
                        hold on
                        plot(x2(1),x2(2),'o','DisplayName','node')
                        plot(x3(1),x3(2),'o','DisplayName','crackbefore')
                        plot(x4(1),x4(2),'o','DisplayName','crackafter')
                        legend show
                        hold off
                        1;
                    end
                    %}
					Field2Counter=Field2Counter+1;
				elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
                    %{
                    if sp==220 && ni==8 && CloseEnough(x1(1),58.740308582876274101636226987466)
                        1;
                        plot(x1(1),x1(2),'o','DisplayName','particle')
                        hold on
                        plot(x2(1),x2(2),'o','DisplayName','node')
                        plot(x3(1),x3(2),'o','DisplayName','crackbefore')
                        plot(x4(1),x4(2),'o','DisplayName','crackafter')
                        legend show
                        hold off
                        1;
                    end
                    %}
					Field3Counter=Field3Counter+1;
				end
            end
            if Field2Counter>0 && Field3Counter>0
                %{
                try
                    asdf(-pi);
                catch exc
                    disp('Field Split Error!');
                    getReport(exc,'extended');
                    pause;
                    1;
                end
                %}
                1;
                Field23Min=min([Field2Counter Field3Counter]);
                Field2Counter=Field2Counter-Field23Min;
                Field3Counter=Field3Counter-Field23Min;
                1;
            end
			if mod(Field2Counter,2)>0
				TheFieldSplit(i,sp)=2;
				Nmatrix(i,sp,2)=Nmatrix(i,sp,1);
				Nmatrix(i,sp,1)=0;
				dNxmatrix(i,sp,2)=dNxmatrix(i,sp,1);
				dNxmatrix(i,sp,1)=0;
				dNymatrix(i,sp,2)=dNymatrix(i,sp,1);
				dNymatrix(i,sp,1)=0;
			elseif mod(Field3Counter,2)>0
				TheFieldSplit(i,sp)=3;
				Nmatrix(i,sp,3)=Nmatrix(i,sp,1);
				Nmatrix(i,sp,1)=0;
				dNxmatrix(i,sp,3)=dNxmatrix(i,sp,1);
				dNxmatrix(i,sp,1)=0;
				dNymatrix(i,sp,3)=dNymatrix(i,sp,1);
				dNymatrix(i,sp,1)=0;
			end
		end
	end
    for i=1:length(CONNECTpn)
        if CloseEnough(t,0.25291484448446682753441905333602) && i==613 %temporary for debugging
            1;
        end
        nodalfieldlist=sort(unique(TheFieldSplit(i,:)));
		newfieldrevision=1;
        if length(nodalfieldlist)==2
            if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
				newfieldrevision=3;
            elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
				newfieldrevision=2;
            end
        elseif length(nodalfieldlist)==3
            disp('Field split error, ignoring 1904092154')
            pause
            1;
        end
		if newfieldrevision>1
			for sp=1:length(CONNECT)
				if TheFieldSplit(i,sp)==1
                    TheFieldSplit(i,sp)=newfieldrevision;
					Nmatrix(i,sp,newfieldrevision)=Nmatrix(i,sp,1);
					Nmatrix(i,sp,1)=0;
					dNxmatrix(i,sp,newfieldrevision)=dNxmatrix(i,sp,1);
					dNxmatrix(i,sp,1)=0;
					dNymatrix(i,sp,newfieldrevision)=dNymatrix(i,sp,1);
					dNymatrix(i,sp,1)=0;
				end
			end
		end
    end
	for sp=1:length(CONNECT)
		if max(TheFieldSplit(:,sp))==2
			Nmatrixtop(:,sp)=NmatrixAll(:,sp);
		elseif max(TheFieldSplit(:,sp))==3
			Nmatrixbot(:,sp)=NmatrixAll(:,sp);
		end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit,Nmatrix,dNxmatrix,dNymatrix,NmatrixAll] = SplitFieldMulti(LOC,x_sp,CONNECT,CONNECTpn,x_crack,CONNECT_crack,CONNECTpn_crack,Nmatrix,dNxmatrix,dNymatrix,t)
	NmatrixAll=Nmatrix;
	numberofcrackpaths=length(x_crack);
	numberoffields=3^numberofcrackpaths;
	if numberoffields>1
        Nmatrix(1,1,numberoffields)=0;
        dNxmatrix(1,1,numberoffields)=0;
        dNymatrix(1,1,numberoffields)=0;
    end
	TheFieldSplit=ones(length(CONNECTpn),length(CONNECT));
	TheFieldSplitBase3=ones(length(CONNECTpn),length(CONNECT),numberofcrackpaths);
	
	%for SuspectedNodeCounter=1:length(CONNECTpn_crack)
	Area=zeros(4,1);
	for ncrack=1:numberofcrackpaths %not to get confused with numberofcrackpaths, ncrack is the moving number, from 1 to numberofcrackpaths
		for sp=1:length(CONNECT)
			for ni=1:length(CONNECT{sp})
				Field2Counter=0;
				Field3Counter=0;
				for crack_p_counter=1:(size(x_crack{ncrack},1)-1)
					i=CONNECT{sp}(ni);
					x1=x_sp(sp,:);
					x2=LOC(i,:);
					x3=x_crack{ncrack}(crack_p_counter,:);
					x4=x_crack{ncrack}(crack_p_counter+1,:);
					Area(1)=TriangleArea(x1,x2,x3);
					Area(2)=TriangleArea(x1,x2,x4);
					Area(3)=TriangleArea(x3,x4,x1);
					Area(4)=TriangleArea(x3,x4,x2);
					if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
						Field2Counter=Field2Counter+1;
					elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
						%{
						if sp==220 && ni==8 && CloseEnough(x1(1),58.740308582876274101636226987466)
							1;
							plot(x1(1),x1(2),'o','DisplayName','particle')
							hold on
							plot(x2(1),x2(2),'o','DisplayName','node')
							plot(x3(1),x3(2),'o','DisplayName','crackbefore')
							plot(x4(1),x4(2),'o','DisplayName','crackafter')
							legend show
							hold off
							1;
						end
						%}
						Field3Counter=Field3Counter+1;
					end
				end
				if Field2Counter>0 && Field3Counter>0
					%{
					try
						asdf(-pi);
					catch exc
						disp('Field Split Error!');
						getReport(exc,'extended');
						pause;
						1;
					end
					%}
					1;
					Field23Min=min([Field2Counter Field3Counter]);
					Field2Counter=Field2Counter-Field23Min;
					Field3Counter=Field3Counter-Field23Min;
					1;
				end
				if mod(Field2Counter,2)>0
				%{
					TheFieldSplit(i,sp)=2*ncrack;
					Nmatrix(i,sp,2*ncrack)=Nmatrix(i,sp,1);
					Nmatrix(i,sp,1)=0;
					dNxmatrix(i,sp,2*ncrack)=dNxmatrix(i,sp,1);
					dNxmatrix(i,sp,1)=0;
					dNymatrix(i,sp,2*ncrack)=dNymatrix(i,sp,1);
					dNymatrix(i,sp,1)=0;
				%}
					TheFieldSplitBase3(i,sp,ncrack)=2;
				elseif mod(Field3Counter,2)>0
				%{
					TheFieldSplit(i,sp)=2*ncrack+1;
					Nmatrix(i,sp,2*ncrack+1)=Nmatrix(i,sp,1);
					Nmatrix(i,sp,1)=0;
					dNxmatrix(i,sp,2*ncrack+1)=dNxmatrix(i,sp,1);
					dNxmatrix(i,sp,1)=0;
					dNymatrix(i,sp,2*ncrack+1)=dNymatrix(i,sp,1);
					dNymatrix(i,sp,1)=0;
				%}
					TheFieldSplitBase3(i,sp,ncrack)=3;
				end
			end
		end
		
		for i=1:length(CONNECTpn)
			nodalfieldlist=sort(unique(TheFieldSplitBase3(i,CONNECTpn{i},ncrack)));
			newfieldrevision=1;
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			elseif length(nodalfieldlist)==3
				disp('Field split error! (code 1904012104)')
				pause
				1;
			end
			if newfieldrevision>1
				for nsp=1:length(CONNECTpn{i})
					if TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)==1
						TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)=newfieldrevision;
					end
				end
			end
		end

		%{
		for i=1:length(CONNECTpn)
			nodalfieldlist=sort(unique(TheFieldSplit(i,:)));
			newfieldrevision=1;
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			elseif length(nodalfieldlist)==3
				disp('Field split error, ignoring')
				%pause
				1;
			end
			if newfieldrevision>1
				for sp=1:length(CONNECT)
					if TheFieldSplit(i,sp)==1
						TheFieldSplit(i,sp)=newfieldrevision;
						Nmatrix(i,sp,newfieldrevision)=Nmatrix(i,sp,1);
						Nmatrix(i,sp,1)=0;
						dNxmatrix(i,sp,newfieldrevision)=dNxmatrix(i,sp,1);
						dNxmatrix(i,sp,1)=0;
						dNymatrix(i,sp,newfieldrevision)=dNymatrix(i,sp,1);
						dNymatrix(i,sp,1)=0;
					end
				end
			end
		end
		%}
	end
	for i=1:size(TheFieldSplitBase3,1)
		for sp=1:size(TheFieldSplitBase3,2)
			TheFieldSplit(i,sp)=BaseNtoDec(TheFieldSplitBase3(i,sp,:),1,3);
		end
	end
	for i=1:size(TheFieldSplit,1)
		for sp=1:size(TheFieldSplit,2)
			if TheFieldSplit(i,sp)==1
			else
				if TheFieldSplit(i,sp)==9
					1;
				end
				Nmatrix(i,sp,TheFieldSplit(i,sp))=Nmatrix(i,sp,1);
				Nmatrix(i,sp,1)=0;
				
				dNxmatrix(i,sp,TheFieldSplit(i,sp))=dNxmatrix(i,sp,1);
				dNxmatrix(i,sp,1)=0;
				
				dNymatrix(i,sp,TheFieldSplit(i,sp))=dNymatrix(i,sp,1);
				dNymatrix(i,sp,1)=0;
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit] = SplitFieldMultiOptimized(LOC,x_sp,CONNECT,CONNECTpn,x_crack,t,le)
	numberofcrackpaths=length(x_crack);
	numberoffields=3^numberofcrackpaths;

	TheFieldSplit=ones(length(CONNECTpn),length(CONNECT));
	TheFieldSplitBase3=ones(length(CONNECTpn),length(CONNECT),numberofcrackpaths);
	%SplitSourceSplitBase3=zeros(length(CONNECTpn),length(CONNECT),numberofcrackpaths);
	
	Area=zeros(4,1);
	for ncrack=1:numberofcrackpaths %not to get confused with numberofcrackpaths, ncrack is the moving number, from 1 to numberofcrackpaths
		for sp=1:length(CONNECT)
			for ni=1:length(CONNECT{sp})
				Field2Counter=0;
				Field3Counter=0;
				for crack_p_counter=1:(size(x_crack{ncrack},1)-1)
					i=CONNECT{sp}(ni);
					x1=x_sp(sp,:);
					x2=LOC(i,:);
					x3=x_crack{ncrack}(crack_p_counter,:);
					x4=x_crack{ncrack}(crack_p_counter+1,:);
					Area(1)=TriangleArea(x1,x2,x3);
					Area(2)=TriangleArea(x1,x2,x4);
					Area(3)=TriangleArea(x3,x4,x1);
					Area(4)=TriangleArea(x3,x4,x2);
					if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
						Field2Counter=Field2Counter+1;
					elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
						Field3Counter=Field3Counter+1;
					end
				end
				if Field2Counter>0 && Field3Counter>0
					Field23Min=min([Field2Counter Field3Counter]);
					Field2Counter=Field2Counter-Field23Min;
					Field3Counter=Field3Counter-Field23Min;
				end
				if mod(Field2Counter,2)>0
					TheFieldSplitBase3(i,sp,ncrack)=2;
					%SplitSourceSplitBase3(i,sp,ncrack)=crack_p_counter;
				elseif mod(Field3Counter,2)>0
					TheFieldSplitBase3(i,sp,ncrack)=3;
					%SplitSourceSplitBase3(i,sp,ncrack)=crack_p_counter;
				end
			end
		end
		
		for i=1:length(CONNECTpn)
			nodalfieldlist=sort(unique(TheFieldSplitBase3(i,CONNECTpn{i},ncrack)));
			newfieldrevision=1;
			if length(nodalfieldlist)==3
				disp('Field split error, applying fix! (code 1904012106)')
				%pause
				1;
				problematicnsp=[];
				for nsp=1:length(CONNECTpn{i})
					if TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)>1
						problematicnsp=[problematicnsp nsp];
					end
                end
				TheFieldSplitBase3_old=TheFieldSplitBase3;
				for fixmode=1:3
					% extending the crack
					%fixmode=1: x_crack{npid}(size(x_crack{npid},1),:) extension by le(1)
					%fixmode=2: x_crack{npid}(0,:) extension by le(1)
					%fixmode=3: both extensions
					if fixmode==1
						x_crack_modified=x_crack{ncrack};
						cracksize=size(x_crack_modified,1);
						trajectory=reliableatan(x_crack{ncrack}(cracksize,1)-x_crack{ncrack}(cracksize-1,1),x_crack{ncrack}(cracksize,2)-x_crack{ncrack}(cracksize-1,2));
						x_crack_modified(cracksize,1)=x_crack{ncrack}(cracksize,1)+le(1)*cos(trajectory);
						x_crack_modified(cracksize,2)=x_crack{ncrack}(cracksize,2)+le(1)*sin(trajectory);
					elseif fixmode==2
						x_crack_modified=x_crack{ncrack};
						cracksize=size(x_crack_modified,1);
						trajectory=reliableatan(x_crack{ncrack}(1,1)-x_crack{ncrack}(2,1),x_crack{ncrack}(1,2)-x_crack{ncrack}(2,2));
						x_crack_modified(1,1)=x_crack{ncrack}(1,1)+le(1)*cos(trajectory);
						x_crack_modified(1,2)=x_crack{ncrack}(1,2)+le(1)*sin(trajectory);
					elseif fixmode==3
						x_crack_modified=x_crack{ncrack};
						cracksize=size(x_crack_modified,1);
						trajectory1=reliableatan(x_crack{ncrack}(cracksize,1)-x_crack{ncrack}(cracksize-1,1),x_crack{ncrack}(cracksize,2)-x_crack{ncrack}(cracksize-1,2));
						x_crack_modified(cracksize,1)=x_crack{ncrack}(cracksize,1)+le(1)*cos(trajectory1);
						x_crack_modified(cracksize,2)=x_crack{ncrack}(cracksize,2)+le(1)*sin(trajectory1);
						trajectory2=reliableatan(x_crack{ncrack}(1,1)-x_crack{ncrack}(2,1),x_crack{ncrack}(1,2)-x_crack{ncrack}(2,2));
						x_crack_modified(1,1)=x_crack{ncrack}(1,1)+le(1)*cos(trajectory2);
						x_crack_modified(1,2)=x_crack{ncrack}(1,2)+le(1)*sin(trajectory2);
					end
					% extending the crack finished
					
					% revising bad mapping
					for nsp=1:length(problematicnsp)
						Field2Counter=0;
						Field3Counter=0;
                        sp=CONNECTpn{i}(problematicnsp(nsp));
                        TheFieldSplitBase3(i,sp,ncrack)=1;
						for crack_p_counter=1:(size(x_crack_modified,1)-1)
							x1=x_sp(sp,:);
							x2=LOC(i,:);
							x3=x_crack_modified(crack_p_counter,:);
							x4=x_crack_modified(crack_p_counter+1,:);
							Area(1)=TriangleArea(x1,x2,x3);
							Area(2)=TriangleArea(x1,x2,x4);
							Area(3)=TriangleArea(x3,x4,x1);
							Area(4)=TriangleArea(x3,x4,x2);
							if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
								Field2Counter=Field2Counter+1;
                                %close gcf;
                                %plot(LOC(i,1),LOC(i,2),'o','DisplayName','Node');
                                %hold on
                                %plot(x_sp(sp,1),x_sp(sp,2),'o','DisplayName','Particle');
                                %plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
                                %plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
                                %daspect([1 1 1]);
                                %legend show
                                %title(['above, particle=' num2str(sp) ', node=' num2str(i)]);
                                %1;
							elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
								Field3Counter=Field3Counter+1;
                                %close gcf;
                                %plot(LOC(i,1),LOC(i,2),'o','DisplayName','Node');
                                %hold on
                                %plot(x_sp(sp,1),x_sp(sp,2),'o','DisplayName','Particle');
                                %plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
                                %plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
                                %daspect([1 1 1]);
                                %legend show
                                %title(['below, particle=' num2str(sp) ', node=' num2str(i)]);
                                %1;
							end
						end
						if Field2Counter>0 && Field3Counter>0
							Field23Min=min([Field2Counter Field3Counter]);
							Field2Counter=Field2Counter-Field23Min;
							Field3Counter=Field3Counter-Field23Min;
						end
						if mod(Field2Counter,2)>0
							TheFieldSplitBase3(i,sp,ncrack)=2;
							%SplitSourceSplitBase3(i,sp,ncrack)=crack_p_counter;
						elseif mod(Field3Counter,2)>0
							TheFieldSplitBase3(i,sp,ncrack)=3;
							%SplitSourceSplitBase3(i,sp,ncrack)=crack_p_counter;
						end
					end
					% mapping revision done

					% checking if revision is successful
					nodalfieldlist=sort(unique(TheFieldSplitBase3(i,CONNECTpn{i},ncrack)));
					if length(nodalfieldlist)==3
						disp(['fix attempt number ' num2str(fixmode) ' failed']);
						TheFieldSplitBase3=TheFieldSplitBase3_old;
						if fixmode==3
							disp('code 1904172033');
							pause
							1;
						end
					elseif length(nodalfieldlist)==2
						disp(['fix attempt number ' num2str(fixmode) ' successful']);
						break;
					elseif length(nodalfieldlist)==1
						disp(['fix attempt number ' num2str(fixmode) ' broke separation (code 1904172022)']);
						pause
						1;
					end
					% done checking if revision is successful
				end	
			end
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			end
			if newfieldrevision>1
				for nsp=1:length(CONNECTpn{i})
					if TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)==1
						TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)=newfieldrevision;
					end
				end
			end
		end
	end
	for i=1:size(TheFieldSplitBase3,1)
		for sp=1:size(TheFieldSplitBase3,2)
			TheFieldSplit(i,sp)=BaseNtoDec(TheFieldSplitBase3(i,sp,:),1,3);
		end
	end
	%{
	UniqueFields=unique(TheFieldSplit);
	for i=length(UniqueFields):-1:1
		UniqueFieldsInv(UniqueFields(i))=i;
	end
	for i=1:size(TheFieldSplitBase3,1)
		for sp=1:size(TheFieldSplitBase3,2)
			TheFieldSplit(i,sp)=UniqueFieldsInv(TheFieldSplit(i,sp));
			if TheFieldSplit(i,sp)==0
				disp('FieldSplitZero! 1904151633');
			end
		end
	end
	%}
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplitBase3] = SplitFieldMultiOptimized2(LOC,x_sp,CONNECT,CONNECTpn,x_crack,t,le)
	numberofcrackpaths=length(x_crack);
	numberoffields=3^numberofcrackpaths;

	TheFieldSplit=ones(length(CONNECTpn),length(CONNECT));
	TheFieldSplitBase3=ones(length(CONNECTpn),length(CONNECT),numberofcrackpaths);
	%SplitSourceSplitBase3=zeros(length(CONNECTpn),length(CONNECT),numberofcrackpaths);
	
	Area=zeros(4,1);
	lengthCONNECTpn=length(CONNECTpn);
	for sp=length(CONNECT):-1:1;
		LOC_CONNECT{sp}=LOC(CONNECT{sp},:);
	end
	for ncrack=1:numberofcrackpaths %not to get confused with numberofcrackpaths, ncrack is the moving number, from 1 to numberofcrackpaths
		try
			parfor sp=1:length(CONNECT)
				TheFieldSplitBase3(:,sp,ncrack)=SplitFieldMultiOptimized2_parforred(LOC_CONNECT{sp},x_sp(sp,:),CONNECT{sp},lengthCONNECTpn,x_crack{ncrack},t);
			end
		catch
			for sp=1:length(CONNECT)
				TheFieldSplitBase3(:,sp,ncrack)=SplitFieldMultiOptimized2_parforred(LOC_CONNECT{sp},x_sp(sp,:),CONNECT{sp},lengthCONNECTpn,x_crack{ncrack},t);
			end
		end
		
		for i=1:length(CONNECTpn)
			nodalfieldlist=sort(unique(TheFieldSplitBase3(i,CONNECTpn{i},ncrack)));
			newfieldrevision=1;
			if length(nodalfieldlist)==3
				disp('Field split error, applying fix! (code 1904012106)')
				%pause
				1;
				problematicnsp=[];
				for nsp=1:length(CONNECTpn{i})
					if TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)>1
						problematicnsp=[problematicnsp nsp];
					end
                end
				TheFieldSplitBase3_old=TheFieldSplitBase3;
				for fixmode=1:3
					% extending the crack
					%fixmode=1: x_crack{npid}(size(x_crack{npid},1),:) extension by le(1)
					%fixmode=2: x_crack{npid}(0,:) extension by le(1)
					%fixmode=3: both extensions
					if fixmode==1
						x_crack_modified=x_crack{ncrack};
						cracksize=size(x_crack_modified,1);
						trajectory=reliableatan(x_crack{ncrack}(cracksize,1)-x_crack{ncrack}(cracksize-1,1),x_crack{ncrack}(cracksize,2)-x_crack{ncrack}(cracksize-1,2));
						x_crack_modified(cracksize,1)=x_crack{ncrack}(cracksize,1)+le(1)*cos(trajectory);
						x_crack_modified(cracksize,2)=x_crack{ncrack}(cracksize,2)+le(1)*sin(trajectory);
					elseif fixmode==2
						x_crack_modified=x_crack{ncrack};
						cracksize=size(x_crack_modified,1);
						trajectory=reliableatan(x_crack{ncrack}(1,1)-x_crack{ncrack}(2,1),x_crack{ncrack}(1,2)-x_crack{ncrack}(2,2));
						x_crack_modified(1,1)=x_crack{ncrack}(1,1)+le(1)*cos(trajectory);
						x_crack_modified(1,2)=x_crack{ncrack}(1,2)+le(1)*sin(trajectory);
					elseif fixmode==3
						x_crack_modified=x_crack{ncrack};
						cracksize=size(x_crack_modified,1);
						trajectory1=reliableatan(x_crack{ncrack}(cracksize,1)-x_crack{ncrack}(cracksize-1,1),x_crack{ncrack}(cracksize,2)-x_crack{ncrack}(cracksize-1,2));
						x_crack_modified(cracksize,1)=x_crack{ncrack}(cracksize,1)+le(1)*cos(trajectory1);
						x_crack_modified(cracksize,2)=x_crack{ncrack}(cracksize,2)+le(1)*sin(trajectory1);
						trajectory2=reliableatan(x_crack{ncrack}(1,1)-x_crack{ncrack}(2,1),x_crack{ncrack}(1,2)-x_crack{ncrack}(2,2));
						x_crack_modified(1,1)=x_crack{ncrack}(1,1)+le(1)*cos(trajectory2);
						x_crack_modified(1,2)=x_crack{ncrack}(1,2)+le(1)*sin(trajectory2);
					end
					% extending the crack finished
					
					% revising bad mapping
					for nsp=1:length(problematicnsp)
						Field2Counter=0;
						Field3Counter=0;
                        sp=CONNECTpn{i}(problematicnsp(nsp));
                        TheFieldSplitBase3(i,sp,ncrack)=1;
						for crack_p_counter=1:(size(x_crack_modified,1)-1)
							x1=x_sp(sp,:);
							x2=LOC(i,:);
							x3=x_crack_modified(crack_p_counter,:);
							x4=x_crack_modified(crack_p_counter+1,:);
							Area(1)=TriangleArea(x1,x2,x3);
							Area(2)=TriangleArea(x1,x2,x4);
							Area(3)=TriangleArea(x3,x4,x1);
							Area(4)=TriangleArea(x3,x4,x2);
							if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
								Field2Counter=Field2Counter+1;
                                %close gcf;
                                %plot(LOC(i,1),LOC(i,2),'o','DisplayName','Node');
                                %hold on
                                %plot(x_sp(sp,1),x_sp(sp,2),'o','DisplayName','Particle');
                                %plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
                                %plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
                                %daspect([1 1 1]);
                                %legend show
                                %title(['above, particle=' num2str(sp) ', node=' num2str(i)]);
                                %1;
							elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
								Field3Counter=Field3Counter+1;
                                %close gcf;
                                %plot(LOC(i,1),LOC(i,2),'o','DisplayName','Node');
                                %hold on
                                %plot(x_sp(sp,1),x_sp(sp,2),'o','DisplayName','Particle');
                                %plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
                                %plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
                                %daspect([1 1 1]);
                                %legend show
                                %title(['below, particle=' num2str(sp) ', node=' num2str(i)]);
                                %1;
							end
						end
						if Field2Counter>0 && Field3Counter>0
							Field23Min=min([Field2Counter Field3Counter]);
							Field2Counter=Field2Counter-Field23Min;
							Field3Counter=Field3Counter-Field23Min;
						end
						if mod(Field2Counter,2)>0
							TheFieldSplitBase3(i,sp,ncrack)=2;
							%SplitSourceSplitBase3(i,sp,ncrack)=crack_p_counter;
						elseif mod(Field3Counter,2)>0
							TheFieldSplitBase3(i,sp,ncrack)=3;
							%SplitSourceSplitBase3(i,sp,ncrack)=crack_p_counter;
						end
					end
					% mapping revision done

					% checking if revision is successful
					nodalfieldlist=sort(unique(TheFieldSplitBase3(i,CONNECTpn{i},ncrack)));
					if length(nodalfieldlist)==3
						disp(['fix attempt number ' num2str(fixmode) ' failed']);
						TheFieldSplitBase3=TheFieldSplitBase3_old;
						if fixmode==3
							disp('code 1904172033');
							pause
							1;
						end
					elseif length(nodalfieldlist)==2
						disp(['fix attempt number ' num2str(fixmode) ' successful']);
						break;
					elseif length(nodalfieldlist)==1
						disp(['fix attempt number ' num2str(fixmode) ' broke separation (code 1904172022)']);
						pause
						1;
					end
					% done checking if revision is successful
				end	
			end
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			end
			if newfieldrevision>1
				for nsp=1:length(CONNECTpn{i})
					if TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)==1
						TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)=newfieldrevision;
					end
				end
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplitBase3] = SplitFieldMultiOptimized2_parforred(LOC_CONNECT,x_sp,CONNECT,lengthCONNECTpn,x_crack,t)
	TheFieldSplitBase3=ones(lengthCONNECTpn,1,1);
	sp=1;
	for ni=1:length(CONNECT)
		Field2Counter=0;
		Field3Counter=0;
		for crack_p_counter=1:(size(x_crack,1)-1)
			i=CONNECT(ni);
			x1=x_sp(sp,:);
			x2=LOC_CONNECT(ni,:);
			x3=x_crack(crack_p_counter,:);
			x4=x_crack(crack_p_counter+1,:);
			Area(1)=TriangleArea(x1,x2,x3);
			Area(2)=TriangleArea(x1,x2,x4);
			Area(3)=TriangleArea(x3,x4,x1);
			Area(4)=TriangleArea(x3,x4,x2);
			if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
				Field2Counter=Field2Counter+1;
			elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
				Field3Counter=Field3Counter+1;
			end
		end
		if Field2Counter>0 && Field3Counter>0
			Field23Min=min([Field2Counter Field3Counter]);
			Field2Counter=Field2Counter-Field23Min;
			Field3Counter=Field3Counter-Field23Min;
		end
		if mod(Field2Counter,2)>0
			TheFieldSplitBase3(i,1,1)=2;
			%SplitSourceSplitBase3(i,sp,ncrack)=crack_p_counter;
		elseif mod(Field3Counter,2)>0
			TheFieldSplitBase3(i,1,1)=3;
			%SplitSourceSplitBase3(i,sp,ncrack)=crack_p_counter;
		end
	end

end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit,Nmatrix,dNxmatrix,dNymatrix,NmatrixAll] = SplitFieldMulti_crack(LOC,x_sp,CONNECT,CONNECTpn,x_crack,CONNECT_crack,CONNECTpn_crack,Nmatrix,dNxmatrix,dNymatrix,t,currentcrackpathnum,cracktoporbot)
	%fill in cracktoporbot=1 for crack, cracktoporbot=2 for top, and cracktoporbot=3 for bot
	NmatrixAll=Nmatrix;
	numberofcrackpaths=length(x_crack);
	numberoffields=3^numberofcrackpaths;
	if numberoffields>1
        Nmatrix(1,1,numberoffields)=0;
        dNxmatrix(1,1,numberoffields)=0;
        dNymatrix(1,1,numberoffields)=0;
    end
	TheFieldSplit=ones(length(CONNECTpn),length(CONNECT));
	TheFieldSplitBase3=ones(length(CONNECTpn),length(CONNECT),numberofcrackpaths);
	
	%for SuspectedNodeCounter=1:length(CONNECTpn_crack)
	Area=zeros(4,1);
	for ncrack=1:numberofcrackpaths %not to get confused with numberofcrackpaths, ncrack is the moving number, from 1 to numberofcrackpaths
		for sp=1:length(CONNECT)
			for ni=1:length(CONNECT{sp})
				if ncrack==currentcrackpathnum
                    i=CONNECT{sp}(ni);
					TheFieldSplitBase3(i,sp,ncrack)=cracktoporbot;
				else
					Field2Counter=0;
					Field3Counter=0;
					for crack_p_counter=1:(size(x_crack{ncrack},1)-1)
						i=CONNECT{sp}(ni);
						x1=x_sp(sp,:);
						x2=LOC(i,:);
						x3=x_crack{ncrack}(crack_p_counter,:);
						x4=x_crack{ncrack}(crack_p_counter+1,:);
						Area(1)=TriangleArea(x1,x2,x3);
						Area(2)=TriangleArea(x1,x2,x4);
						Area(3)=TriangleArea(x3,x4,x1);
						Area(4)=TriangleArea(x3,x4,x2);
						if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
							Field2Counter=Field2Counter+1;
						elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
							%{
							if sp==220 && ni==8 && CloseEnough(x1(1),58.740308582876274101636226987466)
								1;
								plot(x1(1),x1(2),'o','DisplayName','particle')
								hold on
								plot(x2(1),x2(2),'o','DisplayName','node')
								plot(x3(1),x3(2),'o','DisplayName','crackbefore')
								plot(x4(1),x4(2),'o','DisplayName','crackafter')
								legend show
								hold off
								1;
							end
							%}
							Field3Counter=Field3Counter+1;
						end
					end
					if Field2Counter>0 && Field3Counter>0
						%{
						try
							asdf(-pi);
						catch exc
							disp('Field Split Error!');
							getReport(exc,'extended');
							pause;
							1;
						end
						%}
						1;
						Field23Min=min([Field2Counter Field3Counter]);
						Field2Counter=Field2Counter-Field23Min;
						Field3Counter=Field3Counter-Field23Min;
						1;
					end
					if mod(Field2Counter,2)>0
					%{
						TheFieldSplit(i,sp)=2*ncrack;
						Nmatrix(i,sp,2*ncrack)=Nmatrix(i,sp,1);
						Nmatrix(i,sp,1)=0;
						dNxmatrix(i,sp,2*ncrack)=dNxmatrix(i,sp,1);
						dNxmatrix(i,sp,1)=0;
						dNymatrix(i,sp,2*ncrack)=dNymatrix(i,sp,1);
						dNymatrix(i,sp,1)=0;
					%}
						TheFieldSplitBase3(i,sp,ncrack)=2;
					elseif mod(Field3Counter,2)>0
					%{
						TheFieldSplit(i,sp)=2*ncrack+1;
						Nmatrix(i,sp,2*ncrack+1)=Nmatrix(i,sp,1);
						Nmatrix(i,sp,1)=0;
						dNxmatrix(i,sp,2*ncrack+1)=dNxmatrix(i,sp,1);
						dNxmatrix(i,sp,1)=0;
						dNymatrix(i,sp,2*ncrack+1)=dNymatrix(i,sp,1);
						dNymatrix(i,sp,1)=0;
					%}
						TheFieldSplitBase3(i,sp,ncrack)=3;
					end
				end
			end
		end
		
		for i=1:length(CONNECTpn)
			nodalfieldlist=sort(unique(TheFieldSplitBase3(i,CONNECTpn{i},ncrack)));
			newfieldrevision=1;
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			elseif length(nodalfieldlist)==3
				disp('Field split error! (code 1904012104)')
				pause
				1;
			end
			if newfieldrevision>1
				for nsp=1:length(CONNECTpn{i})
					if TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)==1
						TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)=newfieldrevision;
					end
				end
			end
		end

		%{
		for i=1:length(CONNECTpn)
			nodalfieldlist=sort(unique(TheFieldSplit(i,:)));
			newfieldrevision=1;
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			elseif length(nodalfieldlist)==3
				disp('Field split error, ignoring')
				%pause
				1;
			end
			if newfieldrevision>1
				for sp=1:length(CONNECT)
					if TheFieldSplit(i,sp)==1
						TheFieldSplit(i,sp)=newfieldrevision;
						Nmatrix(i,sp,newfieldrevision)=Nmatrix(i,sp,1);
						Nmatrix(i,sp,1)=0;
						dNxmatrix(i,sp,newfieldrevision)=dNxmatrix(i,sp,1);
						dNxmatrix(i,sp,1)=0;
						dNymatrix(i,sp,newfieldrevision)=dNymatrix(i,sp,1);
						dNymatrix(i,sp,1)=0;
					end
				end
			end
		end
		%}
	end
	for i=1:size(TheFieldSplitBase3,1)
		for sp=1:size(TheFieldSplitBase3,2)
			TheFieldSplit(i,sp)=BaseNtoDec(TheFieldSplitBase3(i,sp,:),1,3);
		end
	end
	for i=1:size(TheFieldSplit,1)
		for sp=1:size(TheFieldSplit,2)
			if TheFieldSplit(i,sp)==1
			else
				if TheFieldSplit(i,sp)==9
					1;
				end
				Nmatrix(i,sp,TheFieldSplit(i,sp))=Nmatrix(i,sp,1);
				Nmatrix(i,sp,1)=0;
				
				dNxmatrix(i,sp,TheFieldSplit(i,sp))=dNxmatrix(i,sp,1);
				dNxmatrix(i,sp,1)=0;
				
				dNymatrix(i,sp,TheFieldSplit(i,sp))=dNymatrix(i,sp,1);
				dNymatrix(i,sp,1)=0;
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit] = SplitFieldMulti_crackoptimized(LOC,x_sp,CONNECT,CONNECTpn,x_crack,currentcrackpathnum,cracktoporbot)
	%fill in cracktoporbot=1 for crack, cracktoporbot=2 for top, and cracktoporbot=3 for bot
	
	numberofcrackpaths=length(x_crack);
	numberoffields=3^numberofcrackpaths;
	
	TheFieldSplit=ones(length(CONNECTpn),length(CONNECT));
	TheFieldSplitBase3=ones(length(CONNECTpn),length(CONNECT),numberofcrackpaths);
	
	Area=zeros(4,1);
	for ncrack=1:numberofcrackpaths %not to get confused with numberofcrackpaths, ncrack is the moving number, from 1 to numberofcrackpaths
		for sp=1:length(CONNECT)
			for ni=1:length(CONNECT{sp})
				if ncrack==currentcrackpathnum
                    i=CONNECT{sp}(ni);
					TheFieldSplitBase3(i,sp,ncrack)=cracktoporbot;
				else
					Field2Counter=0;
					Field3Counter=0;
					for crack_p_counter=1:(size(x_crack{ncrack},1)-1)
						i=CONNECT{sp}(ni);
						x1=x_sp(sp,:);
						x2=LOC(i,:);
						x3=x_crack{ncrack}(crack_p_counter,:);
						x4=x_crack{ncrack}(crack_p_counter+1,:);
						Area(1)=TriangleArea(x1,x2,x3);
						Area(2)=TriangleArea(x1,x2,x4);
						Area(3)=TriangleArea(x3,x4,x1);
						Area(4)=TriangleArea(x3,x4,x2);
						if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
							Field2Counter=Field2Counter+1;
						elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
							Field3Counter=Field3Counter+1;
						end
					end
					if Field2Counter>0 && Field3Counter>0
						1;
						Field23Min=min([Field2Counter Field3Counter]);
						Field2Counter=Field2Counter-Field23Min;
						Field3Counter=Field3Counter-Field23Min;
						1;
					end
					if mod(Field2Counter,2)>0
						TheFieldSplitBase3(i,sp,ncrack)=2;
					elseif mod(Field3Counter,2)>0
						TheFieldSplitBase3(i,sp,ncrack)=3;
					end
				end
			end
		end
		
		for i=1:length(CONNECTpn)
			nodalfieldlist=sort(unique(TheFieldSplitBase3(i,CONNECTpn{i},ncrack)));
			newfieldrevision=1;
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			elseif length(nodalfieldlist)==3
				disp('Field split error! (code 1904012105)')
				pause
				1;
			end
			if newfieldrevision>1
				for nsp=1:length(CONNECTpn{i})
					if TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)==1
						TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)=newfieldrevision;
					end
				end
			end
		end
	end
	for i=1:size(TheFieldSplitBase3,1)
		for sp=1:size(TheFieldSplitBase3,2)
			TheFieldSplit(i,sp)=BaseNtoDec(TheFieldSplitBase3(i,sp,:),1,3);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplitBase3] = SplitFieldMulti_crackoptimized2(LOC,x_sp,CONNECT,CONNECTpn,x_crack,currentcrackpathnum,cracktoporbot,le)
	%fill in cracktoporbot=1 for crack, cracktoporbot=2 for top, and cracktoporbot=3 for bot
	
	numberofcrackpaths=length(x_crack);
	numberoffields=3^numberofcrackpaths;
	
	TheFieldSplit=ones(length(CONNECTpn),length(CONNECT));
	TheFieldSplitBase3=ones(length(CONNECTpn),length(CONNECT),numberofcrackpaths);
	
	Area=zeros(4,1);
	for ncrack=1:numberofcrackpaths %not to get confused with numberofcrackpaths, ncrack is the moving number, from 1 to numberofcrackpaths
		for sp=1:length(CONNECT)
			for ni=1:length(CONNECT{sp})
				if ncrack==currentcrackpathnum
                    i=CONNECT{sp}(ni);
					TheFieldSplitBase3(i,sp,ncrack)=cracktoporbot;
				else
					Field2Counter=0;
					Field3Counter=0;
					for crack_p_counter=1:(size(x_crack{ncrack},1)-1)
						i=CONNECT{sp}(ni);
						x1=x_sp(sp,:);
						x2=LOC(i,:);
						x3=x_crack{ncrack}(crack_p_counter,:);
						x4=x_crack{ncrack}(crack_p_counter+1,:);
						Area(1)=TriangleArea(x1,x2,x3);
						Area(2)=TriangleArea(x1,x2,x4);
						Area(3)=TriangleArea(x3,x4,x1);
						Area(4)=TriangleArea(x3,x4,x2);
						if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
							Field2Counter=Field2Counter+1;
						elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
							Field3Counter=Field3Counter+1;
						end
					end
					if Field2Counter>0 && Field3Counter>0
						1;
						Field23Min=min([Field2Counter Field3Counter]);
						Field2Counter=Field2Counter-Field23Min;
						Field3Counter=Field3Counter-Field23Min;
						1;
					end
					if mod(Field2Counter,2)>0
						TheFieldSplitBase3(i,sp,ncrack)=2;
					elseif mod(Field3Counter,2)>0
						TheFieldSplitBase3(i,sp,ncrack)=3;
					end
				end
			end
		end
		
		for i=1:length(CONNECTpn)
			nodalfieldlist=sort(unique(TheFieldSplitBase3(i,CONNECTpn{i},ncrack)));
			newfieldrevision=1;
			if length(nodalfieldlist)==3
				disp('Field split error, applying fix! (code 1904012106)')
				%pause
				1;
				problematicnsp=[];
				for nsp=1:length(CONNECTpn{i})
					if TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)>1
						problematicnsp=[problematicnsp nsp];
					end
                end
				TheFieldSplitBase3_old=TheFieldSplitBase3;
				for fixmode=1:3
					% extending the crack
					%fixmode=1: x_crack{npid}(size(x_crack{npid},1),:) extension by le(1)
					%fixmode=2: x_crack{npid}(0,:) extension by le(1)
					%fixmode=3: both extensions
					if fixmode==1
						x_crack_modified=x_crack{ncrack};
						cracksize=size(x_crack_modified,1);
						trajectory=reliableatan(x_crack{ncrack}(cracksize,1)-x_crack{ncrack}(cracksize-1,1),x_crack{ncrack}(cracksize,2)-x_crack{ncrack}(cracksize-1,2));
						x_crack_modified(cracksize,1)=x_crack{ncrack}(cracksize,1)+le(1)*cos(trajectory);
						x_crack_modified(cracksize,2)=x_crack{ncrack}(cracksize,2)+le(1)*sin(trajectory);
					elseif fixmode==2
						x_crack_modified=x_crack{ncrack};
						cracksize=size(x_crack_modified,1);
						trajectory=reliableatan(x_crack{ncrack}(1,1)-x_crack{ncrack}(2,1),x_crack{ncrack}(1,2)-x_crack{ncrack}(2,2));
						x_crack_modified(1,1)=x_crack{ncrack}(1,1)+le(1)*cos(trajectory);
						x_crack_modified(1,2)=x_crack{ncrack}(1,2)+le(1)*sin(trajectory);
					elseif fixmode==3
						x_crack_modified=x_crack{ncrack};
						cracksize=size(x_crack_modified,1);
						trajectory1=reliableatan(x_crack{ncrack}(cracksize,1)-x_crack{ncrack}(cracksize-1,1),x_crack{ncrack}(cracksize,2)-x_crack{ncrack}(cracksize-1,2));
						x_crack_modified(cracksize,1)=x_crack{ncrack}(cracksize,1)+le(1)*cos(trajectory1);
						x_crack_modified(cracksize,2)=x_crack{ncrack}(cracksize,2)+le(1)*sin(trajectory1);
						trajectory2=reliableatan(x_crack{ncrack}(1,1)-x_crack{ncrack}(2,1),x_crack{ncrack}(1,2)-x_crack{ncrack}(2,2));
						x_crack_modified(1,1)=x_crack{ncrack}(1,1)+le(1)*cos(trajectory2);
						x_crack_modified(1,2)=x_crack{ncrack}(1,2)+le(1)*sin(trajectory2);
					end
					% extending the crack finished
					
					% revising bad mapping
					for nsp=1:length(problematicnsp)
						Field2Counter=0;
						Field3Counter=0;
                        sp=CONNECTpn{i}(problematicnsp(nsp));
                        TheFieldSplitBase3(i,sp,ncrack)=1;
						for crack_p_counter=1:(size(x_crack_modified,1)-1)
							x1=x_sp(sp,:);
							x2=LOC(i,:);
							x3=x_crack_modified(crack_p_counter,:);
							x4=x_crack_modified(crack_p_counter+1,:);
							Area(1)=TriangleArea(x1,x2,x3);
							Area(2)=TriangleArea(x1,x2,x4);
							Area(3)=TriangleArea(x3,x4,x1);
							Area(4)=TriangleArea(x3,x4,x2);
							if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
								Field2Counter=Field2Counter+1;
                                %close gcf;
                                %plot(LOC(i,1),LOC(i,2),'o','DisplayName','Node');
                                %hold on
                                %plot(x_sp(sp,1),x_sp(sp,2),'o','DisplayName','Particle');
                                %plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
                                %plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
                                %daspect([1 1 1]);
                                %legend show
                                %title(['above, particle=' num2str(sp) ', node=' num2str(i)]);
                                %1;
							elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
								Field3Counter=Field3Counter+1;
                                %close gcf;
                                %plot(LOC(i,1),LOC(i,2),'o','DisplayName','Node');
                                %hold on
                                %plot(x_sp(sp,1),x_sp(sp,2),'o','DisplayName','Particle');
                                %plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
                                %plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
                                %daspect([1 1 1]);
                                %legend show
                                %title(['below, particle=' num2str(sp) ', node=' num2str(i)]);
                                %1;
							end
						end
						if Field2Counter>0 && Field3Counter>0
							Field23Min=min([Field2Counter Field3Counter]);
							Field2Counter=Field2Counter-Field23Min;
							Field3Counter=Field3Counter-Field23Min;
						end
						if mod(Field2Counter,2)>0
							TheFieldSplitBase3(i,sp,ncrack)=2;
							%SplitSourceSplitBase3(i,sp,ncrack)=crack_p_counter;
						elseif mod(Field3Counter,2)>0
							TheFieldSplitBase3(i,sp,ncrack)=3;
							%SplitSourceSplitBase3(i,sp,ncrack)=crack_p_counter;
						end
					end
					% mapping revision done

					% checking if revision is successful
					nodalfieldlist=sort(unique(TheFieldSplitBase3(i,CONNECTpn{i},ncrack)));
					if length(nodalfieldlist)==3
						disp(['fix attempt number ' num2str(fixmode) ' failed']);
						TheFieldSplitBase3=TheFieldSplitBase3_old;
						if fixmode==3
							disp('code 1904172033');
							pause
							1;
						end
					elseif length(nodalfieldlist)==2
						disp(['fix attempt number ' num2str(fixmode) ' successful']);
						break;
					elseif length(nodalfieldlist)==1
						disp(['fix attempt number ' num2str(fixmode) ' broke separation (code 1904172022)']);
						pause
						1;
					end
					% done checking if revision is successful
				end	
			end
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			end
			if newfieldrevision>1
				for nsp=1:length(CONNECTpn{i})
					if TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)==1
						TheFieldSplitBase3(i,CONNECTpn{i}(nsp),ncrack)=newfieldrevision;
					end
				end
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function DecOut=BaseNtoDec(inputarray,startnum,endnum)
    DecOut=startnum;
    inputarraylength=length(inputarray);
    for i=inputarraylength:-1:1
        DecOut=DecOut+(inputarray(i)-startnum)*(endnum+1-startnum)^(inputarraylength-i);
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [CrossDir,RelativeLocation]=FindCrossing(x1,x2,x3,x4)
	%CrossDir=0:no crossing; 1:cross from above; 2:cross from below
	CrossDir=0;
	RelativeLocation=0;
	Area(1)=TriangleArea(x1,x2,x3);
	Area(2)=TriangleArea(x1,x2,x4);
	Area(3)=TriangleArea(x3,x4,x1);
	Area(4)=TriangleArea(x3,x4,x2);
	if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
		CrossDir=1;
		RelativeLocation=Area(3)/(Area(3)-Area(4));
	elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
		CrossDir=2;
		RelativeLocation=Area(3)/(Area(3)-Area(4));
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function Area = TriangleArea(x1,x2,x3)
	Area=x1(1)*(x2(2)-x3(2))+x2(1)*(x3(2)-x1(2))+x3(1)*(x1(2)-x2(2));
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [nmass_si,nmomentum_si,niforce_si,neforce_si,traction_si,pforce_si,ncforce_si,L_si]=Interpolate_Particle_To_Grid_WithPredeterminedVelocity2(NODES,nodeCount,CONNECT,le,N,dN,spCount,b_sp,A_sp,t_sp,ptraction_sp,v_ssp,s_sp,m_sp,pforce_sp,Nmatrix,dNxmatrix,dNymatrix,ncforce_cracktop,ncforce_crackbot,Nmatrix_cracktop,Nmatrix_crackbot,TheFieldSplit,CasetoRun)
	%% Interpolation from particle to grid task
	% Node variables
	fieldnumber=size(Nmatrix,3);
	for field=fieldnumber:-1:1
		nmass_si(:,field)                = Nmatrix(:,:,field)*m_sp;                         % Nodal Mass
		nmomentum_si(:,1,field)       = Nmatrix(:,:,field)*(m_sp.*v_ssp(:,1));           % Nodal Momentum in X direction
		nmomentum_si(:,2,field)       = Nmatrix(:,:,field)*(m_sp.*v_ssp(:,2));           % Nodal Momentum in Y direction
	end
	niforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal Internal force
	neforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal External force
	traction_si             = zeros(nodeCount,2,fieldnumber);                   % Nodal Traction
	pforce_si               = zeros(nodeCount,2,fieldnumber);                   % Nodal Extra Particle force
	L_si                    = zeros(nodeCount,2,2,fieldnumber);
	pforce_si               = zeros(nodeCount,2,fieldnumber);                   % Nodal traction
	SSPtophalf_sp           = zeros(spCount,2);
	SSPbothalf_sp           = zeros(spCount,2);

	ncforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal crack force

	if CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 %multicrack nodal force deactivated for now
	else
		ncforce_si(:,:,2)    = Nmatrix_cracktop*ncforce_cracktop;
		ncforce_si(:,:,3)    = Nmatrix_crackbot*ncforce_crackbot;
	end

	%{
	ncforce_si(:,1,2)    = Nmatrix_cracktop*ncforce_cracktop(:,1);
	ncforce_si(:,2,2)    = Nmatrix_cracktop*ncforce_cracktop(:,2);
	ncforce_si(:,1,3)    = Nmatrix_crackbot*ncforce_crackbot(:,1);
	ncforce_si(:,2,3)    = Nmatrix_crackbot*ncforce_crackbot(:,2);
	%}

	for i=1:nodeCount
		if unique(TheFieldSplit(i,:))==1
			ncforce_si(i,:,1)=ncforce_si(i,:,2)+ncforce_si(i,:,3);
			ncforce_si(i,:,2)=[0 0];
			ncforce_si(i,:,3)=[0 0];
		end
	end

	for sp=1:spCount %originally parfor
		SSPtophalf_sp(sp,:)=[s_sp(sp,1) s_sp(sp,3)];
		SSPbothalf_sp(sp,:)=[s_sp(sp,3) s_sp(sp,2)];
	end

	for field=1:fieldnumber
		niforce_si(:,1,field)        = -((dNxmatrix(:,:,field)*(A_sp.*t_sp.*SSPtophalf_sp(:,1)))+(dNymatrix(:,:,field)*(A_sp.*t_sp.*SSPtophalf_sp(:,2)))) ;%- 0.07*v_ssp(sp,:); %damping
		niforce_si(:,2,field)        = -((dNxmatrix(:,:,field)*(A_sp.*t_sp.*SSPbothalf_sp(:,1)))+(dNymatrix(:,:,field)*(A_sp.*t_sp.*SSPbothalf_sp(:,2)))) ;%- 0.07*v_ssp(sp,:); %damping
	end

	for field=1:fieldnumber
		L_si(:,1,1,field)=dNxmatrix(:,:,field)*v_ssp(:,1);
		L_si(:,1,2,field)=dNymatrix(:,:,field)*v_ssp(:,1);
		L_si(:,2,1,field)=dNxmatrix(:,:,field)*v_ssp(:,2);
		L_si(:,2,2,field)=dNymatrix(:,:,field)*v_ssp(:,2);

		neforce_si(:,1,field)         = Nmatrix(:,:,field)*((ones(spCount,1)*b_sp(1)).*m_sp);
		neforce_si(:,2,field)         = Nmatrix(:,:,field)*((ones(spCount,1)*b_sp(2)).*m_sp);
		pforce_si(:,1,field)       = Nmatrix(:,:,field)*pforce_sp(:,1);
		pforce_si(:,2,field)       = Nmatrix(:,:,field)*pforce_sp(:,2);

		traction_si(:,1,field)       = Nmatrix(:,:,field)*(A_sp.*t_sp.*ptraction_sp(:,1)/le(2));
		traction_si(:,2,field)       = Nmatrix(:,:,field)*(A_sp.*t_sp.*ptraction_sp(:,2)/le(1)); 

	end

	%{
	 for sp=1:spCount
	 % Build stress tensor
	 %SSP = [s_sp(sp,1) s_sp(sp,3);s_sp(sp,3) s_sp(sp,2)];
	 
	 for j=1:NODES(sp)
		 npid                           = CONNECT{sp}(j);
		 
			  if N{sp}(j)==0
			 continue
			  end
		 
	 % Mass bn m 
	 %nmass_si(npid)            = nmass_si(npid) + m_sp(sp)*N{sp}(j);
	 
	 % Momentumlp(1,1)lp(1,1)lp(1,1)
	 %nmomentum_si(npid,:)      = nmomentum_si(npid,:) + m_sp(sp)*v_ssp(sp,:)*N{sp}(j);
	 
	 % Internal forces
	 %niforce_si(npid,:)        = niforce_si(npid,:) - (A_sp(sp)*t_sp(sp)*SSP*dN{sp}(:,j))' ;%- 0.07*v_ssp(sp,:); %damping
	%{
	 if niforce_si(npid,1)~=0
		 disp(['niforce_si(' num2str(npid) ',:)=[' num2str(niforce_si(npid,1)) ',' num2str(niforce_si(npid,2)) '];sp=' num2str(sp) ';npid=' num2str(npid) ';N{' num2str(sp) '}(j)=' num2str(N{sp}(j)) ';A_sp(' num2str(sp) ')=' num2str(A_sp(sp)) ';SSP=[' num2str(SSP(1,1)) ' ' num2str(SSP(1,2)) ';' num2str(SSP(2,1)) ' ' num2str(SSP(2,2)) '];dN{' num2str(sp) '}(:,' num2str(j) ')=[' num2str(dN{sp}(1,j)) ' ' num2str(dN{sp}(2,j)) ']']);
		 dummy=sum(niforce_si);
		 disp(['sum(niforce_si)=[' num2str(dummy(1)) ',' num2str(dummy(2)) '];']); 
		 1;
	 end
	%}
	%for p=1:2
	%    for q=1:2
	%        L_si(npid,p,q)=L_si(npid,p,q)+v_ssp(sp,p)*dN{sp}(q,j);
	%    end
	%end
	 % External forces
	%neforce_si(npid,:)         = neforce_si(npid,:) + b_sp*m_sp(sp)*N{sp}(j);

	 % Extra particle forces
	%pforce_si(npid,:)          = pforce_si(npid,:) + pforce_sp(sp,:)*N{sp}(j);

	% Traction
	%  traction_si(npid,:)       = traction_si(npid,:) + A_sp(sp)*ptraction_sp(sp,:)*N{sp}(j)/le(1,1)/le(1,2);
	 %traction_si(npid,1)       = traction_si(npid,1) + A_sp(sp)*t_sp(sp)*ptraction_sp(sp,1)*N{sp}(j)/le(2);
	 %traction_si(npid,2)       = traction_si(npid,2) + A_sp(sp)*t_sp(sp)*ptraction_sp(sp,2)*N{sp}(j)/le(1); 
	 end 
	 end
	%}
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [nmass_si,nmomentum_si,niforce_si,neforce_si,traction_si,pforce_si,ncforce_si,L_si]=Interpolate_Particle_To_Grid_WithPredeterminedVelocity2_optimized(NODES,nodeCount,CONNECT,le,N,dN,spCount,b_sp,A_sp,t_sp,ptraction_sp,v_ssp,s_sp,m_sp,pforce_sp,TheFieldSplit,CasetoRun,fieldnumber)
	%% Interpolation from particle to grid task
	% Node variables

	niforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal Internal force
	neforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal External force
	traction_si             = zeros(nodeCount,2,fieldnumber);                   % Nodal Traction
	pforce_si               = zeros(nodeCount,2,fieldnumber);                   % Nodal Extra Particle force
	L_si                    = zeros(nodeCount,2,2,fieldnumber);
	pforce_si               = zeros(nodeCount,2,fieldnumber);                   % Nodal traction
	ncforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal crack force
    nmass_si                = zeros(nodeCount,fieldnumber);
    nmomentum_si            = zeros(nodeCount,2,fieldnumber);

	for sp=1:spCount
		% Build stress tensor
		SSP = [s_sp(sp,1) s_sp(sp,3);s_sp(sp,3) s_sp(sp,2)];

		for j=1:NODES(sp)
			npid                           = CONNECT{sp}(j);

			if N{sp}(j)==0
				continue
			end

			% Mass bn m 
			nmass_si(npid,TheFieldSplit(npid,sp))            = nmass_si(npid,TheFieldSplit(npid,sp)) + m_sp(sp)*N{sp}(j);

			% Momentumlp(1,1)lp(1,1)lp(1,1)
			nmomentum_si(npid,:,TheFieldSplit(npid,sp))      = nmomentum_si(npid,:,TheFieldSplit(npid,sp)) + m_sp(sp)*v_ssp(sp,:)*N{sp}(j);

			% Internal forces
			niforce_si(npid,:,TheFieldSplit(npid,sp))        = niforce_si(npid,:,TheFieldSplit(npid,sp)) - (A_sp(sp)*t_sp(sp)*SSP*dN{sp}(:,j))' ;%- 0.07*v_ssp(sp,:); %damping
			for p=1:2
				for q=1:2
					L_si(npid,p,q,TheFieldSplit(npid,sp))=L_si(npid,p,q,TheFieldSplit(npid,sp))+v_ssp(sp,p)*dN{sp}(q,j);
				end
			end
			% External forces
			neforce_si(npid,:,TheFieldSplit(npid,sp))         = neforce_si(npid,:,TheFieldSplit(npid,sp)) + b_sp*m_sp(sp)*N{sp}(j);

			% Extra particle forces
			pforce_si(npid,:,TheFieldSplit(npid,sp))          = pforce_si(npid,:,TheFieldSplit(npid,sp)) + pforce_sp(sp,:)*N{sp}(j);

			% Traction
			%traction_si(npid,:)       = traction_si(npid,:) + A_sp(sp)*ptraction_sp(sp,:)*N{sp}(j)/le(1,1)/le(1,2);
			traction_si(npid,1,TheFieldSplit(npid,sp))       = traction_si(npid,1,TheFieldSplit(npid,sp)) + A_sp(sp)*t_sp(sp)*ptraction_sp(sp,1)*N{sp}(j)/le(2);
			traction_si(npid,2,TheFieldSplit(npid,sp))       = traction_si(npid,2,TheFieldSplit(npid,sp)) + A_sp(sp)*t_sp(sp)*ptraction_sp(sp,2)*N{sp}(j)/le(1); 
		end 
	end


end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix] = Compute_Interpolator_CPDI_var(spCount,cellCount,x_sp,le_c,NN,LOC,r1_sp,r2_sp,A_sp,LOCX,LOCY)

    spElems        = zeros(spCount,1);
    N{spCount}       = [];
    dN{spCount}      = [];
    CONNECT{spCount} = [];
    siCount=NN(1)*NN(2);
    Nmatrix=zeros(siCount,spCount);
    dNxmatrix=zeros(siCount,spCount);
    dNymatrix=zeros(siCount,spCount);

 try
     parfor sp=1:spCount
        [N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow,dNxmatrixrow,dNymatrixrow] = ...
            Compute_Interpolator_CPDI_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
        Nmatrix(:,sp)=Nmatrixrow;
        dNxmatrix(:,sp)=dNxmatrixrow;
        dNymatrix(:,sp)=dNymatrixrow;
     end
 catch
     disp('parforred Compute_Interpolator_CPDI_parforred failed, switching to regular for!');
     for sp=1:spCount
        [N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow,dNxmatrixrow,dNymatrixrow] = ...
            Compute_Interpolator_CPDI_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
        Nmatrix(:,sp)=Nmatrixrow;
        dNxmatrix(:,sp)=dNxmatrixrow;
        dNymatrix(:,sp)=dNymatrixrow;
     end
 end


    for c =1:cellCount
        id_sp = find(spElems==c);
        mspoints{c}=id_sp;
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,NODES,Nmatrixrow,dNxmatrixrow,dNymatrixrow] = ...
    Compute_Interpolator_CPDI_parforred_var(x_sp,le_c,LOC,r1_sp,r2_sp,A_sp,siCount,LOCX,LOCY)

    CONNECT_TEMP   = zeros(1,16);
    spElems_corner = zeros(1,4);
    x_corner{4}      = zeros(1,2);
    x_corner{3}      = zeros(1,2);
    x_corner{2}      = zeros(1,2);
    x_corner{1}      = zeros(1,2);
    Nmatrixrow     = zeros(siCount,1);
    dNxmatrixrow   = zeros(siCount,1);
    dNymatrixrow   = zeros(siCount,1);


    x_corner{1}(1,:) = x_sp(1,:) - r1_sp(1,:) - r2_sp(1,:);      % Position of corner 1
    x_corner{2}(1,:) = x_sp(1,:) + r1_sp(1,:) - r2_sp(1,:);
    x_corner{3}(1,:) = x_sp(1,:) + r1_sp(1,:) + r2_sp(1,:);
    x_corner{4}(1,:) = x_sp(1,:) - r1_sp(1,:) + r2_sp(1,:);

    %spElems(1) = ceil(x_sp(1,1)/le(1))+(NN(1)-1)*(fix(x_sp(1,2)/le(2)));   % compute vector store index elements                           
    
    spElems=identifycellsandnodes(x_sp,LOCX,LOCY,[],[],[1 0 0 0]);

    %spElems_corner(1,1) = ceil(x_corner{1}(1,1)/le(1))+(NN(1)-1)*(fix(x_corner{1}(1,2)/le(2)));                        
    %spElems_corner(1,2) = ceil(x_corner{2}(1,1)/le(1))+(NN(1)-1)*(fix(x_corner{2}(1,2)/le(2)));                        
    %spElems_corner(1,3) = ceil(x_corner{3}(1,1)/le(1))+(NN(1)-1)*(fix(x_corner{3}(1,2)/le(2)));
    %spElems_corner(1,4) = ceil(x_corner{4}(1,1)/le(1))+(NN(1)-1)*(fix(x_corner{4}(1,2)/le(2)));

    for i=1:4
        [spElems_corner(1,i), CONNECT_TEMP(1,((i-1)*4+1):(i*4))] = identifycellsandnodes(x_corner{i},LOCX,LOCY,[],[],[1 1 0 0]);
    end
    
    CONNECT=unique(CONNECT_TEMP(1,:));    % Store nodes interacting with corners
    NODES(1)=length(CONNECT);         % Store number of interacting nodes

    N1 = zeros(1,NODES(1));   % Shape function of corner 1 for 16 nodes
    N2 = zeros(1,NODES(1));
    N3 = zeros(1,NODES(1));
    N4 = zeros(1,NODES(1));
    N_local = zeros(1,NODES(1));

    for i=1:NODES(1)
        [N1(i),~,~] = linearshape(x_corner{1}(1,:),LOC(CONNECT(i),:),le_c(spElems_corner(1,1),1),le_c(spElems_corner(1,1),2));
        [N2(i),~,~] = linearshape(x_corner{2}(1,:),LOC(CONNECT(i),:),le_c(spElems_corner(1,2),1),le_c(spElems_corner(1,2),2));
        [N3(i),~,~] = linearshape(x_corner{3}(1,:),LOC(CONNECT(i),:),le_c(spElems_corner(1,3),1),le_c(spElems_corner(1,3),2));
        [N4(i),~,~] = linearshape(x_corner{4}(1,:),LOC(CONNECT(i),:),le_c(spElems_corner(1,4),1),le_c(spElems_corner(1,4),2));
        N_local(i)  = 0.25*(N1(i)+N2(i)+N3(i)+N4(i));
    end

    N = N_local;

    % Build matrix of gradient of shape function 
    w1 = [r1_sp(1,2)-r2_sp(1,2) r2_sp(1,1)-r1_sp(1,1)];
    w2 = [r1_sp(1,2)+r2_sp(1,2) -r2_sp(1,1)-r1_sp(1,1)];

    for i=1:NODES(1)      
        dN(1,i)     = 1/A_sp(1)*((N1(i)-N3(i))*w1(1) + (N2(i)-N4(i))*w2(1));
        dN(2,i)     = 1/A_sp(1)*((N1(i)-N3(i))*w1(2) + (N2(i)-N4(i))*w2(2));
    end

    for i=1:NODES(1)
        Nmatrixrow(CONNECT(i),1)=N(i);
        dNxmatrixrow(CONNECT(i),1)=dN(1,i);
        dNymatrixrow(CONNECT(i),1)=dN(2,i);
    end
 

end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix,CONNECTpn] = Compute_Interpolator_CPDI(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp)
    spElems        = zeros(spCount,1);
    N{spCount}       = [];
    dN{spCount}      = [];
    CONNECT{spCount} = [];
    siCount=NN(1)*NN(2);
    CONNECTpn{siCount}=[];
    Nmatrix=zeros(siCount,spCount);
    dNxmatrix=zeros(siCount,spCount);
    dNymatrix=zeros(siCount,spCount);

    try
        parfor sp=1:spCount
            [N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow,dNxmatrixrow,dNymatrixrow] = ...
                Compute_Interpolator_CPDI_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
            Nmatrix(:,sp)=Nmatrixrow;
            dNxmatrix(:,sp)=dNxmatrixrow;
            dNymatrix(:,sp)=dNymatrixrow;
        end
    catch
        disp('parfor failed inside Compute_Interpolator_CPID, switching to regular for');
        for sp=1:spCount
            [N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow,dNxmatrixrow,dNymatrixrow] = ...
                Compute_Interpolator_CPDI_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
            Nmatrix(:,sp)=Nmatrixrow;
            dNxmatrix(:,sp)=dNxmatrixrow;
            dNymatrix(:,sp)=dNymatrixrow;
        end
    end
    for sp=1:spCount
        for i=1:length(CONNECT{sp})
            CONNECTpn{CONNECT{sp}(i)}=[CONNECTpn{CONNECT{sp}(i)} sp];
        end
    end


    for c =1:cellCount
        id_sp = find(spElems==c);
        mspoints{c}=id_sp;
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,CONNECTpn] = Compute_Interpolator_CPDI_optimized(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp)
    spElems        = zeros(spCount,1);
    N{spCount}       = [];
    dN{spCount}      = [];
    CONNECT{spCount} = [];
    siCount=NN(1)*NN(2);
    CONNECTpn{siCount}=[];
    Nmatrix=zeros(siCount,spCount);

    try
        parfor sp=1:spCount
            [N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow] = ...
                Compute_Interpolator_CPDI_parforred_optimized(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
            Nmatrix(:,sp)=Nmatrixrow;
        end
    catch
        disp('parfor failed inside Compute_Interpolator_CPID, switching to regular for');
        for sp=1:spCount
            [N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow] = ...
                Compute_Interpolator_CPDI_parforred_optimized(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
            Nmatrix(:,sp)=Nmatrixrow;
        end
    end
    for sp=1:spCount
        for i=1:length(CONNECT{sp})
            CONNECTpn{CONNECT{sp}(i)}=[CONNECTpn{CONNECT{sp}(i)} sp];
        end
    end


    for c =1:cellCount
        id_sp = find(spElems==c);
        mspoints{c}=id_sp;
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,NODES,Nmatrixrow,dNxmatrixrow,dNymatrixrow] = ...
    Compute_Interpolator_CPDI_parforred(x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,siCount)
 
    CONNECT_TEMP   = zeros(1,16);
    spElems_corner = zeros(1,4);
    x_corner1      = zeros(1,2);
    x_corner2      = zeros(1,2);
    x_corner3      = zeros(1,2);
    x_corner4      = zeros(1,2);
    Nmatrixrow     = zeros(siCount,1);
    dNxmatrixrow   = zeros(siCount,1);
    dNymatrixrow   = zeros(siCount,1);


    x_corner1(1,:) = x_sp(1,:) - r1_sp(1,:) - r2_sp(1,:);      % Position of corner 1
    x_corner2(1,:) = x_sp(1,:) + r1_sp(1,:) - r2_sp(1,:);
    x_corner3(1,:) = x_sp(1,:) + r1_sp(1,:) + r2_sp(1,:);
    x_corner4(1,:) = x_sp(1,:) - r1_sp(1,:) + r2_sp(1,:);

    spElems(1) = ceil(x_sp(1,1)/le(1))+(NN(1)-1)*(fix(x_sp(1,2)/le(2)));   % compute vector store index elements                           

    spElems_corner(1,1) = ceil(x_corner1(1,1)/le(1))+(NN(1)-1)*(fix(x_corner1(1,2)/le(2)));                        
    spElems_corner(1,2) = ceil(x_corner2(1,1)/le(1))+(NN(1)-1)*(fix(x_corner2(1,2)/le(2)));                        
    spElems_corner(1,3) = ceil(x_corner3(1,1)/le(1))+(NN(1)-1)*(fix(x_corner3(1,2)/le(2)));
    spElems_corner(1,4) = ceil(x_corner4(1,1)/le(1))+(NN(1)-1)*(fix(x_corner4(1,2)/le(2)));

    CONNECT_TEMP(1,1)  = spElems_corner(1,1) + floor((spElems_corner(1,1)-1)/(NN(1)-1));
    CONNECT_TEMP(1,2)  = CONNECT_TEMP(1,1) + 1;
    CONNECT_TEMP(1,3)  = CONNECT_TEMP(1,2) + NN(1);
    CONNECT_TEMP(1,4)  = CONNECT_TEMP(1,1) + NN(1);

    CONNECT_TEMP(1,5)  = spElems_corner(1,2) + floor((spElems_corner(1,2)-1)/(NN(1)-1));
    CONNECT_TEMP(1,6)  = CONNECT_TEMP(1,5) + 1;
    CONNECT_TEMP(1,7)  = CONNECT_TEMP(1,6) + NN(1);
    CONNECT_TEMP(1,8)  = CONNECT_TEMP(1,5) + NN(1); 

    CONNECT_TEMP(1,9)  = spElems_corner(1,3) + floor((spElems_corner(1,3)-1)/(NN(1)-1));
    CONNECT_TEMP(1,10) = CONNECT_TEMP(1,9) + 1;
    CONNECT_TEMP(1,11) = CONNECT_TEMP(1,10) + NN(1);
    CONNECT_TEMP(1,12) = CONNECT_TEMP(1,9) + NN(1); 

    CONNECT_TEMP(1,13) = spElems_corner(1,4) + floor((spElems_corner(1,4)-1)/(NN(1)-1));
    CONNECT_TEMP(1,14) = CONNECT_TEMP(1,13) + 1;
    CONNECT_TEMP(1,15) = CONNECT_TEMP(1,14) + NN(1);
    CONNECT_TEMP(1,16) = CONNECT_TEMP(1,13) + NN(1);

    CONNECT=unique(CONNECT_TEMP(1,:));    % Store nodes interacting with corners
    NODES(1)=length(CONNECT);         % Store number of interacting nodes

    N1 = zeros(1,NODES(1));   % Shape function of corner 1 for 16 nodes
    N2 = zeros(1,NODES(1));
    N3 = zeros(1,NODES(1));
    N4 = zeros(1,NODES(1));
    N_local = zeros(1,NODES(1));

    for i=1:NODES(1)
        [N1(i),~,~] = linearshape(x_corner1(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
        [N2(i),~,~] = linearshape(x_corner2(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
        [N3(i),~,~] = linearshape(x_corner3(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
        [N4(i),~,~] = linearshape(x_corner4(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
        N_local(i)  = 0.25*(N1(i)+N2(i)+N3(i)+N4(i));
    end

    N = N_local;

    % Build matrix of gradient of shape function 
    w1 = [r1_sp(1,2)-r2_sp(1,2) r2_sp(1,1)-r1_sp(1,1)];
    w2 = [r1_sp(1,2)+r2_sp(1,2) -r2_sp(1,1)-r1_sp(1,1)];

    for i=1:NODES(1)      
        dN(1,i)     = 1/A_sp(1)*((N1(i)-N3(i))*w1(1) + (N2(i)-N4(i))*w2(1));
        dN(2,i)     = 1/A_sp(1)*((N1(i)-N3(i))*w1(2) + (N2(i)-N4(i))*w2(2));
    end

    for i=1:NODES(1)
        Nmatrixrow(CONNECT(i),1)=N(i);
        dNxmatrixrow(CONNECT(i),1)=dN(1,i);
        dNymatrixrow(CONNECT(i),1)=dN(2,i);
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,NODES,Nmatrixrow] = Compute_Interpolator_CPDI_parforred_optimized(x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,siCount)
 
    CONNECT_TEMP   = zeros(1,16);
    spElems_corner = zeros(1,4);
    x_corner1      = zeros(1,2);
    x_corner2      = zeros(1,2);
    x_corner3      = zeros(1,2);
    x_corner4      = zeros(1,2);
    Nmatrixrow     = zeros(siCount,1);
    dNxmatrixrow   = zeros(siCount,1);
    dNymatrixrow   = zeros(siCount,1);


    x_corner1(1,:) = x_sp(1,:) - r1_sp(1,:) - r2_sp(1,:);      % Position of corner 1
    x_corner2(1,:) = x_sp(1,:) + r1_sp(1,:) - r2_sp(1,:);
    x_corner3(1,:) = x_sp(1,:) + r1_sp(1,:) + r2_sp(1,:);
    x_corner4(1,:) = x_sp(1,:) - r1_sp(1,:) + r2_sp(1,:);

    spElems(1) = ceil(x_sp(1,1)/le(1))+(NN(1)-1)*(fix(x_sp(1,2)/le(2)));   % compute vector store index elements                           

    spElems_corner(1,1) = ceil(x_corner1(1,1)/le(1))+(NN(1)-1)*(fix(x_corner1(1,2)/le(2)));                        
    spElems_corner(1,2) = ceil(x_corner2(1,1)/le(1))+(NN(1)-1)*(fix(x_corner2(1,2)/le(2)));                        
    spElems_corner(1,3) = ceil(x_corner3(1,1)/le(1))+(NN(1)-1)*(fix(x_corner3(1,2)/le(2)));
    spElems_corner(1,4) = ceil(x_corner4(1,1)/le(1))+(NN(1)-1)*(fix(x_corner4(1,2)/le(2)));

    CONNECT_TEMP(1,1)  = spElems_corner(1,1) + floor((spElems_corner(1,1)-1)/(NN(1)-1));
    CONNECT_TEMP(1,2)  = CONNECT_TEMP(1,1) + 1;
    CONNECT_TEMP(1,3)  = CONNECT_TEMP(1,2) + NN(1);
    CONNECT_TEMP(1,4)  = CONNECT_TEMP(1,1) + NN(1);

    CONNECT_TEMP(1,5)  = spElems_corner(1,2) + floor((spElems_corner(1,2)-1)/(NN(1)-1));
    CONNECT_TEMP(1,6)  = CONNECT_TEMP(1,5) + 1;
    CONNECT_TEMP(1,7)  = CONNECT_TEMP(1,6) + NN(1);
    CONNECT_TEMP(1,8)  = CONNECT_TEMP(1,5) + NN(1); 

    CONNECT_TEMP(1,9)  = spElems_corner(1,3) + floor((spElems_corner(1,3)-1)/(NN(1)-1));
    CONNECT_TEMP(1,10) = CONNECT_TEMP(1,9) + 1;
    CONNECT_TEMP(1,11) = CONNECT_TEMP(1,10) + NN(1);
    CONNECT_TEMP(1,12) = CONNECT_TEMP(1,9) + NN(1); 

    CONNECT_TEMP(1,13) = spElems_corner(1,4) + floor((spElems_corner(1,4)-1)/(NN(1)-1));
    CONNECT_TEMP(1,14) = CONNECT_TEMP(1,13) + 1;
    CONNECT_TEMP(1,15) = CONNECT_TEMP(1,14) + NN(1);
    CONNECT_TEMP(1,16) = CONNECT_TEMP(1,13) + NN(1);

    CONNECT=unique(CONNECT_TEMP(1,:));    % Store nodes interacting with corners
    NODES(1)=length(CONNECT);         % Store number of interacting nodes

    N1 = zeros(1,NODES(1));   % Shape function of corner 1 for 16 nodes
    N2 = zeros(1,NODES(1));
    N3 = zeros(1,NODES(1));
    N4 = zeros(1,NODES(1));
    N_local = zeros(1,NODES(1));

    for i=1:NODES(1)
        [N1(i),~,~] = linearshape(x_corner1(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
        [N2(i),~,~] = linearshape(x_corner2(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
        [N3(i),~,~] = linearshape(x_corner3(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
        [N4(i),~,~] = linearshape(x_corner4(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
        N_local(i)  = 0.25*(N1(i)+N2(i)+N3(i)+N4(i));
    end

    N = N_local;

    % Build matrix of gradient of shape function 
    w1 = [r1_sp(1,2)-r2_sp(1,2) r2_sp(1,1)-r1_sp(1,1)];
    w2 = [r1_sp(1,2)+r2_sp(1,2) -r2_sp(1,1)-r1_sp(1,1)];

    for i=1:NODES(1)      
        dN(1,i)     = 1/A_sp(1)*((N1(i)-N3(i))*w1(1) + (N2(i)-N4(i))*w2(1));
        dN(2,i)     = 1/A_sp(1)*((N1(i)-N3(i))*w1(2) + (N2(i)-N4(i))*w2(2));
    end

    for i=1:NODES(1)
        Nmatrixrow(CONNECT(i),1)=N(i);
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix,CONNECTpn] = Compute_Interpolator_MPM(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp)
    spElems        = zeros(spCount,1);
    N{spCount}       = [];
    dN{spCount}      = [];
    CONNECT{spCount} = [];
    siCount=NN(1)*NN(2);
	CONNECTpn{siCount}=[];
    Nmatrix=zeros(siCount,spCount);
    dNxmatrix=zeros(siCount,spCount);
    dNymatrix=zeros(siCount,spCount);

    try
        parfor sp=1:spCount
            [N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow,dNxmatrixrow,dNymatrixrow] = Compute_Interpolator_MPM_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
            Nmatrix(:,sp)=Nmatrixrow;
            dNxmatrix(:,sp)=dNxmatrixrow;
            dNymatrix(:,sp)=dNymatrixrow;
        end
    catch
        disp('parfor failed inside Compute_Interpolator_MPM, switching to regular for');
        for sp=1:spCount
            [N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow,dNxmatrixrow,dNymatrixrow] = Compute_Interpolator_MPM_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
            Nmatrix(:,sp)=Nmatrixrow;
            dNxmatrix(:,sp)=dNxmatrixrow;
            dNymatrix(:,sp)=dNymatrixrow;
        end
    end        
    for sp=1:spCount
        for i=1:length(CONNECT{sp})
            CONNECTpn{CONNECT{sp}(i)}=[CONNECTpn{CONNECT{sp}(i)} sp];
        end
    end

    for c =1:cellCount
        id_sp = find(spElems==c);
        mspoints{c}=id_sp;
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,CONNECTpn] = Compute_Interpolator_MPM_optimized(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp)
    spElems        = zeros(spCount,1);
    N{spCount}       = [];
    dN{spCount}      = [];
    CONNECT{spCount} = [];
    siCount=NN(1)*NN(2);
	CONNECTpn{siCount}=[];
    Nmatrix=zeros(siCount,spCount);

    try
        parfor sp=1:spCount
            [N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow] = Compute_Interpolator_MPM_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
            Nmatrix(:,sp)=Nmatrixrow;
        end
    catch
        disp('parfor failed inside Compute_Interpolator_MPM, switching to regular for');
        for sp=1:spCount
            [N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow] = Compute_Interpolator_MPM_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
            Nmatrix(:,sp)=Nmatrixrow;
        end
    end        
    for sp=1:spCount
        for i=1:length(CONNECT{sp})
            CONNECTpn{CONNECT{sp}(i)}=[CONNECTpn{CONNECT{sp}(i)} sp];
        end
    end

    for c =1:cellCount
        id_sp = find(spElems==c);
        mspoints{c}=id_sp;
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,pElems,NODES,Nmatrixrow,dNxmatrixrow,dNymatrixrow] = Compute_Interpolator_MPM_parforred(x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,siCount)
	 
	pElems         = zeros(1,1);                             % index of elements where stores particles
	CONNECT_TEMP    = zeros(1,4);                            % node 1=leftdown 2=righdown 3=rightup 4= leftup
	NODES           = 4 * ones(1,1);                         % Number of interation nodes for each particle
	N_local         = zeros(1,4);                            % Value of shape function
	dN_local        = zeros(1,8);                            % Value of gradient of shape function
	p=1;
	 Nmatrixrow     = zeros(siCount,1);
	 dNxmatrixrow   = zeros(siCount,1);
	 dNymatrixrow   = zeros(siCount,1);

	 pElems(p) = ceil(x_sp(p,1)/le(1))+(NN(1)-1)*(fix(x_sp(p,2)/le(2)));   % compute vector store index elements                           
	 
	 CONNECT_TEMP(p,1) = pElems(p) + floor((pElems(p)-1)/(NN(1)-1));
	 CONNECT_TEMP(p,2) = CONNECT_TEMP(p,1)+1; 
	 CONNECT_TEMP(p,3) = CONNECT_TEMP(p,2)+NN(1); 
	 CONNECT_TEMP(p,4) = CONNECT_TEMP(p,1)+NN(1);
	 CONNECT        = [CONNECT_TEMP(p,1) CONNECT_TEMP(p,2) CONNECT_TEMP(p,3) CONNECT_TEMP(p,4)];
	 
	[N_local(p,1),dN_local(p,1),dN_local(p,5)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,1),:),le(1,1),le(1,2));
	[N_local(p,2),dN_local(p,2),dN_local(p,6)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,2),:),le(1,1),le(1,2));
	[N_local(p,3),dN_local(p,3),dN_local(p,7)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,3),:),le(1,1),le(1,2));
	[N_local(p,4),dN_local(p,4),dN_local(p,8)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,4),:),le(1,1),le(1,2));

	 % Build matrix of gradient of shape function of 4 nodes of the cell which
	 % contain the particles
	% dG((sp-1)*4+[1:4],:) = [dN(sp,1) dN(sp,5);dN(sp,2) dN(sp,6);dN(sp,3) dN(sp,7);dN(sp,4) dN(sp,8)];

	for i = 1:NODES(p)
	N(i) = N_local(p,i);    
	dN(1,i) = dN_local(p,i);
	dN(2,i) = dN_local(p,i+4);
	end
	 
	  for i=1:NODES(1)
		Nmatrixrow(CONNECT(i),1)=N(i);
		dNxmatrixrow(CONNECT(i),1)=dN(1,i);
		dNymatrixrow(CONNECT(i),1)=dN(2,i);
	 end
	 
	
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,pElems,NODES,Nmatrixrow] = Compute_Interpolator_MPM_parforred_optimized(x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,siCount)
	 
	pElems         = zeros(1,1);                             % index of elements where stores particles
	CONNECT_TEMP    = zeros(1,4);                            % node 1=leftdown 2=righdown 3=rightup 4= leftup
	NODES           = 4 * ones(1,1);                         % Number of interation nodes for each particle
	N_local         = zeros(1,4);                            % Value of shape function
	dN_local        = zeros(1,8);                            % Value of gradient of shape function
	p=1;
	 Nmatrixrow     = zeros(siCount,1);

	 pElems(p) = ceil(x_sp(p,1)/le(1))+(NN(1)-1)*(fix(x_sp(p,2)/le(2)));   % compute vector store index elements                           
	 
	 CONNECT_TEMP(p,1) = pElems(p) + floor((pElems(p)-1)/(NN(1)-1));
	 CONNECT_TEMP(p,2) = CONNECT_TEMP(p,1)+1; 
	 CONNECT_TEMP(p,3) = CONNECT_TEMP(p,2)+NN(1); 
	 CONNECT_TEMP(p,4) = CONNECT_TEMP(p,1)+NN(1);
	 CONNECT        = [CONNECT_TEMP(p,1) CONNECT_TEMP(p,2) CONNECT_TEMP(p,3) CONNECT_TEMP(p,4)];
	 
	[N_local(p,1),dN_local(p,1),dN_local(p,5)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,1),:),le(1,1),le(1,2));
	[N_local(p,2),dN_local(p,2),dN_local(p,6)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,2),:),le(1,1),le(1,2));
	[N_local(p,3),dN_local(p,3),dN_local(p,7)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,3),:),le(1,1),le(1,2));
	[N_local(p,4),dN_local(p,4),dN_local(p,8)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,4),:),le(1,1),le(1,2));

	 % Build matrix of gradient of shape function of 4 nodes of the cell which
	 % contain the particles
	% dG((sp-1)*4+[1:4],:) = [dN(sp,1) dN(sp,5);dN(sp,2) dN(sp,6);dN(sp,3) dN(sp,7);dN(sp,4) dN(sp,8)];

	for i = 1:NODES(p)
	N(i) = N_local(p,i);    
	dN(1,i) = dN_local(p,i);
	dN(2,i) = dN_local(p,i+4);
	end
	 
	  for i=1:NODES(1)
		Nmatrixrow(CONNECT(i),1)=N(i);
	 end
	 
	
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,mspoints,NODES] = Compute_Interpolator_CPDI_regularloop(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp)

 CONNECT_TEMP   = zeros(spCount,16);
 spElems_corner = zeros(spCount,4);
 spElems        = zeros(spCount,1);
 x_corner1      = zeros(spCount,2);
 x_corner2      = zeros(spCount,2);
 x_corner3      = zeros(spCount,2);
 x_corner4      = zeros(spCount,2);
 
 for sp=1:spCount
 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
 end
 
 for sp = 1:spCount
 spElems(sp) = ceil(x_sp(sp,1)/le(1))+(NN(1)-1)*(fix(x_sp(sp,2)/le(2)));   % compute vector store index elements                           

 spElems_corner(sp,1) = ceil(x_corner1(sp,1)/le(1))+(NN(1)-1)*(fix(x_corner1(sp,2)/le(2)));                        
 spElems_corner(sp,2) = ceil(x_corner2(sp,1)/le(1))+(NN(1)-1)*(fix(x_corner2(sp,2)/le(2)));                        
 spElems_corner(sp,3) = ceil(x_corner3(sp,1)/le(1))+(NN(1)-1)*(fix(x_corner3(sp,2)/le(2)));
 spElems_corner(sp,4) = ceil(x_corner4(sp,1)/le(1))+(NN(1)-1)*(fix(x_corner4(sp,2)/le(2)));

 CONNECT_TEMP(sp,1)  = spElems_corner(sp,1) + floor((spElems_corner(sp,1)-1)/(NN(1)-1));
 CONNECT_TEMP(sp,2)  = CONNECT_TEMP(sp,1) + 1;
 CONNECT_TEMP(sp,3)  = CONNECT_TEMP(sp,2) + NN(1);
 CONNECT_TEMP(sp,4)  = CONNECT_TEMP(sp,1) + NN(1);
 
 CONNECT_TEMP(sp,5)  = spElems_corner(sp,2) + floor((spElems_corner(sp,2)-1)/(NN(1)-1));
 CONNECT_TEMP(sp,6)  = CONNECT_TEMP(sp,5) + 1;
 CONNECT_TEMP(sp,7)  = CONNECT_TEMP(sp,6) + NN(1);
 CONNECT_TEMP(sp,8)  = CONNECT_TEMP(sp,5) + NN(1); 

 CONNECT_TEMP(sp,9)  = spElems_corner(sp,3) + floor((spElems_corner(sp,3)-1)/(NN(1)-1));
 CONNECT_TEMP(sp,10) = CONNECT_TEMP(sp,9) + 1;
 CONNECT_TEMP(sp,11) = CONNECT_TEMP(sp,10) + NN(1);
 CONNECT_TEMP(sp,12) = CONNECT_TEMP(sp,9) + NN(1); 

 CONNECT_TEMP(sp,13) = spElems_corner(sp,4) + floor((spElems_corner(sp,4)-1)/(NN(1)-1));
 CONNECT_TEMP(sp,14) = CONNECT_TEMP(sp,13) + 1;
 CONNECT_TEMP(sp,15) = CONNECT_TEMP(sp,14) + NN(1);
 CONNECT_TEMP(sp,16) = CONNECT_TEMP(sp,13) + NN(1);

 CONNECT{sp}=unique(CONNECT_TEMP(sp,:));    % Store nodes interacting with corners
 NODES(sp)=length(CONNECT{sp});         % Store number of interacting nodes
 
 N1 = zeros(1,NODES(sp));   % Shape function of corner 1 for 16 nodes
 N2 = zeros(1,NODES(sp));
 N3 = zeros(1,NODES(sp));
 N4 = zeros(1,NODES(sp));
 N_local = zeros(1,NODES(sp));
 
 for i=1:NODES(sp)
    [N1(i),~,~] = linearshape(x_corner1(sp,:),LOC(CONNECT{sp}(i),:),le(1,1),le(1,2));
    [N2(i),~,~] = linearshape(x_corner2(sp,:),LOC(CONNECT{sp}(i),:),le(1,1),le(1,2));
    [N3(i),~,~] = linearshape(x_corner3(sp,:),LOC(CONNECT{sp}(i),:),le(1,1),le(1,2));
    [N4(i),~,~] = linearshape(x_corner4(sp,:),LOC(CONNECT{sp}(i),:),le(1,1),le(1,2));
    N_local(i)  = 0.25*(N1(i)+N2(i)+N3(i)+N4(i));
 end
 
 N{sp} = N_local;
 
 % Build matrix of gradient of shape function 
 w1 = [r1_sp(sp,2)-r2_sp(sp,2) r2_sp(sp,1)-r1_sp(sp,1)];
 w2 = [r1_sp(sp,2)+r2_sp(sp,2) -r2_sp(sp,1)-r1_sp(sp,1)];
 
 for i=1:NODES(sp)      
dN{sp}(1,i)     = 1/A_sp(sp)*((N1(i)-N3(i))*w1(1) + (N2(i)-N4(i))*w2(1));
dN{sp}(2,i)     = 1/A_sp(sp)*((N1(i)-N3(i))*w1(2) + (N2(i)-N4(i))*w2(2));
 end
 end
 
 for c =1:cellCount
     id_sp = find(spElems==c);
     mspoints{c}=id_sp;
 end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function PrintResults_parfor(switcher,TimeStampedName,videofps,tt,ttstart,DispPump,CModel,LOC,le,d_sp,e_sp,v_ssp,spCount,E_acc,TLD,plotignore,matmodel,lp,layer,CasetoRun,orientationoffset,xdirletter,ydirletter,x_spo, ...
    ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,thetacrackrtl)

%{
    if switcher==1
        switcher=17;
    elseif switcher==2
        switcher=20;
    elseif switcher==3
        switcher=26;
    elseif switcher==4
        switcher=29;
    elseif switcher==5
        switcher=13;
    elseif switcher==6
        switcher=43;
    end
%}
%{
    if switcher==1
        switcher=48;
    elseif switcher==2
        switcher=49;
    elseif switcher==3
        switcher=50;
    elseif switcher==4
        switcher=51;
    end
%}  
    if CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==61 || CasetoRun==62 || CasetoRun==63
        if switcher==1
            %switcher=52;
            switcher=-99;
        elseif switcher==2
            switcher=53;
        else
            switcher=-99;
        end
    elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==65 || CasetoRun==70
        if switcher==1
            switcher=54; %smax_var (with crack)
        elseif switcher==2
            switcher=55; %smax_var_nc (no crack)
        elseif switcher==3
            switcher=10; %uy
		elseif switcher==4
			switcher=45; %ux
		else
			switcher=-1;
        end
    elseif CasetoRun==73
        if switcher==1
            switcher=56; %crack_dirs
        elseif switcher==2
            switcher=10; %s_max
        elseif switcher==3
            switcher=9; %s_min
		elseif switcher==4
			switcher=-1; %nada
		else
			switcher=-1;
        end
	elseif CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77
        if switcher==1
            switcher=57; %crack_dirs_nnairn
        elseif switcher==2
            switcher=54; %s_max_var
        elseif switcher==3
            switcher=9; %s_min_without
		elseif switcher==4
			switcher=-1; %nada
		else
			switcher=-1;
        end
	elseif CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
        if switcher==1
			switcher=55;
		elseif switcher==2
			switcher=61;
		elseif switcher==3
			switcher=60; %crack_dirs_nnairn multi
		elseif switcher==4
			switcher=62; %minimum principal stress with cracks
		elseif switcher>=5 && switcher<=11
			switcher=switcher+10;
		else
			switcher=-1;
		end
	elseif CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117
        if switcher==1
			switcher=63; %s_max with traction plots
		elseif switcher==2
			switcher=61;
		elseif switcher==3
			switcher=60; %crack_dirs_nnairn multi
		elseif switcher==4
			switcher=62; %minimum principal stress with cracks
		elseif switcher>=5 && switcher<=11
			switcher=switcher+10;
		else
			switcher=-1;
		end
    else
        if switcher==1
    %switcher=13: constant scaling max epl shear
    %switcher=43: variable scaling max epl shear
    %switcher=41: load-disp
            switcher=43;
        elseif switcher==2
            %switcher=48; %uy
            switcher=41;
        elseif switcher==3
            %switcher=49; %sx or s1
            switcher=13;
        elseif switcher==4
            %switcher=50; %sy or s2
        elseif switcher==5
            %switcher=51; %deformed
        end
    end
    
    disp(['Start Plotting Switcher #' num2str(switcher)]);
    climit=[];
    if switcher==40
        VideoName           = 'e_pl_max';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(CModel) == length('Wood_Schmidt17')
                if CModel == 'Wood_Schmidt17'
                    %if exist('climitse')==0
                    %    climitse=[];
                    %end
                    [PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,1,0);
                    if length(climit)==0
                        climit(1)=min(cutvector(e_pl_sp_max,0,plotignore));
                        climit(2)=max(cutvector(e_pl_sp_max,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(e_pl_sp_max,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(e_pl_sp_max,0,plotignore)));
                    end
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(CModel) == length('Wood_Schmidt17')
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,1,1);
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);
    elseif switcher==52
        VideoName           = 'e_pl_shear_ovl';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(CModel) == length('Wood_Schmidt17')
                if CModel == 'Wood_Schmidt17'
                    %if exist('climitse')==0
                    %    climitse=[];
                    %end
                    [PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit_ovl(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,0,plotignore);
                    if length(climit)==0
                        climit(1)=min(cutvector(e_pl_sp_shear,0,plotignore));
                        climit(2)=max(cutvector(e_pl_sp_shear,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(e_pl_sp_shear,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(e_pl_sp_shear,0,plotignore)));
                    end
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(CModel) == length('Wood_Schmidt17')
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit_ovl(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,1,plotignore);
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    eval(['cd ' TimeStampedName]);
                    eval(['cd ' VideoName]);
                    eval(['export_fig ' 'tt=' num2str(i) 'd=' num2str(DispPump) '.png' ' -transparent']);
                    cd ..
                    cd ..
                    export_fig  -transparent
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);

    elseif switcher==0 % here here
        if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
            VideoName           = 's2perlayer';
            mkdir([TimeStampedName '\\' VideoName]);
            writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
            writerObj.FrameRate = videofps;    % number of frame per second
            open(writerObj);

            for i=ttstart:tt
				load([TimeStampedName '\\' num2str(i) '.mat']);
				if i==ttstart
					x_sp_1=x_sp;
				end
                for j=1:size(layer,1)
                    y_layer(i,j)=x_sp_1(layer(1,j),2);
                    s_summed(i,j)=0;
                    for k=1:size(layer,2)
                        s_summed(i,j)=s_summed(i,j)+s_sp(layer(j,k),2);
                    end
                end
            end
            s_min=min([0 min(min(s_summed))]);
            s_max=max([0 max(max(s_summed))]);
            for i=ttstart:tt
				load([TimeStampedName '\\' num2str(i) '.mat']);
                PlotImage=figure;
                set(PlotImage,'visible','off');
                plot(s_summed(i,:),y_layer(i,:));
                hold on
                plot(s_min,y_layer(i,1));
                plot(s_max,y_layer(i,1));
                xlabel('s2 (MPa)');
                ylabel('Particle Position (mm)');
                title('Summed layer Y-stress');
                saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                frame=getframe(PlotImage);
                writeVideo(writerObj,frame);
                hold off
                close(PlotImage);
            end
            close(writerObj);
        elseif CasetoRun==4
        elseif CasetoRun==5 || CasetoRun==6
        elseif CasetoRun==7
            VideoName           = 's2perlayer';
            mkdir([TimeStampedName '\\' VideoName]);
            writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
            writerObj.FrameRate = videofps;    % number of frame per second
            open(writerObj);

            for i=ttstart:tt
				load([TimeStampedName '\\' num2str(i) '.mat']);
				if i==ttstart
					x_sp_1=x_sp;
				end
                for j=1:size(layer,1)
                    y_layer(i,j)=x_sp_1(layer(1,j),2);
                    s_summed(i,j)=0;
                    for k=1:size(layer,2)
                        s_summed(i,j)=s_summed(i,j)+s_sp(layer(j,k),2);
                    end
                end
            end
            s_min=min([0 min(min(s_summed))]);
            s_max=max([0 max(max(s_summed))]);
            for i=ttstart:tt
				load([TimeStampedName '\\' num2str(i) '.mat']);
                PlotImage=figure;
                set(PlotImage,'visible','off');
                plot(s_summed(i,:),y_layer(i,:));
                hold on
                plot(s_min,y_layer(i,1));
                plot(s_max,y_layer(i,1));
                xlabel('s2 (MPa)');
                ylabel('Particle Position (mm)');
                title('Summed layer Y-stress');
                %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                frame=getframe(PlotImage);
                writeVideo(writerObj,frame);
                hold off
                close(PlotImage);
            end
            close(writerObj);
        elseif CasetoRun==8 || CasetoRun==9
        elseif CasetoRun==10
            VideoName           = 's2perlayer';
            mkdir([TimeStampedName '\\' VideoName]);
            writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
            writerObj.FrameRate = videofps;    % number of frame per second
            open(writerObj);

            for i=ttstart:tt
				load([TimeStampedName '\\' num2str(i) '.mat']);
				if i==ttstart
					x_sp_1=x_sp;
				end
                for j=1:size(layer,1)
                    y_layer(i,j)=x_sp_1(layer(1,j),2);
                    s_summed(i,j)=0;
                    for k=1:size(layer,2)
                        s_summed(i,j)=s_summed(i,j)+s_sp(layer(j,k),2);
                    end
                end
            end
            s_min=min([0 min(min(s_summed))]);
            s_max=max([0 max(max(s_summed))]);
            for i=ttstart:tt
				load([TimeStampedName '\\' num2str(i) '.mat']);
                PlotImage=figure;
                set(PlotImage,'visible','off');
                plot(s_summed(i,:),y_layer(i,:));
                hold on
                plot(s_min,y_layer(i,1));
                plot(s_max,y_layer(i,1));
                xlabel('s2 (MPa)');
                ylabel('Particle Position (mm)');
                title('Summed layer Y-stress');
                %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                frame=getframe(PlotImage);
                writeVideo(writerObj,frame);
                hold off
                close(PlotImage);
            end
            close(writerObj);
        elseif CasetoRun==11
        elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
        elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
        end

   elseif switcher==35
        VideoName           = 'deformed';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    %if exist('climitse')==0
                    %    climitse=[];
                    %end
                    PlotImage=Plot_Current(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp);
                    %climitserec=[climitserec;climitse];
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);
        
   elseif switcher==56
        VideoName           = 'crackdir';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    %if exist('climitse')==0
                    %    climitse=[];
                    %end
                    PlotImage=Plot_CrackDir(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack);
                    %climitserec=[climitserec;climitse];
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);
	elseif switcher==57
        VideoName           = 'crackdirnairn';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    %if exist('climitse')==0
                    %    climitse=[];
                    %end
                    PlotImage=Plot_CrackDirNairn(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack,x_crack,x_cracktop,x_crackbot);
                    %climitserec=[climitserec;climitse];
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);

	elseif switcher==59
        VideoName           = 'crackdirnairn_multi';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    %if exist('climitse')==0
                    %    climitse=[];
                    %end
                    PlotImage=Plot_CrackDirNairn_multi(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack,x_crack,x_cracktop,x_crackbot);
                    %climitserec=[climitserec;climitse];
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);
	elseif switcher==60
        VideoName           = 'crackdirnairn_multilines';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    %if exist('climitse')==0
                    %    climitse=[];
                    %end
                    PlotImage=Plot_CrackDirNairn_multilines(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack,x_crack,x_cracktop,x_crackbot,CasetoRun);
                    %climitserec=[climitserec;climitse];
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);
	elseif switcher==36
        VideoName           = 'e_pl_min';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    if exist('climit')==0
                        climit=[];
                    end
                    [PlotImage,DUMMY,e_pl_sp_min,~]=Plot_Final2_principalclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,2,0);
                    if length(climit)==0
                        climit(1)=min(cutvector(e_pl_sp_min,0,plotignore));
                        climit(2)=max(cutvector(e_pl_sp_min,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(e_pl_sp_min,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(e_pl_sp_min,0,plotignore)));
                    end
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(CModel) == length('Wood_Schmidt17')
                if CModel == 'Wood_Schmidt17'
                    %climitserec=[climitserec;climitse];
                    [PlotImage,DUMMY,e_pl_sp_min,~]=Plot_Final2_principalclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,2,1);
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);
    
    elseif switcher==37
        VideoName           = 'e_el_min';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    if exist('climit')==0
                        climit=[];
                    end
                    e_el_sp=e_t_global_big(:,[1 2 4])-e_pl_sp;
                    [PlotImage,DUMMY,e_pl_sp_min,~]=Plot_Final2_principalclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_el_sp,climit,2,0);
                    if length(climit)==0
                        climit(1)=min(cutvector(e_pl_sp_min,0,plotignore));
                        climit(2)=max(cutvector(e_pl_sp_min,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(e_pl_sp_min,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(e_pl_sp_min,0,plotignore)));
                    end
                    %climitserec=[climitserec;climitse];
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    e_el_sp=e_t_global_big(:,[1 2 4])-e_pl_sp;
                    [PlotImage,DUMMY,e_pl_sp_min,~]=Plot_Final2_principalclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_el_sp,climit,2,1);
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);
    elseif switcher==38
        VideoName           = 'e_el_max';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    if exist('climit')==0
                        climit=[];
                    end
                    e_el_sp=e_t_global_big(:,[1 2 4])-e_pl_sp;
                    [PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_el_sp,climit,1,0);
                    if length(climit)==0
                        climit(1)=min(cutvector(e_pl_sp_max,0,plotignore));
                        climit(2)=max(cutvector(e_pl_sp_max,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(e_pl_sp_max,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(e_pl_sp_max,0,plotignore)));
                    end
                    %climitserec=[climitserec;climitse];
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    e_el_sp=e_t_global_big(:,[1 2 4])-e_pl_sp;
                    [PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_el_sp,climit,1,1);
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);
    
    elseif switcher==13
        VideoName           = 'e_pl_shear';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    if exist('climit')==0
                        climit=[];
                    end
                    [PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,0);
                    if length(climit)==0
                        climit(1)=min(cutvector(e_pl_sp_shear,0,plotignore));
                        climit(2)=max(cutvector(e_pl_sp_shear,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(e_pl_sp_shear,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(e_pl_sp_shear,0,plotignore)));
                    end
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,1);
                    %climitserec=[climitserec;climitse];
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);
    
    elseif switcher==53
        VideoName           = 'e_pl_shear_report';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        if CasetoRun==61 || CasetoRun==62 || CasetoRun==63
            tt=min([tt 120]);
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    if exist('climit')==0
                        climit=[];
                    end
                    [PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit_report(matmodel,CasetoRun,t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,0);
                    if length(climit)==0
                        climit(1)=min(cutvector(e_pl_sp_shear,0,plotignore));
                        climit(2)=max(cutvector(e_pl_sp_shear,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(e_pl_sp_shear,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(e_pl_sp_shear,0,plotignore)));
                    end
                end
            end
        end
        if CasetoRun==61 || CasetoRun==62 || CasetoRun==63
            climit(1)=0;
            climit(2)=0.18;
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit_report(matmodel,CasetoRun,t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,1);
                    %climitserec=[climitserec;climitse];
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);
    
    elseif switcher==43
        VideoName           = 'e_pl_shear2';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    if exist('climit')==0
                        climit=[];
                    end
                    %[PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,0);
                    [PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,1);
                    %climitserec=[climitserec;climitse];
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                    if length(climit)==0
                        climit(1)=min(cutvector(e_pl_sp_shear,0,plotignore));
                        climit(2)=max(cutvector(e_pl_sp_shear,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(e_pl_sp_shear,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(e_pl_sp_shear,0,plotignore)));
                    end
                end
            end
        end
        close(writerObj);
    
    elseif switcher==54
        VideoName           = 's_max_var';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions_crack(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
                    if length(climit)==0
                        climit(1)=min(cutvector(s_sp_max,0,plotignore));
                        climit(2)=max(cutvector(s_sp_max,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
                    end
%{
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
%}
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
        end
        
        close(writerObj);
    
    elseif switcher==58
        VideoName           = 's_max_multi';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
		
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions_crackmulti(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun);
                    if length(climit)==0
                        climit(1)=min(cutvector(s_sp_max,0,plotignore));
                        climit(2)=max(cutvector(s_sp_max,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
                    end
				%{
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
				%}
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
        end
        
        close(writerObj);
    
    elseif switcher==61
        VideoName           = 's_max_multiline';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions_crackmultiline(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun);
                    if length(climit)==0
                        climit(1)=min(cutvector(s_sp_max,0,plotignore));
                        climit(2)=max(cutvector(s_sp_max,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
                    end
%{
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
%}
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
        end
        
        close(writerObj);
	
	elseif switcher==62
        VideoName           = 's_min_multiline';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,DUMMY,s_sp_min,~]=Plot_Final2_principalclimit_directions_crackmultiline(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,2,lp,plotignore,1,CasetoRun);
                    if length(climit)==0
                        climit(1)=min(cutvector(s_sp_min,0,plotignore));
                        climit(2)=max(cutvector(s_sp_min,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
                    end
%{
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
%}
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
        end
        
        close(writerObj);
	elseif switcher==63
        VideoName           = 's_max_pforce';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_principal_crackmulti_pforce(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun,pforce_sp);
                    if length(climit)==0
                        climit(1)=min(cutvector(s_sp_max,0,plotignore));
                        climit(2)=max(cutvector(s_sp_max,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
                    end
%{
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
%}
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
        end
        
        close(writerObj);
	
    elseif switcher==55
        VideoName           = 's_max_var_nc';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun);
                    if length(climit)==0
                        climit(1)=min(cutvector(s_sp_max,0,plotignore));
                        climit(2)=max(cutvector(s_sp_max,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
                    end
%{
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
%}
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
        end
        
        close(writerObj);
    
    elseif switcher==10
        VideoName           = 's_max';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,0,CasetoRun);
                    if length(climit)==0
                        climit(1)=min(cutvector(s_sp_max,0,plotignore));
                        climit(2)=max(cutvector(s_sp_max,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
                    end
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun);
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
        end
        
        close(writerObj);
    
    elseif switcher==22
        VideoName           = 's_shr';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,DUMMY,DUMMY2,s_sp_shr]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,3,lp,plotignore,0,CasetoRun);
                    if length(climit)==0
                        climit(1)=min(cutvector(s_sp_shr,0,plotignore));
                        climit(2)=max(cutvector(s_sp_shr,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(s_sp_shr,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(s_sp_shr,0,plotignore)));
                    end
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,DUMMY,DUMMY2,s_sp_shr]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,3,lp,plotignore,1,CasetoRun);
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
        end
        close(writerObj);
    
    elseif switcher==9
        VideoName           = 's_min';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,DUMMY,s_sp_min,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,2,lp,plotignore,0,CasetoRun);
                    if length(climit)==0
                        climit(1)=min(cutvector(s_sp_min,0,plotignore));
                        climit(2)=max(cutvector(s_sp_min,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
                    end
                end
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,DUMMY,s_sp_min,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,2,lp,plotignore,1,CasetoRun);
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
        end
        close(writerObj);
    
    elseif switcher==42
        VideoName           = 's1';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            %climit=[-11 8];
            %[PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,1),climit,plotignore,0);
            if length(climit)==0
                climit(1)=min(cutvector(s_sp(:,1),0,plotignore));
                climit(2)=max(cutvector(s_sp(:,1),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(s_sp(:,1),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(s_sp(:,1),0,plotignore)));
            end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,1),climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);

    elseif switcher==1
        VideoName           = 'evaltimes';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
            evaltimes_accummulated=zeros(spCount,1);
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(climit)==0
                climit(1)=min(cutvector(evaltimes_accummulated,0,plotignore));
                climit(2)=max(cutvector(evaltimes_accummulated,0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(evaltimes_accummulated,0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(evaltimes_accummulated,0,plotignore)));
            end
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,evaltimes_accummulated,climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);
        
    elseif switcher==45
        VideoName           = 'ux';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        direction           = 1;
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            u_sp=x_sp(:,direction)-x_spo(:,direction);
            if length(climit)==0
                climit(1)=min(cutvector(u_sp,0,plotignore));
                climit(2)=max(cutvector(u_sp,0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(u_sp,0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(u_sp,0,plotignore)));
            end
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,u_sp,climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);

    elseif switcher==46
        VideoName           = 'uy';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        direction           = 2;
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            u_sp=x_sp(:,direction)-x_spo(:,direction);
            if length(climit)==0
                climit(1)=min(cutvector(u_sp,0,plotignore));
                climit(2)=max(cutvector(u_sp,0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(u_sp,0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(u_sp,0,plotignore)));
            end
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,u_sp,climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);

    elseif switcher==31
        VideoName           = 's12';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            %climit=[-11 8];
            %[PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,1),climit,plotignore,0);
            if length(climit)==0
                climit(1)=min(cutvector(s_sp(:,3),0,plotignore));
                climit(2)=max(cutvector(s_sp(:,3),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(s_sp(:,3),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(s_sp(:,3),0,plotignore)));
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,3),climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);

        
    elseif switcher==44
        VideoName           = 'fmax';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_f_plot(t,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,plotignore,f_final_vect,alphahp);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);

        
    elseif switcher==2 || switcher==3 || switcher==4 || switcher==5 || switcher==6 || switcher==7 || switcher==8
        surface=switcher-1;
        VideoName           = ['alpha_' num2str(surface)];
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(climit)==0
                climit(1)=min(cutvector(alphahp(:,surface),0,plotignore));
                climit(2)=max(cutvector(alphahp(:,surface),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(alphahp(:,surface),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(alphahp(:,surface),0,plotignore)));
            end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_alpha(climit,x_sp,LOC,spCount,r1_sp,r2_sp,plotignore,alphahp,surface);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);

        
    elseif switcher==24 || switcher==25 || switcher==26 || switcher==27 || switcher==28 || switcher==29 || switcher==30
        surface=switcher-23;
        VideoName           = ['q_' num2str(surface)];
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        qtoprint=zeros(spCount,tt);        
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            for sp=1:spCount
                if plotignore(sp)
                    continue;
                end
                [qtemp,~]=qandDfromalpha2(alphahp(sp,:),ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
                qtoprint(sp,i)=qtemp(surface);
            end
            if length(climit)==0
                climit(1)=min(cutvector(qtoprint(:,i),0,plotignore));
                climit(2)=max(cutvector(qtoprint(:,i),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(qtoprint(:,i),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(qtoprint(:,i),0,plotignore)));
            end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
%        end
%        for i=ttstart:tt
%			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,qtoprint(:,i),climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);

        
    elseif switcher==14
        VideoName           = 's2';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(climit)==0
                climit(1)=min(cutvector(s_sp(:,2),0,plotignore));
                climit(2)=max(cutvector(s_sp(:,2),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(s_sp(:,2),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(s_sp(:,2),0,plotignore)));
            end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,2),climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);

    elseif switcher==39
        VideoName           = 's2d';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(climit)==0
                climit(1)=min(cutvector(s_sp(:,2),0,plotignore));
                climit(2)=max(cutvector(s_sp(:,2),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(s_sp(:,2),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(s_sp(:,2),0,plotignore)));
            end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,2),climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);

    elseif switcher==15 || switcher==16 || switcher==17 || switcher==18 || switcher==19 || switcher==20 || switcher==21
        surface=switcher-14;
        VideoName           = ['f_' num2str(surface)];
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(climit)==0
                climit(1)=min(cutvector(f_final_vect(:,surface),0,plotignore));
                climit(2)=max(cutvector(f_final_vect(:,surface),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(f_final_vect(:,surface),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(f_final_vect(:,surface),0,plotignore)));
            end

%        end
%        for i=ttstart:tt
%			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,f_final_vect(:,surface),climit,plotignore);
            %climitsfrec=[climitsfrec;climitsf];
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);

    elseif switcher==41

        xmax=max(-TLD(:,3));
        xmin=min(-TLD(:,3));
        ymax=max(-TLD(:,2));
        ymin=min(-TLD(:,2));
        TLDmaxsize=size(TLD,1);
        
        VideoName           = 'load-disp';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        if CasetoRun==5
            tt=min(tt,2399);
        end
        for i=ttstart:tt
            PlotImage=figure;
            set(PlotImage,'visible','off');
            if CasetoRun==5
                plot(-TLD(1:i,3),-TLD(1:i,2));
            else
                plot(TLD(1:i,3),TLD(1:i,2));
            end
            hold on
            plot(xmax,ymax);
            plot(xmin,ymax);
            plot(xmax,ymin);
            plot(xmin,ymin);
            xlabel('Displacement (mm)');
            ylabel('Load (N)');
            if CasetoRun==5
            else
                title('Load vs Displacement Curve');
            end
            
            set(gca,'FontSize',20)
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) '.png']);
            frame=getframe(PlotImage);
            writeVideo(writerObj,frame);
            hold off
            close(PlotImage);
        end
        close(writerObj);
   
    
    elseif switcher==47

        mkdir([TimeStampedName '\\schedule']);
        %writerObj           = VideoWriter([TimeStampedName '\\schedule.avi']);
        %writerObj.FrameRate = videofps;    % number of frame per second
        %open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if i==ttstart
                xupperlimit=stackvars(size(stackvars,1),2);
            else
                xupperlimit=max(xupperlimit,stackvars(size(stackvars,1),2));
            end
            for j=1:size(stackvars,1)
                if stackvars(j,2)==0
                    stackvars(j,3)=stackvars(size(stackvars,1),2)/1000;
                else
                    stackvars(j,3)=0;
                end
            end
            PlotImage=figure;
            hold on;
            set(PlotImage,'visible','off');
            set(PlotImage,'Position',[0 0 720 1280]);
            title(['tt=' num2str(i) ', t=' char(vpa(t))]);
            %xlim([0 xupperlimit]);
            
            BarProfile=barh(stackvars,'stacked');
            set(BarProfile,{'FaceColor'},{'none';'k';'r'},'EdgeColor','none','BarWidth',1);
            %set(BarProfile,'BarWidth',1);
            saveas(PlotImage,[TimeStampedName '\\schedule\\tt=' num2str(i) ', t=' char(vpa(t)) '.png']);
            %%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            %frame = getframe(PlotImage);
            %writeVideo(writerObj,frame);
            hold off;
            close(PlotImage);
        end
        %close(writerObj);
   
    
    elseif switcher==11
        VideoName           = 'sr';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(climit)==0
                climit(1)=min(cutvector(sigma_local_big(:,1),0,plotignore));
                climit(2)=max(cutvector(sigma_local_big(:,1),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(sigma_local_big(:,1),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(sigma_local_big(:,1),0,plotignore)));
            end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
            %climitssrec=[climitssrec;climitss];
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,sigma_local_big(:,1),climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);
   
    elseif switcher==32
        VideoName           = 'srt';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(climit)==0
                climit(1)=min(cutvector(sigma_local_big(:,4),0,plotignore));
                climit(2)=max(cutvector(sigma_local_big(:,4),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(sigma_local_big(:,4),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(sigma_local_big(:,4),0,plotignore)));
            end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
            %climitssrec=[climitssrec;climitss];
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,sigma_local_big(:,4),climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);
   
    elseif switcher==33
        VideoName           = 'stl';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(climit)==0
                climit(1)=min(cutvector(sigma_local_big(:,5),0,plotignore));
                climit(2)=max(cutvector(sigma_local_big(:,5),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(sigma_local_big(:,5),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(sigma_local_big(:,5),0,plotignore)));
            end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
            %climitssrec=[climitssrec;climitss];
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,sigma_local_big(:,5),climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);
   
    elseif switcher==34
        VideoName           = 'srl';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(climit)==0
                climit(1)=min(cutvector(sigma_local_big(:,6),0,plotignore));
                climit(2)=max(cutvector(sigma_local_big(:,6),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(sigma_local_big(:,6),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(sigma_local_big(:,6),0,plotignore)));
            end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
            %climitssrec=[climitssrec;climitss];
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,sigma_local_big(:,6),climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);
   
    
    elseif switcher==23
        VideoName           = 'st';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(climit)==0
                climit(1)=min(cutvector(sigma_local_big(:,2),0,plotignore));
                climit(2)=max(cutvector(sigma_local_big(:,2),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(sigma_local_big(:,2),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(sigma_local_big(:,2),0,plotignore)));
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,sigma_local_big(:,2),climit,plotignore);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);


            %if exist('climitsf')==0
            %    climitsf=[];
            %end
        end
        close(writerObj);
    
   
    
    elseif switcher==12
        VideoName           = 'sl';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(climit)==0
                climit(1)=min(cutvector(sigma_local_big(:,3),0,plotignore));
                climit(2)=max(cutvector(sigma_local_big(:,3),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(sigma_local_big(:,3),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(sigma_local_big(:,3),0,plotignore)));
            end
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_regularclimit(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,sigma_local_big(:,3),climit,plotignore);
            %climitssrec=[climitssrec;climitss];
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);


            %if exist('climitsf')==0
            %    climitsf=[];
            %end
        end
        close(writerObj);
    elseif switcher==48
        %stress x black and white
        VideoName           = 's1_bw';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        if CasetoRun==5
            tt=min(tt,2399);
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            %climit=[-11 8];
            if length(climit)==0
                climit(1)=min(cutvector(s_sp(:,1),0,plotignore));
                climit(2)=max(cutvector(s_sp(:,1),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(s_sp(:,1),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(s_sp(:,1),0,plotignore)));
            end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
        end
        if CasetoRun==5
            tt=min(tt,2399);
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            [PlotImage]=Plot_Final2_regularclimit_black(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,1),climit,plotignore,CasetoRun);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);

    elseif switcher==49
        %stress y black and white
        VideoName           = 's2_bw';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);
        if CasetoRun==5
            tt=min(tt,2399);
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(climit)==0
                climit(1)=min(cutvector(s_sp(:,2),0,plotignore));
                climit(2)=max(cutvector(s_sp(:,2),0,plotignore));
            else
                climit(1)=min(climit(1),min(cutvector(s_sp(:,2),0,plotignore)));
                climit(2)=max(climit(2),max(cutvector(s_sp(:,2),0,plotignore)));
            end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
        end
        if CasetoRun==5
            tt=min(tt,2399);
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if CasetoRun==10
                climit(1)=-3.8;
                climit(2)=3.8;
            end
            [PlotImage]=Plot_Final2_regularclimit_black(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,2),climit,plotignore,CasetoRun);
            %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
            saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
            frame = getframe(PlotImage);
            writeVideo(writerObj,frame);
            close(PlotImage);
        end
        close(writerObj);

    elseif switcher==50
        %min princ plastic strain 
        VideoName           = 's_min_bw';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        if CasetoRun==5
            tt=min(tt,2399);
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,DUMMY,s_sp_min,~]=Plot_Final2_principalclimit_directions_black(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,2,lp,plotignore,0,CasetoRun);
                    if length(climit)==0
                        climit(1)=min(cutvector(s_sp_min,0,plotignore));
                        climit(2)=max(cutvector(s_sp_min,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
                    end
                end
            end
        end
        if CasetoRun==5
            tt=min(tt,2399);
        end
        for i=ttstart:tt
            load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(CModel) == length('Wood_Schmidt17');
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,DUMMY,s_sp_min,~]=Plot_Final2_principalclimit_directions_black(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,2,lp,plotignore,1,CasetoRun);
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
        end
        close(writerObj);
    
    elseif switcher==51
        VideoName           = 'e_pl_max_bw';
        mkdir([TimeStampedName '\\' VideoName]);
        writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
        writerObj.FrameRate = videofps;    % number of frame per second
        open(writerObj);

        if CasetoRun==5
            tt=min(tt,2399);
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(CModel) == length('Wood_Schmidt17')
                if CModel == 'Wood_Schmidt17'
                    %if exist('climitse')==0
                    %    climitse=[];
                    %end
                    if CasetoRun==10
                        climit(1)=0;
                        climit(2)=0.21;
                    end
                    [PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit_black(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,1,plotignore,0,CasetoRun);
                    if length(climit)==0
                        climit(1)=min(cutvector(e_pl_sp_max,0,plotignore));
                        climit(2)=max(cutvector(e_pl_sp_max,0,plotignore));
                    else
                        climit(1)=min(climit(1),min(cutvector(e_pl_sp_max,0,plotignore)));
                        climit(2)=max(climit(2),max(cutvector(e_pl_sp_max,0,plotignore)));
                    end
                end
            end
        end
        if CasetoRun==5
            tt=min(tt,2399);
        end
        for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
            if length(CModel) == length('Wood_Schmidt17')
                if CModel == 'Wood_Schmidt17'
                    [PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit_black(t,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,1,plotignore,1,CasetoRun);
                    %saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.emf']);
                    saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t=' char(vpa(t)) '.png']);
                    frame = getframe(PlotImage);
                    writeVideo(writerObj,frame);
                    close(PlotImage);
                end
            end
            %if exist('climitss')==0
            %    climitss=[];
            %end
        end
        close(writerObj);
    else
        disp('switcher error!')
    end
    
    % End of Printing TLD Video
    close all
    disp(['Done Plotting Switcher #' num2str(switcher)]);

end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [s_sp,e_pl,sigma_global_big,e_t_global_big,e_pl_global_big,alpha_out,f_final_vect,surfacewithfmax,sigma_local_big,AbeforeQ_rtl,evaltimes,thetacrackrtl,justcracked,Qacoustic,h,Ktangent_global,Ktangent_global_2D,Ktangent_global_tens,Ktangent_global_tens_2D,activesurfacelist,lambdamin,thetamin]= ...
    Wood_Schmidt17(dESP,sigma_global_big,e_t_global_big,e_pl_global_big,alpha_in,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,t,dt,spid,Debugging,thetacrackrtl,dudx_rtl)
	%start function of Wood_Schmidt17
	
	% move efficient than version 16
	%function [outputArg1,outputArg2] = Wood_Schmidt(inputArg1,inputArg2)
	%SCHMIDT Summary of this function goes here
	%   Detailed explanation goes here
	%{
	Voigt's Notation direction:
	1: r
	2: t
	3: l
	4: rt
	5: tl
	6: rl

	Failure surfaces:
	1: r tension
	2: r compression
	3: t tension
	4: t compression
	5: l tension
	6: l compression
	7: shear

	%}
	justcracked=0;
	surfacehistory=zeros(1,7);

	evaltimes=0;
	step=1;

	deltaepsilonglobal(1,1)=dESP(1,1);
	deltaepsilonglobal(2,1)=dESP(2,2);
	deltaepsilonglobal(3,1)=0;
	deltaepsilonglobal(4,1)=dESP(1,2);
	deltaepsilonglobal(5,1)=0;
	deltaepsilonglobal(6,1)=0;

	if dESP(1,2)>0
	end

	xdir=RTLtranslator(xdirletter);
	ydir=RTLtranslator(ydirletter);
	zdir=RTLtranslator(zdirletter);
	xydir=RTLtranslator(xydirletter);
	yzdir=RTLtranslator(yzdirletter);
	xzdir=RTLtranslator(xzdirletter);

	dirglobal=[xdir ydir zdir xydir yzdir xzdir];

	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
		planestressmod=1;
	elseif CasetoRun==4
		planestressmod=1;
	elseif CasetoRun==5 || CasetoRun==6
		planestressmod=0;
	elseif CasetoRun==7
		planestressmod=1;
	elseif CasetoRun==8 || CasetoRun==9
		planestressmod=0;
	elseif CasetoRun==10
		planestressmod=1;
	elseif CasetoRun==11
		planestressmod=1;
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		%planestressmod=0;
		%planestressmod=1; %turns out it's plane STRAIN all along, let's do plane STRESS now.
		planestressmod=0; %plane stress is being done, need PLANE STRAIN for more correctness.
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		%planestressmod=0; %note it's plane strain unlinke CasetoRun==11
		%planestressmod=1; %turns out it's plane STRAIN all along, let's do plane STRESS now.
		planestressmod=0; %plane stress is being done, need PLANE STRAIN for more correctness.
    elseif CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77
        planestressmod=0;
    elseif CasetoRun==-99
        planestressmod=0;
	end

	deltaepsilon(xdir,1)=deltaepsilonglobal(1);
	deltaepsilon(ydir,1)=deltaepsilonglobal(2);
	deltaepsilon(zdir,1)=deltaepsilonglobal(3);
	deltaepsilon(xydir,1)=deltaepsilonglobal(4);
	deltaepsilon(yzdir,1)=deltaepsilonglobal(5);
	deltaepsilon(xzdir,1)=deltaepsilonglobal(6);

	epsilonp(xdir,1)=e_pl_global_big(1);
	epsilonp(ydir,1)=e_pl_global_big(2);
	epsilonp(zdir,1)=e_pl_global_big(3);
	epsilonp(xydir,1)=e_pl_global_big(4);
	epsilonp(yzdir,1)=e_pl_global_big(5);
	epsilonp(xzdir,1)=e_pl_global_big(6);

	epsilont(xdir,1)=e_t_global_big(1);
	epsilont(ydir,1)=e_t_global_big(2);
	epsilont(zdir,1)=e_t_global_big(3);
	epsilont(xydir,1)=e_t_global_big(4);
	epsilont(yzdir,1)=e_t_global_big(5);
	epsilont(xzdir,1)=e_t_global_big(6);

	sigma0(xdir,1)=sigma_global_big(1);
	sigma0(ydir,1)=sigma_global_big(2);
	sigma0(zdir,1)=sigma_global_big(3);
	sigma0(xydir,1)=sigma_global_big(4);
	sigma0(yzdir,1)=sigma_global_big(5);
	sigma0(xzdir,1)=sigma_global_big(6);

	sigma{step}=sigma0;

	Comp=[1/Er -nurt/Et -nurl/El 0 0 0;
		-nurt/Et 1/Et -nutl/El 0 0 0;
		-nurl/El -nutl/El 1/El 0 0 0;
		0 0 0 1/Grt 0 0;
		0 0 0 0 1/Gtl 0;
		0 0 0 0 0 1/Grl];

	%{
	sigmarr=sigmatrial(1);
	sigmatt=sigmatrial(2);
	sigmall=sigmatrial(3);
	sigmart=sigmatrial(4);
	sigmatl=sigmatrial(5);
	sigmarl=sigmatrial(6);
	%}    
	
	%{
	for i=1:7
		deltagamma(i)=0;
	end
	%}
		
	C=Comp^-1;
	Cplanestrain=C;
	if planestressmod==1
		C=MatCondensor(Cplanestrain,[zdir yzdir xzdir]);
	elseif planestressmod==2
		C=MatCondensor(Cplanestrain,[ydir zdir xydir yzdir xzdir]);
	end
	%{
	if planestressmod
		C=zeros(6,6);
		for i=1:6
			if i==zdir|i==yzdir|i==xzdir
				continue;
			end
			if planestressmod==2
				if i==ydir|i==xydir
					continue;
				end
			end
			for j=1:6
				if j==zdir|j==yzdir|j==xzdir
					continue;
				end
				if planestressmod==2
					if j==ydir|j==xydir
						continue;
					end
				end
				C(i,j)=Cplanestrain(i,j);
			end
		end
	end
	%}
	
	%sigmastep(:,1)=transpose([0 0 0 0 0 0]);
	
	%sigmatrial{1}=zeros(6,1);
	
	%q{1}=transpose([0 0 0 0 0 0 0]);
	
	alphahp{1}=alpha_in;
	
	NormLimit=1e-5;
	%fstep=zeros(7,1);
	hardeningsurfaces=[1 2 3 4 5 6 7];
	%hardeningsurfaces=[1 3];
	
	q=[0 0 0 0 0 0 0];
	dqdalpha=[0 0 0 0 0 0 0];
	d2qdalpha2=[0 0 0 0 0 0 0];

	[q,~]=qandDfromalpha2(alphahp{1},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
	sigmatrial=sigma{1}+C*deltaepsilon;
	evaltimes=evaltimes+2;
	[ftrial,~,~]=Wood_Schmidt_EvalSigmaEff(sigmatrial,q,hardeningsurfaces,[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
	[fprev,~,~]=Wood_Schmidt_EvalSigmaEff(sigma{1},q,hardeningsurfaces,[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
	elastic=1;
	if t>=3.2395443013820597322194316802779-dt/2 && t<=3.2395443013820597322194316802779+dt/2 && (spid==17 || spid==17)
		1;
	end
	%surfaceallpositiveproblem=zeros(7,1);
	%surfacevalallpositiveproblem=zeros(7,1);
	for i=1:7
		if ftrial{i}>0 && ftrial{i}>fprev{i}
			alphafact(i)=(fprev{i}/(fprev{i}-ftrial{i}));
			elastic=0;
		else
			if ftrial{i}>0
				%disp(['Warning for spid=' num2str(spid) ': ftrial{' num2str(i) '}>0 but <fprev{' num2str(i) '}, special treatment is assumed']);
				%disp('Press any key to continue');
				%pause;
				alphafact(i)=-fprev{i};
				elastic=0;
				1;
			else
				alphafact(i)=1;
			end
		end
	end
	%if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
	%elseif CasetoRun==4
	%    elastic=1; %forces the system to remain elastic
	%end
	% force elastic here
	%if CasetoRun==4
	%    elastic=1;
	%end
	%if CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
	%    elastic=1;
	%end
	if Debugging.Active && CloseEnough(t,Debugging.Time) && spid==Debugging.Particle
        1;
    end
	if elastic
		substepiter=1;
		sigma{substepiter+1}=sigmatrial;
		alphahp{substepiter+1}=alphahp{substepiter};
		substepiter=2;
	else
		alphafactchosen=min(alphafact);
		for i=1:7
			if alphafactchosen==alphafact(i)
				chosensurface=i;
				break;
			end
		end
		alphafactchosen=max(0,alphafactchosen);
		sigma{2}=sigma{1}+alphafactchosen*C*deltaepsilon;
		alphahp{2}=alphahp{1};
		deltaepsilone=(1-alphafactchosen)*deltaepsilon;
		deltasigmae=(1-alphafactchosen)*C*deltaepsilon;
		T=0;
		deltaT=1;
		substepiter=2;
		last5surfaces=zeros(5,2);
		consistentmultisurfaceconfirmed=0;
		implicithasfailed=0;
		stoprepeater=0;
		implicitsubstepfactor=10;
		implicitsubstepnumber=0;
		while substepiter<inf
			if deltaT<1e-4
				1;
			end
			if Debugging.Active && CloseEnough(t,Debugging.Time) && spid==Debugging.Particle
				1;
				if substepiter>=2
					substepiter
					alphahp{substepiter}
					stoprepeater=stoprepeater+1;
					stoprepeater
					1;
					if consistentmultisurfaceconfirmed==1
						1;
					end
					if stoprepeater>=Debugging.DesignatedStopRepeater
						1;
					end
				end
			end
			
			if min(alphahp{substepiter})<0
				disp('alphahp < zero found!')
				1;
				pause
				1;
			end
			if T==1
				[qtest,~]=qandDfromalpha2(alphahp{substepiter},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
				evaltimes=evaltimes+1;
				[ftest,~]=Wood_Schmidt_EvalSigmaEff(sigma{substepiter},qtest,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
				if CellMax(ftest)<NormLimit
					break
				else
					implicithasfailed=1;
					1;
				end
			elseif T>1
				disp('T>1')
				pause
			end
			deltaT=min(deltaT,1-T);
			sigma1=sigma{substepiter};
			alpha1=alphahp{substepiter};
			sigma1trial=sigma1+deltasigmae*deltaT;
			if consistentmultisurfaceconfirmed==1 && implicithasfailed==0
				if implicitsubstepnumber==0
					%disp('Implicit is a go!')
				end
				alphaimpn=alpha1;                
				alphaimp=alphaimpn;
				sigmaimpn=sigma1trial;
				%sigmaimp=transpose([0 0 0 0 0 0]);
				[q,dqdalpha,~]=qandDfromalpha2(alphaimpn,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
				evaltimes=evaltimes+1;
				[f,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigmaimpn,q,[chosensurface1 chosensurface2],[0 1 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
				
				deltagamma1startreference=transpose(dfdsigma{chosensurface1})*sigma1trial/(transpose(dfdsigma{chosensurface1})*C*dfdsigma{chosensurface1});
				deltagamma2startreference=transpose(dfdsigma{chosensurface2})*sigma1trial/(transpose(dfdsigma{chosensurface2})*C*dfdsigma{chosensurface2});

				deltagamma1=deltagamma1startreference;
				deltagamma2=deltagamma2startreference;
				
				sigmaimp=sigma1trial-C*(deltagamma1*dfdsigma{chosensurface1}+deltagamma2*dfdsigma{chosensurface2});
				
				alphaimp(chosensurface1)=alphaimpn(chosensurface1)+deltagamma1;
				alphaimp(chosensurface2)=alphaimpn(chosensurface2)+deltagamma2;
				alphaerrortracker=zeros(1,16);
				for alphaiteration=1:99999
					if alphaiteration==40
						implicithasfailed=1;
						break;
					end
					[q,dqdalpha,~]=qandDfromalpha2(alphaimp,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
					imperrortracker=zeros(1,16);
					for impiteration=1:100
						if impiteration==20
							implicithasfailed=1;
							break;
						end
						evaltimes=evaltimes+1;
						[f,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigmaimp,q,[chosensurface1 chosensurface2],[1 1 0 1 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
						Rimp(1:6,1)=sigmaimp-sigmaimpn+C*(deltagamma1*dfdsigma{chosensurface1}+deltagamma2*dfdsigma{chosensurface2});
						%Rimp(7,1)=alphaimp(chosensurface1)-alphaimpn(chosensurface1)-deltagamma1;
						%Rimp(8,1)=alphaimp(chosensurface2)-alphaimpn(chosensurface2)-deltagamma2;
						Rimp(7,1)=f{chosensurface1};
						Rimp(8,1)=f{chosensurface2};
						Err=sqrt(dot(Rimp,Rimp));
						for i=15:-1:1
							imperrortracker(i+1)=imperrortracker(i);
						end
						imperrortracker(1)=Err;
						if Err<NormLimit
							break
						end
						if impiteration>=16
							[r,m,b]=regression([1:16],log(imperrortracker));
							if m<0
							%if imperrortracker(1)>sum(imperrortracker(2:5))/4;
								%disp('no error improvement, implicit newton terminated');
								implicithasfailed=1;
								break;
							end
						end
						J=zeros(8,8);
						J(1:6,1:6)=eye(6,6)+C*(deltagamma1*d2fdsigma2{chosensurface1}+deltagamma2*d2fdsigma2{chosensurface2});
						J(1:6,7)=C*dfdsigma{chosensurface1};
						J(1:6,8)=C*dfdsigma{chosensurface2};
						%J(7,7)=1;
						%J(8,8)=1;
						%J(7,9)=-1;
						%J(8,10)=-1;
						J(7,1:6)=transpose(dfdsigma{chosensurface1});
						J(8,1:6)=transpose(dfdsigma{chosensurface2});
						%J(9,7)=dqdalpha(chosensurface1);
						%J(10,8)=dqdalpha(chosensurface2);
						if rcond(J)<1e-15
							implicithasfailed=1;
							break;
						end
						deltaX=-(J^-1)*Rimp;
						sigmaimp=sigmaimp+deltaX(1:6,1);
						%alphaimp(chosensurface1)=alphaimp(chosensurface1)+deltaX(7,1);
						%alphaimp(chosensurface2)=alphaimp(chosensurface2)+deltaX(8,1);
						deltagamma1=deltagamma1+deltaX(7,1);
						deltagamma2=deltagamma2+deltaX(8,1);
						%if deltagamma1<0
							%{
							deltagamma1startreference=deltagamma1startreference*2;
							deltagamma1=deltagamma1startreference;
							sigmaimp=sigma1trial-C*(deltagamma1*dfdsigma{chosensurface1}+deltagamma2*dfdsigma{chosensurface2});
							alphaimp(chosensurface1)=alphaimpn(chosensurface1)+deltagamma1;
							%}
							%implicithasfailed=1;
							%break;
						%end
						%if deltagamma2<0
							%{
							deltagamma2startreference=deltagamma2startreference*2;
							deltagamma2=deltagamma2startreference;
							sigmaimp=sigma1trial-C*(deltagamma1*dfdsigma{chosensurface1}+deltagamma2*dfdsigma{chosensurface2});
							alphaimp(chosensurface2)=alphaimpn(chosensurface2)+deltagamma2;
							%}
							%implicithasfailed=1;
							%break;
						%end
						%{
						[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alphaimp);
						[f,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigmaimp,q,chosensurface,[1 1 1 1 0 0]);
						Rimp(1:6,1)=-epsilonpimp+epsilonpimpn+deltagamma*dfdsigma{chosensurface};
						Rimp(7,1)=-alphaimp(chosensurface)+alphaimpn(chosensurface)+deltagamma;
						if impiteration>1 & sqrt(dot(Rimp,Rimp))<NormLimit & f{chosensurface}<NormLimit
							break
						end
						Ainv=zeros(7,7);
						Ainv(1:6,1:6)=(C^-1)+deltagamma*d2fdsigma2{chosensurface};
						Ainv(7,7)=-(1/dqdalpha(chosensurface));
						Aimp=Ainv^-1;
						delta2gamma=(f{chosensurface}-[transpose(dfdsigma{chosensurface}) 1]*Aimp*Rimp)/([transpose(dfdsigma{chosensurface}) 1]*Aimp*[dfdsigma{chosensurface};1]);
						deltaepsilondeltaalpha=[C^-1 zeros(6,1);zeros(1,6) -(1/dqdalpha(chosensurface))]*Aimp*(Rimp+delta2gamma*[dfdsigma{chosensurface};1]);
						epsilonpimp=epsilonpimp+deltaepsilondeltaalpha(1:6);
						alphaimp(chosensurface)=alphaimp(chosensurface)+deltaepsilondeltaalpha(7);
						deltagamma=deltagamma+delta2gamma;
						%}
					end
					if implicithasfailed==1
						break;
					end
					alphaimp1new=alphaimpn(chosensurface1)+deltagamma1;
					alphaimp2new=alphaimpn(chosensurface2)+deltagamma2;
					alphaerror=sqrt((alphaimp(chosensurface1)-alphaimp1new)^2+(alphaimp(chosensurface2)-alphaimp2new)^2);
					for i=15:-1:1
						alphaerrortracker(i+1)=alphaerrortracker(i);
					end
					alphaerrortracker(1)=alphaerror;
					alphaimp(chosensurface1)=alphaimp1new;
					alphaimp(chosensurface2)=alphaimp2new;
					if alphaerror<NormLimit
						break;
					end
					if alphaiteration>=16
						[r,m,b]=regression([1:16],log(alphaerrortracker));
						if m<0
						%if alphaerrortracker(1)>alphaerrortracker(5)
							%disp('no error improvement, alpha iteration terminated');
							implicithasfailed=1;
							break;
						end
					end
				end
				if implicithasfailed==1
					if implicitsubstepnumber<=4
						%disp('Implicit Didnt converge, substepping');
						deltaT=min(deltaT/implicitsubstepfactor,1-T);
						implicithasfailed=0;
						implicitsubstepnumber=implicitsubstepnumber+1;
					else
						%disp('Implicit Didnt converge, switching back');
						implicithasfailed=1;
					end
					continue;
				end
				sigma{substepiter+1}=sigmaimp;
				alphahp{substepiter+1}=alphaimp;
				if deltagamma1>min(0,-alphaimp(chosensurface1)*NormLimit) && deltagamma2>min(0,-alphaimp(chosensurface2)*NormLimit)
					substepiter=substepiter+1;
					T=T+deltaT;
					deltaT=min(1-T,deltaT*min(1.5,10^(implicitsubstepnumber)));
					implicitsubstepnumber=implicitsubstepnumber-(log(1.5)/log(10));
				else
					%disp('deltagamma less than zero!')
					if implicitsubstepnumber<=4
						%disp('Implicit Didnt converge, substepping');
						deltaT=min(deltaT/implicitsubstepfactor,1-T);
						implicithasfailed=0;
						implicitsubstepnumber=implicitsubstepnumber+1;
					else
						%disp('Implicit Didnt converge, switching back')
						implicithasfailed=1;
					end
					1;
				end
				continue;
			end
			[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alpha1,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
			evaltimes=evaltimes+2;
			[f10,~]=Wood_Schmidt_EvalSigmaEff(sigma1,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
			[f1trial,~]=Wood_Schmidt_EvalSigmaEff(sigma1trial,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
			elastic=1;
			for i=1:7
				if f1trial{i}>0 && f1trial{i}>f10{i}
					alphafact(i)=(f10{i}/(f10{i}-f1trial{i}));
					elastic=0;
				else
					if f1trial{i}>0
						%disp(['Warning for spid=' num2str(spid) ': f1trial{' num2str(i) '}>0 but <f10{' num2str(i) '}, special treatment is assumed']);
						%disp('Press any key to continue');
						%pause;
						alphafact(i)=-f10{i};
						elastic=0;
						1;
					else
						alphafact(i)=1;
					end
				end
			end
			if elastic
				%disp('Turns Out to be Elastic on deltalambda1');
				deltalambda1=0;
				deltalambdanice=0;
				deltasigmanice=0;
				sigma{substepiter+1}=sigma1trial;
				T=T+deltaT;
				alphahp{substepiter+1}=alphahp{substepiter};
				substepiter=substepiter+1;
				qfordeltaT=2;
				deltaT=deltaT*qfordeltaT;
				continue;
			else
				alphafactchosen=min(alphafact);
				if alphafactchosen~=1
					for i=1:7
						if alphafactchosen==alphafact(i)
							chosensurface=i;
						end
					end
				end
				alphafactchosen=max(0,alphafactchosen);
				evaltimes=evaltimes+1;
				[DUMMY,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigma1,q,chosensurface,[0 1 1 1 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
				A1=-dfdqchosen{chosensurface}(chosensurface)*dqdalpha(chosensurface);
				%A1=-dfdqchosen{chosensurface}(chosensurface)*dqdalpha(chosensurface)*([1 1 1 1 1 1])*dfdsigma{chosensurface};
				B=transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface};
				%deltalambda1=(transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,(2*deltaT/(1-T))*f10{chosensurface}))/(A1+B);
				deltalambda1=(transpose(dfdsigma{chosensurface})*deltasigmae*deltaT)/(A1+B);
				deltalambdanice=f10{chosensurface}/(A1+B);
				deltasigmanice=-C*deltalambdanice*dfdsigma{chosensurface};
				chosensurface1=chosensurface;
			end
			%recalculating dfdsigma and dfdq
			
			%end of recalculating dfdsigma and dfdq
			
			%deltalambdadrift=f10{chosensurface};
			%deltalambda1=(transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,deltaT*fprev{chosensurface}))/(A1+B);
			deltalambda1ok=1;
			if deltalambda1<0
				%disp('deltalambda1<0!')
				if A1+B<0
					%disp('A<B!')
					%deltaTbackup=deltaT;
					%deltaT=0;
					%printvector(substepiter,'substepiter');
					%printvector(chosensurface,'chosensurface');
					%printvector(alphafactchosen,'alphafactchosen');
					%printvector(sigma{substepiter},'sigma{substepiter}');
					%printvector(alphahp{substepiter},'alphahp{substepiter}');
					%uisave;
					Aq1=0.5*transpose(C*dfdsigma{chosensurface})*(d2fdsigma2{chosensurface})*(C*dfdsigma{chosensurface})+0.5*d2qdalpha2(chosensurface);
					%Bq1=dqdalpha(chosensurface)-transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}-transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*(deltasigmae*deltaT);
					%Cq1=transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,(2*deltaT/(1-T))*f10{chosensurface})+0.5*transpose(deltasigmae*deltaT)*d2fdsigma2{chosensurface}*(deltasigmae*deltaT);
					%Cq1=transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,deltaT*fprev{chosensurface})+0.5*transpose(deltasigmae*deltaT)*d2fdsigma2{chosensurface}*(deltasigmae*deltaT);
					Pq1=(-transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae)^2+(-2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*C*dfdsigma{chosensurface}-2*d2qdalpha2(chosensurface))*(1/2)*transpose(deltasigmae)*d2fdsigma2{chosensurface}*deltasigmae;
					Qq1=2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae*(transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}-dqdalpha(chosensurface))+(-2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*C*dfdsigma{chosensurface}-2*d2qdalpha2(chosensurface))*transpose(dfdsigma{chosensurface})*deltasigmae;
					Rq1=(-transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}+dqdalpha(chosensurface))^2+(-2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*C*dfdsigma{chosensurface}-2*d2qdalpha2(chosensurface))*f10{chosensurface};
					if Rq1<=0
						deltalambda1=0;
					else
						Kq1=-(Pq1/(2*sqrt(Rq1))-Qq1^2/(8*Rq1*sqrt(Rq1)))/(2*Aq1);
						Lq1a=(transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae-Qq1/(2*sqrt(Rq1)))/(2*Aq1);
						Lq1b=(transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae+Qq1/(2*sqrt(Rq1)))/(2*Aq1);
						Lq1=max(Lq1a,Lq1b);
						Mq1=(transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}-dqdalpha(chosensurface)-sqrt(Rq1))/(2*Aq1);
						%deltalambda1=(-Bq1-sqrt(Bq1^2-4*Aq1*Cq1))/(2*Aq1);
						%deltalambda1=Kq1*deltaT^2+Lq1*deltaT+Mq1;
						%deltalambda1=Kq1*deltaT^2+Lq1*deltaT+(200*deltaT/(1-T))*Mq1;
						%deltalambda1=Kq1*deltaT^2+Lq1*deltaT;
						deltalambda1=Lq1*deltaT;
						if deltalambda1<0
							deltalambda1=0;
						end
					end
					%deltalambdadrift=Mq1;
					%disp('deltalambda1 not ok');
					deltalambda1ok=0;
				else
					deltalambda1=0;
				end
			end
			
			%intermediate for calculating alphahp nice
			deltasigma1=deltasigmae*deltaT-deltalambda1*C*dfdsigma{chosensurface};
			deltaalpha1=[0 0 0 0 0 0 0];
			deltaalpha1(chosensurface)=deltalambda1;
			% start of deltalambdaok
			%if deltalambda1ok
			sigma2=sigma1+deltasigma1;
			alpha2=alpha1+deltaalpha1;
			[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alpha2,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
			evaltimes=evaltimes+1;
			[f20,~]=Wood_Schmidt_EvalSigmaEff(sigma2,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
			%alphanice=f20{chosensurface}/f10{chosensurface};
			%deltalambda1=deltalambda1+alphanice*deltalambdadrift;
			%deltasigmanice=-deltalambdadrift*C*dfdsigma{chosensurface}
			%end of intermediate for calculating alphahp nice
			
			%deltasigma1=deltasigmae*deltaT-deltalambda1*C*dfdsigma{chosensurface};
			%deltaalpha1=[0 0 0 0 0 0 0];
			%deltaalpha1(chosensurface)=deltalambda1;
			% start of deltalambdaok
			%if deltalambda1ok
			%sigma2=sigma1+deltasigma1;%+alphanice*deltasigmanice;
			%alpha2=alpha1+deltaalpha1;%+alphanice*deltalambdadrift;
			%[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alpha2);
			%[f20,dfdsigma,dfdqchosen,~]=Wood_Schmidt_EvalSigmaEff(sigma2,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
			sigma2trial=sigma2+deltasigmae*deltaT;
			evaltimes=evaltimes+1;
			[f2trial,~]=Wood_Schmidt_EvalSigmaEff(sigma2trial,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
			elastic=1;
			for i=1:7
				if f2trial{i}>0 && f2trial{i}>f20{i}
					alphafact(i)=(f20{i}/(f20{i}-f2trial{i}));
					elastic=0;
				else
					if f2trial{i}>0
						%disp(['Warning for spid=' num2str(spid) ': f2trial{' num2str(i) '}>0 but <f20{' num2str(i) '}, special treatment is assumed']);
						%disp('Press any key to continue');
						%pause;
						alphafact(i)=-f20{i};
						elastic=0;
						1;
					else
						alphafact(i)=1;
					end
				end
				
			end
			if elastic
				%disp('Turns Out to be Elastic on deltalambda2');
				deltalambda2=0;
			else
				alphafactchosen=min(alphafact);
				if alphafactchosen~=1
					for i=1:7
						if alphafactchosen==alphafact(i)
							chosensurface=i;
						end
					end
				end
				if implicithasfailed && deltaT<1e-3
					chosensurface=chosensurface1;
				end
				alphafactchosen=max(0,alphafactchosen);
				evaltimes=evaltimes+1;
				[DUMMY,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigma2,q,chosensurface,[0 1 1 1 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
				A2=-dfdqchosen{chosensurface}(chosensurface)*dqdalpha(chosensurface);
				%A2=-dfdqchosen{chosensurface}(chosensurface)*dqdalpha(chosensurface)*([1 1 1 1 1 1])*dfdsigma{chosensurface};
				B=transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface};
				%deltalambda2=(transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,(2*deltaT/(1-T))*f20{chosensurface}))/(A2+B);
				deltalambda2=(transpose(dfdsigma{chosensurface})*deltasigmae*deltaT)/(A2+B);
				%deltalambda2=(transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,deltaT*fprev{chosensurface}))/(A2+B);
				chosensurface2=chosensurface;
			end
			deltalambda2ok=1;


			if deltalambda2<0
				%disp('deltalambda2<0!')
				if A2+B<0
					%printvector(substepiter,'substepiter');
					%printvector(chosensurface,'chosensurface');
					%printvector(alphafactchosen,'alphafactchosen');
					%printvector(sigma{substepiter},'sigma{substepiter}');
					%printvector(alphahp{substepiter},'alphahp{substepiter}');
					Aq2=0.5*transpose(C*dfdsigma{chosensurface})*(d2fdsigma2{chosensurface})*(C*dfdsigma{chosensurface})+0.5*d2qdalpha2(chosensurface);
					%Bq2=dqdalpha(chosensurface)-transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}-transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*(deltasigmae*deltaT);
					%Cq2=transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,(2*deltaT/(1-T))*f20{chosensurface})+0.5*transpose(deltasigmae*deltaT)*d2fdsigma2{chosensurface}*(deltasigmae*deltaT);
					%Cq2=transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,deltaT*fprev{chosensurface})+0.5*transpose(deltasigmae*deltaT)*d2fdsigma2{chosensurface}*(deltasigmae*deltaT);
					Pq2=(-transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae)^2+(-2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*C*dfdsigma{chosensurface}-2*d2qdalpha2(chosensurface))*(1/2)*transpose(deltasigmae)*d2fdsigma2{chosensurface}*deltasigmae;
					Qq2=2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae*(transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}-dqdalpha(chosensurface))+(-2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*C*dfdsigma{chosensurface}-2*d2qdalpha2(chosensurface))*transpose(dfdsigma{chosensurface})*deltasigmae;
					Rq2=(-transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}+dqdalpha(chosensurface))^2+(-2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*C*dfdsigma{chosensurface}-2*d2qdalpha2(chosensurface))*f20{chosensurface};
					if Rq2<=0
						deltalambda2=0;
					else
						Kq2=-(Pq2/(2*sqrt(Rq2))-Qq2^2/(8*Rq2*sqrt(Rq2)))/(2*Aq2);
						Lq2a=(transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae-Qq2/(2*sqrt(Rq2)))/(2*Aq2);
						Lq2b=(transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae+Qq2/(2*sqrt(Rq2)))/(2*Aq2);
						Lq2=max(Lq2a,Lq2b);
						Mq2=(transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}-dqdalpha(chosensurface)-sqrt(Rq2))/(2*Aq2);
						%deltalambda1=(-Bq1-sqrt(Bq1^2-4*Aq2*Cq2))/(2*Aq2);
						%deltalambda1=Kq2*deltaT^2+Lq2*deltaT+Mq2;
						%deltalambda2=Kq2*deltaT^2+Lq2*deltaT+(200*deltaT/(1-T))*Mq2;
						%deltalambda2=Kq2*deltaT^2+Lq2*deltaT;
						%deltalambda2ok=0;
						deltalambda2=Lq2*deltaT;
						if deltalambda2<0
							deltalambda2=0;
						end
					end
					%disp('deltalambda2 not ok');
					deltalambda2ok=0;
					%uisave;
				else
					deltalambda2=0;
				end
			end
			%if deltalambda2ok
			deltasigma2=deltasigmae*deltaT-deltalambda2*C*dfdsigma{chosensurface};
			deltaalpha2=[0 0 0 0 0 0 0];
			deltaalpha2(chosensurface)=deltalambda2;%+alphanice*deltalambdadrift;
			E=0.5*(-deltasigma1+deltasigma2);
			
			sigma{substepiter+1}=sigma{substepiter}+0.5*(deltasigma1+deltasigma2);
			if deltalambda1ok && deltalambda2ok && (deltaT>0 || deltalambdanice>0)
				sigma{substepiter+1}=sigma{substepiter+1}+deltasigmanice;
				R=sqrt(dot(E,E))/sqrt(dot(sigma{substepiter+1},sigma{substepiter+1}));
			else
				sigmaimplicitstart=sigma{substepiter+1};
				R=sqrt(dot(E,E))/sqrt(dot(sigma{substepiter+1}+deltasigmanice,sigma{substepiter+1}+deltasigmanice));
			end
			
			surfacehistory(chosensurface1)=1;
			surfacehistory(chosensurface2)=1;

			%{
			if sqrt(dot(deltasigmanice,deltasigmanice))>1;
				1;
			end
			%}
			
			%end
			%else
			%    sigma{substepiter+1}=sigma{substepiter}+deltasigma1;
			%    R=0;
			%end
				
			% end of delta lambda OK
			
			if R>NormLimit
				qfordeltaT=max(0.8*sqrt(NormLimit/R),0.1);
				deltaT=deltaT*qfordeltaT;
				%disp(['deltaT reduced to ' num2str(deltaT)]);
			else
				T=T+deltaT;
				if deltalambda1ok & deltalambda2ok && (deltaT>0 || deltalambdanice>0)
				%if deltalambda1ok
					deltaalphataken=0.5*(deltaalpha1+deltaalpha2);
					alphahp{substepiter+1}=alphahp{substepiter}+deltaalphataken;
					deltalambdanice=max([deltalambdanice -deltaalphataken(chosensurface1)]);
					alphahp{substepiter+1}(chosensurface1)=alphahp{substepiter+1}(chosensurface1)+deltalambdanice;
				%else
				%    alphahp{substepiter+1}=alphahp{substepiter}+(deltaalpha1);
				%end
				else
					alphaimplicitstart=alphahp{substepiter}+0.5*(deltaalpha1+deltaalpha2);
					[q,~]=qandDfromalpha2(alphaimplicitstart,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
					evaltimes=evaltimes+1;
					[fimplicitstart,~]=Wood_Schmidt_EvalSigmaEff(sigmaimplicitstart,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);

					sigmaimplicitstarttrial=sigmaimplicitstart+deltasigmae*deltaT;
					evaltimes=evaltimes+1;
					[fimplicitstarttrial,~]=Wood_Schmidt_EvalSigmaEff(sigmaimplicitstarttrial,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
					for i=1:7
						if fimplicitstarttrial{i}<=0
							alphafact(i)=1;
						else
							alphafact(i)=(fimplicitstart{i}/(fimplicitstart{i}-fimplicitstarttrial{i}));
							if alphafact(i)>1
								alphafact(i)=-fimplicitstarttrial{i};
							end
						end
					end
					if chosensurface1==chosensurface2
						chosensurface=chosensurface1;
					elseif deltalambda1ok==0 && deltalambda2ok==1
						chosensurface=chosensurface1;
					elseif deltalambda1ok==1 && deltalambda2ok==0
						chosensurface=chosensurface2;
					else
						alphafactchosen=min(alphafact);
						if alphafactchosen~=1
							for i=1:7
								if alphafactchosen==alphafact(i)
									chosensurface=i;
								end
							end
						end
					end
					surfacehistory(chosensurface)=1;
					%{
					if chosensurface1==chosensurface2
						chosensurface=chosensurface1;
					else
						if deltalambda1ok==0 & deltalambda2ok==0
							disp('warning: ambiguous choice of chosensurface for implicit correction');
							uisave;
							chosensurface=chosensurface2;
						elseif deltalambda1ok==0
							chosensurface=chosensurface1;
						elseif deltalambda2ok==0
							chosensurface=chosensurface2;
						else
							disp('unexpected error here');
							uisave;
						end
					end
					%}
					1;
					% start of deltalambda guess (alphahp-widening)
					if CellMax(fimplicitstart)>0
						[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alphaimplicitstart,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
						evaltimes=evaltimes+1;
						[fimplicitstart,dfdsigma,dfdqchosen,~]=Wood_Schmidt_EvalSigmaEff(sigmaimplicitstart,q,chosensurface,[1 1 1 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
						if deltaT==0
							deltalambdaguess=1.1*transpose(dfdsigma{chosensurface})*deltaepsilone*(NormLimit^2)/(transpose(dfdsigma{chosensurface})*dfdsigma{chosensurface});
						else
							deltalambdaguess=1.1*transpose(dfdsigma{chosensurface})*deltaepsilone*deltaT/(transpose(dfdsigma{chosensurface})*dfdsigma{chosensurface});
						end
						if deltalambdaguess<=0
							%disp('deltalambdaguess<0!')
							if deltaT==0
								deltalambdaguess=-0.1*transpose(dfdsigma{chosensurface})*deltaepsilone*(NormLimit^2)/(transpose(dfdsigma{chosensurface})*dfdsigma{chosensurface});
							else
								deltalambdaguess=-0.1*transpose(dfdsigma{chosensurface})*deltaepsilone*deltaT/(transpose(dfdsigma{chosensurface})*dfdsigma{chosensurface});
							end
							%deltalambdaguess=-0.1*transpose(dfdsigma{chosensurface})*deltaepsilone*deltaT/(transpose(dfdsigma{chosensurface})*dfdsigma{chosensurface});
						end
						for wideningiteration=1:99999
							alphawidened=alphaimplicitstart;
							alphawidened(chosensurface)=alphaimplicitstart(chosensurface)+deltalambdaguess;
							sigmawidened=sigmaimplicitstart-C*deltalambdaguess*dfdsigma{chosensurface};
							[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alphawidened,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
							evaltimes=evaltimes+1;
							[fimplicitstart,dfdsigma,~]=Wood_Schmidt_EvalSigmaEff(sigmawidened,q,chosensurface,[1 1 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
							if fimplicitstart{chosensurface}<0
								break
							else
								deltalambdaguess=deltalambdaguess*1.1;
							end
						end
						
						% end of deltalambda guess
					end
					
					% start of implicit iteration
					%{
					epsilontimp=epsilont+T*deltaepsilon;
					epsiloneimp=(C^-1)*sigmaimplicitstart;
					epsilonpimpn=epsilontimp-epsiloneimp;
					epsilonpimp=epsilontimp-epsiloneimp;
					%}
					alphaimpn=alphaimplicitstart;                
					alphaimp=alphawidened;
					sigmaimpn=sigmaimplicitstart;
					sigmaimp=sigmawidened;
					deltagamma=0;
					for impiteration=1:99999
						[q,dqdalpha,~]=qandDfromalpha2(alphaimp,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
						evaltimes=evaltimes+1;
						[f,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigmaimp,q,chosensurface,[1 1 0 1 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
						Rimp(1:6,1)=sigmaimp-sigmaimpn+C*deltagamma*dfdsigma{chosensurface};
						Rimp(7,1)=alphaimp(chosensurface)-alphaimpn(chosensurface)-deltagamma;
						Rimp(8,1)=f{chosensurface};
						Err=sqrt(dot(Rimp,Rimp));
						if Err<NormLimit
							break
						end
						J=zeros(8,8);
						J(1:6,1:6)=eye(6,6)+C*deltagamma*d2fdsigma2{chosensurface};
						J(1:6,8)=C*dfdsigma{chosensurface};
						J(7,7)=1;
						J(7,8)=-1;
						J(8,1:6)=transpose(dfdsigma{chosensurface});
						J(8,7)=dqdalpha(chosensurface);
						deltaX=-(J^-1)*Rimp;
						sigmaimp=sigmaimp+deltaX(1:6,1);
						alphaimp(chosensurface)=alphaimp(chosensurface)+deltaX(7,1);
						deltagamma=deltagamma+deltaX(8,1);
						%{
						[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alphaimp);
						[f,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigmaimp,q,chosensurface,[1 1 1 1 0 0]);
						Rimp(1:6,1)=-epsilonpimp+epsilonpimpn+deltagamma*dfdsigma{chosensurface};
						Rimp(7,1)=-alphaimp(chosensurface)+alphaimpn(chosensurface)+deltagamma;
						if impiteration>1 & sqrt(dot(Rimp,Rimp))<NormLimit & f{chosensurface}<NormLimit
							break
						end
						Ainv=zeros(7,7);
						Ainv(1:6,1:6)=(C^-1)+deltagamma*d2fdsigma2{chosensurface};
						Ainv(7,7)=-(1/dqdalpha(chosensurface));
						Aimp=Ainv^-1;
						delta2gamma=(f{chosensurface}-[transpose(dfdsigma{chosensurface}) 1]*Aimp*Rimp)/([transpose(dfdsigma{chosensurface}) 1]*Aimp*[dfdsigma{chosensurface};1]);
						deltaepsilondeltaalpha=[C^-1 zeros(6,1);zeros(1,6) -(1/dqdalpha(chosensurface))]*Aimp*(Rimp+delta2gamma*[dfdsigma{chosensurface};1]);
						epsilonpimp=epsilonpimp+deltaepsilondeltaalpha(1:6);
						alphaimp(chosensurface)=alphaimp(chosensurface)+deltaepsilondeltaalpha(7);
						deltagamma=deltagamma+delta2gamma;
						%}
					end
					sigma{substepiter+1}=sigmaimp;
					alphahp{substepiter+1}=alphaimp;

					% end of implicit iteration
				end
				substepiter=substepiter+1;
				%if deltalambda1ok
					qfordeltaT=min(0.8*sqrt(NormLimit/R),2);
					deltaT=deltaT*qfordeltaT;
				%else
				%    deltaT=deltaTbackup;
				%end
			end
			if exist('chosensurface1') && exist('chosensurface2') && chosensurface1~=chosensurface2
				for i=size(last5surfaces,1):-1:2
					last5surfaces(i,:)=last5surfaces(i-1,:);
				end
				if chosensurface1<chosensurface2
					last5surfaces(1,1)=chosensurface1;
					last5surfaces(1,2)=chosensurface2;
				else
					last5surfaces(1,1)=chosensurface2;
					last5surfaces(1,2)=chosensurface1;
				end
				%disp(['different surfaces carried out, ' num2str(chosensurface1) ' and ' num2str(chosensurface2) ', deltaT=' num2str(deltaT)]);
				consistentmultisurfaceconfirmed=1;
				for i=2:size(last5surfaces,1)
					if last5surfaces(1,1)~=last5surfaces(i,1) || last5surfaces(1,2)~=last5surfaces(i,2)
						consistentmultisurfaceconfirmed=0;
						break;
					end
				end
			end
			%{
			implicitsubstepnumber=0;
			implicithasfailed=0;
			%}
			if consistentmultisurfaceconfirmed==1 && implicithasfailed==0
				deltaT=1-T;
			end
		end
	end
		
	1;
	
	%hardeningsurfacesoriginal=hardeningsurfaces;
	
	%iteration=0;
	%{
	substepnum=10;
	deltaepsilonsubstep=deltaepsilon/substepnum;
	
	
	for substepiter=1:substepnum
		%deltaepsilon=transpose([1*sin(step/100*2*pi) 1*cos(step/100*2*pi) 1/100*step 1*sin(step/100*2*pi) 1*cos(step/100*2*pi) 1/100*step])/1000;
		[q,Dcut]=qandDfromalpha(alphahp{substepiter},hardeningsurfaces);
		sigmatrial=sigma{substepiter}+C*deltaepsilonsubstep;
		evaltimes=evaltimes+2;
		[ftrial,~,~]=Wood_Schmidt_EvalSigmaHardening(sigmatrial,q,hardeningsurfaces);
		[fprev,~,~]=Wood_Schmidt_EvalSigmaHardening(sigma{substepiter},q,hardeningsurfaces);
		elastic=1;
		for i=1:7
			if ftrial{i}<=0
				alphafact(i)=1;
			%elseif fprev{i}<=0 & ftrial{i}>0
			%    alphafact(i)=(fprev{i}/(fprev{i}-ftrial{i}));
			%else
			%    alphafact(i)=0;
			else
				alphafact(i)=(fprev{i}/(fprev{i}-ftrial{i}));
				elastic=0;
			end
		end
		if elastic
			sigma{substepiter+1}=sigmatrial;
			alphahp{substepiter+1}=alphahp{substepiter};
		else
			alphafactchosen=min(alphafact);
			for i=1:7
				if alphafactchosen==alphafact(i)
					chosensurface=i;
					break;
				end
			end
			alphafactchosen=max(0,alphafactchosen);
			sigmaalpha=sigma{substepiter}+(sigmatrial-sigma{substepiter})*alphafactchosen;
			[q,Dchosen]=qandDfromalpha(alphahp{substepiter},chosensurface);
			[DUMMY,dfdsigma,dfdqchosen,~]=Wood_Schmidt_EvalSigmaHardening(sigmaalpha,q,chosensurface);
			A=dfdqchosen{chosensurface}*Dchosen;
			deltaepsilonsubstepalpha=deltaepsilonsubstep*(1-alphafactchosen);
			deltalambda=transpose(dfdsigma{chosensurface})*C/(A+transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface})*deltaepsilonsubstepalpha;
			if deltalambda<0
				disp('deltalambda<0!')
				printvector(substepiter,'substepiter');
				printvector(chosensurface,'chosensurface');
				printvector(alphafactchosen,'alphafactchosen');
				printvector(sigma{substepiter},'sigma{substepiter}');
				printvector(alphahp{substepiter},'alphahp{substepiter}');
				pause
			end
			Cp=C*dfdsigma{chosensurface}*transpose(dfdsigma{chosensurface})*C/(A+transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface});
			Cep=C-Cp;
			alphahp{substepiter+1}=alphahp{substepiter};
			alphahp{substepiter+1}(chosensurface)=alphahp{substepiter}(chosensurface)+deltalambda;
			sigma{substepiter+1}=sigmaalpha+Cep*deltaepsilonsubstepalpha;
		end
	end
	%}
	[q,~]=qandDfromalpha2(alphahp{substepiter},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
	evaltimes=evaltimes+1;
	[f_final,~]=Wood_Schmidt_EvalSigmaEff(sigma{substepiter},q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
	[f_maxfinal,surfacewithfmax]=CellMax(f_final);
	for i=1:7
		f_final_vect(i)=f_final{i};
	end
	epsilone=Comp*sigma{substepiter};
	epsilont=epsilont+deltaepsilon;
	epsilonp=epsilont-epsilone;
	epsilonp_planestrain=epsilonp;
	if planestressmod
		epsilonp=zeros(6,1);
		for i=1:6
			if i==zdir||i==yzdir||i==xzdir
				continue;
			end
			if planestressmod==2
				if i==ydir||i==xydir
					continue;
				end
			end
			epsilonp(i,1)=epsilonp_planestrain(i,1);
		end
	end
	epsilont=epsilone+epsilonp;

	1;

	%{
	disp('From Previous Step')
	printvector(sigma0,'sigma');
	printvector(epsilonp{step},'epsilonp')
	printvector(epsilont{step}-epsilonp{step},'epsilone');
	printvector(epsilont{step},'epsilont');
	printvector(alphahp{step},'alphahp');
	print11cell(fprev,'f');
	disp(' ')
	printvector(deltaepsilon,'applying deltaepsilon');

	for i=1:7
		if ftrial{i}>0
			elastic=0;
			suspectedsurfaces=[suspectedsurfaces i];
		end
	end
	if elastic
		for i=1:6
			sigma(i,1)=sigmatrial(i);
			%sigmastep(i,step+1)=sigmatrial(i);
		end
		for i=1:7
			fstep(i,step+1)=ftrial{i};
		end
	else
		activesurface=suspectedsurfaces;
		for shediter=1:length(suspectedsurfaces)
			for i=1:length(activesurface)
				reversedactivesurface(1+length(activesurface)-i)=activesurface(i);
			end
			%activesurface=reversedactivesurface;
			sigma=sigmatrial;
			deltagamma=[];
			for i=1:length(activesurface)
				deltagamma(i)=0;
			end
			%start of iteration
			%hardeningsurfaces=[];
			
			
			[q,Dcut]=qandDfromalpha(alphahp{step+1},hardeningsurfaces);
			[f, dfdsigma, dfdqcut, d2fdsigma2, d2fdsigmadqcut, d2fdq2cut]=Wood_Schmidt_EvalSigmaHardening(sigma,q,hardeningsurfaces);
			%q=[ 0.33427665424966501728221146549913, -0.0077191419876790618273584205447933, 0, -0.0077191419876790618273584205447933, 0, -0.10020040080160320641282565130261, -0.0077191419876790618273584205447933];
			%q=[ 0.95, -0.0077191419876790618273584205447933, 0, -0.0077191419876790618273584205447933, 0, -0.10020040080160320641282565130261, -0.0077191419876790618273584205447933];
			%sigma=transpose([0 0 0 0 0 0])
			%sigma=sigma-C*(dfdsigma{1}*0.0037143167443528112177386635295306);
			disp(' ')
			disp('Guess #1, assuming all elastic, deltaepsilone=deltaepsilon')
			
			
	%start of wojtek print
	
	printvector(sigma,'sigma')
	printvector(epsilonp{step+1},'epsilonp')
	printvector(epsilont{step+1}-epsilonp{step+1},'epsilone')
	printvector(epsilont{step+1},'epsilont')
	printvector(alphahp{step+1},'alphahp',activesurface)
	print11cell(f,'f',activesurface)

	%end of wojtek print
			disp(' ');
			disp('Guess #2, assuming all plastic, deltaeisplonp=deltaepsilon');
			
	
			for i=1:length(activesurface)
				%deltagamma(alphaiter)=transpose(deltaepsilon)*dfdsigma{1}/(transpose(dfdsigma{1})*dfdsigma{1});
				deltagamma(i)=f{activesurface(i)}/(transpose(C*dfdsigma{activesurface(i)})*dfdsigma{activesurface(i)});
				alphahp{step+1}(activesurface(i))=alphahp{step}(activesurface(i))+deltagamma(i);
				disp(['best guess of deltaalpha for ' surfacenumtoname(activesurface(i)) ' (surface #' num2str(activesurface(i)) ') = ' num2str(alphahp{step+1}(activesurface(i)))]);
			end

			%start of backforthloop
			for backforthloop=1:999
				%start of alphaexpansion loop
				disp(' ');
				disp(' ');
				disp(['trial #' num2str(backforthloop)]);
				for alphaiter=1:length(activesurface)
					disp([' ']);
					disp(['active surface ' num2str(alphaiter) '/' num2str(length(activesurface)) ' : ' surfacenumtoname(activesurface(alphaiter)) ' (#' num2str(activesurface(alphaiter)) ')']);
					if f{activesurface(alphaiter)}<=0
						disp(' ')
						disp(['f{' num2str(activesurface(alphaiter)) '} already less than zero'])
						disp(['sticking with alphahp(' num2str(activesurface(alphaiter)) ')=' num2str(alphahp{step+1}(activesurface(alphaiter)))]);
						continue
					end
					
					disp(' ')
					%disp(['trial #' num2str(alphaguesstry2)]);
					alphaguesstry2=[];
					alphahp{step+1}(activesurface(alphaiter))=alphahp{step}(activesurface(alphaiter))+deltagamma(alphaiter);
					[q,~]=qandDfromalpha(alphahp{step+1},hardeningsurfaces);
					deltaepsilonp=transpose([0 0 0 0 0 0]);
					for i=1:length(activesurface)
						deltaepsilonp=deltaepsilonp+deltagamma(i)*dfdsigma{activesurface(i)};
					end
					epsilonp{step+1}=epsilonp{step}+deltaepsilonp;
					sigma=sigmatrial-C*deltaepsilonp;
					[f,dfdsigma]=Wood_Schmidt_EvalSigmaHardening(sigma,q,hardeningsurfaces);

					%start of wojtek print

					printvector(sigma,'sigma')
					printvector(epsilonp{step+1},'epsilonp')
					printvector(epsilont{step+1}-epsilonp{step+1},'epsilone')
					printvector(epsilont{step+1},'epsilont')
					printvector(alphahp{step+1},'alphahp',activesurface)
					print11cell(f,'f',activesurface)


					%end of wojtek print

					if f{(activesurface(alphaiter))}<0
						disp(' ')
						disp(['take alphahp(' num2str(activesurface(alphaiter)) ')=' num2str(alphahp{step+1}(activesurface(alphaiter)))]);
						break
					else
						deltagamma(alphaiter)=deltagamma(alphaiter)*1.2;
						disp(['multiplying deltaalpha of surface ' num2str(alphaiter) '/' num2str(length(activesurface)) ' by 1.2'])
						alphahp{step+1}(activesurface(alphaiter))=alphahp{step}(activesurface(alphaiter))+deltagamma(alphaiter);
						printvector(alphahp{step+1},'alphahp',activesurface)
					end
				end        
				%end of alphahp expansion loop
				alphaexpansionbreaksignal=1;
				for i=1:length(activesurface)
					if f{activesurface(i)}>0
						alphaexpansionbreaksignal=0;
					end
				end
				if alphaexpansionbreaksignal==1
					disp('all f are < 0');
					break
				end
			end
			%end of backforthloop
			%sigma=transpose([0 0 0 0 0 0]);
			disp(' ')
			texttodisplay=['starting newton-rhapson from guess #2, initial sigma=['];
			for i=1:length(sigma);
				if i>1
					texttodisplay=[texttodisplay ','];
				end
				texttodisplay=[texttodisplay num2str(sigma(i))];
			end
			texttodisplay=[texttodisplay ']'];
			disp(texttodisplay);
			deltagamma=zeros(1,length(activesurface));
			alphahp{step+1}=alphahp{step};
			[q,~]=qandDfromalpha(alphahp{step+1},hardeningsurfaces);
			for iteration=1:999
				if step==94
				end
				[f, dfdsigma, dfdqcut, d2fdsigma2, d2fdsigmadqcut, d2fdq2cut]=Wood_Schmidt_EvalSigmaHardening(sigma,q,hardeningsurfaces);
				sigmadeltagammadfdsigmadfdq=zeros(6+length(hardeningsurfaces),1);
				for i=1:length(activesurface)
					sigmadeltagammadfdsigmadfdq=sigmadeltagammadfdsigmadfdq+deltagamma(i)*[dfdsigma{activesurface(i)};dfdqcut{activesurface(i)}];
				end
				epsilonandalphavector=[-epsilonp{step+1}+epsilonp{step}];
				for i=1:length(hardeningsurfaces)
					epsilonandalphavector=[epsilonandalphavector;-alphahp{step+1}(hardeningsurfaces(i))+alphahp{step}(hardeningsurfaces(i))];
				end
				R=epsilonandalphavector+sigmadeltagammadfdsigmadfdq;
				BigR=[R];
				for i=1:length(activesurface);
					BigR=[BigR;f{activesurface(i)}];
				end
				Norm=sqrt(dot(BigR,BigR));
				%disp(['Norm=' num2str(Norm)]);
				if length(activesurface)>1
				end
				Cep=Cepcalc(C,deltagamma,dfdsigma,d2fdsigma2,activesurface);
				if Norm<NormLimit
					break
				end
				%Calculating A
				sigmadeltagammad2fdsigma2dsigmadqdqdsigmadq2=zeros(length(epsilonandalphavector),length(epsilonandalphavector));
				for i=1:length(activesurface)
					sigmadeltagammad2fdsigma2dsigmadqdqdsigmadq2=sigmadeltagammad2fdsigma2dsigmadqdqdsigmadq2+deltagamma(i)*[d2fdsigma2{activesurface(i)} d2fdsigmadqcut{activesurface(i)};transpose(d2fdsigmadqcut{activesurface(i)}) d2fdq2cut{activesurface(i)}];
				end
				Ainv=[C^-1 zeros(6,length(hardeningsurfaces));zeros(length(hardeningsurfaces),6) Dcut^-1]+sigmadeltagammad2fdsigma2dsigmadqdqdsigmadq2;
				A=Ainv^-1;
				Gdown=[];
				Gup=[];
				if step==30
				end
				for alphaindex=1:length(activesurface)
					for beta=1:length(activesurface)
						Gdown(alphaindex,beta)=transpose([dfdsigma{activesurface(alphaindex)};dfdqcut{activesurface(alphaindex)}])*A*[dfdsigma{activesurface(beta)};dfdqcut{activesurface(beta)}];
						%Gup(alphaindex,beta)=1/Gdown(alphaindex,beta);
					end
				end
				Gup=Gdown^-1;
				delta2gamma=[];
				for alphaindex=1:length(activesurface)
					delta2gamma(alphaindex)=0;
					for beta=1:length(activesurface)
						delta2gamma(alphaindex)=delta2gamma(alphaindex)+Gup(alphaindex,beta)*(f{activesurface(beta)}-transpose([dfdsigma{activesurface(beta)};dfdqcut{activesurface(beta)}])*A*R);
					end
				end
				if delta2gamma>0 & iteration==1
					if length(activesurface)==1
						if activesurface==[1];
						end
					end
				end
				deltagamma=deltagamma+delta2gamma;
				shedsignal=0;
				newactivesurface=[];
				%{
				for i=1:length(deltagamma)
					if deltagamma(i)<0
						shedsignal=1;
					else
						newactivesurface=[newactivesurface activesurface(i)];
					end
				end
				if shedsignal==1
					activesurface=newactivesurface;
					break
				end
				%}
				sigmadelta2gammadfdsigmadfdq=zeros(length(epsilonandalphavector),1);
				for beta=1:length(activesurface)
					sigmadelta2gammadfdsigmadfdq=sigmadelta2gammadfdsigmadfdq+delta2gamma(beta)*[dfdsigma{activesurface(beta)};dfdqcut{activesurface(beta)}];
				end
				deltaepsilonpdeltaalpha=[C^-1 zeros(6,length(hardeningsurfaces));zeros(length(hardeningsurfaces),6) Dcut^-1]*A*(R+sigmadelta2gammadfdsigmadfdq);
				deltaepsilonp=deltaepsilonpdeltaalpha(1:6);
				epsilonp{step+1}=epsilonp{step+1}+deltaepsilonp;
				epsilone=epsilont{step+1}-epsilonp{step+1};
				deltaalpha=zeros(7,1);
				for i=1:length(hardeningsurfaces)
					deltaalpha(hardeningsurfaces(i))=deltaepsilonpdeltaalpha(6+i);
					alphahp{step+1}(hardeningsurfaces(i))=alphahp{step+1}(hardeningsurfaces(i))+deltaalpha(hardeningsurfaces(i));
				end
				if iteration==1
					%alphahp{step+1}(1)=alphahp{step}(1)+deltagamma(1);
				end
				%hardeningsurfaces=hardeningsurfacesoriginal;
				
				
	
				
				[q,Dcut]=qandDfromalpha(alphahp{step+1},hardeningsurfaces);
				sigma=C*epsilone;
				
				%start of wojtek display
				disp(' ')
				
		texttodisplay=['step=' num2str(step+1) '; '];
		texttodisplay=[texttodisplay 'iteration=' num2str(iteration) '; '];
		texttodisplay=[texttodisplay 'deltaepsilonmag=' num2str(sqrt(dot(deltaepsilon,deltaepsilon))*100) '%; '];
			disp(texttodisplay)
		texttodisplay=[];
		
		printvector(sigma,'sigma')
		if elastic==0
			printvector(activesurface,'activesurface')
			print11cell(f,'f',activesurface);
			printvector(deltagamma,'deltagamma')
			
		end
		printvector(epsilonp{step+1},'epsilonp')
		printvector(epsilont{step+1}-epsilonp{step+1},'epsilone')
		printvector(epsilont{step+1},'epsilont')
		printvector(alphahp{step+1},'alphahp',activesurface)
				%end of wojtek display
			end
			if shedsignal==1
				continue
			end
			%end of iteration
			breaksignal=1;
			newactivesurface=activesurface;
			%{
			newactivesurface=[];
			for i=1:length(deltagamma)
				if deltagamma(i)<0
					breaksignal=0;
				else
					newactivesurface=[newactivesurface activesurface(i)];
				end
			end
			%}
			if breaksignal
				for i=1:6
					%sigmastep(i,step+1)=sigma(i);
				end
				for i=1:7
					fstep(i,step+1)=f{i};
				end
				break
			else
				activesurface=newactivesurface;
				if length(activesurface)==0
					disp('All Surfaces Shedded, Didnt Converge');
					pause;
				end
			end
		end
	end
	%}
	
	sigma_global_big(1)=sigma{substepiter}(xdir);
	sigma_global_big(2)=sigma{substepiter}(ydir);
	sigma_global_big(3)=sigma{substepiter}(zdir);
	sigma_global_big(4)=sigma{substepiter}(xydir);
	sigma_global_big(5)=sigma{substepiter}(yzdir);
	sigma_global_big(6)=sigma{substepiter}(xzdir);

	sigma_local_big=sigma{substepiter};

	s_sp(1)=sigma_global_big(1);
	s_sp(2)=sigma_global_big(2);
	s_sp(3)=sigma_global_big(4);

	e_t_global_big(1)=epsilont(xdir);
	e_t_global_big(2)=epsilont(ydir);
	e_t_global_big(3)=epsilont(zdir);
	e_t_global_big(4)=epsilont(xydir);
	e_t_global_big(5)=epsilont(yzdir);
	e_t_global_big(6)=epsilont(xzdir);


	e_pl_global_big(1)=epsilonp(xdir);
	e_pl_global_big(2)=epsilonp(ydir);
	e_pl_global_big(3)=epsilonp(zdir);
	e_pl_global_big(4)=epsilonp(xydir);
	e_pl_global_big(5)=epsilonp(yzdir);
	e_pl_global_big(6)=epsilonp(xzdir);

	e_pl(1)=e_pl_global_big(1);
	e_pl(2)=e_pl_global_big(2);
	e_pl(3)=e_pl_global_big(4);

	alpha_out=alphahp{substepiter};

	%start Calculating tangent stiffness matrix
	if (isnan(thetacrackrtl) || isinf(thetacrackrtl)) && max(alpha_out)>0
		activesurfacelist=[];
		for i=1:length(surfacehistory)
			if surfacehistory(i)==1
				activesurfacelist=[activesurfacelist i];
			end
		end

		if length(activesurfacelist)==0
			Ktangent_local=C;
		else
			[q,dqdalpha,~]=qandDfromalpha2(alpha_out,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);

			dqdalphamat=zeros(length(activesurfacelist));
			for i=1:length(activesurfacelist)
				dqdalphamat(i,i)=dqdalpha(activesurfacelist(i));
			end

			dfdsigmamat=zeros(length(sigma_local_big),length(activesurfacelist));
			[~, dfdsigma,~]=Wood_Schmidt_EvalSigmaEff(sigma_local_big,q,activesurfacelist,[1 1 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);

			for i=1:length(sigma_local_big)
				for j=1:length(activesurfacelist)
					dfdsigmamat(i,j)=dfdsigma{activesurfacelist(j)}(i);
				end
			end

			Ktangent_local=C*(eye(length(sigma_local_big))-dfdsigmamat*(transpose(dfdsigmamat)*C*dfdsigmamat-dqdalphamat)^(-1)*transpose(dfdsigmamat)*C);
		end
		Ktangent_global=zeros(size(Ktangent_local));
		for i=1:length(dirglobal)
			for j=1:length(dirglobal)
				Ktangent_global(i,j)=Ktangent_local(dirglobal(i),dirglobal(j));
			end
		end

		reductiondesignatorvoight=[1 2 4];

		Ktangent_global_2D=zeros(length(reductiondesignatorvoight),length(reductiondesignatorvoight));

		for i=1:length(reductiondesignatorvoight)
			for j=1:length(reductiondesignatorvoight)
				Ktangent_global_2D(i,j)=Ktangent_global(reductiondesignatorvoight(i),reductiondesignatorvoight(j));
			end
		end

		voight{1}=[1 1];
		voight{2}=[2 2];
		voight{3}=[3 3];
		voight{4}=[1 2];
		voight{5}=[2 3];
		voight{6}=[1 3];

		for i=1:6
			for j=1:6
				tensor{voight{i}(1),voight{i}(2),voight{j}(1),voight{j}(2)}=[i j];
				tensor{voight{i}(1),voight{i}(2),voight{j}(2),voight{j}(1)}=[i j];
				tensor{voight{i}(2),voight{i}(1),voight{j}(1),voight{j}(2)}=[i j];
				tensor{voight{i}(2),voight{i}(1),voight{j}(2),voight{j}(1)}=[i j];
			end
		end

		Ktangent_global_tens=zeros(3,3,3,3);
		for i=1:3
			for j=1:3
				for k=1:3
					for l=1:3
						Ktangent_global_tens(i,j,k,l)=Ktangent_global(tensor{i,j,k,l}(1),tensor{i,j,k,l}(2));
					end
				end
			end
		end

		
		reductiondesignatortensor=[1 2];
		Ktangent_global_tens_2D=zeros(length(reductiondesignatortensor),length(reductiondesignatortensor),length(reductiondesignatortensor),length(reductiondesignatortensor));

		for i=1:length(reductiondesignatortensor)
			for j=1:length(reductiondesignatortensor)
				for k=1:length(reductiondesignatortensor)
					for l=1:length(reductiondesignatortensor)
						Ktangent_global_tens_2D(i,j,k,l)=Ktangent_global_tens(reductiondesignatortensor(i),reductiondesignatortensor(j),reductiondesignatortensor(k),reductiondesignatortensor(l));
					end
				end
			end
		end
		
		s_sp_tens_2D(1,1)=s_sp(1);
		s_sp_tens_2D(2,2)=s_sp(2);
		s_sp_tens_2D(1,2)=s_sp(3);
		s_sp_tens_2D(2,1)=s_sp(3);
		
		sigmacrosseye=zeros(2,2,2,2); %it's 2D mkay?
		eyecrosser=eye(2);
		
		for i=1:2
			for j=1:2
				for k=1:2
					for l=1:2
						sigmacrosseye(i,j,k,l)=s_sp_tens_2D(i,j)*eyecrosser(k,l);
					end
				end
			end
		end
		
		AbeforeQ_rtl=Ktangent_global_tens_2D+sigmacrosseye;
		
		lambdamin=inf;
		thetamin=NaN;
		ntestedangle=360;
		lambda1=zeros(ntestedangle,1);
		lambda2=zeros(ntestedangle,1);
		theta=zeros(ntestedangle,1);
		n=zeros(2,1);
		h=zeros(2,2,ntestedangle); %1st index: direction; 2nd index: which lambda; 3rd index: which angle
		Qacoustic=zeros(2,2,ntestedangle);
		for i=1:ntestedangle
			if CasetoRun==81
				theta(i)=i/ntestedangle*pi;
			else
				theta(i)=i/ntestedangle*2*pi; %change your checked angle here!
			end
			n(1)=cos(theta(i));
			n(2)=sin(theta(i));
			for m=1:2
				for nn=1:2
					for o=1:2
						for p=1:2
							Qacoustic(nn,o,i)=Qacoustic(nn,o,i)+n(m)*AbeforeQ_rtl(m,nn,o,p)*n(p);
						end
					end
				end
			end
			[h_eig,lambda_eig]=eig(Qacoustic(:,:,i));
			h(:,:,i)=h_eig;
			lambda1(i)=lambda_eig(1,1);
			lambda2(i)=lambda_eig(2,2);
			%{
			lambda1(i)=(AbeforeQ_rtl(1,1,1,1)*n(1)^2)/2 + (AbeforeQ_rtl(1,2,2,1)*n(1)^2)/2 + (AbeforeQ_rtl(2,1,1,2)*n(2)^2)/2 + (AbeforeQ_rtl(2,2,2,2)*n(2)^2)/2 - (AbeforeQ_rtl(1,1,1,1)^2*n(1)^4 + AbeforeQ_rtl(1,2,2,1)^2*n(1)^4 + AbeforeQ_rtl(2,1,1,2)^2*n(2)^4 + AbeforeQ_rtl(2,2,2,2)^2*n(2)^4 + AbeforeQ_rtl(1,1,1,2)^2*n(1)^2*n(2)^2 + AbeforeQ_rtl(1,2,2,2)^2*n(1)^2*n(2)^2 + AbeforeQ_rtl(2,1,1,1)^2*n(1)^2*n(2)^2 + AbeforeQ_rtl(2,2,2,1)^2*n(1)^2*n(2)^2 - 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(1,2,2,1)*n(1)^4 + 4*AbeforeQ_rtl(1,1,2,1)*AbeforeQ_rtl(1,2,1,1)*n(1)^4 - 2*AbeforeQ_rtl(2,1,1,2)*AbeforeQ_rtl(2,2,2,2)*n(2)^4 + 4*AbeforeQ_rtl(2,1,2,2)*AbeforeQ_rtl(2,2,1,2)*n(2)^4 + 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(1,1,1,2)*n(1)^3*n(2) - 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(1,2,2,2)*n(1)^3*n(2) - 2*AbeforeQ_rtl(1,1,1,2)*AbeforeQ_rtl(1,2,2,1)*n(1)^3*n(2) + 4*AbeforeQ_rtl(1,1,2,1)*AbeforeQ_rtl(1,2,1,2)*n(1)^3*n(2) + 4*AbeforeQ_rtl(1,1,2,2)*AbeforeQ_rtl(1,2,1,1)*n(1)^3*n(2) + 2*AbeforeQ_rtl(1,2,2,1)*AbeforeQ_rtl(1,2,2,2)*n(1)^3*n(2) + 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(2,1,1,1)*n(1)^3*n(2) + 2*AbeforeQ_rtl(1,1,1,2)*AbeforeQ_rtl(2,1,1,2)*n(1)*n(2)^3 - 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(2,2,2,1)*n(1)^3*n(2) + 4*AbeforeQ_rtl(1,1,2,1)*AbeforeQ_rtl(2,2,1,1)*n(1)^3*n(2) + 4*AbeforeQ_rtl(1,2,1,1)*AbeforeQ_rtl(2,1,2,1)*n(1)^3*n(2) - 2*AbeforeQ_rtl(1,2,2,1)*AbeforeQ_rtl(2,1,1,1)*n(1)^3*n(2) - 2*AbeforeQ_rtl(1,1,1,2)*AbeforeQ_rtl(2,2,2,2)*n(1)*n(2)^3 + 4*AbeforeQ_rtl(1,1,2,2)*AbeforeQ_rtl(2,2,1,2)*n(1)*n(2)^3 + 4*AbeforeQ_rtl(1,2,1,2)*AbeforeQ_rtl(2,1,2,2)*n(1)*n(2)^3 - 2*AbeforeQ_rtl(1,2,2,2)*AbeforeQ_rtl(2,1,1,2)*n(1)*n(2)^3 + 2*AbeforeQ_rtl(1,2,2,1)*AbeforeQ_rtl(2,2,2,1)*n(1)^3*n(2) + 2*AbeforeQ_rtl(1,2,2,2)*AbeforeQ_rtl(2,2,2,2)*n(1)*n(2)^3 + 2*AbeforeQ_rtl(2,1,1,1)*AbeforeQ_rtl(2,1,1,2)*n(1)*n(2)^3 - 2*AbeforeQ_rtl(2,1,1,1)*AbeforeQ_rtl(2,2,2,2)*n(1)*n(2)^3 - 2*AbeforeQ_rtl(2,1,1,2)*AbeforeQ_rtl(2,2,2,1)*n(1)*n(2)^3 + 4*AbeforeQ_rtl(2,1,2,1)*AbeforeQ_rtl(2,2,1,2)*n(1)*n(2)^3 + 4*AbeforeQ_rtl(2,1,2,2)*AbeforeQ_rtl(2,2,1,1)*n(1)*n(2)^3 + 2*AbeforeQ_rtl(2,2,2,1)*AbeforeQ_rtl(2,2,2,2)*n(1)*n(2)^3 - 2*AbeforeQ_rtl(1,1,1,2)*AbeforeQ_rtl(1,2,2,2)*n(1)^2*n(2)^2 + 4*AbeforeQ_rtl(1,1,2,2)*AbeforeQ_rtl(1,2,1,2)*n(1)^2*n(2)^2 + 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(2,1,1,2)*n(1)^2*n(2)^2 + 2*AbeforeQ_rtl(1,1,1,2)*AbeforeQ_rtl(2,1,1,1)*n(1)^2*n(2)^2 - 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(2,2,2,2)*n(1)^2*n(2)^2 - 2*AbeforeQ_rtl(1,1,1,2)*AbeforeQ_rtl(2,2,2,1)*n(1)^2*n(2)^2 + 4*AbeforeQ_rtl(1,1,2,1)*AbeforeQ_rtl(2,2,1,2)*n(1)^2*n(2)^2 + 4*AbeforeQ_rtl(1,1,2,2)*AbeforeQ_rtl(2,2,1,1)*n(1)^2*n(2)^2 + 4*AbeforeQ_rtl(1,2,1,1)*AbeforeQ_rtl(2,1,2,2)*n(1)^2*n(2)^2 + 4*AbeforeQ_rtl(1,2,1,2)*AbeforeQ_rtl(2,1,2,1)*n(1)^2*n(2)^2 - 2*AbeforeQ_rtl(1,2,2,1)*AbeforeQ_rtl(2,1,1,2)*n(1)^2*n(2)^2 - 2*AbeforeQ_rtl(1,2,2,2)*AbeforeQ_rtl(2,1,1,1)*n(1)^2*n(2)^2 + 2*AbeforeQ_rtl(1,2,2,1)*AbeforeQ_rtl(2,2,2,2)*n(1)^2*n(2)^2 + 2*AbeforeQ_rtl(1,2,2,2)*AbeforeQ_rtl(2,2,2,1)*n(1)^2*n(2)^2 - 2*AbeforeQ_rtl(2,1,1,1)*AbeforeQ_rtl(2,2,2,1)*n(1)^2*n(2)^2 + 4*AbeforeQ_rtl(2,1,2,1)*AbeforeQ_rtl(2,2,1,1)*n(1)^2*n(2)^2)^(1/2)/2 + (AbeforeQ_rtl(1,1,1,2)*n(1)*n(2))/2 + (AbeforeQ_rtl(1,2,2,2)*n(1)*n(2))/2 + (AbeforeQ_rtl(2,1,1,1)*n(1)*n(2))/2 + (AbeforeQ_rtl(2,2,2,1)*n(1)*n(2))/2;
			lambda2(i)=(AbeforeQ_rtl(1,1,1,1)*n(1)^2)/2 + (AbeforeQ_rtl(1,2,2,1)*n(1)^2)/2 + (AbeforeQ_rtl(2,1,1,2)*n(2)^2)/2 + (AbeforeQ_rtl(2,2,2,2)*n(2)^2)/2 + (AbeforeQ_rtl(1,1,1,1)^2*n(1)^4 + AbeforeQ_rtl(1,2,2,1)^2*n(1)^4 + AbeforeQ_rtl(2,1,1,2)^2*n(2)^4 + AbeforeQ_rtl(2,2,2,2)^2*n(2)^4 + AbeforeQ_rtl(1,1,1,2)^2*n(1)^2*n(2)^2 + AbeforeQ_rtl(1,2,2,2)^2*n(1)^2*n(2)^2 + AbeforeQ_rtl(2,1,1,1)^2*n(1)^2*n(2)^2 + AbeforeQ_rtl(2,2,2,1)^2*n(1)^2*n(2)^2 - 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(1,2,2,1)*n(1)^4 + 4*AbeforeQ_rtl(1,1,2,1)*AbeforeQ_rtl(1,2,1,1)*n(1)^4 - 2*AbeforeQ_rtl(2,1,1,2)*AbeforeQ_rtl(2,2,2,2)*n(2)^4 + 4*AbeforeQ_rtl(2,1,2,2)*AbeforeQ_rtl(2,2,1,2)*n(2)^4 + 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(1,1,1,2)*n(1)^3*n(2) - 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(1,2,2,2)*n(1)^3*n(2) - 2*AbeforeQ_rtl(1,1,1,2)*AbeforeQ_rtl(1,2,2,1)*n(1)^3*n(2) + 4*AbeforeQ_rtl(1,1,2,1)*AbeforeQ_rtl(1,2,1,2)*n(1)^3*n(2) + 4*AbeforeQ_rtl(1,1,2,2)*AbeforeQ_rtl(1,2,1,1)*n(1)^3*n(2) + 2*AbeforeQ_rtl(1,2,2,1)*AbeforeQ_rtl(1,2,2,2)*n(1)^3*n(2) + 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(2,1,1,1)*n(1)^3*n(2) + 2*AbeforeQ_rtl(1,1,1,2)*AbeforeQ_rtl(2,1,1,2)*n(1)*n(2)^3 - 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(2,2,2,1)*n(1)^3*n(2) + 4*AbeforeQ_rtl(1,1,2,1)*AbeforeQ_rtl(2,2,1,1)*n(1)^3*n(2) + 4*AbeforeQ_rtl(1,2,1,1)*AbeforeQ_rtl(2,1,2,1)*n(1)^3*n(2) - 2*AbeforeQ_rtl(1,2,2,1)*AbeforeQ_rtl(2,1,1,1)*n(1)^3*n(2) - 2*AbeforeQ_rtl(1,1,1,2)*AbeforeQ_rtl(2,2,2,2)*n(1)*n(2)^3 + 4*AbeforeQ_rtl(1,1,2,2)*AbeforeQ_rtl(2,2,1,2)*n(1)*n(2)^3 + 4*AbeforeQ_rtl(1,2,1,2)*AbeforeQ_rtl(2,1,2,2)*n(1)*n(2)^3 - 2*AbeforeQ_rtl(1,2,2,2)*AbeforeQ_rtl(2,1,1,2)*n(1)*n(2)^3 + 2*AbeforeQ_rtl(1,2,2,1)*AbeforeQ_rtl(2,2,2,1)*n(1)^3*n(2) + 2*AbeforeQ_rtl(1,2,2,2)*AbeforeQ_rtl(2,2,2,2)*n(1)*n(2)^3 + 2*AbeforeQ_rtl(2,1,1,1)*AbeforeQ_rtl(2,1,1,2)*n(1)*n(2)^3 - 2*AbeforeQ_rtl(2,1,1,1)*AbeforeQ_rtl(2,2,2,2)*n(1)*n(2)^3 - 2*AbeforeQ_rtl(2,1,1,2)*AbeforeQ_rtl(2,2,2,1)*n(1)*n(2)^3 + 4*AbeforeQ_rtl(2,1,2,1)*AbeforeQ_rtl(2,2,1,2)*n(1)*n(2)^3 + 4*AbeforeQ_rtl(2,1,2,2)*AbeforeQ_rtl(2,2,1,1)*n(1)*n(2)^3 + 2*AbeforeQ_rtl(2,2,2,1)*AbeforeQ_rtl(2,2,2,2)*n(1)*n(2)^3 - 2*AbeforeQ_rtl(1,1,1,2)*AbeforeQ_rtl(1,2,2,2)*n(1)^2*n(2)^2 + 4*AbeforeQ_rtl(1,1,2,2)*AbeforeQ_rtl(1,2,1,2)*n(1)^2*n(2)^2 + 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(2,1,1,2)*n(1)^2*n(2)^2 + 2*AbeforeQ_rtl(1,1,1,2)*AbeforeQ_rtl(2,1,1,1)*n(1)^2*n(2)^2 - 2*AbeforeQ_rtl(1,1,1,1)*AbeforeQ_rtl(2,2,2,2)*n(1)^2*n(2)^2 - 2*AbeforeQ_rtl(1,1,1,2)*AbeforeQ_rtl(2,2,2,1)*n(1)^2*n(2)^2 + 4*AbeforeQ_rtl(1,1,2,1)*AbeforeQ_rtl(2,2,1,2)*n(1)^2*n(2)^2 + 4*AbeforeQ_rtl(1,1,2,2)*AbeforeQ_rtl(2,2,1,1)*n(1)^2*n(2)^2 + 4*AbeforeQ_rtl(1,2,1,1)*AbeforeQ_rtl(2,1,2,2)*n(1)^2*n(2)^2 + 4*AbeforeQ_rtl(1,2,1,2)*AbeforeQ_rtl(2,1,2,1)*n(1)^2*n(2)^2 - 2*AbeforeQ_rtl(1,2,2,1)*AbeforeQ_rtl(2,1,1,2)*n(1)^2*n(2)^2 - 2*AbeforeQ_rtl(1,2,2,2)*AbeforeQ_rtl(2,1,1,1)*n(1)^2*n(2)^2 + 2*AbeforeQ_rtl(1,2,2,1)*AbeforeQ_rtl(2,2,2,2)*n(1)^2*n(2)^2 + 2*AbeforeQ_rtl(1,2,2,2)*AbeforeQ_rtl(2,2,2,1)*n(1)^2*n(2)^2 - 2*AbeforeQ_rtl(2,1,1,1)*AbeforeQ_rtl(2,2,2,1)*n(1)^2*n(2)^2 + 4*AbeforeQ_rtl(2,1,2,1)*AbeforeQ_rtl(2,2,1,1)*n(1)^2*n(2)^2)^(1/2)/2 + (AbeforeQ_rtl(1,1,1,2)*n(1)*n(2))/2 + (AbeforeQ_rtl(1,2,2,2)*n(1)*n(2))/2 + (AbeforeQ_rtl(2,1,1,1)*n(1)*n(2))/2 + (AbeforeQ_rtl(2,2,2,1)*n(1)*n(2))/2;
			%}
			
			%if min([lambda1 lambda2])<lambdamin
			%	lambdamin=min([lambda1 lambda2]);
			%	thetamin=theta;
			%end
		end
		lambdamin=min([lambda1;lambda2]);
		if length(lambdamin)>1
			disp('length(lamdabmin)>1!');
			pause;
			1;
		end
		if lambdamin>0
			thetacrackrtl=NaN;
		else
			localminima1index=[];
			localminima2index=[];
			for i=1:ntestedangle
				if lambda1(i)<0 && lambda1(i)<=lambda1(mod((i-1)-1,ntestedangle)+1) && lambda1(i)<=lambda1(mod((i+1)-1,ntestedangle)+1)
					localminima1index=[localminima1index i];
				end
				if lambda2(i)<0 && lambda2(i)<=lambda2(mod((i-1)-1,ntestedangle)+1) && lambda2(i)<=lambda2(mod((i+1)-1,ntestedangle)+1)
					localminima2index=[localminima2index i];
				end
			end
			nldudxhl=zeros(length(localminima1index)+length(localminima2index),1);
			h_localminima=zeros(2,length(localminima1index)+length(localminima2index));
			for i=1:length(localminima1index)
				n(1)=cos(theta(localminima1index(i)));
				n(2)=sin(theta(localminima1index(i)));
				nldudxhl(i)=transpose(n)*dudx_rtl*h(:,1,localminima1index(i));
				h_localminima(:,i)=h(:,1,localminima1index(i));
			end
			for i=1:length(localminima2index)
				n(1)=cos(theta(localminima2index(i)));
				n(2)=sin(theta(localminima2index(i)));
				nldudxhl(i+length(localminima1index))=transpose(n)*dudx_rtl*h(:,2,localminima2index(i));
				h_localminima(:,i+length(localminima1index))=h(:,2,localminima2index(i));
            end
            localminimaindex=[localminima1index localminima2index];
			FindMaxnldudxhl=FindMax(nldudxhl); %I put FindMax(nldudxhl) to a variable FindMaxnldudxhl as I need to call it twice. Better to save the result rather than calling the function twice.
			crackindex=localminimaindex(FindMaxnldudxhl);
			thetamin=theta(crackindex);
			h_crackdecision(:,1)=h_localminima(:,FindMaxnldudxhl);
			thetacrackrtl=mod(thetamin+pi/2+pi/2,pi)-pi/2;
			justcracked=1;
            1;
		end
	else
		Ktangent_global=[];
		Ktangent_global_2D=[];
		Ktangent_global_tens=[];
		Ktangent_global_tens_2D=[];
		activesurfacelist=[];
		AbeforeQ_rtl=zeros(2,2,2,2);
		lambdamin=[];
		thetamin=[];
		Qacoustic=[];
		h=[];
	end
	
	
	%end Calculating tangent stiffness matrix
	
	%{
	disp(' ')
		texttodisplay=['step=' num2str(step+1) '; '];
		texttodisplay=[texttodisplay 'iteration=' num2str(iteration) '; '];
		texttodisplay=[texttodisplay 'deltaepsilonmag=' num2str(sqrt(dot(deltaepsilon,deltaepsilon))*100) '%; '];
			disp(texttodisplay)
		
		printvector(sigma,'sigma')
		if elastic==0
			printvector(activesurface,'activesurface')
			print11cell(f,'f',activesurface)
		end
		printvector(deltagamma,'deltagamma')
		printvector(epsilonp{step+1},'epsilonp')
		printvector(epsilont{step+1}-epsilonp{step+1},'epsilone')
		printvector(epsilont{step+1},'epsilont')
		if elastic
			printvector(alphahp{step+1},'alphahp')
		else
			printvector(alphahp{step+1},'alphahp',activesurface)
		end
			
	%}
	%end function of Wood_Schmidt17
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MatOut=MatCondensor(MatIn,CondensedIndex)
    ThrowSwitch=zeros(1,size(MatIn,1));
    for i=1:length(CondensedIndex);
        ThrowSwitch(CondensedIndex(i))=1;
    end
    UncondensedIndex=zeros(1,size(MatIn,1)-length(CondensedIndex));
    icount=1;
    for i=1:length(ThrowSwitch);
        if ThrowSwitch
            continue;
        end
        UncondensedIndex(icount)=i;
        icount=icount+1;
    end
    TopLeft=zeros(size(MatIn,1)-length(CondensedIndex));
    TopRight=zeros(size(MatIn,1)-length(CondensedIndex),length(CondensedIndex));
    BottomLeft=zeros(length(CondensedIndex),size(MatIn,2)-length(CondensedIndex));
    BottomRight=zeros(length(CondensedIndex),length(CondensedIndex));
    for i=1:length(UncondensedIndex)
        for j=1:length(UncondensedIndex)
            TopLeft(i,j)=MatIn(UncondensedIndex(i),UncondensedIndex(j));
        end
        for j=1:length(CondensedIndex)
            TopRight(i,j)=MatIn(UncondensedIndex(i),CondensedIndex(j));
        end
    end
    for i=1:length(CondensedIndex)
        for j=1:length(UncondensedIndex)
            BottomLeft(i,j)=MatIn(CondensedIndex(i),UncondensedIndex(j));
        end
        for j=1:length(CondensedIndex)
            BottomRight(i,j)=MatIn(CondensedIndex(i),CondensedIndex(j));
        end
    end
    MatNew=TopLeft-TopRight*(BottomRight^-1)*BottomLeft;
    MatOut=zeros(size(MatIn,1));
    for i=1:length(UncondensedIndex)
        for j=1:length(UncondensedIndex)
            MatOut(UncondensedIndex(i),UncondensedIndex(j))=MatNew(i,j);
        end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MatOut=MatCondensor_old201807031046(MatIn,CondensedIndex)
    MatCurrent=MatIn;
    for IndexIter=1:length(CondensedIndex)
        MatCut=zeros(size(MatCurrent,1));
        ReductorComponentA=zeros(size(MatCut,1),1);
        ReductorComponentB=zeros(1,size(MatCut,1));
        for i=1:size(MatCurrent,1)
            if i==CondensedIndex(IndexIter)
                continue;
            end
            ReductorComponentA(i,1)=MatCurrent(i,CondensedIndex(IndexIter));
            ReductorComponentB(i)=MatCurrent(CondensedIndex(IndexIter),i);
            for j=1:size(MatCurrent,2)
                if j==CondensedIndex(IndexIter)
                    continue;
                end
                MatCut(i,j)=MatCurrent(i,j);
            end
        end
        MatCurrent=MatCut-1/MatCurrent(CondensedIndex(IndexIter),CondensedIndex(IndexIter))*ReductorComponentA*ReductorComponentB;
    end
    MatOut=MatCurrent;
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [LOC,LOCC,cellCount,nodeCount]=Grid_Generation(NN,le)
	%% Generate the structured grid

	% Input
	% NN(1): number of nodes in X direction
	% NN(2): number of nodes in Y direction
	% le(1): element size in X direction
	% le(2): element size in X direction

	% Output
	% nodeCount: total number of nodes
	% cellCount: total number of elements
	% LOC(n,1:2): localtion coordinate of node "n" in x(1) and y(2) direction
	% LOCC(e,1:2): localtion coordinate of element centroid "e" in x(1) and y(2) direction

	%% Grid generation
	cellCount               = (NN(1)-1)*(NN(2)-1);              % number of elements
	nodeCount               = NN(1)*NN(2);                      % number of nodes
	LOC                     = zeros(NN(1)*NN(2),2);             % zero matrix of all nodal coordinate

	LOCX                    = [0:NN(1)-1]'*le(1);               % Location of all nodes in X direction
	LOCY                    = [0:NN(2)-1]'*le(2);               % Location of all nodes in Y direction

	LOCCX                   = [0:(NN(1)-1)-1]'*le(1)+le(1)/2;   % Location of cells in X direction
	LOCCY                   = [0:(NN(2)-1)-1]'*le(2)+le(2)/2;   % Location of cells in X direction

	for i=1:NN(2)
		LOC((1+NN(1)*(i-1)):(NN(1)*(i-1)+NN(1)),1) = LOCX;      % generate the X node position in LOC
	end

	for i=1:NN(2)
		LOC((NN(1)*(i-1))+1:NN(1)*i,2) = LOCY(i);               % generate the Y node position in LOC
	end

	for i=1:NN(2)-1
		LOCC((1+(NN(1)-1)*(i-1)):((NN(1)-1)*(i-1)+(NN(1)-1)),1) = LOCCX;        % generate the X element position in LOCC
	end

	for i=1:NN(2)-1
		LOCC(((NN(1)-1)*(i-1))+1:(NN(1)-1)*i,2) = LOCCY(i);                     % generate the Y element position in LOCC
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [LOC,LOCC,cellCount,nodeCount,LOCX,LOCY,le_c]=Grid_Generation_var(NN,le_x,le_y)
	%% Generate the structured grid

	% Input
	% NN(1): number of nodes in X direction
	% NN(2): number of nodes in Y direction
	% le(1): element size in X direction
	% le(2): element size in X direction

	% Output
	% nodeCount: total number of nodes
	% cellCount: total number of elements
	% LOC(n,1:2): localtion coordinate of node "n" in x(1) and y(2) direction
	% LOCC(e,1:2): localtion coordinate of element centroid "e" in x(1) and y(2) direction

	%% Grid generation
	cellCount               = (NN(1)-1)*(NN(2)-1);              % number of elements
	nodeCount               = NN(1)*NN(2);                      % number of nodes
	LOC                     = zeros(NN(1)*NN(2),2);             % zero matrix of all nodal coordinate
	LOCC                    = zeros(cellCount,2);
	le_c                    = zeros(cellCount,2);


	LOCX(1)=0;
	LOCY(1)=0;

	for i=1:NN(1)-1
		LOCX(i+1)=LOCX(i)+le_x(i);          % Location of all nodes in X direction
		LOCCX(i)=LOCX(i)+le_x(i)/2;         % Location of cells in X direction
	end

	for i=1:NN(2)-1
		LOCY(i+1)=LOCY(i)+le_y(i);          % Location of all nodes in Y direction
		LOCCY(i)=LOCY(i)+le_y(i)/2;         % Location of cells in Y direction
	end

	for i=1:NN(2)
		LOC((1+NN(1)*(i-1)):(NN(1)*(i-1)+NN(1)),1) = LOCX;      % generate the X node position in LOC
	end

	for i=1:NN(2)
		LOC((NN(1)*(i-1))+1:NN(1)*i,2) = LOCY(i);               % generate the Y node position in LOC
	end

	for i=1:NN(2)-1
		LOCC((1+(NN(1)-1)*(i-1)):((NN(1)-1)*(i-1)+(NN(1)-1)),1) = LOCCX;        % generate the X element position in LOCC
	end

	for i=1:NN(2)-1
		LOCC(((NN(1)-1)*(i-1))+1:(NN(1)-1)*i,2) = LOCCY(i);                     % generate the Y element position in LOCC
	end


	for i=1:length(le_y)
		for j=1:length(le_x)
			le_c((i-1)*length(le_x)+j,1)=le_x(j);
			le_c((i-1)*length(le_x)+j,2)=le_y(i);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [nfbcx,nfbcy,fbcx,fbcy]=Compute_Boundary_Nodes(nodeCount,LOC,x_max,x_min,y_max,y_min)
	% Input
	% nodeCount: total number of nodes
	% LOC(n,1:2): localtion coordinate of node "n" in x(1) and y(2) direction

	% Output
	% nfbcx: number of boundary nodes in X direction
	% nfbcy: number of boundary nodes in Y direction
	% fbcx: index of all boundary nodes in X direction
	% fbcy: index of all boundary nodes in Y direction


	nfbcx                   = 0              ;  % initial number of fixed nodes in x direction
	nfbcy                   = 0              ;  % initial number of fixed nodes in y direction
	fbcx = []; fbcy = [];                       % vector store the index of boundary nodes

	for n=1:nodeCount
		if LOC(n,1)<=x_min || LOC(n,1)>=x_max
			nfbcx = nfbcx+1;
			fbcx = [fbcx n];
		end
	end

	for n=1:nodeCount
		if LOC(n,2)<=y_min || LOC(n,2)>=y_max
			nfbcy = nfbcy+1;
			fbcy = [fbcy n];
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_var(x_sp,LOC,LOCX,LOCY,orientationoffset,xdirletter,ydirletter,lp)
    initial_figure=figure;
    plot(x_sp(:,1),x_sp(:,2),'o');
    hold on
    daspect([1 1 1]);
    lp_take=sum(sum(lp))/(size(lp,1)*size(lp,2));
    for i=1:length(orientationoffset)
        if length(xdirletter{i})==1 && xdirletter{i}=='t'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        else
            continue
        end
        xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
        xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
        ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
        yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
        plot([xstart xend],[ystart yend],'color','red');
    end
    title('initial condition');
    grid on
    axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
    set(gca,'xtick',LOCX);
    set(gca,'ytick',LOCY);
    % set(gca,'XTickLabel',[]);
    % set(gca,'YTickLabel',[]);
    hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_linehighlighted2(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp)
	initial_figure=figure;
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
			LineColor='red';
			CircColor='green';
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			LineColor='red';
			CircColor='green';
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
			LineColor='black';
			CircColor='black';
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			LineColor='black';
			CircColor='black';
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			plot(x_sp(i,1),x_sp(i,2),'o','Color','Blue');
			continue;
		end
		plot(x_sp(i,1),x_sp(i,2),'o','Color',CircColor);
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color',LineColor);
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_squishy2(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,matmodel)
	initial_figure=figure;
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			if matmodel(i)==2
				plot(x_sp(i,1),x_sp(i,2),'o','Color','Blue');
			elseif matmodel(i)==3
				plot(x_sp(i,1),x_sp(i,2),'o','Color','Cyan');
			end
			continue;
		end
		plot(x_sp(i,1),x_sp(i,2),'o','Color','Green');
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:inf:max(LOC(:,1))])
	set(gca,'ytick',[0:inf:max(LOC(:,2))])
	set(initial_figure,'Position',[2560 0 1000 1600]);
	set(gca,'color','none')
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_squishy(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,matmodel)
	initial_figure=figure;
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			if matmodel(i)==2
				plot(x_sp(i,1),x_sp(i,2),'o','Color','Blue');
			elseif matmodel(i)==3
				plot(x_sp(i,1),x_sp(i,2),'o','Color','Cyan');
			end
			continue;
		end
		plot(x_sp(i,1),x_sp(i,2),'o','Color','Green');
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_linehighlighted(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp)
	initial_figure=figure;
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			plot(x_sp(i,1),x_sp(i,2),'o','Color','Blue');
			continue;
		end
		plot(x_sp(i,1),x_sp(i,2),'o','Color','Green');
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp)
	initial_figure=figure;
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			continue;
		end
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_crackmulti(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,x_crack,CasetoRun)
	initial_figure=figure;
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			continue;
		end
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	for i=1:length(x_crack)
		if CasetoRun==118
			plot(x_crack{i}(:,1),x_crack{i}(:,2),'-','Color','Black','LineWidth',2);
		else
			plot(x_crack{i}(:,1),x_crack{i}(:,2),'-o','Color','Green');
		end
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_sp(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp)
	initial_figure=figure;
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			continue;
		end
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,156]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):156]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN1,dN2]=linearshape(xp,xn,Lx,Ly)


if abs(xp(1)-xn(1))<Lx 
    
    Nx = 1-abs(xp(1)-xn(1))/Lx;    
    dNx = -sign(xp(1)-xn(1))/Lx;
else
    Nx = 0;
    dNx = 0;
end

if abs(xp(2)-xn(2))<Ly 
    Ny = 1-abs(xp(2)-xn(2))/Ly;     
    dNy = -sign(xp(2)-xn(2))/Ly;
else
    Ny = 0;
    dNy = 0;
end


    N = Nx*Ny;
    dN1 = dNx*Ny;
    dN2 = Nx*dNy;
   
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [x_crack,x_cracktop,x_crackbot] = UpdateCrackPosition2(x_crack,x_cracktop,x_crackbot,nmass_si,nmomentum_si,Nmatrix_crack,Nmatrix_cracktop,Nmatrix_crackbot,dt,Nmatrix,v_ssp_out,m_sp,nfbcx,nfbcy,fbcx,fbcy)
	
	Nmatrixtop=Nmatrix(:,:,1)+Nmatrix(:,:,2);
	Nmatrixbot=Nmatrix(:,:,1)+Nmatrix(:,:,3);
	%nmatrixtop/nmatrixbot: for mapping variables from real particles to background grid appropriate for calculating velocity for updating top/bottom crack particle positions
	
	nmass_si_comb=zeros(size(nmass_si,1));
	nmass_si_top=zeros(size(nmass_si,1));
	nmass_si_bot=zeros(size(nmass_si,1));
	
	v_si_comb=zeros(size(nmass_si,1),2);
	v_si_top=zeros(size(nmass_si,1),2);
	v_si_bot=zeros(size(nmass_si,1),2);
	
	nmomentum_si_top(:,1)=Nmatrixtop*(v_ssp_out(:,1).*m_sp(:,1));
	nmomentum_si_top(:,2)=Nmatrixtop*(v_ssp_out(:,2).*m_sp(:,1));
	nmomentum_si_bot(:,1)=Nmatrixbot*(v_ssp_out(:,1).*m_sp(:,1));
	nmomentum_si_bot(:,2)=Nmatrixbot*(v_ssp_out(:,2).*m_sp(:,1));
	
	[nmomentum_si]  = Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,nmomentum_si); % Boundary condition for nodal force
	[nmomentum_si_top]  = Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,nmomentum_si_top); % Boundary condition for nodal force
	[nmomentum_si_bot]  = Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,nmomentum_si_bot); % Boundary condition for nodal force

	nmass_si_top=Nmatrixtop*m_sp;
	nmass_si_bot=Nmatrixbot*m_sp;
	
	
	for i=1:size(nmass_si,1);
		nmass_si_comb(i)=sum(nmass_si(i,:));
		%nmass_si_top(i)=nmass_si(i,2);
		%nmass_si_bot(i)=nmass_si(i,3);
		
		if nmass_si_comb(i)>0
			v_si_comb(i,1)=sum(nmomentum_si(i,1,:))/nmass_si_comb(i);
			v_si_comb(i,2)=sum(nmomentum_si(i,2,:))/nmass_si_comb(i);
		end
		
		if nmass_si_top(i)>0
			v_si_top(i,1)=nmomentum_si_top(i,1)/nmass_si_top(i);
			v_si_top(i,2)=nmomentum_si_top(i,2)/nmass_si_top(i);
		end
		
		if nmass_si_bot(i)>0
			v_si_bot(i,1)=nmomentum_si_bot(i,1)/nmass_si_bot(i);
			v_si_bot(i,2)=nmomentum_si_bot(i,2)/nmass_si_bot(i);
		end
	end
	
	v_crack=transpose(Nmatrix_crack)*v_si_comb;
	v_cracktop=transpose(Nmatrix_cracktop)*v_si_top;
	v_crackbot=transpose(Nmatrix_crackbot)*v_si_bot;
	
	x_crack=x_crack+dt*v_crack;
	x_cracktop=x_cracktop+dt*v_cracktop;
	x_crackbot=x_crackbot+dt*v_crackbot;
	
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [x_sp] = UpdateCrackPosition_multi(Nmatrix,NmatrixAll,dt,nmass_si,nmomentum_si,x_sp)
	%Nmatrix,NmatrixAll,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2
	fieldnumber=size(Nmatrix,3);

	a_si=zeros(size(nmass_si,1),2,fieldnumber);
	v_si=zeros(size(nmass_si,1),2,fieldnumber);

	for field=1:fieldnumber
	%	try
	%		parfor i=1:size(nmass_si,1)
	%			if nmass_si(i,field)==0
	%			else
	%				a_si(i,:,field)=nforce_si(i,:,field)/nmass_si(i,field);
	%				v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
	%			end
	%		end
	%	catch
	%		disp('Update_Particle_Position_WithPredVel2 a_si v_si parfor failed!');
	%		disp('Rolling back to regular for');
			for i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
%					a_si(i,:,field)=nforce_si(i,:,field)/nmass_si(i,field);
					v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
	%	end
	end

	for field=1:fieldnumber
		for direction=1:2
			if field==1
				x_sp(:,direction)=x_sp(:,direction)+dt*transpose(NmatrixAll(:,:))*(v_si(:,direction,field));
			else
				x_sp(:,direction)=x_sp(:,direction)+dt*transpose(Nmatrix(:,:,field))*(v_si(:,direction,field));
			end
		end
	end

	%{
	v_ssp_free=v_ssp;

	for ni=1:length(NodeswithPredXVel)
		i=NodeswithPredXVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+NmatrixAll(i,sp)*(PredXVel - v_ssp_free(sp,1));
		end
	end

	for ni=1:length(NodeswithPredYVel)
		i=NodeswithPredYVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+NmatrixAll(i,sp)*(PredYVel - v_ssp_free(sp,2));
		end
	end

	for ni=1:length(NodeswithPredYVel2)
		i=NodeswithPredYVel2(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+NmatrixAll(i,sp)*(PredYVel2 - v_ssp_free(sp,2));
		end
	end
	%}
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [x_sp] = UpdateCrackPosition_multioptimized(N,NODES,CONNECT,dt,nmass_si,nmomentum_si,x_sp,TheFieldSplit)
	spCount=size(x_sp,1);
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid                           = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			end

			x_sp(sp,:)                       = x_sp(sp,:) + nmomentum_si(npid,:,TheFieldSplit(npid,sp))*N{sp}(j)*dt/nmass_si(npid,TheFieldSplit(npid,sp));
		end   
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [x_sp] = UpdateCrackPosition_multioptimized_fail(Nmatrix,dt,nmass_si,nmomentum_si,x_sp,TheFieldSplit)
	fieldnumber=max(max(TheFieldSplit));
	a_si=zeros(size(nmass_si,1),2,fieldnumber);
	v_si=zeros(size(nmass_si,1),2,fieldnumber);
	for field=1:fieldnumber
		for i=1:size(nmass_si,1)
			if nmass_si(i,field)==0
			else
				v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
			end
		end
	end
	for field=1:fieldnumber
		if nmass_si(i,field)==0
			for direction=1:2
				x_sp(:,direction)=x_sp(:,direction)+dt*transpose(Nmatrix)*(nmomentum_si(:,direction,field)./nmass_si(:,field));
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [x_crack,x_cracktop,x_crackbot] = UpdateCrackPosition(x_crack,x_cracktop,x_crackbot,nmass_si,nmomentum_si,Nmatrix_crack,Nmatrix_cracktop,Nmatrix_crackbot,dt,Nmatrixtop,Nmatrixbot,v_ssp_out,m_sp)

	nmass_si_comb=zeros(size(nmass_si,1));
	nmass_si_top=zeros(size(nmass_si,1));
	nmass_si_bot=zeros(size(nmass_si,1));
	
	v_si_comb=zeros(size(nmass_si,1),2);
	v_si_top=zeros(size(nmass_si,1),2);
	v_si_bot=zeros(size(nmass_si,1),2);
	
	nmomentum_si_top(:,1)=Nmatrixtop*(v_ssp_out(:,1).*m_sp(:,1));
	nmomentum_si_top(:,2)=Nmatrixtop*(v_ssp_out(:,2).*m_sp(:,1));
	nmomentum_si_bot(:,1)=Nmatrixbot*(v_ssp_out(:,1).*m_sp(:,1));
	nmomentum_si_bot(:,2)=Nmatrixbot*(v_ssp_out(:,2).*m_sp(:,1));

	nmass_si_top=Nmatrixtop*m_sp;
	nmass_si_bot=Nmatrixbot*m_sp;
	
	
	for i=1:size(nmass_si,1);
		nmass_si_comb(i)=sum(nmass_si(i,:));
		%nmass_si_top(i)=nmass_si(i,2);
		%nmass_si_bot(i)=nmass_si(i,3);
		
		if nmass_si_comb(i)>0
			v_si_comb(i,1)=sum(nmomentum_si(i,1,:))/nmass_si_comb(i);
			v_si_comb(i,2)=sum(nmomentum_si(i,2,:))/nmass_si_comb(i);
		end
		
		if nmass_si_top(i)>0
			v_si_top(i,1)=nmomentum_si_top(i,1)/nmass_si_top(i);
			v_si_top(i,2)=nmomentum_si_top(i,2)/nmass_si_top(i);
		end
		
		if nmass_si_bot(i)>0
			v_si_bot(i,1)=nmomentum_si_bot(i,1)/nmass_si_bot(i);
			v_si_bot(i,2)=nmomentum_si_bot(i,2)/nmass_si_bot(i);
		end
	end
	
	v_crack=transpose(Nmatrix_crack)*v_si_comb;
	v_cracktop=transpose(Nmatrix_cracktop)*v_si_top;
	v_crackbot=transpose(Nmatrix_crackbot)*v_si_bot;
	
	x_crack=x_crack+dt*v_crack;
	x_cracktop=x_cracktop+dt*v_cracktop;
	x_crackbot=x_crackbot+dt*v_crackbot;
	
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [v_ssp,x_sp] = Update_Particle_Position_WithPredVel2(Nmatrix,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2)
	%v_ssp=v_ssp*(0.5^(1/1000)); %damping

	fieldnumber=size(Nmatrix,3);

	a_si=zeros(length(nmass_si),2,fieldnumber);
	v_si=zeros(length(nmass_si),2,fieldnumber);

	for field=1:fieldnumber
		try
			parfor i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
					a_si(i,:,field)=nforce_si(i,:,field)/nmass_si(i,field);
					v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
		catch
			disp('Update_Particle_Position_WithPredVel2 a_si v_si parfor failed!');
			disp('Rolling back to regular for');
			for i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
					a_si(i,:,field)=nforce_si(i,:,field)/nmass_si(i,field);
					v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
		end
	end

	for field=1:fieldnumber
		for direction=1:2
			v_ssp(:,direction)=v_ssp(:,direction)+dt*transpose(Nmatrix(:,:,field))*(a_si(:,direction,field));
			x_sp(:,direction)=x_sp(:,direction)+dt*transpose(Nmatrix(:,:,field))*(v_si(:,direction,field));
		end
	end

	%{
	for sp = 1:spCount
		 for j = 1:NODES(sp)
			 npid                           = CONNECT{sp}(j);
			  if nmass_si(npid)==0
				continue
			  end
			  %{
			  NodeisPredXVel=0;
			  for k=1:length(NodeswithPredXVel)
				 if npid==NodeswithPredXVel(k)
					 NodeisPredXVel=1;
					 break
				 end
			 end
			  NodeisPredYVel=0;          
			  for k=1:length(NodeswithPredYVel)
				 if npid==NodeswithPredYVel(k)
					 NodeisPredYVel=1;
					 break
				 end
			  end
			  NodeisPredYVel2=0;
			  for k=1:length(NodeswithPredYVel2)
				 if npid==NodeswithPredYVel2(k)
					 NodeisPredYVel2=1;
					 break
				 end
			  end
			  %}
			  %if NodeisPredXVel==0
				 v_ssp(sp,1)                  = v_ssp(sp,1) + dt * N{sp}(j) * (nforce_si(npid,1)/nmass_si(npid));%*(0.5^(1/1000)); %damping
			 %else
			 %    v_ssp(sp,1)                  = v_ssp(sp,1) + N{sp}(j)*(PredXVel - v_ssp(sp,1));
			 %end
			 
			 %if NodeisPredYVel==0
				 v_ssp(sp,2)                      = v_ssp(sp,2) + dt * N{sp}(j) * (nforce_si(npid,2)/nmass_si(npid));%*(0.5^(1/1000)); %damping
			 %else
			 %    v_ssp(sp,2)                  = v_ssp(sp,2) + N{sp}(j)*(PredYVel - v_ssp(sp,2));
			 %end
			 
			 %if NodeisPredYVel2==0
			 %    v_ssp(sp,2)                      = v_ssp(sp,2) + dt * N{sp}(j) * (nforce_si(npid,2)/nmass_si(npid));%*(0.5^(1/1000)); %damping
			 %else
			 %    v_ssp(sp,2)                  = v_ssp(sp,2) + N{sp}(j)*(PredYVel2 - v_ssp(sp,2));
			 %end
			 %v_ssp(sp,2)                      = v_ssp(sp,2) + dt * N{sp}(j) * (nforce_si(npid,2)/nmass_si(npid));
			 
			 x_sp(sp,:)                       = x_sp(sp,:) + nmomentum_si(npid,:)*N{sp}(j)*dt/ nmass_si(npid);
		 end   
	end
	%}

	v_ssp_free=v_ssp;

	for ni=1:length(NodeswithPredXVel)
		i=NodeswithPredXVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+sum(Nmatrix(i,sp,:))*(PredXVel - v_ssp_free(sp,1));
		end
	end

	for ni=1:length(NodeswithPredYVel)
		i=NodeswithPredYVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp,:))*(PredYVel - v_ssp_free(sp,2));
		end
	end

	for ni=1:length(NodeswithPredYVel2)
		i=NodeswithPredYVel2(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp,:))*(PredYVel2 - v_ssp_free(sp,2));
		end
	end


end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [v_ssp,x_sp] = Update_Prtcl_Posn_WPredVOR_optmzd(Nmatrix,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2,TheFieldSplit)
	%v_ssp=v_ssp*(0.5^(1/1000)); %damping
	
	fieldnumber=max(max(TheFieldSplit));
	
	% keeping the original code incase parfor fails
	%{
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid                           = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			end
			v_ssp(sp,:)                  = v_ssp(sp,:) + dt * N{sp}(j) * (nforce_si(npid,:,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)));%*(0.5^(1/1000)); %damping

			x_sp(sp,:)                       = x_sp(sp,:) + nmomentum_si(npid,:,TheFieldSplit(npid,sp))*N{sp}(j)*dt/nmass_si(npid,TheFieldSplit(npid,sp));
		end   
	end
	%}
	
	v_ssp_before=v_ssp;
	x_sp_before=x_sp;
	try
		parfor sp = 1:spCount
			[v_ssp(sp,:),x_sp(sp,:)]=Update_Prtcl_Posn_WPredVOR_optmzd_prfrd(NODES(sp),dt,CONNECT{sp},N{sp},nmass_si,nforce_si,nmomentum_si,v_ssp(sp,:),x_sp(sp,:),TheFieldSplit(:,sp));
		end
	catch
		v_ssp=v_ssp_before;
		x_sp=x_sp_before;
		for sp = 1:spCount
			[v_ssp(sp,:),x_sp(sp,:)]=Update_Prtcl_Posn_WPredVOR_optmzd_prfrd(NODES(sp),dt,CONNECT{sp},N{sp},nmass_si,nforce_si,nmomentum_si,v_ssp(sp,:),x_sp(sp,:),TheFieldSplit(:,sp));
		end
	end
	
	
	v_ssp_free=v_ssp;
	
	for ni=1:length(NodeswithPredXVel)
		i=NodeswithPredXVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+sum(Nmatrix(i,sp))*(PredXVel - v_ssp_free(sp,1));
		end
	end

	for ni=1:length(NodeswithPredYVel)
		i=NodeswithPredYVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp))*(PredYVel - v_ssp_free(sp,2));
		end
	end

	for ni=1:length(NodeswithPredYVel2)
		i=NodeswithPredYVel2(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp))*(PredYVel2 - v_ssp_free(sp,2));
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [v_ssp,x_sp] = Update_Prtcl_Posn_WPredVOR_optmzd_prfrd(NODES,dt,CONNECT,N,nmass_si,nforce_si,nmomentum_si,v_ssp,x_sp,TheFieldSplit)
	
	for j = 1:NODES
		npid                           = CONNECT(j);
		if nmass_si(npid,TheFieldSplit(npid,1))==0
			continue;
		end
		v_ssp(1,:)                  = v_ssp(1,:) + dt * N(j) * (nforce_si(npid,:,TheFieldSplit(npid,1))/nmass_si(npid,TheFieldSplit(npid,1)));%*(0.5^(1/1000)); %damping

		x_sp(1,:)                       = x_sp(1,:) + nmomentum_si(npid,:,TheFieldSplit(npid,1))*N(j)*dt/nmass_si(npid,TheFieldSplit(npid,1));
	end   
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [v_ssp,x_sp] = Update_Particle_Position_WithPredVel2_optimized(ParticleswithPredYVel,ParticlePredYVel,Nmatrix,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2,TheFieldSplit)

	%v_ssp=v_ssp*(0.5^(1/1000)); %damping
	
	fieldnumber=max(max(TheFieldSplit));

	a_si=zeros(length(nmass_si),2,fieldnumber);
	v_si=zeros(length(nmass_si),2,fieldnumber);
	
	
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid                           = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			end
			v_ssp(sp,:)                  = v_ssp(sp,:) + dt * N{sp}(j) * (nforce_si(npid,:,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)));%*(0.5^(1/1000)); %damping
		end   
	end
	npredvelsp=length(ParticleswithPredYVel);
	for ipredvelsp=1:npredvelsp
		sp=ParticleswithPredYVel(ipredvelsp);
		pyforcedispctrl(1)=0;
		pyforcedispctrl(2)=1;
		for iteration=1:9999
			v_ssp_temp=v_ssp;
			nforcedispctrl_si=zeros(size(nforce_si));
			if iteration>2
				pyforcedispctrl(iteration)=pyforcedispctrl(iteration-1)+(pyforcedispctrl(iteration-1)-pyforcedispctrl(iteration-2))/(v_ssp_out(iteration-1)-v_ssp_out(iteration-2))*(ParticlePredYVel(ipredvelsp)-v_ssp_out(iteration-1));
			end
			for ni=1:length(CONNECT{ParticleswithPredYVel(ipredvelsp)})
				npid=CONNECT{ParticleswithPredYVel(ipredvelsp)}(ni);
				nforcedispctrl_si(npid,2,TheFieldSplit(npid,ParticleswithPredYVel(ipredvelsp)))=nforcedispctrl_si(npid,2,TheFieldSplit(npid,ParticleswithPredYVel(ipredvelsp)))+pyforcedispctrl(iteration)*Nmatrix(npid,ParticleswithPredYVel(ipredvelsp));
				for nsp=1:length(CONNECTpn{npid})
					sp=CONNECTpn{npid}(nsp);
					if nmass_si(npid,TheFieldSplit(npid,sp))==0
						continue;
					end
					v_ssp_temp(sp,:)                  = v_ssp_temp(sp,:) + dt * Nmatrix(npid,sp) * (nforcedispctrl_si(npid,:,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)));%*(0.5^(1/1000)); %damping
				end
			end
			v_ssp_out(iteration)=v_ssp_temp(ParticleswithPredYVel(ipredvelsp),2);
			if abs(v_ssp_out(iteration)-ParticlePredYVel(ipredvelsp))<1e-9
				v_ssp=v_ssp_temp;
				nmomentum_si=nmomentum_si+nforcedispctrl_si*dt;
				break;
			end
		end
	end
	
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid                           = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			end
			x_sp(sp,:)                       = x_sp(sp,:) + nmomentum_si(npid,:,TheFieldSplit(npid,sp))*N{sp}(j)*dt/nmass_si(npid,TheFieldSplit(npid,sp));
		end   
	end
	
	v_ssp_free=v_ssp;
	
	for ni=1:length(NodeswithPredXVel)
		i=NodeswithPredXVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+sum(Nmatrix(i,sp))*(PredXVel - v_ssp_free(sp,1));
		end
	end

	for ni=1:length(NodeswithPredYVel)
		i=NodeswithPredYVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp))*(PredYVel - v_ssp_free(sp,2));
		end
	end

	for ni=1:length(NodeswithPredYVel2)
		i=NodeswithPredYVel2(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp))*(PredYVel2 - v_ssp_free(sp,2));
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [v_ssp,x_sp] = Update_Particle_Position_WithPredVel3_optimized(ParticleswithPredYVel,ParticlePredYVel,Nmatrix,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2,TheFieldSplit)

	%v_ssp=v_ssp*(0.5^(1/1000)); %damping
	
	fieldnumber=max(max(TheFieldSplit));
	
	a_si=zeros(length(nmass_si),2,fieldnumber);
	v_si=zeros(length(nmass_si),2,fieldnumber);

	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid                           = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			end
			v_ssp(sp,:)                  = v_ssp(sp,:) + dt * N{sp}(j) * (nforce_si(npid,:,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)));%*(0.5^(1/1000)); %damping
		end   
	end
	v_ssp_free=v_ssp;
    nmomentum_si_trial=nmomentum_si;
	
	npredvelsp=length(ParticleswithPredYVel);
	for ipredvelsp=1:npredvelsp
		sigmaNsquare=0;
		sp=ParticleswithPredYVel(ipredvelsp);
		
		% sigmaNsquare needs to be calculated for determining the imposed deltavp
		for ni=1:length(CONNECT{sp})
			sigmaNsquare=sigmaNsquare+N{sp}(ni)^2;
        end
        tolerance=1e-3;
        for iteration=1:999
            v_ssp_trial=v_ssp;
            sp=ParticleswithPredYVel(ipredvelsp);
            if iteration==1
                deltavp(iteration)=(ParticlePredYVel(ipredvelsp)-v_ssp_free(sp,2))/sigmaNsquare;
            elseif iteration==2
                deltavp(iteration)=deltavp(iteration-1)*2+tolerance;
            else
                deltavp(iteration)=deltavp(iteration-1)+(deltavp(iteration-2)-deltavp(iteration-1))/(v_ssp_out(iteration-2)-v_ssp_out(iteration-1))*(ParticlePredYVel(ipredvelsp)-v_ssp_out(iteration-1));
            end

            % spreading deltavp to PredYVel of nodes
            PredYVelFromParticle=zeros(length(CONNECT{sp}),1);
            for ni=1:length(CONNECT{sp})
                i=CONNECT{sp}(ni);
                if nmass_si(i,TheFieldSplit(i,sp))==0
                    continue;
                end
                PredYVelFromParticle(ni)=nmomentum_si(i,2,TheFieldSplit(i,sp))/nmass_si(i,TheFieldSplit(i,sp))+N{sp}(ni)*deltavp(iteration);
                nmomentum_si_trial(i,2,TheFieldSplit(i,sp))=PredYVelFromParticle(ni)*nmass_si(i,TheFieldSplit(i,sp));
            end

            % mapping back the spread 
            Nsum=0;%debugging disp control
            for ni=1:length(CONNECT{ParticleswithPredYVel(ipredvelsp)})
                i=CONNECT{ParticleswithPredYVel(ipredvelsp)}(ni);
                for nsp=1:length(CONNECTpn{i})
                    sp=CONNECTpn{i}(nsp);
                    v_ssp_trial(sp,2)=v_ssp_trial(sp,2)+sum(Nmatrix(i,sp))*(PredYVelFromParticle(ni) - v_ssp_free(sp,2));
                end
            end
            v_ssp_out(iteration)=v_ssp_trial(ParticleswithPredYVel(ipredvelsp),2);
            if abs(v_ssp_out(iteration)-ParticlePredYVel(ipredvelsp))<tolerance
                v_ssp=v_ssp_trial;
                nmomentum_si=nmomentum_si_trial;
                break;
            end
        end
        
		v_ssp_free=v_ssp;
	end
	
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid                           = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			end
			x_sp(sp,:)                       = x_sp(sp,:) + nmomentum_si(npid,:,TheFieldSplit(npid,sp))*N{sp}(j)*dt/nmass_si(npid,TheFieldSplit(npid,sp));
		end   
	end
	
	
	for ni=1:length(NodeswithPredXVel)
		i=NodeswithPredXVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+sum(Nmatrix(i,sp))*(PredXVel - v_ssp_free(sp,1));
		end
	end

	for ni=1:length(NodeswithPredYVel)
		i=NodeswithPredYVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp))*(PredYVel - v_ssp_free(sp,2));
		end
	end

	for ni=1:length(NodeswithPredYVel2)
		i=NodeswithPredYVel2(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp))*(PredYVel2 - v_ssp_free(sp,2));
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [v_ssp,x_sp] = Update_Particle_Position_WithPredVel2_optimized_failed(Nmatrix,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2,TheFieldSplit)
	%v_ssp=v_ssp*(0.5^(1/1000)); %damping

	fieldnumber=size(Nmatrix,3);

	a_si=zeros(length(nmass_si),2,fieldnumber);
	v_si=zeros(length(nmass_si),2,fieldnumber);
%{
	for field=1:fieldnumber
		try
			parfor i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
					a_si(i,:,field)=nforce_si(i,:,field)/nmass_si(i,field);
					v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
		catch
			disp('Update_Particle_Position_WithPredVel2 a_si v_si parfor failed!');
			disp('Rolling back to regular for');
			for i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
					a_si(i,:,field)=nforce_si(i,:,field)/nmass_si(i,field);
					v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
		end
	end

	for field=1:fieldnumber
		for direction=1:2
			v_ssp(:,direction)=v_ssp(:,direction)+dt*transpose(Nmatrix(:,:,field))*(a_si(:,direction,field));
			x_sp(:,direction)=x_sp(:,direction)+dt*transpose(Nmatrix(:,:,field))*(v_si(:,direction,field));
		end
	end
%}
	
	for sp = 1:spCount
		 for j = 1:NODES(sp)
			 npid                           = CONNECT{sp}(j);
			  if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			  end
			  %{
			  NodeisPredXVel=0;
			  for k=1:length(NodeswithPredXVel)
				 if npid==NodeswithPredXVel(k)
					 NodeisPredXVel=1;
					 break
				 end
			 end
			  NodeisPredYVel=0;          
			  for k=1:length(NodeswithPredYVel)
				 if npid==NodeswithPredYVel(k)
					 NodeisPredYVel=1;
					 break
				 end
			  end
			  NodeisPredYVel2=0;
			  for k=1:length(NodeswithPredYVel2)
				 if npid==NodeswithPredYVel2(k)
					 NodeisPredYVel2=1;
					 break
				 end
			  end
			  %}
			  %if NodeisPredXVel==0
				 v_ssp(sp,1)                  = v_ssp(sp,1) + dt * Nmatrix(npid,sp,TheFieldSplit(npid,sp)) * (nforce_si(npid,1,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)));%*(0.5^(1/1000)); %damping
			 %else
			 %    v_ssp(sp,1)                  = v_ssp(sp,1) + N{sp}(j)*(PredXVel - v_ssp(sp,1));
			 %end
			 
			 %if NodeisPredYVel==0
				 v_ssp(sp,2)                      = v_ssp(sp,2) + dt * Nmatrix(npid,sp,TheFieldSplit(npid,sp)) * (nforce_si(npid,2,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)));%*(0.5^(1/1000)); %damping
			 %else
			 %    v_ssp(sp,2)                  = v_ssp(sp,2) + N{sp}(j)*(PredYVel - v_ssp(sp,2));
			 %end
			 
			 %if NodeisPredYVel2==0
			 %    v_ssp(sp,2)                      = v_ssp(sp,2) + dt * N{sp}(j) * (nforce_si(npid,2)/nmass_si(npid));%*(0.5^(1/1000)); %damping
			 %else
			 %    v_ssp(sp,2)                  = v_ssp(sp,2) + N{sp}(j)*(PredYVel2 - v_ssp(sp,2));
			 %end
			 %v_ssp(sp,2)                      = v_ssp(sp,2) + dt * N{sp}(j) * (nforce_si(npid,2)/nmass_si(npid));
			 
			 x_sp(sp,:)                       = x_sp(sp,:) + nmomentum_si(npid,:,TheFieldSplit(npid,sp))*Nmatrix(npid,sp,TheFieldSplit(npid,sp))*dt/ nmass_si(npid,TheFieldSplit(npid,sp));
		 end   
	end
	

	v_ssp_free=v_ssp;

	for ni=1:length(NodeswithPredXVel)
		i=NodeswithPredXVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+sum(Nmatrix(i,sp,:))*(PredXVel - v_ssp_free(sp,1));
		end
	end

	for ni=1:length(NodeswithPredYVel)
		i=NodeswithPredYVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp,:))*(PredYVel - v_ssp_free(sp,2));
		end
	end

	for ni=1:length(NodeswithPredYVel2)
		i=NodeswithPredYVel2(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp,:))*(PredYVel2 - v_ssp_free(sp,2));
		end
	end


end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [nvelo_si,L_si] = Interpolate_velocity_back(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp,N,dN,nmass_si,Nmatrix,dNxmatrix,dNymatrix)
	fieldnumber=size(Nmatrix,3);

	%% Interpolation from particle to grid task
	% Node variables

	 nvelo_si                = zeros(nodeCount,2,fieldnumber);                   % Nodal Velocity
	 nmomentum_si            = zeros(nodeCount,2,fieldnumber);                   % Nodal Momentum
	 L_si                    = zeros(nodeCount,2,2,fieldnumber);

	for field=fieldnumber:-1:1
		nmass_si(:,field)                = Nmatrix(:,:,field)*m_sp;                         % Nodal Mass
		nmomentum_si(:,1,field)       = Nmatrix(:,:,field)*(m_sp.*v_ssp(:,1));           % Nodal Momentum in X direction
		nmomentum_si(:,2,field)       = Nmatrix(:,:,field)*(m_sp.*v_ssp(:,2));           % Nodal Momentum in Y direction
		L_si(:,1,1,field)=dNxmatrix(:,:,field)*v_ssp(:,1);
		L_si(:,1,2,field)=dNymatrix(:,:,field)*v_ssp(:,1);
		L_si(:,2,1,field)=dNxmatrix(:,:,field)*v_ssp(:,2);
		L_si(:,2,2,field)=dNymatrix(:,:,field)*v_ssp(:,2);
	end
	 
	 for field=1:fieldnumber
		try
			parfor i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
					nvelo_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
		catch
			disp('Update_Particle_Position_WithPredVel2 a_si v_si parfor failed!');
			disp('Rolling back to regular for');
			for i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
					nvelo_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
		end
	end

	 
	 % Momentum
	 %{
	 for sp = 1:spCount
		 for j = 1:NODES(sp)
			 npid                  = CONNECT{sp}(j);
			 nmomentum_si(npid,:)  = nmomentum_si(npid,:) + m_sp(sp)*v_ssp(sp,:)*N{sp}(j);

	%{
	if v_ssp(sp,1)*N{sp}(j)~=0|v_ssp(sp,2)*N{sp}(j)~=0
		texttodisplay=[];
		texttodisplay=[texttodisplay 'sp=' num2str(sp)];
		texttodisplay=[texttodisplay '; npid=' num2str(npid)];
		texttodisplay=[texttodisplay '; j=' num2str(j)];
		texttodisplay=[texttodisplay '; v_ssp(sp,1)=' num2str(v_ssp(sp,1))];
		texttodisplay=[texttodisplay '; N{sp}(j)=' num2str(N{sp}(j))];
		texttodisplay=[texttodisplay '; v_ssp(sp,1)*N{sp}(j)=' num2str(v_ssp(sp,1)*N{sp}(j))];
		texttodisplay=[texttodisplay '; nmomentum_si(npid,1)=' num2str(nmomentum_si(npid,1))];
		disp(texttodisplay);
	1;
	end
	%}
			 
			for p=1:2
				for q=1:2
					L_si(npid,p,q)=L_si(npid,p,q)+v_ssp(sp,p)*dN{sp}(q,j);
				end
			end
		 end
	 end
	 
	 % Velocity
	  for sp = 1:spCount
	 for j = 1:NODES(sp)
		 npid                      = CONNECT{sp}(j);
				  if nmass_si(npid)==0
					continue
				  end 
				  
	nvelo_si(npid,:)               = nmomentum_si(npid,:)/nmass_si(npid); 
	%{
	if nvelo_si(npid,1)~=0|nvelo_si(npid,2)~=0
		texttodisplay=[];
		texttodisplay=[texttodisplay 'npid=' num2str(npid)];
		texttodisplay=[texttodisplay '; nmomentum_si(npid,:)=[' num2str(nmomentum_si(npid,1)) ',' num2str(nmomentum_si(npid,2)) ']'];
		texttodisplay=[texttodisplay '; nmass_si(npid)=' num2str(nmass_si(npid))];
		texttodisplay=[texttodisplay '; nvelo_si(npid,:)=[' num2str(nvelo_si(npid,1)) ',' num2str(nvelo_si(npid,2)) ']'];
		disp(texttodisplay);
		1;
	end
	%}
	 end
	  end
	 %}
	1;
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [nvelo_si] = Interpolate_velocity_back_optimized(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp,N,dN,nmass_si,TheFieldSplit)
	fieldnumber=max(max(TheFieldSplit));

	%% Interpolation from particle to grid task
	% Node variables
 
	 nvelo_si                = zeros(nodeCount,2,fieldnumber);                   % Nodal Velocity
	 nmomentum_si            = zeros(nodeCount,2,fieldnumber);                   % Nodal Momentum
	% L_si                    = zeros(nodeCount,2,2,fieldnumber);

	 % Momentum
	
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid                  = CONNECT{sp}(j);
			nmomentum_si(npid,:,TheFieldSplit(npid,sp))  = nmomentum_si(npid,:,TheFieldSplit(npid,sp)) + m_sp(sp)*v_ssp(sp,:)*N{sp}(j);
%{
			for p=1:2
				for q=1:2
					L_si(npid,p,q,TheFieldSplit(npid,sp))=L_si(npid,p,q,TheFieldSplit(npid,sp))+v_ssp(sp,p)*dN{sp}(q,j);
				end
			end
%}
		end
	end

	% Velocity
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid                      = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue
			end 
			nvelo_si(npid,:,TheFieldSplit(npid,sp))               = nmomentum_si(npid,:,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)); 
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [data]=Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,data)
	for i=1:nfbcx
		data(fbcx(i),1,:)     = 0;
	end

	for i=1:nfbcy
		data(fbcy(i),2,:)     = 0;
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [F_sp,A_sp,t_sp,s_sp,p_sp,E_acc,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,evaltimes,stackvars,duration,dudx_sp,W_sp,thetacrackrtl,thetacrack,justcracked,Qacoustic,h,RQ,QbackRback,AbeforeQ_rtl] = ...
    Update_Stress_par(CModel,NODES,dt,cellCount,mspoints,CONNECT,nvelo_si,dN,E,nu,F_sp,A_spo,t_spo,m_sp,s_sp,p_sp,A_sp,t_sp,E_acc,epsilonshrinkdot_sp,epsilonshrinkdotx_sp,epsilonshrinkdoty_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,troubleshotparticles,matmodel,weakeningfactor_sp,orientationoffset,Rdisplayedparticles,t,Debugging,Nmatrix,dNxmatrix,dNymatrix,spCount,dudx_sp,W_sp,thetacrackrtl)
	% Calculate stress for solid phase
	fieldnumber=size(Nmatrix,3);

	L_sp_vect=zeros(spCount,2,2);
	dudx_matrix=zeros(2,2,spCount);
	for field=fieldnumber:-1:1
		L_sp_vect(:,1,1)=L_sp_vect(:,1,1)+transpose(dNxmatrix(:,:,field))*nvelo_si(:,1,field);
		L_sp_vect(:,1,2)=L_sp_vect(:,1,2)+transpose(dNymatrix(:,:,field))*nvelo_si(:,1,field);
		L_sp_vect(:,2,1)=L_sp_vect(:,2,1)+transpose(dNxmatrix(:,:,field))*nvelo_si(:,2,field);
		L_sp_vect(:,2,2)=L_sp_vect(:,2,2)+transpose(dNymatrix(:,:,field))*nvelo_si(:,2,field);
	end
		
	for c=1:cellCount
		mpts = mspoints{c};
		
		for sp = 1:length(mpts)
			spid = mpts(sp);
			L_sp{spid} = [L_sp_vect(spid,1,1) L_sp_vect(spid,1,2) ; L_sp_vect(spid,2,1) L_sp_vect(spid,2,2)];
		
	%		for j=1:NODES(spid)
	%				  if dN{spid}(j)==0
	%				 continue
	%				  end
	%					npid = CONNECT{spid}(j);
	%					L_sp{spid} = L_sp{spid} + (nvelo_si(npid,:)'*dN{spid}(:,j)');
	 %       end
			%ESP_prev=[e_t_global_big(spid,1) e_t_global_big(spid,4);e_t_global_big(spid,4) e_t_global_big(spid,2)];

			dESP{spid} = ((L_sp{spid} + L_sp{spid}')/2-([epsilonshrinkdot_sp(spid)+epsilonshrinkdotx_sp(spid) 0;0 epsilonshrinkdot_sp(spid)+epsilonshrinkdoty_sp(spid)]))*dt; 
		   % if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
		   %     W{spid}=(L_sp{spid} - L_sp{spid}')/2;
		   %     s_sp_prev(spid,1)=sigma_global_big(spid,1);
		   %     s_sp_prev(spid,2)=sigma_global_big(spid,2);
		   %     s_sp_prev(spid,3)=sigma_global_big(spid,4);
		   % end
			
			F_sp{spid} = (eye(2,2)+L_sp{spid}*dt)*F_sp{spid};
			%dESP{spid} = transpose(F_sp{spid})*dESP{spid}*F_sp{spid};
			%deltaF=L_sp{spid}*dt*F_sp{spid};
			J{spid} = det(F_sp{spid});
			A_sp(spid)=A_spo(spid)*J{spid};
			
			t_sp(spid)=t_spo(spid)*exp(e_t_global_big(spid,3));

			p_sp(spid) = m_sp(spid)/(A_sp(spid)*t_sp(spid));
			%ESP_now=1/2*(transpose(F_sp{spid})*F_sp{spid}-eye(2));
			%dESP{spid} = ESP_now-ESP_prev;
			%dESP{spid}=1/2*(deltaF*transpose(F_sp{spid})+F_sp{spid}*transpose(deltaF));
			%dESP{spid}=1/2*(deltaF+transpose(deltaF)+transpose(deltaF)*deltaF);
			
			%{
			dudx_sp(spid,1)=dudx_sp(spid,1)+L_sp{spid}(1,1)*dt;
			dudx_sp(spid,2)=dudx_sp(spid,2)+L_sp{spid}(1,2)*dt;
			dudx_sp(spid,3)=dudx_sp(spid,3)+L_sp{spid}(2,1)*dt;
			dudx_sp(spid,4)=dudx_sp(spid,4)+L_sp{spid}(2,2)*dt;
			%}
			
			dudx_matrix(:,:,spid)=eye(2)-(F_sp{spid}^(-1));
			dudx_sp(spid,1)=dudx_matrix(1,1,spid);
			dudx_sp(spid,2)=dudx_matrix(1,2,spid);
			dudx_sp(spid,3)=dudx_matrix(2,1,spid);
			dudx_sp(spid,4)=dudx_matrix(2,2,spid);
		end      
	end
	evaltimes=zeros(length(dESP),1);
	for i=1:length(Rdisplayedparticles)
		Rback=poldecomp(F_sp{Rdisplayedparticles(i)},0);
		R=transpose(Rback);
		Q=[cos(orientationoffset(Rdisplayedparticles(i))) sin(orientationoffset(Rdisplayedparticles(i))); -sin(orientationoffset(Rdisplayedparticles(i))) cos(orientationoffset(Rdisplayedparticles(i)))];
		%Qback=[cos(-orientationoffset(Rdisplayedparticles(i))) sin(-orientationoffset(Rdisplayedparticles(i))); -sin(-orientationoffset(Rdisplayedparticles(i))) cos(-orientationoffset(Rdisplayedparticles(i)))];
		RQ=R*Q;
		thetarotateall=asin(RQ(1,2));
		thetarotateoriginal=asin(Q(1,2));
		disp([PrintMatrixVectorized(RQ,['RQ{' num2str(Rdisplayedparticles(i)) '}'],0) '; theta=' num2str(thetarotateall*180/pi) ' deg; thetaoriginal=' num2str(thetarotateoriginal*180/pi) ' deg']);
		
	end
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==5 || CasetoRun==6 || CasetoRun==10 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		if s_sp(3,1)<-5.95
			1;
		end
		
		f_final_vect=zeros(size(alphahp));
		surfacewithfmax=zeros(size(E_acc));
		sigma_local_big=zeros(size(sigma_global_big));
		switcherconfirmer=zeros(1,length(dESP));
		thetacrack=zeros(1,length(dESP));
		
		s_sp_store=s_sp;
		sigma_global_big_store=sigma_global_big;
		e_t_global_big_store=e_t_global_big;
		e_pl_global_big_store=e_pl_global_big;
		alphahp_store=alphahp;
		thetacrackrtl_store=thetacrackrtl;
		
		stackvars=zeros(length(dESP)+1,2);
		justcracked=zeros(length(dESP),1);
		Qacoustic=cell(1,length(dESP));
		h=cell(1,length(dESP));
		RQ=zeros(2,2,length(dESP));
		QbackRback=zeros(2,2,length(dESP));

		try
			if Debugging.Active && CloseEnough(t,Debugging.Time)
				asdf(-pi);
			end
			
			parforstarttime=clockallsec;
			parfor spid=1:length(dESP) %originally parfor
				[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid),switcherconfirmer(spid),evaltimes(spid),stackvars(spid,:),duration(spid),thetacrackrtl(spid),thetacrack(spid),justcracked(spid),Qacoustic{spid},h{spid},RQ(:,:,spid),QbackRback(:,:,spid),AbeforeQ_rtl(:,:,:,:,spid)]= ... 
					Matmodel_parforred_confirmer(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid),switcherconfirmer(spid),t,dt,spid,Debugging,parforstarttime,thetacrackrtl(spid),dudx_matrix(:,:,spid));   
			end
		catch		
			s_sp=s_sp_store;
			sigma_global_big=sigma_global_big_store;
			e_t_global_big=e_t_global_big_store;
			e_pl_global_big=e_pl_global_big_store;
			alphahp=alphahp_store;
			thetacrackrtl=thetacrackrtl_store;
			
			disp('that parfor random error again!');
			printvector(switcherconfirmer,'switcherconfirmer');
			disp(['# of done particles = ' num2str(sum(switcherconfirmer))]);
			switcherconfirmer=zeros(1,length(dESP));
			parforstarttime=clockallsec;
			for spid=1:length(dESP)
				[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid),switcherconfirmer(spid),evaltimes(spid),stackvars(spid,:),duration(spid),thetacrackrtl(spid),thetacrack(spid),justcracked(spid),Qacoustic{spid},h{spid},RQ(:,:,spid),QbackRback(:,:,spid),AbeforeQ_rtl(:,:,:,:,spid)]= ... 
					Matmodel_parforred_confirmer(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid),switcherconfirmer(spid),t,dt,spid,Debugging,parforstarttime,thetacrackrtl(spid),dudx_matrix(:,:,spid));   
			end
			disp('regular for alternative successful!')
			printvector(switcherconfirmer,'switcherconfirmer');
			1;
		end
		stackvars(length(dESP)+1,2)=max(stackvars(:,1)+stackvars(:,2));
		stackvars(length(dESP)+1,1)=0;
		1==1;
		if 1==0
			h = barh(stackvars,'stacked');
			set(h,{'FaceColor'},{'w';'k'},'EdgeColor','none');
		end
	elseif CasetoRun==4
		parfor spid=1:length(dESP)
			switch CModel
				case 'Neo_Hookean_Elastic'
					[s_sp(spid,:)]=Neo_Hookean_elastic(F_sp{spid},J{spid},E,nu);
				case 'Linear_Elastic'
					[s_sp(spid,:)]=Linear_elastic(dESP{spid},s_sp(spid,:),E,nu);
					f_final_vect(spid,:)=zeros(1,7);
					surfacewithfmax(spid)=0;
				case 'Mises'
					[s_sp(spid,:)]=Von_Mises(dESP{spid},s_sp(spid,:),E,nu,30);
				case 'Mises_Softening'
					[s_sp(spid,:),E_acc(spid),e_pl_sp(spid,:)]=Von_Mises_Softening(dESP{spid},s_sp(spid,:),E,nu,30,E_acc(spid),e_pl_sp(spid,:));
				case 'Wood_Schmidt5'
					[s_sp(spid,:),e_pl_sp(spid,:)]=Wood_Schmidt5(dESP{spid},s_sp(spid,:),e_pl_sp(spid,:));
					E_acc(spid)=0;
				case 'Wood_Schmidt15'
					[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:)]=Wood_Schmidt15_function(dESP{spid},sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:));
					E_acc(spid)=0;
				case 'Wood_Schmidt16'
					[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:)]=Wood_Schmidt16(dESP{spid},sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:));
					E_acc(spid)=0;
				case 'Wood_Schmidt17'
					[s_sp(spid,:),e_pl_sp(spid,: ),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:)]= ...
						Wood_Schmidt17(dESP{spid},sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun);

					E_acc(spid)=0;
			end    
		end
	%elseif CasetoRun==5 || CasetoRun==6
	%    f_final_vect=zeros(size(alphahp));
	%    surfacewithfmax=zeros(size(E_acc));
	%    sigma_local_big=zeros(size(sigma_global_big));
	%    parfor spid=1:length(dESP) %originally parfor
	%        [s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid)]= ... 
	%            Matmodel_parforred(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid));   
	%    end
	elseif CasetoRun==7
		if s_sp(3,1)<-5.95
			1;
		end
		f_final_vect=zeros(size(alphahp));
		surfacewithfmax=zeros(size(E_acc));
		sigma_local_big=zeros(size(sigma_global_big));
		parfor spid=1:length(dESP) %originally parfor
			[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid),AbeforeQ_rtl(:,:,:,:,spid)]= ... 
				Matmodel_parforred(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid));   
		end
	elseif CasetoRun==8 || CasetoRun==9
		f_final_vect=zeros(size(alphahp));
		surfacewithfmax=zeros(size(E_acc));
		sigma_local_big=zeros(size(sigma_global_big));
		parfor spid=1:length(dESP) %originally parfor
			[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid),AbeforeQ_rtl(:,:,:,:,spid)]= ... 
				Matmodel_parforred(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid));   
		end
	%{    
	elseif CasetoRun==10
		if s_sp(3,1)<-5.95
			1;
		end
		f_final_vect=zeros(size(alphahp));
		surfacewithfmax=zeros(size(E_acc));
		sigma_local_big=zeros(size(sigma_global_big));
		parfor spid=1:length(dESP) %originally parfor
			[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid)]= ... 
				Matmodel_parforred(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid));   
		end
		%}
	end
	for sp=1:spCount
		dW_sp=sum(sum([s_sp(sp,1) s_sp(sp,3);s_sp(sp,3) s_sp(sp,2)].*dESP{sp}));
		W_sp(sp)=W_sp(sp)+dW_sp;
	end
	%{
	for spid=1:length(dESP)
	%    if spid==troubleshotparticles(1) | spid==troubleshotparticles(2)
	%        if e_pl_sp(troubleshotparticles(1),1)<-1e-10 | e_pl_sp(troubleshotparticles(2),1)<-1e-10
	%            1;
	%        end
	%    end
		newSSP=(1/J{spid})*F_sp{spid}*[s_sp(spid,1) s_sp(spid,3);s_sp(spid,3) s_sp(spid,2)]*transpose(F_sp{spid});
		s_sp(spid,1)=newSSP(1,1);
		s_sp(spid,2)=newSSP(2,2);
		s_sp(spid,3)=newSSP(1,2);
	end
	%}
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [F_sp,A_sp,t_sp,s_sp,p_sp,E_acc,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,evaltimes,stackvars,duration,dudx_sp,W_sp,thetacrackrtl,thetacrack,justcracked,Qacoustic,h,RQ,QbackRback,AbeforeQ_rtl] = ...
    Update_Stress_par_optimized(CModel,NODES,dt,cellCount,mspoints,CONNECT,nvelo_si,dN,E,nu,F_sp,A_spo,t_spo,m_sp,s_sp,p_sp,A_sp,t_sp,E_acc,epsilonshrinkdot_sp,epsilonshrinkdotx_sp,epsilonshrinkdoty_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,troubleshotparticles,matmodel,weakeningfactor_sp,orientationoffset,Rdisplayedparticles,t,Debugging,spCount,dudx_sp,W_sp,thetacrackrtl,TheFieldSplit)
	% Calculate stress for solid phase
	fieldnumber=max(max(TheFieldSplit));
	L_sp=cell(1,spCount);
	for c=1:cellCount
		mpts = mspoints{c};
		
		for sp = 1:length(mpts)
			spid = mpts(sp);
			%L_sp{spid} = [L_sp_vect(spid,1,1) L_sp_vect(spid,1,2) ; L_sp_vect(spid,2,1) L_sp_vect(spid,2,2)];
			L_sp{spid} = zeros(2,2);
			for j=1:NODES(spid)
				if dN{spid}(j)==0
					continue
				end
				npid = CONNECT{spid}(j);
				L_sp{spid} = L_sp{spid} + (nvelo_si(npid,:,TheFieldSplit(npid,spid))'*dN{spid}(:,j)');
	       end
			%ESP_prev=[e_t_global_big(spid,1) e_t_global_big(spid,4);e_t_global_big(spid,4) e_t_global_big(spid,2)];

			dESP{spid} = ((L_sp{spid} + L_sp{spid}')/2-([epsilonshrinkdot_sp(spid)+epsilonshrinkdotx_sp(spid) 0;0 epsilonshrinkdot_sp(spid)+epsilonshrinkdoty_sp(spid)]))*dt; 
		   % if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
		   %     W{spid}=(L_sp{spid} - L_sp{spid}')/2;
		   %     s_sp_prev(spid,1)=sigma_global_big(spid,1);
		   %     s_sp_prev(spid,2)=sigma_global_big(spid,2);
		   %     s_sp_prev(spid,3)=sigma_global_big(spid,4);
		   % end
			
			F_sp{spid} = (eye(2,2)+L_sp{spid}*dt)*F_sp{spid};
			%dESP{spid} = transpose(F_sp{spid})*dESP{spid}*F_sp{spid};
			%deltaF=L_sp{spid}*dt*F_sp{spid};
			J{spid} = det(F_sp{spid});
			A_sp(spid)=A_spo(spid)*J{spid};
			
			t_sp(spid)=t_spo(spid)*exp(e_t_global_big(spid,3));

			p_sp(spid) = m_sp(spid)/(A_sp(spid)*t_sp(spid));
			%ESP_now=1/2*(transpose(F_sp{spid})*F_sp{spid}-eye(2));
			%dESP{spid} = ESP_now-ESP_prev;
			%dESP{spid}=1/2*(deltaF*transpose(F_sp{spid})+F_sp{spid}*transpose(deltaF));
			%dESP{spid}=1/2*(deltaF+transpose(deltaF)+transpose(deltaF)*deltaF);
			
			%{
			dudx_sp(spid,1)=dudx_sp(spid,1)+L_sp{spid}(1,1)*dt;
			dudx_sp(spid,2)=dudx_sp(spid,2)+L_sp{spid}(1,2)*dt;
			dudx_sp(spid,3)=dudx_sp(spid,3)+L_sp{spid}(2,1)*dt;
			dudx_sp(spid,4)=dudx_sp(spid,4)+L_sp{spid}(2,2)*dt;
			%}
			
			dudx_matrix(:,:,spid)=eye(2)-(F_sp{spid}^(-1));
			dudx_sp(spid,1)=dudx_matrix(1,1,spid);
			dudx_sp(spid,2)=dudx_matrix(1,2,spid);
			dudx_sp(spid,3)=dudx_matrix(2,1,spid);
			dudx_sp(spid,4)=dudx_matrix(2,2,spid);
		end      
	end
	evaltimes=zeros(length(dESP),1);
	for i=1:length(Rdisplayedparticles)
		Rback=poldecomp(F_sp{Rdisplayedparticles(i)},0);
		R=transpose(Rback);
		Q=[cos(orientationoffset(Rdisplayedparticles(i))) sin(orientationoffset(Rdisplayedparticles(i))); -sin(orientationoffset(Rdisplayedparticles(i))) cos(orientationoffset(Rdisplayedparticles(i)))];
		%Qback=[cos(-orientationoffset(Rdisplayedparticles(i))) sin(-orientationoffset(Rdisplayedparticles(i))); -sin(-orientationoffset(Rdisplayedparticles(i))) cos(-orientationoffset(Rdisplayedparticles(i)))];
		RQ=R*Q;
		thetarotateall=asin(RQ(1,2));
		thetarotateoriginal=asin(Q(1,2));
		disp([PrintMatrixVectorized(RQ,['RQ{' num2str(Rdisplayedparticles(i)) '}'],0) '; theta=' num2str(thetarotateall*180/pi) ' deg; thetaoriginal=' num2str(thetarotateoriginal*180/pi) ' deg']);
		
	end
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==5 || CasetoRun==6 || CasetoRun==10 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==118 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		if s_sp(3,1)<-5.95
			1;
		end
		
		f_final_vect=zeros(size(alphahp));
		surfacewithfmax=zeros(size(E_acc));
		sigma_local_big=zeros(size(sigma_global_big));
		switcherconfirmer=zeros(1,length(dESP));
		thetacrack=zeros(1,length(dESP));
		
		s_sp_store=s_sp;
		sigma_global_big_store=sigma_global_big;
		e_t_global_big_store=e_t_global_big;
		e_pl_global_big_store=e_pl_global_big;
		alphahp_store=alphahp;
		thetacrackrtl_store=thetacrackrtl;
		
		stackvars=zeros(length(dESP)+1,2);
		justcracked=zeros(length(dESP),1);
		Qacoustic=cell(1,length(dESP));
		h=cell(1,length(dESP));
		RQ=zeros(2,2,length(dESP));
		QbackRback=zeros(2,2,length(dESP));
        AbeforeQ_rtl=zeros(2,2,2,2,length(dESP));

		try
			if Debugging.Active && CloseEnough(t,Debugging.Time)
				asdf(-pi);
            end
			parforstarttime=clockallsec;
			parfor spid=1:length(dESP) %originally parfor
				[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid),switcherconfirmer(spid),evaltimes(spid),stackvars(spid,:),duration(spid),thetacrackrtl(spid),thetacrack(spid),justcracked(spid),Qacoustic{spid},h{spid},RQ(:,:,spid),QbackRback(:,:,spid),AbeforeQ_rtl(:,:,:,:,spid)]= ... 
					Matmodel_parforred_confirmer(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid),switcherconfirmer(spid),t,dt,spid,Debugging,parforstarttime,thetacrackrtl(spid),dudx_matrix(:,:,spid));   
			end
		catch		
			s_sp=s_sp_store;
			sigma_global_big=sigma_global_big_store;
			e_t_global_big=e_t_global_big_store;
			e_pl_global_big=e_pl_global_big_store;
			alphahp=alphahp_store;
			thetacrackrtl=thetacrackrtl_store;
			
			disp('that parfor random error again!');
			printvector(switcherconfirmer,'switcherconfirmer');
			disp(['# of done particles = ' num2str(sum(switcherconfirmer))]);
			switcherconfirmer=zeros(1,length(dESP));
			parforstarttime=clockallsec;
			for spid=1:length(dESP)
				[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid),switcherconfirmer(spid),evaltimes(spid),stackvars(spid,:),duration(spid),thetacrackrtl(spid),thetacrack(spid),justcracked(spid),Qacoustic{spid},h{spid},RQ(:,:,spid),QbackRback(:,:,spid),AbeforeQ_rtl(:,:,:,:,spid)]= ... 
					Matmodel_parforred_confirmer(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid),switcherconfirmer(spid),t,dt,spid,Debugging,parforstarttime,thetacrackrtl(spid),dudx_matrix(:,:,spid));   
			end
			disp('regular for alternative successful!')
			printvector(switcherconfirmer,'switcherconfirmer');
			1;
		end
		stackvars(length(dESP)+1,2)=max(stackvars(:,1)+stackvars(:,2));
		stackvars(length(dESP)+1,1)=0;
		1==1;
		if 1==0
			h = barh(stackvars,'stacked');
			set(h,{'FaceColor'},{'w';'k'},'EdgeColor','none');
		end
	elseif CasetoRun==4
		parfor spid=1:length(dESP)
			switch CModel
				case 'Neo_Hookean_Elastic'
					[s_sp(spid,:)]=Neo_Hookean_elastic(F_sp{spid},J{spid},E,nu);
				case 'Linear_Elastic'
					[s_sp(spid,:)]=Linear_elastic(dESP{spid},s_sp(spid,:),E,nu);
					f_final_vect(spid,:)=zeros(1,7);
					surfacewithfmax(spid)=0;
				case 'Mises'
					[s_sp(spid,:)]=Von_Mises(dESP{spid},s_sp(spid,:),E,nu,30);
				case 'Mises_Softening'
					[s_sp(spid,:),E_acc(spid),e_pl_sp(spid,:)]=Von_Mises_Softening(dESP{spid},s_sp(spid,:),E,nu,30,E_acc(spid),e_pl_sp(spid,:));
				case 'Wood_Schmidt5'
					[s_sp(spid,:),e_pl_sp(spid,:)]=Wood_Schmidt5(dESP{spid},s_sp(spid,:),e_pl_sp(spid,:));
					E_acc(spid)=0;
				case 'Wood_Schmidt15'
					[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:)]=Wood_Schmidt15_function(dESP{spid},sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:));
					E_acc(spid)=0;
				case 'Wood_Schmidt16'
					[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:)]=Wood_Schmidt16(dESP{spid},sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:));
					E_acc(spid)=0;
				case 'Wood_Schmidt17'
					[s_sp(spid,:),e_pl_sp(spid,: ),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),AbeforeQ_rtl(:,:,:,:,spid)]= ...
						Wood_Schmidt17(dESP{spid},sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun);

					E_acc(spid)=0;
			end    
		end
	%elseif CasetoRun==5 || CasetoRun==6
	%    f_final_vect=zeros(size(alphahp));
	%    surfacewithfmax=zeros(size(E_acc));
	%    sigma_local_big=zeros(size(sigma_global_big));
	%    parfor spid=1:length(dESP) %originally parfor
	%        [s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid)]= ... 
	%            Matmodel_parforred(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid));   
	%    end
	elseif CasetoRun==7
		if s_sp(3,1)<-5.95
			1;
		end
		f_final_vect=zeros(size(alphahp));
		surfacewithfmax=zeros(size(E_acc));
		sigma_local_big=zeros(size(sigma_global_big));
		parfor spid=1:length(dESP) %originally parfor
			[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid),AbeforeQ_rtl(:,:,:,:,spid)]= ... 
				Matmodel_parforred(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid));   
		end
	elseif CasetoRun==8 || CasetoRun==9
		f_final_vect=zeros(size(alphahp));
		surfacewithfmax=zeros(size(E_acc));
		sigma_local_big=zeros(size(sigma_global_big));
		parfor spid=1:length(dESP) %originally parfor
			[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid),AbeforeQ_rtl(:,:,:,:,spid)]= ... 
				Matmodel_parforred(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid));   
		end
	%{    
	elseif CasetoRun==10
		if s_sp(3,1)<-5.95
			1;
		end
		f_final_vect=zeros(size(alphahp));
		surfacewithfmax=zeros(size(E_acc));
		sigma_local_big=zeros(size(sigma_global_big));
		parfor spid=1:length(dESP) %originally parfor
			[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid)]= ... 
				Matmodel_parforred(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid));   
		end
		%}
	end
	for sp=1:spCount
		dW_sp=sum(sum([s_sp(sp,1) s_sp(sp,3);s_sp(sp,3) s_sp(sp,2)].*dESP{sp}));
		W_sp(sp)=W_sp(sp)+dW_sp;
	end
	%{
	for spid=1:length(dESP)
	%    if spid==troubleshotparticles(1) | spid==troubleshotparticles(2)
	%        if e_pl_sp(troubleshotparticles(1),1)<-1e-10 | e_pl_sp(troubleshotparticles(2),1)<-1e-10
	%            1;
	%        end
	%    end
		newSSP=(1/J{spid})*F_sp{spid}*[s_sp(spid,1) s_sp(spid,3);s_sp(spid,3) s_sp(spid,2)]*transpose(F_sp{spid});
		s_sp(spid,1)=newSSP(1,1);
		s_sp(spid,2)=newSSP(2,2);
		s_sp(spid,3)=newSSP(1,2);
	end
	%}
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [s_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,E_acc,switcherconfirmer,evaltimes,stackvars,duration,thetacrackrtl,thetacrack,justcracked,Qacoustic,h,RQ,QbackRback,AbeforeQ_rtl]= ... 
    Matmodel_parforred_confirmer(F_sp,matmodel,dESP,s_sp,E,nu,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp,orientationoffset,switcherconfirmer,t,dt,spid,Debugging,parforstarttime,thetacrackrtl,dudx_matrix)
    matmodelstarttime=clockallsec;
    evaltimes=0;
    switch matmodel(1)
        case 1
            Rback=poldecomp(F_sp,0);
            %Rback=eye(2);
            R=transpose(Rback);
            Q=[cos(orientationoffset) sin(orientationoffset); -sin(orientationoffset) cos(orientationoffset)];
            Qback=[cos(-orientationoffset) sin(-orientationoffset); -sin(-orientationoffset) cos(-orientationoffset)];
            RQ=R*Q;
            QbackRback=Qback*Rback;
            dESP=(RQ)*dESP*transpose(RQ);
			dudx_rtl=(RQ)*dudx_matrix*transpose(RQ);
            [s_sp(1,:),e_pl_sp(1,:),sigma_global_big(1,:),e_t_global_big(1,:),e_pl_global_big(1,:),alphahp(1,:),f_final_vect(1,:),surfacewithfmax(1),sigma_local_big(1,:),AbeforeQ_rtl(:,:,:,:,1),evaltimes,thetacrackrtl,justcracked,Qacoustic,h,~]= ... 
                Wood_Schmidt17(dESP,sigma_global_big(1,:),e_t_global_big(1,:),e_pl_global_big(1,:),alphahp(1,:),xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl*(1-weakeningfactor_sp),ftr*(1-weakeningfactor_sp),ftt*(1-weakeningfactor_sp),fcl*(1-weakeningfactor_sp),fcr*(1-weakeningfactor_sp),fct*(1-weakeningfactor_sp),fvrt*(1-weakeningfactor_sp),fvrl*(1-weakeningfactor_sp),fvtl*(1-weakeningfactor_sp),Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,t,dt,spid,Debugging,thetacrackrtl,dudx_rtl);
			thetacrack=thetacrackrtl+reliableatan(RQ(1,1),RQ(1,2));
			thetacrack=mod(thetacrack+pi/2,pi)-pi/2;
            E_acc(1)=0;
            s_sp_mat_backrotated=(QbackRback)*[s_sp(1,1) s_sp(1,3);s_sp(1,3) s_sp(1,2)]*transpose(QbackRback);
            s_sp(1,1)=s_sp_mat_backrotated(1,1);
            s_sp(1,2)=s_sp_mat_backrotated(2,2);
            s_sp(1,3)=s_sp_mat_backrotated(1,2);
        case 2
            thetacrackrtl=NaN;
            thetacrack=NaN;
            justcracked=0;
            s_sp(1,1)=sigma_global_big(1,1);
            s_sp(1,2)=sigma_global_big(1,2);
            s_sp(1,3)=sigma_global_big(1,4);
            [s_sp(1,:)]=Linear_elastic(dESP,s_sp(1,:),E,nu);
            f_final_vect(1,:)=zeros(1,7);
            sigma_global_big(1,:)=zeros(1,6);
            
            sigma_global_big(1,1)=s_sp(1,1);
            sigma_global_big(1,2)=s_sp(1,2);
            sigma_global_big(1,4)=s_sp(1,3);
            sigma_local_big(1,:)=zeros(1,6);
            
            surfacewithfmax(1)=0;
            
            e_pl_sp=zeros(1,3);
            e_t_global_big=zeros(1,6);
            e_pl_global_big=zeros(1,6);
            alphahp=zeros(1,7);
            sigma_local_big=zeros(1,6);
            E_acc=0;
			Qacoustic=[];
			h=[];
			RQ=eye(2);
			QbackRback=eye(2);
            AbeforeQ_rtl=zeros(2,2,2,2,1);
        case 3
            thetacrackrtl=NaN;
            thetacrack=NaN;
            justcracked=0;
            s_sp(1,1)=sigma_global_big(1,1);
            s_sp(1,2)=sigma_global_big(1,2);
            s_sp(1,3)=sigma_global_big(1,4);
            %[s_sp(1,:)]=Linear_elastic_orthotropic(dESP,s_sp(1,:),1.5*Er*2,1.5*Er,1.5*Er,nu);
            if CasetoRun==55 || CasetoRun==56 || CasetoRun==57
                [s_sp(1,:)]=Linear_elastic_orthotropic_2(dESP,s_sp(1,:),10*Er,1.5*Er,El,Grt,Grl,Grl,nurt,nurl,nurl);
            elseif CasetoRun==58 || CasetoRun==59 || CasetoRun==60
                [s_sp(1,:)]=Linear_elastic_orthotropic_2(dESP,s_sp(1,:),200*Er,0.001*Er,El,Grt,Grl,Grl,nurt,nurl,nurl);
            elseif CasetoRun==61 || CasetoRun==62 || CasetoRun==63
                [s_sp(1,:)]=Linear_elastic_orthotropic_2(dESP,s_sp(1,:),1.5*Er,1.5*Er/(10^5),El,Grt,Grl,Grl,0,0,0);
            end
            %[s_sp(1,:)]=Linear_elastic(dESP,s_sp(1,:),1.5*Er,nu);
            f_final_vect(1,:)=zeros(1,7);
            sigma_global_big(1,:)=zeros(1,6);
            
            sigma_global_big(1,1)=s_sp(1,1);
            sigma_global_big(1,2)=s_sp(1,2);
            sigma_global_big(1,4)=s_sp(1,3);
            sigma_local_big(1,:)=zeros(1,6);
            
            surfacewithfmax(1)=0;
            
            e_pl_sp=zeros(1,3);
            e_t_global_big=zeros(1,6);
            e_pl_global_big=zeros(1,6);
            alphahp=zeros(1,7);
            sigma_local_big=zeros(1,6);
            E_acc=0;
			Qacoustic=[];
			h=[];
			RQ=eye(2);
			QbackRback=eye(2);
            AbeforeQ_rtl=zeros(2,2,2,2,1);
    end
    switcherconfirmer=switcherconfirmer+1;
    matmodelendtime=clockallsec;
    duration=matmodelendtime-matmodelstarttime;
    stackvars(1,1)=matmodelstarttime-parforstarttime;
    stackvars(1,2)=duration;
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [s_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,E_acc,AbeforeQ_rtl]= ... 
    Matmodel_parforred(F_sp,matmodel,dESP,s_sp,E,nu,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp,orientationoffset)

    switch matmodel(1)
        case 1
            Rback=poldecomp(F_sp,0);
            R=transpose(Rback);
            Q=[cos(orientationoffset) sin(orientationoffset); -sin(orientationoffset) cos(orientationoffset)];
            Qback=[cos(-orientationoffset) sin(-orientationoffset); -sin(-orientationoffset) cos(-orientationoffset)];
            RQ=R*Q;
            QbackRback=Qback*Rback;
            dESP=(RQ)*dESP*transpose(RQ);
            [s_sp(1,:),e_pl_sp(1,:),sigma_global_big(1,:),e_t_global_big(1,:),e_pl_global_big(1,:),alphahp(1,:),f_final_vect(1,:),surfacewithfmax(1),sigma_local_big(1,:),AbeforeQ_rtl(:,:,:,:,1)]= ... 
                Wood_Schmidt17(dESP,sigma_global_big(1,:),e_t_global_big(1,:),e_pl_global_big(1,:),alphahp(1,:),xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl*(1-weakeningfactor_sp),ftr*(1-weakeningfactor_sp),ftt*(1-weakeningfactor_sp),fcl*(1-weakeningfactor_sp),fcr*(1-weakeningfactor_sp),fct*(1-weakeningfactor_sp),fvrt*(1-weakeningfactor_sp),fvrl*(1-weakeningfactor_sp),fvtl*(1-weakeningfactor_sp),Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun);
            E_acc(1)=0;
            s_sp_mat_backrotated=(QbackRback)*[s_sp(1,1) s_sp(1,3);s_sp(1,3) s_sp(1,2)]*transpose(QbackRback);
            s_sp(1,1)=s_sp_mat_backrotated(1,1);
            s_sp(1,2)=s_sp_mat_backrotated(2,2);
            s_sp(1,3)=s_sp_mat_backrotated(1,2);
        case 2
            s_sp(1,1)=sigma_global_big(1,1);
            s_sp(1,2)=sigma_global_big(1,2);
            s_sp(1,3)=sigma_global_big(1,4);
            [s_sp(1,:)]=Linear_elastic(dESP,s_sp(1,:),E,nu);
            f_final_vect(1,:)=zeros(1,7);
            sigma_global_big(1,:)=zeros(1,6);
            
            sigma_global_big(1,1)=s_sp(1,1);
            sigma_global_big(1,2)=s_sp(1,2);
            sigma_global_big(1,4)=s_sp(1,3);
            sigma_local_big(1,:)=zeros(1,6);
            
            surfacewithfmax(1)=0;
            
            e_pl_sp=zeros(1,3);
            e_t_global_big=zeros(1,6);
            e_pl_global_big=zeros(1,6);
            alphahp=zeros(1,7);
            sigma_local_big=zeros(1,6);
            E_acc=0;
    end    
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [f, dfdsigma, dfdq, d2fdsigma2, d2fdsigmadq, d2fdq2]=Wood_Schmidt_EvalSigmaEff(sigma,q,requestedfaces,requestedoutput,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun)
requestedfacesarr=[0 0 0 0 0 0 0];
for i=1:length(requestedfaces)
    requestedfacesarr(requestedfaces(i))=1;
end
%requestedoutput: f, dfdsigma, dfdq, d2fdsigma2, d2fdsigmadq, d2fdq2

sigmarr=sigma(1);
sigmatt=sigma(2);
sigmall=sigma(3);
sigmart=sigma(4);
sigmatl=sigma(5);
sigmarl=sigma(6);

q1=q(1);
q2=q(2);
q3=q(3);
q4=q(4);
q5=q(5);
q6=q(6);
q7=q(7);

if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21
    %q7=0;
elseif CasetoRun==4
    %q1=-1e99;
    %q2=-1e99;
    q3=-1e99;
    q4=-1e99;
    %q5=-1e99;
    %q6=-1e99;
    q7=-1e99;
elseif CasetoRun==5 || CasetoRun==6
elseif CasetoRun==7
elseif CasetoRun==8 || CasetoRun==9
elseif CasetoRun==10
elseif CasetoRun==11
elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
    %q7=0;
    % direct elastic plastic revoked, parameter adjustment chosen instead
elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
    %q7=0; %note perfect shear plasticity unlike CasetoRun==11
    % direct elastic plastic revoked, parameter adjustment chosen instead
elseif CasetoRun==17
	q7=0;
elseif CasetoRun==77
    q1=-1e99;
    q2=-1e99;
    q3=-1e99;
    q4=-1e99;
    q5=-1e99;
    q6=-1e99;
    q7=-1e99;
end

% start sym paste, paste here!
if requestedfacesarr(1)==1
if requestedoutput(1)==1
f{1}=0+q1 + sigmarr/ftr + sigmatt^2/(2*fct^2) + (33*sigmarl^2)/(100*fvrl^2) + sigmart^2/(2*fvrt^2) + (33*sigmatl^2)/(100*fvtl^2) - sigmall^2/(4*fcl*ftl) - 1;
else
f{1}=[0];
end
if requestedoutput(2)==1
dfdsigma{1}(1,1)=1/ftr;
dfdsigma{1}(2,1)=sigmatt/fct^2;
dfdsigma{1}(3,1)=-sigmall/(2*fcl*ftl);
dfdsigma{1}(4,1)=sigmart/fvrt^2;
dfdsigma{1}(5,1)=(33*sigmatl)/(50*fvtl^2);
dfdsigma{1}(6,1)=(33*sigmarl)/(50*fvrl^2);
else
dfdsigma{1}(1,1)=[0];
end
if requestedoutput(3)==1
dfdq{1}(1,1)=1;
dfdq{1}(2,1)=0;
dfdq{1}(3,1)=0;
dfdq{1}(4,1)=0;
dfdq{1}(5,1)=0;
dfdq{1}(6,1)=0;
dfdq{1}(7,1)=0;
else
dfdq{1}(1,1)=[0];
end
if requestedoutput(4)==1
d2fdsigma2{1}(1,1)=0;
d2fdsigma2{1}(1,2)=0;
d2fdsigma2{1}(1,3)=0;
d2fdsigma2{1}(1,4)=0;
d2fdsigma2{1}(1,5)=0;
d2fdsigma2{1}(1,6)=0;
d2fdsigma2{1}(2,1)=0;
d2fdsigma2{1}(2,2)=1/fct^2;
d2fdsigma2{1}(2,3)=0;
d2fdsigma2{1}(2,4)=0;
d2fdsigma2{1}(2,5)=0;
d2fdsigma2{1}(2,6)=0;
d2fdsigma2{1}(3,1)=0;
d2fdsigma2{1}(3,2)=0;
d2fdsigma2{1}(3,3)=-1/(2*fcl*ftl);
d2fdsigma2{1}(3,4)=0;
d2fdsigma2{1}(3,5)=0;
d2fdsigma2{1}(3,6)=0;
d2fdsigma2{1}(4,1)=0;
d2fdsigma2{1}(4,2)=0;
d2fdsigma2{1}(4,3)=0;
d2fdsigma2{1}(4,4)=1/fvrt^2;
d2fdsigma2{1}(4,5)=0;
d2fdsigma2{1}(4,6)=0;
d2fdsigma2{1}(5,1)=0;
d2fdsigma2{1}(5,2)=0;
d2fdsigma2{1}(5,3)=0;
d2fdsigma2{1}(5,4)=0;
d2fdsigma2{1}(5,5)=33/(50*fvtl^2);
d2fdsigma2{1}(5,6)=0;
d2fdsigma2{1}(6,1)=0;
d2fdsigma2{1}(6,2)=0;
d2fdsigma2{1}(6,3)=0;
d2fdsigma2{1}(6,4)=0;
d2fdsigma2{1}(6,5)=0;
d2fdsigma2{1}(6,6)=33/(50*fvrl^2);
else
d2fdsigma2{1}(1,1)=[0];
end
if requestedoutput(5)==1
d2fdsigmadq{1}(1,1)=0;
d2fdsigmadq{1}(1,2)=0;
d2fdsigmadq{1}(1,3)=0;
d2fdsigmadq{1}(1,4)=0;
d2fdsigmadq{1}(1,5)=0;
d2fdsigmadq{1}(1,6)=0;
d2fdsigmadq{1}(1,7)=0;
d2fdsigmadq{1}(2,1)=0;
d2fdsigmadq{1}(2,2)=0;
d2fdsigmadq{1}(2,3)=0;
d2fdsigmadq{1}(2,4)=0;
d2fdsigmadq{1}(2,5)=0;
d2fdsigmadq{1}(2,6)=0;
d2fdsigmadq{1}(2,7)=0;
d2fdsigmadq{1}(3,1)=0;
d2fdsigmadq{1}(3,2)=0;
d2fdsigmadq{1}(3,3)=0;
d2fdsigmadq{1}(3,4)=0;
d2fdsigmadq{1}(3,5)=0;
d2fdsigmadq{1}(3,6)=0;
d2fdsigmadq{1}(3,7)=0;
d2fdsigmadq{1}(4,1)=0;
d2fdsigmadq{1}(4,2)=0;
d2fdsigmadq{1}(4,3)=0;
d2fdsigmadq{1}(4,4)=0;
d2fdsigmadq{1}(4,5)=0;
d2fdsigmadq{1}(4,6)=0;
d2fdsigmadq{1}(4,7)=0;
d2fdsigmadq{1}(5,1)=0;
d2fdsigmadq{1}(5,2)=0;
d2fdsigmadq{1}(5,3)=0;
d2fdsigmadq{1}(5,4)=0;
d2fdsigmadq{1}(5,5)=0;
d2fdsigmadq{1}(5,6)=0;
d2fdsigmadq{1}(5,7)=0;
d2fdsigmadq{1}(6,1)=0;
d2fdsigmadq{1}(6,2)=0;
d2fdsigmadq{1}(6,3)=0;
d2fdsigmadq{1}(6,4)=0;
d2fdsigmadq{1}(6,5)=0;
d2fdsigmadq{1}(6,6)=0;
d2fdsigmadq{1}(6,7)=0;
else
d2fdsigmadq{1}(1,1)=[0];
end
if requestedoutput(6)==1
d2fdq2{1}(1,1)=0;
d2fdq2{1}(1,2)=0;
d2fdq2{1}(1,3)=0;
d2fdq2{1}(1,4)=0;
d2fdq2{1}(1,5)=0;
d2fdq2{1}(1,6)=0;
d2fdq2{1}(1,7)=0;
d2fdq2{1}(2,1)=0;
d2fdq2{1}(2,2)=0;
d2fdq2{1}(2,3)=0;
d2fdq2{1}(2,4)=0;
d2fdq2{1}(2,5)=0;
d2fdq2{1}(2,6)=0;
d2fdq2{1}(2,7)=0;
d2fdq2{1}(3,1)=0;
d2fdq2{1}(3,2)=0;
d2fdq2{1}(3,3)=0;
d2fdq2{1}(3,4)=0;
d2fdq2{1}(3,5)=0;
d2fdq2{1}(3,6)=0;
d2fdq2{1}(3,7)=0;
d2fdq2{1}(4,1)=0;
d2fdq2{1}(4,2)=0;
d2fdq2{1}(4,3)=0;
d2fdq2{1}(4,4)=0;
d2fdq2{1}(4,5)=0;
d2fdq2{1}(4,6)=0;
d2fdq2{1}(4,7)=0;
d2fdq2{1}(5,1)=0;
d2fdq2{1}(5,2)=0;
d2fdq2{1}(5,3)=0;
d2fdq2{1}(5,4)=0;
d2fdq2{1}(5,5)=0;
d2fdq2{1}(5,6)=0;
d2fdq2{1}(5,7)=0;
d2fdq2{1}(6,1)=0;
d2fdq2{1}(6,2)=0;
d2fdq2{1}(6,3)=0;
d2fdq2{1}(6,4)=0;
d2fdq2{1}(6,5)=0;
d2fdq2{1}(6,6)=0;
d2fdq2{1}(6,7)=0;
d2fdq2{1}(7,1)=0;
d2fdq2{1}(7,2)=0;
d2fdq2{1}(7,3)=0;
d2fdq2{1}(7,4)=0;
d2fdq2{1}(7,5)=0;
d2fdq2{1}(7,6)=0;
d2fdq2{1}(7,7)=0;
else
d2fdq2{1}(1)=[0];
end
%{
if requestedoutput(7)==1
dfdinput{1}(1,1)=sigmall^2/(4*fcl*ftl^2);
dfdinput{1}(2,1)=-sigmarr/ftr^2;
dfdinput{1}(3,1)=0;
dfdinput{1}(4,1)=sigmall^2/(4*fcl^2*ftl);
dfdinput{1}(5,1)=0;
dfdinput{1}(6,1)=-sigmatt^2/fct^3;
dfdinput{1}(7,1)=-sigmart^2/fvrt^3;
dfdinput{1}(8,1)=-(33*sigmarl^2)/(50*fvrl^3);
dfdinput{1}(9,1)=-(33*sigmatl^2)/(50*fvtl^3);
else
dfdinput{1}(1,1)=[0];
end
%}
end
if requestedfacesarr(2)==1
if requestedoutput(1)==1
f{2}=0+q2 + sigmarr/fcr + (2*sigmatt^2)/(5*fct^2) + (33*sigmarl^2)/(100*fvrl^2) + (2*sigmart^2)/(5*fvrt^2) + (33*sigmatl^2)/(100*fvtl^2) - sigmall^2/(4*fcl*ftl) - 1;
else
f{2}=[0];
end
if requestedoutput(2)==1
dfdsigma{2}(1,1)=1/fcr;
dfdsigma{2}(2,1)=(4*sigmatt)/(5*fct^2);
dfdsigma{2}(3,1)=-sigmall/(2*fcl*ftl);
dfdsigma{2}(4,1)=(4*sigmart)/(5*fvrt^2);
dfdsigma{2}(5,1)=(33*sigmatl)/(50*fvtl^2);
dfdsigma{2}(6,1)=(33*sigmarl)/(50*fvrl^2);
else
dfdsigma{2}(1,1)=[0];
end
if requestedoutput(3)==1
dfdq{2}(1,1)=0;
dfdq{2}(2,1)=1;
dfdq{2}(3,1)=0;
dfdq{2}(4,1)=0;
dfdq{2}(5,1)=0;
dfdq{2}(6,1)=0;
dfdq{2}(7,1)=0;
else
dfdq{2}(1,1)=[0];
end
if requestedoutput(4)==1
d2fdsigma2{2}(1,1)=0;
d2fdsigma2{2}(1,2)=0;
d2fdsigma2{2}(1,3)=0;
d2fdsigma2{2}(1,4)=0;
d2fdsigma2{2}(1,5)=0;
d2fdsigma2{2}(1,6)=0;
d2fdsigma2{2}(2,1)=0;
d2fdsigma2{2}(2,2)=4/(5*fct^2);
d2fdsigma2{2}(2,3)=0;
d2fdsigma2{2}(2,4)=0;
d2fdsigma2{2}(2,5)=0;
d2fdsigma2{2}(2,6)=0;
d2fdsigma2{2}(3,1)=0;
d2fdsigma2{2}(3,2)=0;
d2fdsigma2{2}(3,3)=-1/(2*fcl*ftl);
d2fdsigma2{2}(3,4)=0;
d2fdsigma2{2}(3,5)=0;
d2fdsigma2{2}(3,6)=0;
d2fdsigma2{2}(4,1)=0;
d2fdsigma2{2}(4,2)=0;
d2fdsigma2{2}(4,3)=0;
d2fdsigma2{2}(4,4)=4/(5*fvrt^2);
d2fdsigma2{2}(4,5)=0;
d2fdsigma2{2}(4,6)=0;
d2fdsigma2{2}(5,1)=0;
d2fdsigma2{2}(5,2)=0;
d2fdsigma2{2}(5,3)=0;
d2fdsigma2{2}(5,4)=0;
d2fdsigma2{2}(5,5)=33/(50*fvtl^2);
d2fdsigma2{2}(5,6)=0;
d2fdsigma2{2}(6,1)=0;
d2fdsigma2{2}(6,2)=0;
d2fdsigma2{2}(6,3)=0;
d2fdsigma2{2}(6,4)=0;
d2fdsigma2{2}(6,5)=0;
d2fdsigma2{2}(6,6)=33/(50*fvrl^2);
else
d2fdsigma2{2}(1,1)=[0];
end
if requestedoutput(5)==1
d2fdsigmadq{2}(1,1)=0;
d2fdsigmadq{2}(1,2)=0;
d2fdsigmadq{2}(1,3)=0;
d2fdsigmadq{2}(1,4)=0;
d2fdsigmadq{2}(1,5)=0;
d2fdsigmadq{2}(1,6)=0;
d2fdsigmadq{2}(1,7)=0;
d2fdsigmadq{2}(2,1)=0;
d2fdsigmadq{2}(2,2)=0;
d2fdsigmadq{2}(2,3)=0;
d2fdsigmadq{2}(2,4)=0;
d2fdsigmadq{2}(2,5)=0;
d2fdsigmadq{2}(2,6)=0;
d2fdsigmadq{2}(2,7)=0;
d2fdsigmadq{2}(3,1)=0;
d2fdsigmadq{2}(3,2)=0;
d2fdsigmadq{2}(3,3)=0;
d2fdsigmadq{2}(3,4)=0;
d2fdsigmadq{2}(3,5)=0;
d2fdsigmadq{2}(3,6)=0;
d2fdsigmadq{2}(3,7)=0;
d2fdsigmadq{2}(4,1)=0;
d2fdsigmadq{2}(4,2)=0;
d2fdsigmadq{2}(4,3)=0;
d2fdsigmadq{2}(4,4)=0;
d2fdsigmadq{2}(4,5)=0;
d2fdsigmadq{2}(4,6)=0;
d2fdsigmadq{2}(4,7)=0;
d2fdsigmadq{2}(5,1)=0;
d2fdsigmadq{2}(5,2)=0;
d2fdsigmadq{2}(5,3)=0;
d2fdsigmadq{2}(5,4)=0;
d2fdsigmadq{2}(5,5)=0;
d2fdsigmadq{2}(5,6)=0;
d2fdsigmadq{2}(5,7)=0;
d2fdsigmadq{2}(6,1)=0;
d2fdsigmadq{2}(6,2)=0;
d2fdsigmadq{2}(6,3)=0;
d2fdsigmadq{2}(6,4)=0;
d2fdsigmadq{2}(6,5)=0;
d2fdsigmadq{2}(6,6)=0;
d2fdsigmadq{2}(6,7)=0;
else
d2fdsigmadq{2}(1,1)=[0];
end
if requestedoutput(6)==1
d2fdq2{2}(1,1)=0;
d2fdq2{2}(1,2)=0;
d2fdq2{2}(1,3)=0;
d2fdq2{2}(1,4)=0;
d2fdq2{2}(1,5)=0;
d2fdq2{2}(1,6)=0;
d2fdq2{2}(1,7)=0;
d2fdq2{2}(2,1)=0;
d2fdq2{2}(2,2)=0;
d2fdq2{2}(2,3)=0;
d2fdq2{2}(2,4)=0;
d2fdq2{2}(2,5)=0;
d2fdq2{2}(2,6)=0;
d2fdq2{2}(2,7)=0;
d2fdq2{2}(3,1)=0;
d2fdq2{2}(3,2)=0;
d2fdq2{2}(3,3)=0;
d2fdq2{2}(3,4)=0;
d2fdq2{2}(3,5)=0;
d2fdq2{2}(3,6)=0;
d2fdq2{2}(3,7)=0;
d2fdq2{2}(4,1)=0;
d2fdq2{2}(4,2)=0;
d2fdq2{2}(4,3)=0;
d2fdq2{2}(4,4)=0;
d2fdq2{2}(4,5)=0;
d2fdq2{2}(4,6)=0;
d2fdq2{2}(4,7)=0;
d2fdq2{2}(5,1)=0;
d2fdq2{2}(5,2)=0;
d2fdq2{2}(5,3)=0;
d2fdq2{2}(5,4)=0;
d2fdq2{2}(5,5)=0;
d2fdq2{2}(5,6)=0;
d2fdq2{2}(5,7)=0;
d2fdq2{2}(6,1)=0;
d2fdq2{2}(6,2)=0;
d2fdq2{2}(6,3)=0;
d2fdq2{2}(6,4)=0;
d2fdq2{2}(6,5)=0;
d2fdq2{2}(6,6)=0;
d2fdq2{2}(6,7)=0;
d2fdq2{2}(7,1)=0;
d2fdq2{2}(7,2)=0;
d2fdq2{2}(7,3)=0;
d2fdq2{2}(7,4)=0;
d2fdq2{2}(7,5)=0;
d2fdq2{2}(7,6)=0;
d2fdq2{2}(7,7)=0;
else
d2fdq2{2}(1)=[0];
end
%{
if requestedoutput(7)==1
dfdinput{2}(1,1)=sigmall^2/(4*fcl*ftl^2);
dfdinput{2}(2,1)=0;
dfdinput{2}(3,1)=0;
dfdinput{2}(4,1)=sigmall^2/(4*fcl^2*ftl);
dfdinput{2}(5,1)=-sigmarr/fcr^2;
dfdinput{2}(6,1)=-(4*sigmatt^2)/(5*fct^3);
dfdinput{2}(7,1)=-(4*sigmart^2)/(5*fvrt^3);
dfdinput{2}(8,1)=-(33*sigmarl^2)/(50*fvrl^3);
dfdinput{2}(9,1)=-(33*sigmatl^2)/(50*fvtl^3);
else
dfdinput{2}(1,1)=[0];
end
%}
end
if requestedfacesarr(3)==1
if requestedoutput(1)==1
f{3}=0+q3 + sigmatt/ftt + sigmarr^2/(2*fcr^2) + (33*sigmarl^2)/(100*fvrl^2) + (2*sigmart^2)/(5*fvrt^2) + (33*sigmatl^2)/(100*fvtl^2) - sigmall^2/(4*fcl*ftl) - 1;
else
f{3}=[0];
end
if requestedoutput(2)==1
dfdsigma{3}(1,1)=sigmarr/fcr^2;
dfdsigma{3}(2,1)=1/ftt;
dfdsigma{3}(3,1)=-sigmall/(2*fcl*ftl);
dfdsigma{3}(4,1)=(4*sigmart)/(5*fvrt^2);
dfdsigma{3}(5,1)=(33*sigmatl)/(50*fvtl^2);
dfdsigma{3}(6,1)=(33*sigmarl)/(50*fvrl^2);
else
dfdsigma{3}(1,1)=[0];
end
if requestedoutput(3)==1
dfdq{3}(1,1)=0;
dfdq{3}(2,1)=0;
dfdq{3}(3,1)=1;
dfdq{3}(4,1)=0;
dfdq{3}(5,1)=0;
dfdq{3}(6,1)=0;
dfdq{3}(7,1)=0;
else
dfdq{3}(1,1)=[0];
end
if requestedoutput(4)==1
d2fdsigma2{3}(1,1)=1/fcr^2;
d2fdsigma2{3}(1,2)=0;
d2fdsigma2{3}(1,3)=0;
d2fdsigma2{3}(1,4)=0;
d2fdsigma2{3}(1,5)=0;
d2fdsigma2{3}(1,6)=0;
d2fdsigma2{3}(2,1)=0;
d2fdsigma2{3}(2,2)=0;
d2fdsigma2{3}(2,3)=0;
d2fdsigma2{3}(2,4)=0;
d2fdsigma2{3}(2,5)=0;
d2fdsigma2{3}(2,6)=0;
d2fdsigma2{3}(3,1)=0;
d2fdsigma2{3}(3,2)=0;
d2fdsigma2{3}(3,3)=-1/(2*fcl*ftl);
d2fdsigma2{3}(3,4)=0;
d2fdsigma2{3}(3,5)=0;
d2fdsigma2{3}(3,6)=0;
d2fdsigma2{3}(4,1)=0;
d2fdsigma2{3}(4,2)=0;
d2fdsigma2{3}(4,3)=0;
d2fdsigma2{3}(4,4)=4/(5*fvrt^2);
d2fdsigma2{3}(4,5)=0;
d2fdsigma2{3}(4,6)=0;
d2fdsigma2{3}(5,1)=0;
d2fdsigma2{3}(5,2)=0;
d2fdsigma2{3}(5,3)=0;
d2fdsigma2{3}(5,4)=0;
d2fdsigma2{3}(5,5)=33/(50*fvtl^2);
d2fdsigma2{3}(5,6)=0;
d2fdsigma2{3}(6,1)=0;
d2fdsigma2{3}(6,2)=0;
d2fdsigma2{3}(6,3)=0;
d2fdsigma2{3}(6,4)=0;
d2fdsigma2{3}(6,5)=0;
d2fdsigma2{3}(6,6)=33/(50*fvrl^2);
else
d2fdsigma2{3}(1,1)=[0];
end
if requestedoutput(5)==1
d2fdsigmadq{3}(1,1)=0;
d2fdsigmadq{3}(1,2)=0;
d2fdsigmadq{3}(1,3)=0;
d2fdsigmadq{3}(1,4)=0;
d2fdsigmadq{3}(1,5)=0;
d2fdsigmadq{3}(1,6)=0;
d2fdsigmadq{3}(1,7)=0;
d2fdsigmadq{3}(2,1)=0;
d2fdsigmadq{3}(2,2)=0;
d2fdsigmadq{3}(2,3)=0;
d2fdsigmadq{3}(2,4)=0;
d2fdsigmadq{3}(2,5)=0;
d2fdsigmadq{3}(2,6)=0;
d2fdsigmadq{3}(2,7)=0;
d2fdsigmadq{3}(3,1)=0;
d2fdsigmadq{3}(3,2)=0;
d2fdsigmadq{3}(3,3)=0;
d2fdsigmadq{3}(3,4)=0;
d2fdsigmadq{3}(3,5)=0;
d2fdsigmadq{3}(3,6)=0;
d2fdsigmadq{3}(3,7)=0;
d2fdsigmadq{3}(4,1)=0;
d2fdsigmadq{3}(4,2)=0;
d2fdsigmadq{3}(4,3)=0;
d2fdsigmadq{3}(4,4)=0;
d2fdsigmadq{3}(4,5)=0;
d2fdsigmadq{3}(4,6)=0;
d2fdsigmadq{3}(4,7)=0;
d2fdsigmadq{3}(5,1)=0;
d2fdsigmadq{3}(5,2)=0;
d2fdsigmadq{3}(5,3)=0;
d2fdsigmadq{3}(5,4)=0;
d2fdsigmadq{3}(5,5)=0;
d2fdsigmadq{3}(5,6)=0;
d2fdsigmadq{3}(5,7)=0;
d2fdsigmadq{3}(6,1)=0;
d2fdsigmadq{3}(6,2)=0;
d2fdsigmadq{3}(6,3)=0;
d2fdsigmadq{3}(6,4)=0;
d2fdsigmadq{3}(6,5)=0;
d2fdsigmadq{3}(6,6)=0;
d2fdsigmadq{3}(6,7)=0;
else
d2fdsigmadq{3}(1,1)=[0];
end
if requestedoutput(6)==1
d2fdq2{3}(1,1)=0;
d2fdq2{3}(1,2)=0;
d2fdq2{3}(1,3)=0;
d2fdq2{3}(1,4)=0;
d2fdq2{3}(1,5)=0;
d2fdq2{3}(1,6)=0;
d2fdq2{3}(1,7)=0;
d2fdq2{3}(2,1)=0;
d2fdq2{3}(2,2)=0;
d2fdq2{3}(2,3)=0;
d2fdq2{3}(2,4)=0;
d2fdq2{3}(2,5)=0;
d2fdq2{3}(2,6)=0;
d2fdq2{3}(2,7)=0;
d2fdq2{3}(3,1)=0;
d2fdq2{3}(3,2)=0;
d2fdq2{3}(3,3)=0;
d2fdq2{3}(3,4)=0;
d2fdq2{3}(3,5)=0;
d2fdq2{3}(3,6)=0;
d2fdq2{3}(3,7)=0;
d2fdq2{3}(4,1)=0;
d2fdq2{3}(4,2)=0;
d2fdq2{3}(4,3)=0;
d2fdq2{3}(4,4)=0;
d2fdq2{3}(4,5)=0;
d2fdq2{3}(4,6)=0;
d2fdq2{3}(4,7)=0;
d2fdq2{3}(5,1)=0;
d2fdq2{3}(5,2)=0;
d2fdq2{3}(5,3)=0;
d2fdq2{3}(5,4)=0;
d2fdq2{3}(5,5)=0;
d2fdq2{3}(5,6)=0;
d2fdq2{3}(5,7)=0;
d2fdq2{3}(6,1)=0;
d2fdq2{3}(6,2)=0;
d2fdq2{3}(6,3)=0;
d2fdq2{3}(6,4)=0;
d2fdq2{3}(6,5)=0;
d2fdq2{3}(6,6)=0;
d2fdq2{3}(6,7)=0;
d2fdq2{3}(7,1)=0;
d2fdq2{3}(7,2)=0;
d2fdq2{3}(7,3)=0;
d2fdq2{3}(7,4)=0;
d2fdq2{3}(7,5)=0;
d2fdq2{3}(7,6)=0;
d2fdq2{3}(7,7)=0;
else
d2fdq2{3}(1)=[0];
end
%{
if requestedoutput(7)==1
dfdinput{3}(1,1)=sigmall^2/(4*fcl*ftl^2);
dfdinput{3}(2,1)=0;
dfdinput{3}(3,1)=-sigmatt/ftt^2;
dfdinput{3}(4,1)=sigmall^2/(4*fcl^2*ftl);
dfdinput{3}(5,1)=-sigmarr^2/fcr^3;
dfdinput{3}(6,1)=0;
dfdinput{3}(7,1)=-(4*sigmart^2)/(5*fvrt^3);
dfdinput{3}(8,1)=-(33*sigmarl^2)/(50*fvrl^3);
dfdinput{3}(9,1)=-(33*sigmatl^2)/(50*fvtl^3);
else
dfdinput{3}(1,1)=[0];
end
%}
end
if requestedfacesarr(4)==1
if requestedoutput(1)==1
f{4}=0+q4 + sigmatt/fct + (2*sigmarr^2)/(5*fcr^2) + (33*sigmarl^2)/(100*fvrl^2) + (2*sigmart^2)/(5*fvrt^2) + (33*sigmatl^2)/(100*fvtl^2) - sigmall^2/(4*fcl*ftl) - 1;
else
f{4}=[0];
end
if requestedoutput(2)==1
dfdsigma{4}(1,1)=(4*sigmarr)/(5*fcr^2);
dfdsigma{4}(2,1)=1/fct;
dfdsigma{4}(3,1)=-sigmall/(2*fcl*ftl);
dfdsigma{4}(4,1)=(4*sigmart)/(5*fvrt^2);
dfdsigma{4}(5,1)=(33*sigmatl)/(50*fvtl^2);
dfdsigma{4}(6,1)=(33*sigmarl)/(50*fvrl^2);
else
dfdsigma{4}(1,1)=[0];
end
if requestedoutput(3)==1
dfdq{4}(1,1)=0;
dfdq{4}(2,1)=0;
dfdq{4}(3,1)=0;
dfdq{4}(4,1)=1;
dfdq{4}(5,1)=0;
dfdq{4}(6,1)=0;
dfdq{4}(7,1)=0;
else
dfdq{4}(1,1)=[0];
end
if requestedoutput(4)==1
d2fdsigma2{4}(1,1)=4/(5*fcr^2);
d2fdsigma2{4}(1,2)=0;
d2fdsigma2{4}(1,3)=0;
d2fdsigma2{4}(1,4)=0;
d2fdsigma2{4}(1,5)=0;
d2fdsigma2{4}(1,6)=0;
d2fdsigma2{4}(2,1)=0;
d2fdsigma2{4}(2,2)=0;
d2fdsigma2{4}(2,3)=0;
d2fdsigma2{4}(2,4)=0;
d2fdsigma2{4}(2,5)=0;
d2fdsigma2{4}(2,6)=0;
d2fdsigma2{4}(3,1)=0;
d2fdsigma2{4}(3,2)=0;
d2fdsigma2{4}(3,3)=-1/(2*fcl*ftl);
d2fdsigma2{4}(3,4)=0;
d2fdsigma2{4}(3,5)=0;
d2fdsigma2{4}(3,6)=0;
d2fdsigma2{4}(4,1)=0;
d2fdsigma2{4}(4,2)=0;
d2fdsigma2{4}(4,3)=0;
d2fdsigma2{4}(4,4)=4/(5*fvrt^2);
d2fdsigma2{4}(4,5)=0;
d2fdsigma2{4}(4,6)=0;
d2fdsigma2{4}(5,1)=0;
d2fdsigma2{4}(5,2)=0;
d2fdsigma2{4}(5,3)=0;
d2fdsigma2{4}(5,4)=0;
d2fdsigma2{4}(5,5)=33/(50*fvtl^2);
d2fdsigma2{4}(5,6)=0;
d2fdsigma2{4}(6,1)=0;
d2fdsigma2{4}(6,2)=0;
d2fdsigma2{4}(6,3)=0;
d2fdsigma2{4}(6,4)=0;
d2fdsigma2{4}(6,5)=0;
d2fdsigma2{4}(6,6)=33/(50*fvrl^2);
else
d2fdsigma2{4}(1,1)=[0];
end
if requestedoutput(5)==1
d2fdsigmadq{4}(1,1)=0;
d2fdsigmadq{4}(1,2)=0;
d2fdsigmadq{4}(1,3)=0;
d2fdsigmadq{4}(1,4)=0;
d2fdsigmadq{4}(1,5)=0;
d2fdsigmadq{4}(1,6)=0;
d2fdsigmadq{4}(1,7)=0;
d2fdsigmadq{4}(2,1)=0;
d2fdsigmadq{4}(2,2)=0;
d2fdsigmadq{4}(2,3)=0;
d2fdsigmadq{4}(2,4)=0;
d2fdsigmadq{4}(2,5)=0;
d2fdsigmadq{4}(2,6)=0;
d2fdsigmadq{4}(2,7)=0;
d2fdsigmadq{4}(3,1)=0;
d2fdsigmadq{4}(3,2)=0;
d2fdsigmadq{4}(3,3)=0;
d2fdsigmadq{4}(3,4)=0;
d2fdsigmadq{4}(3,5)=0;
d2fdsigmadq{4}(3,6)=0;
d2fdsigmadq{4}(3,7)=0;
d2fdsigmadq{4}(4,1)=0;
d2fdsigmadq{4}(4,2)=0;
d2fdsigmadq{4}(4,3)=0;
d2fdsigmadq{4}(4,4)=0;
d2fdsigmadq{4}(4,5)=0;
d2fdsigmadq{4}(4,6)=0;
d2fdsigmadq{4}(4,7)=0;
d2fdsigmadq{4}(5,1)=0;
d2fdsigmadq{4}(5,2)=0;
d2fdsigmadq{4}(5,3)=0;
d2fdsigmadq{4}(5,4)=0;
d2fdsigmadq{4}(5,5)=0;
d2fdsigmadq{4}(5,6)=0;
d2fdsigmadq{4}(5,7)=0;
d2fdsigmadq{4}(6,1)=0;
d2fdsigmadq{4}(6,2)=0;
d2fdsigmadq{4}(6,3)=0;
d2fdsigmadq{4}(6,4)=0;
d2fdsigmadq{4}(6,5)=0;
d2fdsigmadq{4}(6,6)=0;
d2fdsigmadq{4}(6,7)=0;
else
d2fdsigmadq{4}(1,1)=[0];
end
if requestedoutput(6)==1
d2fdq2{4}(1,1)=0;
d2fdq2{4}(1,2)=0;
d2fdq2{4}(1,3)=0;
d2fdq2{4}(1,4)=0;
d2fdq2{4}(1,5)=0;
d2fdq2{4}(1,6)=0;
d2fdq2{4}(1,7)=0;
d2fdq2{4}(2,1)=0;
d2fdq2{4}(2,2)=0;
d2fdq2{4}(2,3)=0;
d2fdq2{4}(2,4)=0;
d2fdq2{4}(2,5)=0;
d2fdq2{4}(2,6)=0;
d2fdq2{4}(2,7)=0;
d2fdq2{4}(3,1)=0;
d2fdq2{4}(3,2)=0;
d2fdq2{4}(3,3)=0;
d2fdq2{4}(3,4)=0;
d2fdq2{4}(3,5)=0;
d2fdq2{4}(3,6)=0;
d2fdq2{4}(3,7)=0;
d2fdq2{4}(4,1)=0;
d2fdq2{4}(4,2)=0;
d2fdq2{4}(4,3)=0;
d2fdq2{4}(4,4)=0;
d2fdq2{4}(4,5)=0;
d2fdq2{4}(4,6)=0;
d2fdq2{4}(4,7)=0;
d2fdq2{4}(5,1)=0;
d2fdq2{4}(5,2)=0;
d2fdq2{4}(5,3)=0;
d2fdq2{4}(5,4)=0;
d2fdq2{4}(5,5)=0;
d2fdq2{4}(5,6)=0;
d2fdq2{4}(5,7)=0;
d2fdq2{4}(6,1)=0;
d2fdq2{4}(6,2)=0;
d2fdq2{4}(6,3)=0;
d2fdq2{4}(6,4)=0;
d2fdq2{4}(6,5)=0;
d2fdq2{4}(6,6)=0;
d2fdq2{4}(6,7)=0;
d2fdq2{4}(7,1)=0;
d2fdq2{4}(7,2)=0;
d2fdq2{4}(7,3)=0;
d2fdq2{4}(7,4)=0;
d2fdq2{4}(7,5)=0;
d2fdq2{4}(7,6)=0;
d2fdq2{4}(7,7)=0;
else
d2fdq2{4}(1)=[0];
end
%{
if requestedoutput(7)==1
dfdinput{4}(1,1)=sigmall^2/(4*fcl*ftl^2);
dfdinput{4}(2,1)=0;
dfdinput{4}(3,1)=0;
dfdinput{4}(4,1)=sigmall^2/(4*fcl^2*ftl);
dfdinput{4}(5,1)=-(4*sigmarr^2)/(5*fcr^3);
dfdinput{4}(6,1)=-sigmatt/fct^2;
dfdinput{4}(7,1)=-(4*sigmart^2)/(5*fvrt^3);
dfdinput{4}(8,1)=-(33*sigmarl^2)/(50*fvrl^3);
dfdinput{4}(9,1)=-(33*sigmatl^2)/(50*fvtl^3);
else
dfdinput{4}(1,1)=[0];
end
%}
end
if requestedfacesarr(5)==1
if requestedoutput(1)==1
f{5}=0+q5 + sigmall/ftl + sigmarr^2/(5*fcr^2) + sigmatt^2/(5*fct^2) + sigmarl^2/(10*fvrl^2) + sigmart^2/(10*fvrt^2) + sigmatl^2/(10*fvtl^2) - 1;
else
f{5}=[0];
end
if requestedoutput(2)==1
dfdsigma{5}(1,1)=(2*sigmarr)/(5*fcr^2);
dfdsigma{5}(2,1)=(2*sigmatt)/(5*fct^2);
dfdsigma{5}(3,1)=1/ftl;
dfdsigma{5}(4,1)=sigmart/(5*fvrt^2);
dfdsigma{5}(5,1)=sigmatl/(5*fvtl^2);
dfdsigma{5}(6,1)=sigmarl/(5*fvrl^2);
else
dfdsigma{5}(1,1)=[0];
end
if requestedoutput(3)==1
dfdq{5}(1,1)=0;
dfdq{5}(2,1)=0;
dfdq{5}(3,1)=0;
dfdq{5}(4,1)=0;
dfdq{5}(5,1)=1;
dfdq{5}(6,1)=0;
dfdq{5}(7,1)=0;
else
dfdq{5}(1,1)=[0];
end
if requestedoutput(4)==1
d2fdsigma2{5}(1,1)=2/(5*fcr^2);
d2fdsigma2{5}(1,2)=0;
d2fdsigma2{5}(1,3)=0;
d2fdsigma2{5}(1,4)=0;
d2fdsigma2{5}(1,5)=0;
d2fdsigma2{5}(1,6)=0;
d2fdsigma2{5}(2,1)=0;
d2fdsigma2{5}(2,2)=2/(5*fct^2);
d2fdsigma2{5}(2,3)=0;
d2fdsigma2{5}(2,4)=0;
d2fdsigma2{5}(2,5)=0;
d2fdsigma2{5}(2,6)=0;
d2fdsigma2{5}(3,1)=0;
d2fdsigma2{5}(3,2)=0;
d2fdsigma2{5}(3,3)=0;
d2fdsigma2{5}(3,4)=0;
d2fdsigma2{5}(3,5)=0;
d2fdsigma2{5}(3,6)=0;
d2fdsigma2{5}(4,1)=0;
d2fdsigma2{5}(4,2)=0;
d2fdsigma2{5}(4,3)=0;
d2fdsigma2{5}(4,4)=1/(5*fvrt^2);
d2fdsigma2{5}(4,5)=0;
d2fdsigma2{5}(4,6)=0;
d2fdsigma2{5}(5,1)=0;
d2fdsigma2{5}(5,2)=0;
d2fdsigma2{5}(5,3)=0;
d2fdsigma2{5}(5,4)=0;
d2fdsigma2{5}(5,5)=1/(5*fvtl^2);
d2fdsigma2{5}(5,6)=0;
d2fdsigma2{5}(6,1)=0;
d2fdsigma2{5}(6,2)=0;
d2fdsigma2{5}(6,3)=0;
d2fdsigma2{5}(6,4)=0;
d2fdsigma2{5}(6,5)=0;
d2fdsigma2{5}(6,6)=1/(5*fvrl^2);
else
d2fdsigma2{5}(1,1)=[0];
end
if requestedoutput(5)==1
d2fdsigmadq{5}(1,1)=0;
d2fdsigmadq{5}(1,2)=0;
d2fdsigmadq{5}(1,3)=0;
d2fdsigmadq{5}(1,4)=0;
d2fdsigmadq{5}(1,5)=0;
d2fdsigmadq{5}(1,6)=0;
d2fdsigmadq{5}(1,7)=0;
d2fdsigmadq{5}(2,1)=0;
d2fdsigmadq{5}(2,2)=0;
d2fdsigmadq{5}(2,3)=0;
d2fdsigmadq{5}(2,4)=0;
d2fdsigmadq{5}(2,5)=0;
d2fdsigmadq{5}(2,6)=0;
d2fdsigmadq{5}(2,7)=0;
d2fdsigmadq{5}(3,1)=0;
d2fdsigmadq{5}(3,2)=0;
d2fdsigmadq{5}(3,3)=0;
d2fdsigmadq{5}(3,4)=0;
d2fdsigmadq{5}(3,5)=0;
d2fdsigmadq{5}(3,6)=0;
d2fdsigmadq{5}(3,7)=0;
d2fdsigmadq{5}(4,1)=0;
d2fdsigmadq{5}(4,2)=0;
d2fdsigmadq{5}(4,3)=0;
d2fdsigmadq{5}(4,4)=0;
d2fdsigmadq{5}(4,5)=0;
d2fdsigmadq{5}(4,6)=0;
d2fdsigmadq{5}(4,7)=0;
d2fdsigmadq{5}(5,1)=0;
d2fdsigmadq{5}(5,2)=0;
d2fdsigmadq{5}(5,3)=0;
d2fdsigmadq{5}(5,4)=0;
d2fdsigmadq{5}(5,5)=0;
d2fdsigmadq{5}(5,6)=0;
d2fdsigmadq{5}(5,7)=0;
d2fdsigmadq{5}(6,1)=0;
d2fdsigmadq{5}(6,2)=0;
d2fdsigmadq{5}(6,3)=0;
d2fdsigmadq{5}(6,4)=0;
d2fdsigmadq{5}(6,5)=0;
d2fdsigmadq{5}(6,6)=0;
d2fdsigmadq{5}(6,7)=0;
else
d2fdsigmadq{5}(1,1)=[0];
end
if requestedoutput(6)==1
d2fdq2{5}(1,1)=0;
d2fdq2{5}(1,2)=0;
d2fdq2{5}(1,3)=0;
d2fdq2{5}(1,4)=0;
d2fdq2{5}(1,5)=0;
d2fdq2{5}(1,6)=0;
d2fdq2{5}(1,7)=0;
d2fdq2{5}(2,1)=0;
d2fdq2{5}(2,2)=0;
d2fdq2{5}(2,3)=0;
d2fdq2{5}(2,4)=0;
d2fdq2{5}(2,5)=0;
d2fdq2{5}(2,6)=0;
d2fdq2{5}(2,7)=0;
d2fdq2{5}(3,1)=0;
d2fdq2{5}(3,2)=0;
d2fdq2{5}(3,3)=0;
d2fdq2{5}(3,4)=0;
d2fdq2{5}(3,5)=0;
d2fdq2{5}(3,6)=0;
d2fdq2{5}(3,7)=0;
d2fdq2{5}(4,1)=0;
d2fdq2{5}(4,2)=0;
d2fdq2{5}(4,3)=0;
d2fdq2{5}(4,4)=0;
d2fdq2{5}(4,5)=0;
d2fdq2{5}(4,6)=0;
d2fdq2{5}(4,7)=0;
d2fdq2{5}(5,1)=0;
d2fdq2{5}(5,2)=0;
d2fdq2{5}(5,3)=0;
d2fdq2{5}(5,4)=0;
d2fdq2{5}(5,5)=0;
d2fdq2{5}(5,6)=0;
d2fdq2{5}(5,7)=0;
d2fdq2{5}(6,1)=0;
d2fdq2{5}(6,2)=0;
d2fdq2{5}(6,3)=0;
d2fdq2{5}(6,4)=0;
d2fdq2{5}(6,5)=0;
d2fdq2{5}(6,6)=0;
d2fdq2{5}(6,7)=0;
d2fdq2{5}(7,1)=0;
d2fdq2{5}(7,2)=0;
d2fdq2{5}(7,3)=0;
d2fdq2{5}(7,4)=0;
d2fdq2{5}(7,5)=0;
d2fdq2{5}(7,6)=0;
d2fdq2{5}(7,7)=0;
else
d2fdq2{5}(1)=[0];
end
%{
if requestedoutput(7)==1
dfdinput{5}(1,1)=-sigmall/ftl^2;
dfdinput{5}(2,1)=0;
dfdinput{5}(3,1)=0;
dfdinput{5}(4,1)=0;
dfdinput{5}(5,1)=-(2*sigmarr^2)/(5*fcr^3);
dfdinput{5}(6,1)=-(2*sigmatt^2)/(5*fct^3);
dfdinput{5}(7,1)=-sigmart^2/(5*fvrt^3);
dfdinput{5}(8,1)=-sigmarl^2/(5*fvrl^3);
dfdinput{5}(9,1)=-sigmatl^2/(5*fvtl^3);
else
dfdinput{5}(1,1)=[0];
end
%}
end
if requestedfacesarr(6)==1
if requestedoutput(1)==1
f{6}=0+q6 + sigmall/fcl + (33*sigmarr^2)/(100*fcr^2) + (33*sigmatt^2)/(100*fct^2) + sigmarl^2/(4*fvrl^2) + sigmart^2/(4*fvrt^2) + sigmatl^2/(4*fvtl^2) - 1;
else
f{6}=[0];
end
if requestedoutput(2)==1
dfdsigma{6}(1,1)=(33*sigmarr)/(50*fcr^2);
dfdsigma{6}(2,1)=(33*sigmatt)/(50*fct^2);
dfdsigma{6}(3,1)=1/fcl;
dfdsigma{6}(4,1)=sigmart/(2*fvrt^2);
dfdsigma{6}(5,1)=sigmatl/(2*fvtl^2);
dfdsigma{6}(6,1)=sigmarl/(2*fvrl^2);
else
dfdsigma{6}(1,1)=[0];
end
if requestedoutput(3)==1
dfdq{6}(1,1)=0;
dfdq{6}(2,1)=0;
dfdq{6}(3,1)=0;
dfdq{6}(4,1)=0;
dfdq{6}(5,1)=0;
dfdq{6}(6,1)=1;
dfdq{6}(7,1)=0;
else
dfdq{6}(1,1)=[0];
end
if requestedoutput(4)==1
d2fdsigma2{6}(1,1)=33/(50*fcr^2);
d2fdsigma2{6}(1,2)=0;
d2fdsigma2{6}(1,3)=0;
d2fdsigma2{6}(1,4)=0;
d2fdsigma2{6}(1,5)=0;
d2fdsigma2{6}(1,6)=0;
d2fdsigma2{6}(2,1)=0;
d2fdsigma2{6}(2,2)=33/(50*fct^2);
d2fdsigma2{6}(2,3)=0;
d2fdsigma2{6}(2,4)=0;
d2fdsigma2{6}(2,5)=0;
d2fdsigma2{6}(2,6)=0;
d2fdsigma2{6}(3,1)=0;
d2fdsigma2{6}(3,2)=0;
d2fdsigma2{6}(3,3)=0;
d2fdsigma2{6}(3,4)=0;
d2fdsigma2{6}(3,5)=0;
d2fdsigma2{6}(3,6)=0;
d2fdsigma2{6}(4,1)=0;
d2fdsigma2{6}(4,2)=0;
d2fdsigma2{6}(4,3)=0;
d2fdsigma2{6}(4,4)=1/(2*fvrt^2);
d2fdsigma2{6}(4,5)=0;
d2fdsigma2{6}(4,6)=0;
d2fdsigma2{6}(5,1)=0;
d2fdsigma2{6}(5,2)=0;
d2fdsigma2{6}(5,3)=0;
d2fdsigma2{6}(5,4)=0;
d2fdsigma2{6}(5,5)=1/(2*fvtl^2);
d2fdsigma2{6}(5,6)=0;
d2fdsigma2{6}(6,1)=0;
d2fdsigma2{6}(6,2)=0;
d2fdsigma2{6}(6,3)=0;
d2fdsigma2{6}(6,4)=0;
d2fdsigma2{6}(6,5)=0;
d2fdsigma2{6}(6,6)=1/(2*fvrl^2);
else
d2fdsigma2{6}(1,1)=[0];
end
if requestedoutput(5)==1
d2fdsigmadq{6}(1,1)=0;
d2fdsigmadq{6}(1,2)=0;
d2fdsigmadq{6}(1,3)=0;
d2fdsigmadq{6}(1,4)=0;
d2fdsigmadq{6}(1,5)=0;
d2fdsigmadq{6}(1,6)=0;
d2fdsigmadq{6}(1,7)=0;
d2fdsigmadq{6}(2,1)=0;
d2fdsigmadq{6}(2,2)=0;
d2fdsigmadq{6}(2,3)=0;
d2fdsigmadq{6}(2,4)=0;
d2fdsigmadq{6}(2,5)=0;
d2fdsigmadq{6}(2,6)=0;
d2fdsigmadq{6}(2,7)=0;
d2fdsigmadq{6}(3,1)=0;
d2fdsigmadq{6}(3,2)=0;
d2fdsigmadq{6}(3,3)=0;
d2fdsigmadq{6}(3,4)=0;
d2fdsigmadq{6}(3,5)=0;
d2fdsigmadq{6}(3,6)=0;
d2fdsigmadq{6}(3,7)=0;
d2fdsigmadq{6}(4,1)=0;
d2fdsigmadq{6}(4,2)=0;
d2fdsigmadq{6}(4,3)=0;
d2fdsigmadq{6}(4,4)=0;
d2fdsigmadq{6}(4,5)=0;
d2fdsigmadq{6}(4,6)=0;
d2fdsigmadq{6}(4,7)=0;
d2fdsigmadq{6}(5,1)=0;
d2fdsigmadq{6}(5,2)=0;
d2fdsigmadq{6}(5,3)=0;
d2fdsigmadq{6}(5,4)=0;
d2fdsigmadq{6}(5,5)=0;
d2fdsigmadq{6}(5,6)=0;
d2fdsigmadq{6}(5,7)=0;
d2fdsigmadq{6}(6,1)=0;
d2fdsigmadq{6}(6,2)=0;
d2fdsigmadq{6}(6,3)=0;
d2fdsigmadq{6}(6,4)=0;
d2fdsigmadq{6}(6,5)=0;
d2fdsigmadq{6}(6,6)=0;
d2fdsigmadq{6}(6,7)=0;
else
d2fdsigmadq{6}(1,1)=[0];
end
if requestedoutput(6)==1
d2fdq2{6}(1,1)=0;
d2fdq2{6}(1,2)=0;
d2fdq2{6}(1,3)=0;
d2fdq2{6}(1,4)=0;
d2fdq2{6}(1,5)=0;
d2fdq2{6}(1,6)=0;
d2fdq2{6}(1,7)=0;
d2fdq2{6}(2,1)=0;
d2fdq2{6}(2,2)=0;
d2fdq2{6}(2,3)=0;
d2fdq2{6}(2,4)=0;
d2fdq2{6}(2,5)=0;
d2fdq2{6}(2,6)=0;
d2fdq2{6}(2,7)=0;
d2fdq2{6}(3,1)=0;
d2fdq2{6}(3,2)=0;
d2fdq2{6}(3,3)=0;
d2fdq2{6}(3,4)=0;
d2fdq2{6}(3,5)=0;
d2fdq2{6}(3,6)=0;
d2fdq2{6}(3,7)=0;
d2fdq2{6}(4,1)=0;
d2fdq2{6}(4,2)=0;
d2fdq2{6}(4,3)=0;
d2fdq2{6}(4,4)=0;
d2fdq2{6}(4,5)=0;
d2fdq2{6}(4,6)=0;
d2fdq2{6}(4,7)=0;
d2fdq2{6}(5,1)=0;
d2fdq2{6}(5,2)=0;
d2fdq2{6}(5,3)=0;
d2fdq2{6}(5,4)=0;
d2fdq2{6}(5,5)=0;
d2fdq2{6}(5,6)=0;
d2fdq2{6}(5,7)=0;
d2fdq2{6}(6,1)=0;
d2fdq2{6}(6,2)=0;
d2fdq2{6}(6,3)=0;
d2fdq2{6}(6,4)=0;
d2fdq2{6}(6,5)=0;
d2fdq2{6}(6,6)=0;
d2fdq2{6}(6,7)=0;
d2fdq2{6}(7,1)=0;
d2fdq2{6}(7,2)=0;
d2fdq2{6}(7,3)=0;
d2fdq2{6}(7,4)=0;
d2fdq2{6}(7,5)=0;
d2fdq2{6}(7,6)=0;
d2fdq2{6}(7,7)=0;
else
d2fdq2{6}(1)=[0];
end
%{
if requestedoutput(7)==1
dfdinput{6}(1,1)=0;
dfdinput{6}(2,1)=0;
dfdinput{6}(3,1)=0;
dfdinput{6}(4,1)=-sigmall/fcl^2;
dfdinput{6}(5,1)=-(33*sigmarr^2)/(50*fcr^3);
dfdinput{6}(6,1)=-(33*sigmatt^2)/(50*fct^3);
dfdinput{6}(7,1)=-sigmart^2/(2*fvrt^3);
dfdinput{6}(8,1)=-sigmarl^2/(2*fvrl^3);
dfdinput{6}(9,1)=-sigmatl^2/(2*fvtl^3);
else
dfdinput{6}(1,1)=[0];
end
%}
end
if requestedfacesarr(7)==1
if requestedoutput(1)==1
f{7}=q7 - sigmall/(20*fcl) - sigmarr/(5*fcr) - sigmatt/(5*fct) + sigmarr^2/(4*fcr^2) + sigmatt^2/(4*fct^2) + sigmarl^2/fvrl^2 + sigmart^2/fvrt^2 + sigmatl^2/fvtl^2 - sigmall^2/(10*fcl*ftl) - 1;
else
f{7}=[0];
end
if requestedoutput(2)==1
dfdsigma{7}(1,1)=-(2*fcr - 5*sigmarr)/(10*fcr^2);
dfdsigma{7}(2,1)=-(2*fct - 5*sigmatt)/(10*fct^2);
dfdsigma{7}(3,1)=-(ftl + 4*sigmall)/(20*fcl*ftl);
dfdsigma{7}(4,1)=(2*sigmart)/fvrt^2;
dfdsigma{7}(5,1)=(2*sigmatl)/fvtl^2;
dfdsigma{7}(6,1)=(2*sigmarl)/fvrl^2;
else
dfdsigma{7}(1,1)=[0];
end
if requestedoutput(3)==1
dfdq{7}(1,1)=0;
dfdq{7}(2,1)=0;
dfdq{7}(3,1)=0;
dfdq{7}(4,1)=0;
dfdq{7}(5,1)=0;
dfdq{7}(6,1)=0;
dfdq{7}(7,1)=1;
else
dfdq{7}(1,1)=[0];
end
if requestedoutput(4)==1
d2fdsigma2{7}(1,1)=1/(2*fcr^2);
d2fdsigma2{7}(1,2)=0;
d2fdsigma2{7}(1,3)=0;
d2fdsigma2{7}(1,4)=0;
d2fdsigma2{7}(1,5)=0;
d2fdsigma2{7}(1,6)=0;
d2fdsigma2{7}(2,1)=0;
d2fdsigma2{7}(2,2)=1/(2*fct^2);
d2fdsigma2{7}(2,3)=0;
d2fdsigma2{7}(2,4)=0;
d2fdsigma2{7}(2,5)=0;
d2fdsigma2{7}(2,6)=0;
d2fdsigma2{7}(3,1)=0;
d2fdsigma2{7}(3,2)=0;
d2fdsigma2{7}(3,3)=-1/(5*fcl*ftl);
d2fdsigma2{7}(3,4)=0;
d2fdsigma2{7}(3,5)=0;
d2fdsigma2{7}(3,6)=0;
d2fdsigma2{7}(4,1)=0;
d2fdsigma2{7}(4,2)=0;
d2fdsigma2{7}(4,3)=0;
d2fdsigma2{7}(4,4)=2/fvrt^2;
d2fdsigma2{7}(4,5)=0;
d2fdsigma2{7}(4,6)=0;
d2fdsigma2{7}(5,1)=0;
d2fdsigma2{7}(5,2)=0;
d2fdsigma2{7}(5,3)=0;
d2fdsigma2{7}(5,4)=0;
d2fdsigma2{7}(5,5)=2/fvtl^2;
d2fdsigma2{7}(5,6)=0;
d2fdsigma2{7}(6,1)=0;
d2fdsigma2{7}(6,2)=0;
d2fdsigma2{7}(6,3)=0;
d2fdsigma2{7}(6,4)=0;
d2fdsigma2{7}(6,5)=0;
d2fdsigma2{7}(6,6)=2/fvrl^2;
else
d2fdsigma2{7}(1,1)=[0];
end
if requestedoutput(5)==1
d2fdsigmadq{7}(1,1)=0;
d2fdsigmadq{7}(1,2)=0;
d2fdsigmadq{7}(1,3)=0;
d2fdsigmadq{7}(1,4)=0;
d2fdsigmadq{7}(1,5)=0;
d2fdsigmadq{7}(1,6)=0;
d2fdsigmadq{7}(1,7)=0;
d2fdsigmadq{7}(2,1)=0;
d2fdsigmadq{7}(2,2)=0;
d2fdsigmadq{7}(2,3)=0;
d2fdsigmadq{7}(2,4)=0;
d2fdsigmadq{7}(2,5)=0;
d2fdsigmadq{7}(2,6)=0;
d2fdsigmadq{7}(2,7)=0;
d2fdsigmadq{7}(3,1)=0;
d2fdsigmadq{7}(3,2)=0;
d2fdsigmadq{7}(3,3)=0;
d2fdsigmadq{7}(3,4)=0;
d2fdsigmadq{7}(3,5)=0;
d2fdsigmadq{7}(3,6)=0;
d2fdsigmadq{7}(3,7)=0;
d2fdsigmadq{7}(4,1)=0;
d2fdsigmadq{7}(4,2)=0;
d2fdsigmadq{7}(4,3)=0;
d2fdsigmadq{7}(4,4)=0;
d2fdsigmadq{7}(4,5)=0;
d2fdsigmadq{7}(4,6)=0;
d2fdsigmadq{7}(4,7)=0;
d2fdsigmadq{7}(5,1)=0;
d2fdsigmadq{7}(5,2)=0;
d2fdsigmadq{7}(5,3)=0;
d2fdsigmadq{7}(5,4)=0;
d2fdsigmadq{7}(5,5)=0;
d2fdsigmadq{7}(5,6)=0;
d2fdsigmadq{7}(5,7)=0;
d2fdsigmadq{7}(6,1)=0;
d2fdsigmadq{7}(6,2)=0;
d2fdsigmadq{7}(6,3)=0;
d2fdsigmadq{7}(6,4)=0;
d2fdsigmadq{7}(6,5)=0;
d2fdsigmadq{7}(6,6)=0;
d2fdsigmadq{7}(6,7)=0;
else
d2fdsigmadq{7}(1,1)=[0];
end
if requestedoutput(6)==1
d2fdq2{7}(1,1)=0;
d2fdq2{7}(1,2)=0;
d2fdq2{7}(1,3)=0;
d2fdq2{7}(1,4)=0;
d2fdq2{7}(1,5)=0;
d2fdq2{7}(1,6)=0;
d2fdq2{7}(1,7)=0;
d2fdq2{7}(2,1)=0;
d2fdq2{7}(2,2)=0;
d2fdq2{7}(2,3)=0;
d2fdq2{7}(2,4)=0;
d2fdq2{7}(2,5)=0;
d2fdq2{7}(2,6)=0;
d2fdq2{7}(2,7)=0;
d2fdq2{7}(3,1)=0;
d2fdq2{7}(3,2)=0;
d2fdq2{7}(3,3)=0;
d2fdq2{7}(3,4)=0;
d2fdq2{7}(3,5)=0;
d2fdq2{7}(3,6)=0;
d2fdq2{7}(3,7)=0;
d2fdq2{7}(4,1)=0;
d2fdq2{7}(4,2)=0;
d2fdq2{7}(4,3)=0;
d2fdq2{7}(4,4)=0;
d2fdq2{7}(4,5)=0;
d2fdq2{7}(4,6)=0;
d2fdq2{7}(4,7)=0;
d2fdq2{7}(5,1)=0;
d2fdq2{7}(5,2)=0;
d2fdq2{7}(5,3)=0;
d2fdq2{7}(5,4)=0;
d2fdq2{7}(5,5)=0;
d2fdq2{7}(5,6)=0;
d2fdq2{7}(5,7)=0;
d2fdq2{7}(6,1)=0;
d2fdq2{7}(6,2)=0;
d2fdq2{7}(6,3)=0;
d2fdq2{7}(6,4)=0;
d2fdq2{7}(6,5)=0;
d2fdq2{7}(6,6)=0;
d2fdq2{7}(6,7)=0;
d2fdq2{7}(7,1)=0;
d2fdq2{7}(7,2)=0;
d2fdq2{7}(7,3)=0;
d2fdq2{7}(7,4)=0;
d2fdq2{7}(7,5)=0;
d2fdq2{7}(7,6)=0;
d2fdq2{7}(7,7)=0;
else
d2fdq2{7}(1)=[0];
end
%{
if requestedoutput(7)==1
dfdinput{7}(1,1)=sigmall^2/(10*fcl*ftl^2);
dfdinput{7}(2,1)=0;
dfdinput{7}(3,1)=0;
dfdinput{7}(4,1)=(sigmall*(ftl + 2*sigmall))/(20*fcl^2*ftl);
dfdinput{7}(5,1)=(sigmarr*(2*fcr - 5*sigmarr))/(10*fcr^3);
dfdinput{7}(6,1)=(sigmatt*(2*fct - 5*sigmatt))/(10*fct^3);
dfdinput{7}(7,1)=-(2*sigmart^2)/fvrt^3;
dfdinput{7}(8,1)=-(2*sigmarl^2)/fvrl^3;
dfdinput{7}(9,1)=-(2*sigmatl^2)/fvtl^3;
else
dfdinput{7}(1,1)=[0];
end
%}
end

% end of sym paste
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alphahp,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit)
alpha1=alphahp(1);
alpha2=alphahp(2);
alpha3=alphahp(3);
alpha4=alphahp(4);
alpha5=alphahp(5);
alpha6=alphahp(6);
alpha7=alphahp(7);


%{
beta0tl=65;
beta0cl=49.9;
beta0tr=4.5;
beta0cr=beta0tr/beta0tl*beta0cl;
beta0tt=beta0tr;
beta0ct=beta0cr;
%}

beta0tl=abs(ftl);
beta0cl=abs(fcl);
beta0tr=abs(ftr);
beta0cr=abs(fcr);
beta0tt=abs(ftt);
beta0ct=abs(fct);

zeta2=Hrd/beta0cr^2;
zeta4=Htd/beta0ct^2;
zeta6=Hld/beta0cl^2;
zeta7=zeta2;


alpha2d=alpha2dnounit*abs(fcr);
alpha2max=alpha2maxnounit*abs(fcr);
alpha4d=alpha4dnounit*abs(fct);
alpha4max=alpha4maxnounit*abs(fct);
alpha6d=alpha6dnounit*abs(fcl);
alpha6max=alpha6maxnounit*abs(fcl);
alpha7d=alpha7dnounit*abs(1/3*(fvrt+fvrl+fvtl));
alpha7max=alpha7maxnounit*abs(1/3*(fvrt+fvrl+fvtl));

% Start of Sym Results, paste here!
q(1)=(exp(-(alpha1*abs(lc))/abs(Gftr)) - 1)*(kappa1 - 1);
if alpha2<=alpha2d
q(2)=(exp(-(alpha2*abs(lc))/abs(Gfcr)) - 1)*(kappa2 - 1);
else
q(2)=(exp(-(alpha2*abs(lc))/abs(Gfcr)) - 1)*(kappa2 - 1) + (zeta2*(alpha2 - alpha2d)^2)/(alpha2 - alpha2max);
end
q(3)=(exp(-(alpha3*abs(lc))/abs(Gftt)) - 1)*(kappa3 - 1);
if alpha4<=alpha4d
q(4)=(exp(-(alpha4*abs(lc))/abs(Gfct)) - 1)*(kappa4 - 1);
else
q(4)=(exp(-(alpha4*abs(lc))/abs(Gfct)) - 1)*(kappa4 - 1) + (zeta4*(alpha4 - alpha4d)^2)/(alpha4 - alpha4max);
end
q(5)=(exp(-(alpha5*abs(lc))/abs(Gftl)) - 1)*(kappa5 - 1);
if alpha6<=alpha6d
q(6)=(exp(-(alpha6*abs(lc))/abs(Gfcl)) - 1)*(kappa6 - 1);
else
q(6)=(exp(-(alpha6*abs(lc))/abs(Gfcl)) - 1)*(kappa6 - 1) + (zeta6*(alpha6 - alpha6d)^2)/(alpha6 - alpha6max);
end
if alpha7<=alpha7d
q(7)=(exp(-(alpha7*abs(lc))/abs(GII)) - 1)*(kappa7 - 1);
else
q(7)=(exp(-(alpha7*abs(lc))/abs(GII)) - 1)*(kappa7 - 1) + (zeta7*(alpha7 - alpha7d)^2)/(alpha7 - alpha7max);
end
dqdalpha(1)=-(exp(-(alpha1*abs(lc))/abs(Gftr))*abs(lc)*(kappa1 - 1))/abs(Gftr);
if alpha2<=alpha2d
dqdalpha(2)=-(exp(-(alpha2*abs(lc))/abs(Gfcr))*abs(lc)*(kappa2 - 1))/abs(Gfcr);
else
dqdalpha(2)=(zeta2*(2*alpha2 - 2*alpha2d))/(alpha2 - alpha2max) - (zeta2*(alpha2 - alpha2d)^2)/(alpha2 - alpha2max)^2 - (exp(-(alpha2*abs(lc))/abs(Gfcr))*abs(lc)*(kappa2 - 1))/abs(Gfcr);
end
dqdalpha(3)=-(exp(-(alpha3*abs(lc))/abs(Gftt))*abs(lc)*(kappa3 - 1))/abs(Gftt);
if alpha4<=alpha4d
dqdalpha(4)=-(exp(-(alpha4*abs(lc))/abs(Gfct))*abs(lc)*(kappa4 - 1))/abs(Gfct);
else
dqdalpha(4)=(zeta4*(2*alpha4 - 2*alpha4d))/(alpha4 - alpha4max) - (zeta4*(alpha4 - alpha4d)^2)/(alpha4 - alpha4max)^2 - (exp(-(alpha4*abs(lc))/abs(Gfct))*abs(lc)*(kappa4 - 1))/abs(Gfct);
end
dqdalpha(5)=-(exp(-(alpha5*abs(lc))/abs(Gftl))*abs(lc)*(kappa5 - 1))/abs(Gftl);
if alpha6<=alpha6d
dqdalpha(6)=-(exp(-(alpha6*abs(lc))/abs(Gfcl))*abs(lc)*(kappa6 - 1))/abs(Gfcl);
else
dqdalpha(6)=(zeta6*(2*alpha6 - 2*alpha6d))/(alpha6 - alpha6max) - (zeta6*(alpha6 - alpha6d)^2)/(alpha6 - alpha6max)^2 - (exp(-(alpha6*abs(lc))/abs(Gfcl))*abs(lc)*(kappa6 - 1))/abs(Gfcl);
end
if alpha7<=alpha7d
dqdalpha(7)=-(exp(-(alpha7*abs(lc))/abs(GII))*abs(lc)*(kappa7 - 1))/abs(GII);
else
dqdalpha(7)=(zeta7*(2*alpha7 - 2*alpha7d))/(alpha7 - alpha7max) - (zeta7*(alpha7 - alpha7d)^2)/(alpha7 - alpha7max)^2 - (exp(-(alpha7*abs(lc))/abs(GII))*abs(lc)*(kappa7 - 1))/abs(GII);
end
d2qdalpha2(1)=(exp(-(alpha1*abs(lc))/abs(Gftr))*abs(lc)^2*(kappa1 - 1))/abs(Gftr)^2;
if alpha2<=alpha2d
d2qdalpha2(2)=(exp(-(alpha2*abs(lc))/abs(Gfcr))*abs(lc)^2*(kappa2 - 1))/abs(Gfcr)^2;
else
d2qdalpha2(2)=(2*zeta2)/(alpha2 - alpha2max) - (2*zeta2*(2*alpha2 - 2*alpha2d))/(alpha2 - alpha2max)^2 + (2*zeta2*(alpha2 - alpha2d)^2)/(alpha2 - alpha2max)^3 + (exp(-(alpha2*abs(lc))/abs(Gfcr))*abs(lc)^2*(kappa2 - 1))/abs(Gfcr)^2;
end
d2qdalpha2(3)=(exp(-(alpha3*abs(lc))/abs(Gftt))*abs(lc)^2*(kappa3 - 1))/abs(Gftt)^2;
if alpha4<=alpha4d
d2qdalpha2(4)=(exp(-(alpha4*abs(lc))/abs(Gfct))*abs(lc)^2*(kappa4 - 1))/abs(Gfct)^2;
else
d2qdalpha2(4)=(2*zeta4)/(alpha4 - alpha4max) - (2*zeta4*(2*alpha4 - 2*alpha4d))/(alpha4 - alpha4max)^2 + (2*zeta4*(alpha4 - alpha4d)^2)/(alpha4 - alpha4max)^3 + (exp(-(alpha4*abs(lc))/abs(Gfct))*abs(lc)^2*(kappa4 - 1))/abs(Gfct)^2;
end
d2qdalpha2(5)=(exp(-(alpha5*abs(lc))/abs(Gftl))*abs(lc)^2*(kappa5 - 1))/abs(Gftl)^2;
if alpha6<=alpha6d
d2qdalpha2(6)=(exp(-(alpha6*abs(lc))/abs(Gfcl))*abs(lc)^2*(kappa6 - 1))/abs(Gfcl)^2;
else
d2qdalpha2(6)=(2*zeta6)/(alpha6 - alpha6max) - (2*zeta6*(2*alpha6 - 2*alpha6d))/(alpha6 - alpha6max)^2 + (2*zeta6*(alpha6 - alpha6d)^2)/(alpha6 - alpha6max)^3 + (exp(-(alpha6*abs(lc))/abs(Gfcl))*abs(lc)^2*(kappa6 - 1))/abs(Gfcl)^2;
end
if alpha7<=alpha7d
d2qdalpha2(7)=(exp(-(alpha7*abs(lc))/abs(GII))*abs(lc)^2*(kappa7 - 1))/abs(GII)^2;
else
d2qdalpha2(7)=(2*zeta7)/(alpha7 - alpha7max) - (2*zeta7*(2*alpha7 - 2*alpha7d))/(alpha7 - alpha7max)^2 + (2*zeta7*(alpha7 - alpha7d)^2)/(alpha7 - alpha7max)^3 + (exp(-(alpha7*abs(lc))/abs(GII))*abs(lc)^2*(kappa7 - 1))/abs(GII)^2;
end

% End of Sym Results

%{
Dcut=[];
for i=1:length(hardeningsurfaces)
    %qcut(i)=q(hardeningsurfaces(i));
    for j=1:length(hardeningsurfaces)
        Dcut(i,j)=D(hardeningsurfaces(i),hardeningsurfaces(j));
    end
end
%}
%for i=1:7
%    q(i)=q(i)-1e99;
%end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [maxvalue,maxnum]=CellMax(cell11in)
maxnum=1;
maxvalue=cell11in{1};
for i=2:length(cell11in)
    if cell11in{i}>maxvalue
        maxvalue=cell11in{i};
        maxnum=i;
    end
end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [s_sp]=Linear_elastic(dESP,s_sp,E,nu)

% de_sp                   = zeros(spCount,3);                     % Strain increment
% e_sp                    = zeros(spCount,3);                     % Strain tensor
% ds_sp                   = zeros(spCount,3);                     % Stress increment


%D = [E/(1-nu.^2) E*nu/(1-nu.^2) 0; E*nu/(1-nu.^2) E/(1-nu.^2) 0; 0 0 E/(1-nu)];
D=E/((1+nu)*(1-2*nu))*[1-nu nu 0;nu 1-nu 0;0 0 (1-2*nu)];

% THis is the linear elastic model
        de_sp(1) = dESP(1,1);
        de_sp(2) = dESP(2,2);
        de_sp(3) = dESP(2,1);
        
        ds_sp = D * de_sp';
%         e_sp(spid,:)  =  e_sp(spid,:)+de_sp(spid,:);
        s_sp = s_sp + ds_sp';
        
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [s_sp]=Linear_elastic_orthotropic(dESP,s_sp,Ebase,Ex,Ey,nu)

% de_sp                   = zeros(spCount,3);                     % Strain increment
% e_sp                    = zeros(spCount,3);                     % Strain tensor
% ds_sp                   = zeros(spCount,3);                     % Stress increment

%{
Comp=[1/Er -nurt/Et -nurl/El 0 0 0;
    -nurt/Et 1/Et -nutl/El 0 0 0;
    -nurl/El -nutl/El 1/El 0 0 0;
    0 0 0 1/Grt 0 0;
    0 0 0 0 1/Gtl 0;
    0 0 0 0 0 1/Grl];
%}

nuxy=nu;
nuxz=nu;
nuyz=nu;
Gbase=Ebase/(2*(1+nu));
Gxy=Gbase;
Gxz=Gbase;
Gyz=Gbase;
Ez=Ebase;
E=Ebase;

%D = [E/(1-nu.^2) E*nu/(1-nu.^2) 0; E*nu/(1-nu.^2) E/(1-nu.^2) 0; 0 0 E/(1-nu)];

%{
D3D=[       -(Ex*Ey*(- Ey*nuyz^2 + Ez))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2), -(Ex*Ey*(Ez*nuxy + Ey*nuxz*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),    -(Ex*Ey*Ez*(nuxz + nuxy*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),   0,   0,   0;
 -(Ex*Ey*(Ez*nuxy + Ey*nuxz*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),        -(Ey^2*(- Ex*nuxz^2 + Ez))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2), -(Ey*Ez*(Ey*nuyz + Ex*nuxy*nuxz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),   0,   0,   0;
    -(Ex*Ey*Ez*(nuxz + nuxy*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2), -(Ey*Ez*(Ey*nuyz + Ex*nuxy*nuxz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),        -(Ez^2*(- Ex*nuxy^2 + Ey))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),   0,   0,   0;
                                                                                                              0,                                                                                                              0,                                                                                                              0, Gxy,   0,   0;
                                                                                                              0,                                                                                                              0,                                                                                                              0,   0, Gyz,   0;
                                                                                                              0,                                                                                                              0,                                                                                                              0,   0,   0, Gxz];

D=[D3D(1:2,1:2) D3D(1:2,4);
    D3D(4,1:2) D3D(4,4)];
%}

D = [Ex/(1-nu.^2) E*nu/(1-nu.^2) 0; E*nu/(1-nu.^2) E/(1-nu.^2) 0; 0 0 E/(1-nu)];

% THis is the linear elastic model
        de_sp(1) = dESP(1,1);
        de_sp(2) = dESP(2,2);
        de_sp(3) = dESP(2,1);
        
        ds_sp = D * de_sp';
%         e_sp(spid,:)  =  e_sp(spid,:)+de_sp(spid,:);
        s_sp = s_sp + ds_sp';
        
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [s_sp]=Linear_elastic_orthotropic_2(dESP,s_sp,Ex,Ey,Ez,Gxy,Gyz,Gxz,nuxy,nuyz,nuxz)

% de_sp                   = zeros(spCount,3);                     % Strain increment
% e_sp                    = zeros(spCount,3);                     % Strain tensor
% ds_sp                   = zeros(spCount,3);                     % Stress increment

%{
Comp=[1/Er -nurt/Et -nurl/El 0 0 0;
    -nurt/Et 1/Et -nutl/El 0 0 0;
    -nurl/El -nutl/El 1/El 0 0 0;
    0 0 0 1/Grt 0 0;
    0 0 0 0 1/Gtl 0;
    0 0 0 0 0 1/Grl];
%}



%D = [E/(1-nu.^2) E*nu/(1-nu.^2) 0; E*nu/(1-nu.^2) E/(1-nu.^2) 0; 0 0 E/(1-nu)];


D3D=[       -(Ex*Ey*(- Ey*nuyz^2 + Ez))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2), -(Ex*Ey*(Ez*nuxy + Ey*nuxz*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),    -(Ex*Ey*Ez*(nuxz + nuxy*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),   0,   0,   0;
 -(Ex*Ey*(Ez*nuxy + Ey*nuxz*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),        -(Ey^2*(- Ex*nuxz^2 + Ez))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2), -(Ey*Ez*(Ey*nuyz + Ex*nuxy*nuxz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),   0,   0,   0;
    -(Ex*Ey*Ez*(nuxz + nuxy*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2), -(Ey*Ez*(Ey*nuyz + Ex*nuxy*nuxz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),        -(Ez^2*(- Ex*nuxy^2 + Ey))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),   0,   0,   0;
                                                                                                              0,                                                                                                              0,                                                                                                              0, Gxy,   0,   0;
                                                                                                              0,                                                                                                              0,                                                                                                              0,   0, Gyz,   0;
                                                                                                              0,                                                                                                              0,                                                                                                              0,   0,   0, Gxz];

D=[D3D(1:2,1:2) D3D(1:2,4);
    D3D(4,1:2) D3D(4,4)];


%D = [Ex/(1-nu.^2) E*nu/(1-nu.^2) 0; E*nu/(1-nu.^2) E/(1-nu.^2) 0; 0 0 E/(1-nu)];

% THis is the linear elastic model
        de_sp(1) = dESP(1,1);
        de_sp(2) = dESP(2,2);
        de_sp(3) = dESP(2,1);
        
        ds_sp = D * de_sp';
%         e_sp(spid,:)  =  e_sp(spid,:)+de_sp(spid,:);
        s_sp = s_sp + ds_sp';
        
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [r1_sp,r2_sp] = Update_topology(spCount,F_sp,r1_sp,r10_sp,r2_sp,r20_sp)

for spid=1:spCount
        r1_sp(spid,:) = (F_sp{spid} * r10_sp(spid,:)')';
        r2_sp(spid,:) = (F_sp{spid} * r20_sp(spid,:)')';     
end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Final2_alpha(climit,x_sp,LOC,spCount,r1_sp,r2_sp,plotignore,alphahp,surfacenum)

 x_corner1              = zeros(spCount,2);
 x_corner2              = zeros(spCount,2);
 x_corner3              = zeros(spCount,2);
 x_corner4              = zeros(spCount,2);
 
% displacement = zeros(spCount,1);
velocity = zeros(spCount,1);
% strain = zeros(spCount,1);
spnum=0;
x_sp_plot=zeros(1,2);
splot_plot=zeros(1,1);
for sp=1:spCount
    if plotignore(sp)
        continue;
    elseif alphahp(sp,surfacenum)==0
        continue;
    end
    spnum=spnum+1;
    x_sp_plot(spnum,:)=x_sp(sp,:);
    splot_plot(spnum)=alphahp(sp,surfacenum);
end

for sp=1:spCount
     x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
     x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
     x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
     x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
 end

StressProfile1=figure;
 set(StressProfile1, 'visible','off');
sz = 40;
%color = velocity;
color = splot_plot;
scatter(x_sp_plot(:,1),x_sp_plot(:,2),sz,color,'filled');
hold on
daspect([1 1 1]);
for sp=1:spCount
    x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
    y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
    plot(x_cor,y_cor,'r')
end
grid on
axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
set(gca,'xtick',[0:20:max(LOC(:,1))]);
set(gca,'ytick',[0:20:max(LOC(:,2))]);
h=colorbar;
colormap(jet(256))
set(gca,'FontSize',20)
% set(h, 'ytick', [0:0.2:1.2]);a
caxis(climit);
%set(gca,'ctick',[0:8]);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Final2_f_plot(t,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,plotignore,f_final_vect,alphahp)

 x_corner1              = zeros(spCount,2);
 x_corner2              = zeros(spCount,2);
 x_corner3              = zeros(spCount,2);
 x_corner4              = zeros(spCount,2);
 
% displacement = zeros(spCount,1);
velocity = zeros(spCount,1);
% strain = zeros(spCount,1);
spnum=0;
x_sp_plot=zeros(1,2);
splot_plot=zeros(1,1);
for sp=1:spCount
    if plotignore(sp)
        continue;
    elseif max(alphahp(sp,:))==0
        continue;
    end
    spnum=spnum+1;
    x_sp_plot(spnum,:)=x_sp(sp,:);
    splot_plot(spnum)=FindMax(f_final_vect(sp,:));
end

for sp=1:spCount
     x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
     x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
     x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
     x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
 end

StressProfile1=figure;
 set(StressProfile1, 'visible','off');
sz = 10;
%color = velocity;
color = splot_plot;
scatter(x_sp_plot(:,1),x_sp_plot(:,2),sz,color,'filled');
hold on
daspect([1 1 1]);
title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
set(StressProfile1,'Position',[0 0 720 1280]);
for sp=1:spCount
    x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
    y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
    plot(x_cor,y_cor,'r')
end
grid on
axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
set(gca,'xtick',[0:20:max(LOC(:,1))]);
set(gca,'ytick',[0:20:max(LOC(:,2))]);
h=colorbar;
colormap(jet(256))
set(gca,'FontSize',20)
% set(h, 'ytick', [0:0.2:1.2]);a
caxis([0 7]);
%set(gca,'ctick',[0:8]);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%function not in use
function CurrentConfig = Plot_Current_var(x_sp,LOC,LOCX,LOCY,orientationoffset,xdirletter,ydirletter,lp,F_sp)

    CurrentConfig=figure;
    plot(x_sp(:,1),x_sp(:,2),'o');
    hold on
    daspect([1 1 1]);
    lp_take=sum(sum(lp))/(size(lp,1)*size(lp,2));
    for i=1:length(orientationoffset)
        if length(xdirletter{i})==1 && xdirletter{i}=='l'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        else
            continue
        end
        Rback=poldecomp(F_sp{i},0);
        R=transpose(Rback);
        totalangle=asin(R(1,2))+orientationoffset(i);
        xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(totalangle);
        xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(totalangle);
        ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(totalangle);
        yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(totalangle);
        plot([xstart xend],[ystart yend],'color','red');
    end
    title('initial condition');
    grid on
    axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
    set(gca,'xtick',LOCX);
    set(gca,'ytick',LOCY);
    % set(gca,'XTickLabel',[]);
    % set(gca,'YTickLabel',[]);
    hold off
end
%function not in use
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function CurrentConfig = Plot_CrackDirNairn(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack,x_crack,x_cracktop,x_crackbot)

    CurrentConfig=figure;
    set(CurrentConfig, 'visible','off');
    plot(x_sp(:,1),x_sp(:,2),'o');
    hold on
    daspect([1 1 1]);
    %set(CurrentConfig,'Position',[0 0 720 1280]);
    lp_take=max(lp);
    for i=1:length(orientationoffset)
        if length(xdirletter{i})==1 && xdirletter{i}=='l'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        else
            continue;
        end
        Rback=poldecomp(F_sp{i},0);
        R=transpose(Rback);
        %totalangle=asin(R(1,2))+orientationoffset(i);
		if isnan(thetacrack(i))
		elseif isinf(thetacrack(i))
		else
			totalangle=thetacrack(i);
			xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(totalangle);
			xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(totalangle);
			ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(totalangle);
			yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(totalangle);
			plot([xstart xend],[ystart yend],'color','red');
		end
    end
    if length(x_crack)==0
    else
        plot(x_cracktop(:,1),x_cracktop(:,2),'o','Color','red');
        plot(x_crack(:,1),x_crack(:,2),'o','Color','green');
        plot(x_crackbot(:,1),x_crackbot(:,2),'o','Color','blue');
    end
	title('Proposed Crack');
    grid on
    axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
    set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
    set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
    % set(gca,'XTickLabel',[]);
    % set(gca,'YTickLabel',[]);
    hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function CurrentConfig = Plot_CrackDirNairn_multi(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack,x_crack,x_cracktop,x_crackbot)
    CurrentConfig=figure;
    set(CurrentConfig, 'visible','off');
    plot(x_sp(:,1),x_sp(:,2),'o');
    hold on
    daspect([1 1 1]);
    %set(CurrentConfig,'Position',[0 0 720 1280]);
    lp_take=max(lp);
    for i=1:length(orientationoffset)
        if length(xdirletter{i})==1 && xdirletter{i}=='l'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        else
            continue;
        end
        Rback=poldecomp(F_sp{i},0);
        R=transpose(Rback);
        %totalangle=asin(R(1,2))+orientationoffset(i);
		if isnan(thetacrack(i))
		elseif isinf(thetacrack(i))
		else
			totalangle=thetacrack(i);
			xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(totalangle);
			xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(totalangle);
			ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(totalangle);
			yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(totalangle);
			plot([xstart xend],[ystart yend],'color','red');
		end
    end
    for ncrack=1:length(x_crack)
        plot(x_cracktop{ncrack}(:,1),x_cracktop{ncrack}(:,2),'o','Color','red');
        plot(x_crack{ncrack}(:,1),x_crack{ncrack}(:,2),'o','Color','green');
        plot(x_crackbot{ncrack}(:,1),x_crackbot{ncrack}(:,2),'o','Color','blue');
    end
	title('Proposed Crack');
    grid on
    axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
    set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
    set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
    % set(gca,'XTickLabel',[]);
    % set(gca,'YTickLabel',[]);
    hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function CurrentConfig = Plot_CrackDirNairn_multilines(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack,x_crack,x_cracktop,x_crackbot,CasetoRun)
    CurrentConfig=figure;
    set(CurrentConfig, 'visible','off');
    plot(x_sp(:,1),x_sp(:,2),'o');
    hold on
    daspect([1 1 1]);
	if CasetoRun==105 || CasetoRun==110
		set(CurrentConfig,'Position',[0 0 1800 1800]);
	end
    lp_take=max(lp);
    for i=1:length(orientationoffset)
        if length(xdirletter{i})==1 && xdirletter{i}=='l'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        else
            continue;
        end
        Rback=poldecomp(F_sp{i},0);
        R=transpose(Rback);
        %totalangle=asin(R(1,2))+orientationoffset(i);
		if isnan(thetacrack(i))
		elseif isinf(thetacrack(i))
		else
			totalangle=thetacrack(i);
			xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(totalangle);
			xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(totalangle);
			ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(totalangle);
			yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(totalangle);
			plot([xstart xend],[ystart yend],'color','red');
		end
    end
    for ncrack=1:length(x_crack)
		if CasetoRun==117
			plot(x_cracktop{ncrack}(:,1),x_cracktop{ncrack}(:,2),'x-','Color','red');
			plot(x_crack{ncrack}(:,1),x_crack{ncrack}(:,2),'x-','Color','black','LineWidth',2);
			plot(x_crackbot{ncrack}(:,1),x_crackbot{ncrack}(:,2),'x-','Color','blue');
		else
			%plot(x_cracktop{ncrack}(:,1),x_cracktop{ncrack}(:,2),'o','Color','red');
			plot(x_crack{ncrack}(:,1),x_crack{ncrack}(:,2),'-','Color','black','LineWidth',2);
			%plot(x_crackbot{ncrack}(:,1),x_crackbot{ncrack}(:,2),'o','Color','blue');
		end
    end
	title('Proposed Crack');
    grid on
    axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
    set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
    set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
    % set(gca,'XTickLabel',[]);
    % set(gca,'YTickLabel',[]);
    hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function CurrentConfig = Plot_CrackDir(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack)

    CurrentConfig=figure;
    set(CurrentConfig, 'visible','off');
    plot(x_sp(:,1),x_sp(:,2),'o');
    hold on
    daspect([1 1 1]);
    set(CurrentConfig,'Position',[0 0 720 1280]);
    lp_take=max(lp);
    for i=1:length(orientationoffset)
        if length(xdirletter{i})==1 && xdirletter{i}=='l'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        else
            continue;
        end
        Rback=poldecomp(F_sp{i},0);
        R=transpose(Rback);
        %totalangle=asin(R(1,2))+orientationoffset(i);
		if isnan(thetacrack(i))
		elseif isinf(thetacrack(i))
		else
			totalangle=thetacrack(i);
			xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(totalangle);
			xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(totalangle);
			ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(totalangle);
			yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(totalangle);
			plot([xstart xend],[ystart yend],'color','red');
		end
    end
    
	title('Proposed Crack');
    grid on
    axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
    set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
    set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
    % set(gca,'XTickLabel',[]);
    % set(gca,'YTickLabel',[]);
    hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function CurrentConfig = Plot_Current(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp)

    CurrentConfig=figure;
    set(CurrentConfig, 'visible','off');
    plot(x_sp(:,1),x_sp(:,2),'o');
    hold on
    daspect([1 1 1]);
    set(CurrentConfig,'Position',[0 0 720 1280]);
    lp_take=max(lp);
    for i=1:length(orientationoffset)
        if length(xdirletter{i})==1 && xdirletter{i}=='l'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
        elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
            orientationoffset(i)=orientationoffset(i)+pi/2;
        else
            continue;
        end
        Rback=poldecomp(F_sp{i},0);
        R=transpose(Rback);
        totalangle=asin(R(1,2))+orientationoffset(i);
        xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(totalangle);
        xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(totalangle);
        ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(totalangle);
        yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(totalangle);
        plot([xstart xend],[ystart yend],'color','red');
    end
    title('Current Config');
    grid on
    axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
    set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
    set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
    % set(gca,'XTickLabel',[]);
    % set(gca,'YTickLabel',[]);
    hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Final2_regularclimit(t,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,splot,climits,plotignore)

 x_corner1              = zeros(spCount,2);
 x_corner2              = zeros(spCount,2);
 x_corner3              = zeros(spCount,2);
 x_corner4              = zeros(spCount,2);
 
% displacement = zeros(spCount,1);
velocity = zeros(spCount,1);
% strain = zeros(spCount,1);
for sp=1:spCount
%     displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
    velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
%     strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
end
spnum=0;
x_sp_plot=zeros(spCount-sum(plotignore),2);
splot_plot=zeros(spCount-sum(plotignore),1);
for sp=1:spCount
    if plotignore(sp)
        continue;
    end
    spnum=spnum+1;
    x_sp_plot(spnum,:)=x_sp(sp,:);
    splot_plot(spnum)=splot(sp);
end

for sp=1:spCount
   
     x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
     x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
     x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
     x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
 end

StressProfile1=figure;
 set(StressProfile1, 'visible','off');
sz = 40;
%color = velocity;
color = splot_plot;
scatter(x_sp_plot(:,1),x_sp_plot(:,2),sz,color,'filled');
hold on
daspect([1 1 1]);
title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
%set(StressProfile1,'Position',[0 0 720 1280]);
for sp=1:spCount
    x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
    y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
    plot(x_cor,y_cor,'r')
end
grid on
axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
set(gca,'xtick',[0:20:max(LOC(:,1))]);
set(gca,'ytick',[0:20:max(LOC(:,2))]);
h=colorbar;
colormap(jet(256))
set(gca,'FontSize',20)
% set(h, 'ytick', [0:0.2:1.2]);
if exist('climits')
    if length(climits)>0
        if climits(2)>climits(1);
            caxis(climits);
        end
    end
end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Final2_regularclimit_black(t,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,splot,climits,plotignore,CasetoRun)

 x_corner1              = zeros(spCount,2);
 x_corner2              = zeros(spCount,2);
 x_corner3              = zeros(spCount,2);
 x_corner4              = zeros(spCount,2);
 
% displacement = zeros(spCount,1);
velocity = zeros(spCount,1);
% strain = zeros(spCount,1);
for sp=1:spCount
%     displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
    velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
%     strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
end
spnum=0;
x_sp_plot=zeros(spCount-sum(plotignore),2);
splot_plot=zeros(spCount-sum(plotignore),1);
for sp=1:spCount
    if plotignore(sp)
        continue;
    end
    spnum=spnum+1;
    x_sp_plot(spnum,:)=x_sp(sp,:);
    splot_plot(spnum)=splot(sp);
end

for sp=1:spCount
   
     x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
     x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
     x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
     x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
end

StressProfile1=figure;
 set(StressProfile1, 'visible','off');
 if CasetoRun==10
     sz = 140;
 else
    sz = 80;
 end
%color = velocity;
color = splot_plot;
scatter(x_sp_plot(:,1),x_sp_plot(:,2),sz,color,'filled');
hold on
daspect([1 1 1]);
%title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
set(StressProfile1,'Position',[0 0 1000 1000]);
for sp=1:spCount
    x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
    y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
    if plotignore(sp)
        x_cross1=[x_corner1(sp,1) x_corner3(sp,1)];
        y_cross1=[x_corner1(sp,2) x_corner3(sp,2)];
        x_cross2=[x_corner2(sp,1) x_corner4(sp,1)];
        y_cross2=[x_corner2(sp,2) x_corner4(sp,2)];
        plot(x_cross1,y_cross1,'r');
        plot(x_cross2,y_cross2,'r');
    end
    plot(x_cor,y_cor,'r')
end
grid on
if CasetoRun==10
    axis([0,max(LOC(:,1)),0,160]);
else
    axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
end
set(gca,'xtick',[0:20:max(LOC(:,1))]);
if CasetoRun==10
    set(gca,'ytick',[0:20:160]);
else
    set(gca,'ytick',[0:20:max(LOC(:,2))]);
end
h=colorbar;
currentcolormap1=jet(256);
currentcolormap2=currentcolormap1;
colormap(currentcolormap2)
set(gca,'FontSize',40)
% set(h, 'ytick', [0:0.2:1.2]);
if exist('climits')
    if length(climits)>0
        if climits(2)>climits(1);
            caxis(climits);
        end
    end
end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Final2_regularnolimit(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,splot)

 x_corner1              = zeros(spCount,2);
 x_corner2              = zeros(spCount,2);
 x_corner3              = zeros(spCount,2);
 x_corner4              = zeros(spCount,2);
 
% displacement = zeros(spCount,1);
velocity = zeros(spCount,1);
% strain = zeros(spCount,1);
for sp=1:spCount
%     displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
    velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
%     strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
end

 for sp=1:spCount
 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
 end

StressProfile1=figure;
 set(StressProfile1, 'visible','off');
sz = 40;
%color = velocity;
color = splot;
scatter(x_sp(:,1),x_sp(:,2),sz,color,'filled');
hold on
daspect([1 1 1]);
for sp=1:spCount
    x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
    y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
    plot(x_cor,y_cor,'r')
end
grid on
axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
set(gca,'xtick',[0:20:max(LOC(:,1))]);
set(gca,'ytick',[0:20:max(LOC(:,2))]);
h=colorbar;
colormap(jet(256))
set(gca,'FontSize',20)
% set(h, 'ytick', [0:0.2:1.2]);
%{
if exist('climits')
    if length(climits)>0
        if climits(2)>climits(1);
            caxis(climits);
        end
    end
end
%}
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_ovl(t,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,ActuallyPlot,plotignore)

 x_corner1              = zeros(spCount,2);
 x_corner2              = zeros(spCount,2);
 x_corner3              = zeros(spCount,2);
 x_corner4              = zeros(spCount,2);
 
% displacement = zeros(spCount,1);
velocity = zeros(spCount,1);
% strain = zeros(spCount,1);

for sp=1:spCount
%     displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
    velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
%     strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
end


 for sp=1:spCount
 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
 end

 %%Calculating Max Princ Plast Strain
 for sp=1:spCount
     theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
     e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
     e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
     e_pl_max(sp)=max(e_pl_first,e_pl_second);
     e_pl_min(sp)=min(e_pl_first,e_pl_second);
     e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
     if plotignore(sp)
     else
        if maxminshear==1
            if isnan(e_pl_max(sp)) || isinf(e_pl_max(sp))
                e_pl_max(sp)=0;
            end
        elseif maxminshear==2
            if isnan(e_pl_min(sp)) || isinf(e_pl_min(sp))
                e_pl_min(sp)=0;
            end
        elseif maxminshear==3
            if isnan(e_pl_shear(sp)) || isinf(e_pl_shear(sp))
                e_pl_shear(sp)=0;
            end
        else
            disp('wrong maxminshear input!');
            pause
        end
     end
 end
 if ActuallyPlot==1
    StressProfile1=figure;
     set(StressProfile1, 'visible','off');
    sz = 30;
    %color = velocity;
    if maxminshear==1
        color = e_pl_max;
    elseif maxminshear==2
        color = e_pl_min;
    elseif maxminshear==3
        color = e_pl_shear;
    else
        disp('wrong maxminshear input!');
        pause
    end
    scatter(x_sp(:,1),x_sp(:,2),sz,color,'filled');
    hold on
    daspect([1 1 1]);
    title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
    set(StressProfile1,'Position',[0 0 5760 10240]);
    set(gca,'color','none');
    for sp=1:spCount
        if plotignore(sp)
        else
            x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
            y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
            plot(x_cor,y_cor,'r','LineWidth',2)
        end
    end
    grid on
    axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
    set(gca,'xtick',[0:inf:max(LOC(:,1))]);
    set(gca,'ytick',[0:inf:max(LOC(:,2))]);
    %h=colorbar;
    colormap(jet(256))
    % set(h, 'ytick', [0:0.2:1.2]);
    set(gca,'FontSize',1)
else
    StressProfile1=[];
end
if exist('climits')
    if length(climits)>0
        if climits(2)>climits(1)
            caxis(climits);
        end
    end
end

end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_report(matmodel,CasetoRun,t,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,ActuallyPlot)

 x_corner1              = zeros(spCount,2);
 x_corner2              = zeros(spCount,2);
 x_corner3              = zeros(spCount,2);
 x_corner4              = zeros(spCount,2);
 
% displacement = zeros(spCount,1);
velocity = zeros(spCount,1);
% strain = zeros(spCount,1);

for sp=1:spCount
%     displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
    velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
%     strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
end


 for sp=1:spCount
 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
 end

 %%Calculating Max Princ Plast Strain
 for sp=1:spCount
     theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
     e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
     e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
     e_pl_max(sp)=max(e_pl_first,e_pl_second);
     e_pl_min(sp)=min(e_pl_first,e_pl_second);
     e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
     if matmodel(sp)~=1
     else
        if maxminshear==1
            if isnan(e_pl_max(sp)) || isinf(e_pl_max(sp))
                e_pl_max(sp)=0;
            end
        elseif maxminshear==2
            if isnan(e_pl_min(sp)) || isinf(e_pl_min(sp))
                e_pl_min(sp)=0;
            end
        elseif maxminshear==3
            if isnan(e_pl_shear(sp)) || isinf(e_pl_shear(sp))
                e_pl_shear(sp)=0;
            end
        else
            disp('wrong maxminshear input!');
            pause
        end
     end
end
 if ActuallyPlot==1
    StressProfile1=figure;
     set(StressProfile1, 'visible','off');
    if CasetoRun==40 || CasetoRun==52 || CasetoRun==54
        sz = 20;
    elseif CasetoRun==61 || CasetoRun==62 || CasetoRun==63
        sz = 20;
    else
        sz = 10;
    end
    %color = velocity;
    if maxminshear==1
        color = e_pl_max;
    elseif maxminshear==2
        color = e_pl_min;
    elseif maxminshear==3
        color = e_pl_shear;
    else
        disp('wrong maxminshear input!');
        pause
    end
    scatter(x_sp(:,1),x_sp(:,2),sz,color,'filled');
    hold on
    daspect([1 1 1]);
    if CasetoRun==40 || CasetoRun==52 || CasetoRun==54
    elseif CasetoRun==61 || CasetoRun==62 || CasetoRun==63
    else
        title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
    end
    if CasetoRun==40 || CasetoRun==52 || CasetoRun==54
        set(StressProfile1,'Position',[0 0 600 960]);
    elseif CasetoRun==61 || CasetoRun==62 || CasetoRun==63
        set(StressProfile1,'Position',[0 0 600 960]);
    else
        set(StressProfile1,'Position',[0 0 720 1280]);
    end
    for sp=1:spCount
        x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
        y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
        plot(x_cor,y_cor,'r')
    end
    grid on
    if CasetoRun==40 || CasetoRun==52 || CasetoRun==54
        axis([0,max(LOC(:,1)),0,140]);
        set(gca,'xtick',[0:20:max(LOC(:,1))]);
        set(gca,'ytick',[0:20:140]);
    elseif CasetoRun==61 || CasetoRun==62 || CasetoRun==63
        axis([40,180,40,480]);
        set(gca,'xtick',[40:inf:180]);
        set(gca,'ytick',[40:inf:480]);
        axis off
    else
        axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
        set(gca,'xtick',[0:20:max(LOC(:,1))]);
        set(gca,'ytick',[0:20:max(LOC(:,2))]);
    end
    h=colorbar;
    colormap(jet(256))
    % set(h, 'ytick', [0:0.2:1.2]);
    if CasetoRun==40 || CasetoRun==52 || CasetoRun==54
        set(gca,'FontSize',30);
    else
        set(gca,'FontSize',20);
    end
else
    StressProfile1=[];
end
if exist('climits')
    if length(climits)>0
        if climits(2)>climits(1)
            caxis(climits);
        end
    end
end

end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit(t,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,ActuallyPlot)

 x_corner1              = zeros(spCount,2);
 x_corner2              = zeros(spCount,2);
 x_corner3              = zeros(spCount,2);
 x_corner4              = zeros(spCount,2);
 
% displacement = zeros(spCount,1);
velocity = zeros(spCount,1);
% strain = zeros(spCount,1);

for sp=1:spCount
%     displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
    velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
%     strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
end


 for sp=1:spCount
 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
 end

 %%Calculating Max Princ Plast Strain
 for sp=1:spCount
     theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
     e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
     e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
     e_pl_max(sp)=max(e_pl_first,e_pl_second);
     e_pl_min(sp)=min(e_pl_first,e_pl_second);
     e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
 end
 if ActuallyPlot==1
    StressProfile1=figure;
     set(StressProfile1, 'visible','off');
    sz = 10;
    %color = velocity;
    if maxminshear==1
        color = e_pl_max;
    elseif maxminshear==2
        color = e_pl_min;
    elseif maxminshear==3
        color = e_pl_shear;
    else
        disp('wrong maxminshear input!');
        pause
    end
    scatter(x_sp(:,1),x_sp(:,2),sz,color,'filled');
    hold on
    daspect([1 1 1]);
    title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
    set(StressProfile1,'Position',[0 0 720 1280]);
    for sp=1:spCount
        x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
        y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
        plot(x_cor,y_cor,'r')
    end
    grid on
    axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
    set(gca,'xtick',[0:20:max(LOC(:,1))]);
    set(gca,'ytick',[0:20:max(LOC(:,2))]);
    h=colorbar;
    colormap(jet(256))
    % set(h, 'ytick', [0:0.2:1.2]);
    set(gca,'FontSize',20)
else
    StressProfile1=[];
end
if exist('climits')
    if length(climits)>0
        if climits(2)>climits(1)
            caxis(climits);
        end
    end
end

end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_black(t,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,plotignore,ActuallyPlot,CasetoRun)

 x_corner1              = zeros(spCount,2);
 x_corner2              = zeros(spCount,2);
 x_corner3              = zeros(spCount,2);
 x_corner4              = zeros(spCount,2);
 
% displacement = zeros(spCount,1);
velocity = zeros(spCount,1);
% strain = zeros(spCount,1);

for sp=1:spCount
%     displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
    velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
%     strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
end


 for sp=1:spCount
 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
 end

 %%Calculating Max Princ Plast Strain
 for sp=1:spCount
     theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
     e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
     e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
     e_pl_max(sp)=max(e_pl_first,e_pl_second);
     e_pl_min(sp)=min(e_pl_first,e_pl_second);
     e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
 end
 if ActuallyPlot==1
    StressProfile1=figure;
     set(StressProfile1, 'visible','off');
     if CasetoRun==10
         sz = 140;
     else
        sz = 80;
     end
    %color = velocity;
    if maxminshear==1
        color = e_pl_max;
    elseif maxminshear==2
        color = e_pl_min;
    elseif maxminshear==3
        color = e_pl_shear;
    else
        disp('wrong maxminshear input!');
        pause
    end
    scatter(x_sp(:,1),x_sp(:,2),sz,color,'filled');
    hold on
    daspect([1 1 1]);
    %title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
    set(StressProfile1,'Position',[0 0 1000 1000]);
    for sp=1:spCount
        x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
        y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
        if plotignore(sp)
            x_cross1=[x_corner1(sp,1) x_corner3(sp,1)];
            y_cross1=[x_corner1(sp,2) x_corner3(sp,2)];
            x_cross2=[x_corner2(sp,1) x_corner4(sp,1)];
            y_cross2=[x_corner2(sp,2) x_corner4(sp,2)];
            plot(x_cross1,y_cross1,'color','red');
            plot(x_cross2,y_cross2,'color','red');
        end
        plot(x_cor,y_cor,'red')
    end
    grid on
    if CasetoRun==10
        axis([0,max(LOC(:,1)),0,160]);
        set(gca,'ytick',[0:20:160]);
    else
        axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
        set(gca,'ytick',[0:20:max(LOC(:,2))]);
    end
    set(gca,'xtick',[0:20:max(LOC(:,1))]);
    h=colorbar;
    currentcolormap1=jet(256);
    currentcolormap2=currentcolormap1;
    colormap(currentcolormap2)
    % set(h, 'ytick', [0:0.2:1.2]);
    set(gca,'FontSize',40)
else
    StressProfile1=[];
end
if exist('climits')
    if length(climits)>0
        if climits(2)>climits(1)
            caxis(climits);
        end
    end
end

end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_directions_crack(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot)
	 x_corner1              = zeros(spCount,2);
	 x_corner2              = zeros(spCount,2);
	 x_corner3              = zeros(spCount,2);
	 x_corner4              = zeros(spCount,2);
	 
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	for sp=1:spCount
	%     displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%     strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end

	 for sp=1:spCount
	 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
	 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
	 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
	 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	 end

	 %%Calculating Max Princ Plast Strain
	 for sp=1:spCount
		 theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		 e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		 e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		 if plotignore(sp)==0
			 if e_pl_first>e_pl_second
				 thetamax(sp)=theta;
				 thetamin(sp)=theta+pi/2;
			 else
				 thetamax(sp)=theta+pi/2;
				 thetamin(sp)=theta;
			 end
		 end
		 e_pl_max(sp)=max(e_pl_first,e_pl_second);
		 e_pl_min(sp)=min(e_pl_first,e_pl_second);
		 e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		 
	 end
	if ActuallyPlot==1
		StressProfile1=figure;
		 set(StressProfile1, 'visible','off');
		sz = 40;
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		for sp=1:spCount
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			plot(x_cor,y_cor,'r')
			if plotignore(sp)
				continue;
			end
			if maxminshear==1
				thetaplot=thetamax(sp);
			elseif maxminshear==2
				thetaplot=thetamin(sp);
			elseif maxminshear==3
				continue;
			else
				disp('MaxminShear Wrong! Put either 1, 2, or 3!')
				pause
			end
			xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
			xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
			ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
			yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
			plot([xstart xend],[ystart yend],'color','black');
		end
		if length(x_crack)==0
		else
			plot(x_cracktop(:,1),x_cracktop(:,2),'o','Color','red');
			plot(x_crack(:,1),x_crack(:,2),'o','Color','green');
			plot(x_crackbot(:,1),x_crackbot(:,2),'o','Color','blue');
		end
		grid on
		axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
		set(gca,'xtick',[0:20:max(LOC(:,1))]);
		set(gca,'ytick',[0:20:max(LOC(:,2))]);
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_directions_crackmulti(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun)
	x_corner1              = zeros(spCount,2);
	x_corner2              = zeros(spCount,2);
	x_corner3              = zeros(spCount,2);
	x_corner4              = zeros(spCount,2);
	 
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	%%Calculating Max Princ Plast Strain
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		 
	end
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		sz = 40;
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		for sp=1:spCount
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			plot(x_cor,y_cor,'r')
			if plotignore(sp)
				continue;
			end
			if maxminshear==1
				thetaplot=thetamax(sp);
			elseif maxminshear==2
				thetaplot=thetamin(sp);
			elseif maxminshear==3
				continue;
			else
				disp('MaxminShear Wrong! Put either 1, 2, or 3!')
				pause
			end
			xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
			xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
			ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
			yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
			plot([xstart xend],[ystart yend],'color','black');
		end
		if length(x_crack)==0
		else
			for ncrack=1:length(x_crack)
				plot(x_cracktop{ncrack}(:,1),x_cracktop{ncrack}(:,2),'o','Color','red');
				plot(x_crack{ncrack}(:,1),x_crack{ncrack}(:,2),'o','Color','green');
				plot(x_crackbot{ncrack}(:,1),x_crackbot{ncrack}(:,2),'o','Color','blue');
			end
		end
		grid on
		axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
		set(gca,'xtick',[0:20:max(LOC(:,1))]);
		set(gca,'ytick',[0:20:max(LOC(:,2))]);
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_directions_crackmultiline(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun)
	x_corner1              = zeros(spCount,2);
	x_corner2              = zeros(spCount,2);
	x_corner3              = zeros(spCount,2);
	x_corner4              = zeros(spCount,2);
	 
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	%%Calculating Max Princ Plast Strain
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		 
	end
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		sz = 40;
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		for sp=1:spCount
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			plot(x_cor,y_cor,'r')
			if plotignore(sp)
				continue;
			end
			if maxminshear==1
				thetaplot=thetamax(sp);
			elseif maxminshear==2
				thetaplot=thetamin(sp);
			elseif maxminshear==3
				continue;
			else
				disp('MaxminShear Wrong! Put either 1, 2, or 3!')
				pause
			end
			xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
			xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
			ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
			yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
			plot([xstart xend],[ystart yend],'color','black');
		end
		if length(x_crack)==0
		else
			for ncrack=1:length(x_crack)
				%plot(x_cracktop{ncrack}(:,1),x_cracktop{ncrack}(:,2),'o','Color','red');
				plot(x_crack{ncrack}(:,1),x_crack{ncrack}(:,2),'-','Color','black','LineWidth',2);
				%plot(x_crackbot{ncrack}(:,1),x_crackbot{ncrack}(:,2),'o','Color','blue');
			end
		end
		grid on
		axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
		set(gca,'xtick',[0:20:max(LOC(:,1))]);
		set(gca,'ytick',[0:20:max(LOC(:,2))]);
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_principal_crackmulti_pforce(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun,pforce_sp)
	x_corner1              = zeros(spCount,2);
	x_corner2              = zeros(spCount,2);
	x_corner3              = zeros(spCount,2);
	x_corner4              = zeros(spCount,2);
	 
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	%%Calculating Max Princ Plast Strain
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		 
	end
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		sz = 40;
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		for sp=1:spCount
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			plot(x_cor,y_cor,'r')
			if plotignore(sp)
				continue;
			end
			if maxminshear==1
				thetaplot=thetamax(sp);
			elseif maxminshear==2
				thetaplot=thetamin(sp);
			elseif maxminshear==3
				continue;
			else
				disp('MaxminShear Wrong! Put either 1, 2, or 3!')
				pause
			end
			xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
			xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
			ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
			yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
			plot([xstart xend],[ystart yend],'color','black');
		end
		if length(x_crack)==0
		else
			for ncrack=1:length(x_crack)
				%plot(x_cracktop{ncrack}(:,1),x_cracktop{ncrack}(:,2),'o','Color','red');
				plot(x_crack{ncrack}(:,1),x_crack{ncrack}(:,2),'-','Color','black','LineWidth',2);
				%plot(x_crackbot{ncrack}(:,1),x_crackbot{ncrack}(:,2),'o','Color','blue');
			end
		end
		domainsizevect=[max(LOC(:,1))-min(LOC(:,1)) max(LOC(:,2))-min(LOC(:,2))];
		domainsize=sqrt(dot(domainsizevect,domainsizevect));
		pforce_magnitude=zeros(spCount,1);
		for sp=1:spCount
			pforce_magnitude(sp,1)=sqrt(dot(pforce_sp(sp,:),pforce_sp(sp,:)));
		end
		pforce_maxmagnitude=max(pforce_magnitude);
		if pforce_maxmagnitude>0
			maxlinesize=domainsize/10;
			pforcetolinescale=maxlinesize/pforce_maxmagnitude;
			for sp=1:spCount
				if pforce_magnitude(sp,1)>0
					pforce_angle=reliableatan(pforce_sp(sp,1),pforce_sp(sp,2));
					linelength=pforce_magnitude(sp,1)*pforcetolinescale;
					plot([x_sp(sp,1) x_sp(sp,1)+linelength*cos(pforce_angle)],[x_sp(sp,2) x_sp(sp,2)+linelength*sin(pforce_angle)],'color','red','LineWidth',1.5);
				end
			end
		end
		grid on
		axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
		set(gca,'xtick',[0:20:max(LOC(:,1))]);
		set(gca,'ytick',[0:20:max(LOC(:,2))]);
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun)

 x_corner1              = zeros(spCount,2);
 x_corner2              = zeros(spCount,2);
 x_corner3              = zeros(spCount,2);
 x_corner4              = zeros(spCount,2);
 
% displacement = zeros(spCount,1);
velocity = zeros(spCount,1);
% strain = zeros(spCount,1);
for sp=1:spCount
%     displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
    velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
%     strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
end

 for sp=1:spCount
 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
 end

 %%Calculating Max Princ Plast Strain
 for sp=1:spCount
     theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
     e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
     e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
     if plotignore(sp)==0
         if e_pl_first>e_pl_second
             thetamax(sp)=theta;
             thetamin(sp)=theta+pi/2;
         else
             thetamax(sp)=theta+pi/2;
             thetamin(sp)=theta;
         end
     end
     e_pl_max(sp)=max(e_pl_first,e_pl_second);
     e_pl_min(sp)=min(e_pl_first,e_pl_second);
     e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
     
 end
if ActuallyPlot==1
    StressProfile1=figure;
     set(StressProfile1, 'visible','off');
    sz = 40;
    %color = velocity;
    if maxminshear==1
        color = e_pl_max;
    elseif maxminshear==2
        color = e_pl_min;
    elseif maxminshear==3
        color = e_pl_shear;
    else
        disp('wrong maxminshear input!');
        pause
    end
    color_cut=cutvector(color,0,plotignore);
    x_sp_cut=cutvector(x_sp,1,plotignore);
    scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
    hold on
    daspect([1 1 1]);
	if CasetoRun==105 || CasetoRun==110
		set(StressProfile1,'Position',[0 0 1800 1800]);
	end
    for sp=1:spCount
        x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
        y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
        plot(x_cor,y_cor,'r')
        if plotignore(sp)
            continue;
        end
        if maxminshear==1
            thetaplot=thetamax(sp);
        elseif maxminshear==2
            thetaplot=thetamin(sp);
        elseif maxminshear==3
            continue;
        else
            disp('MaxminShear Wrong! Put either 1, 2, or 3!')
            pause
        end
        xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
        xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
        ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
        yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
        plot([xstart xend],[ystart yend],'color','black');
    end
    grid on
    axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
    set(gca,'xtick',[0:20:max(LOC(:,1))]);
    set(gca,'ytick',[0:20:max(LOC(:,2))]);
    h=colorbar;
    colormap(jet(256))
    set(gca,'FontSize',20)
else
    StressProfile1=[];
end
% set(h, 'ytick', [0:0.2:1.2]);
if exist('climits')
    if length(climits)>0
        if climits(2)>climits(1)
            caxis(climits);
        end
    end
end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_directions_black(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun)

 x_corner1              = zeros(spCount,2);
 x_corner2              = zeros(spCount,2);
 x_corner3              = zeros(spCount,2);
 x_corner4              = zeros(spCount,2);
 
% displacement = zeros(spCount,1);
velocity = zeros(spCount,1);
% strain = zeros(spCount,1);
for sp=1:spCount
%     displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
    velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
%     strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
end

 for sp=1:spCount
 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
 end

 %%Calculating Max Princ Plast Strain
 for sp=1:spCount
     theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
     e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
     e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
     if plotignore(sp)==0
         if e_pl_first>e_pl_second
             thetamax(sp)=theta;
             thetamin(sp)=theta+pi/2;
         else
             thetamax(sp)=theta+pi/2;
             thetamin(sp)=theta;
         end
     end
     e_pl_max(sp)=max(e_pl_first,e_pl_second);
     e_pl_min(sp)=min(e_pl_first,e_pl_second);
     e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
     
 end
if ActuallyPlot==1
    StressProfile1=figure;
     set(StressProfile1, 'visible','off');
    sz = 30;
    %color = velocity;
    if maxminshear==1
        color = e_pl_max;
    elseif maxminshear==2
        color = e_pl_min;
    elseif maxminshear==3
        color = e_pl_shear;
    else
        disp('wrong maxminshear input!');
        pause
    end
    color_cut=cutvector(color,0,plotignore);
    
    if maxminshear==1
        maxvalue=max(color_cut);
    elseif maxminshear==2
        maxvalue=min(color_cut);
    elseif maxminshear==3
        maxvalue=max(color_cut);
    end
    TheDisplayName=['0 to ' num2str(abs(maxvalue)) ' MPa' ];

    if maxminshear==1
        TheDisplayName=[TheDisplayName ' (tension)'];
    elseif maxminshear==2
        TheDisplayName=[TheDisplayName ' (compression)'];
    elseif maxminshear==3
        TheDisplayName=[TheDisplayName ' (shear)'];
    end
    x_sp_cut=cutvector(x_sp,1,plotignore);
    scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
    hold on
    daspect([1 1 1]);
	set(StressProfile1,'Position',[0 0 1000 1000]);
    for sp=1:spCount
        if abs(x_sp(sp,1)-min(x_sp(:,1)))<lp(1)/2 && abs(x_sp(sp,2)-min(x_sp(:,2)))<lp(2)/2
            1;
        end
        x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
        y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
        if plotignore(sp)
            x_cross1=[x_corner1(sp,1) x_corner3(sp,1)];
            y_cross1=[x_corner1(sp,2) x_corner3(sp,2)];
            x_cross2=[x_corner2(sp,1) x_corner4(sp,1)];
            y_cross2=[x_corner2(sp,2) x_corner4(sp,2)];
            plot(x_cross1,y_cross1,'color','red','HandleVisibility','off');
            plot(x_cross2,y_cross2,'color','red','HandleVisibility','off');
        end
        if sp==1
            plot(x_cor,y_cor,'r','DisplayName',TheDisplayName)
        else
            plot(x_cor,y_cor,'r','HandleVisibility','off')
        end
%        if sp==1
%            hold on;
%            daspect([1 1 1]);
%        end
        if plotignore(sp)
            continue;
        end
        if maxminshear==1
            thetaplot=thetamax(sp);
            relativelength=max(color(sp),0)/maxvalue;
        elseif maxminshear==2
            thetaplot=thetamin(sp);
            relativelength=min(color(sp),0)/maxvalue;
        elseif maxminshear==3
            continue;
        else
            disp('MaxminShear Wrong! Put either 1, 2, or 3!')
            pause
        end
        relativelength=1;
        xstart=x_sp(sp,1)-lp(1)*relativelength*sqrt(2)/2*cos(thetaplot);
        xend=x_sp(sp,1)+lp(1)*relativelength*sqrt(2)/2*cos(thetaplot);
        ystart=x_sp(sp,2)-lp(2)*relativelength*sqrt(2)/2*sin(thetaplot);
        yend=x_sp(sp,2)+lp(2)*relativelength*sqrt(2)/2*sin(thetaplot);
        plot([xstart xend],[ystart yend],'color','black','HandleVisibility','off');
    end
    grid on
    if CasetoRun==10
        axis([0,max(LOC(:,1)),0,160]);
        set(gca,'ytick',[0:20:160]);
    else
        axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
        set(gca,'ytick',[0:20:max(LOC(:,2))]);
    end
    set(gca,'xtick',[0:20:max(LOC(:,1))]);
    %title(TheDisplayName);
    %legend show
    h=colorbar;
    colormap(jet(256));
    set(gca,'FontSize',40)
else
    StressProfile1=[];
end
% set(h, 'ytick', [0:0.2:1.2]);
%if exist('climits')
%    if length(climits)>0
%        if climits(2)>climits(1)
%            caxis(climits);
%        end
%    end
%end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function directionnum = RTLtranslator(directionstr)
%RTLTRANSLATOR Summary of this function goes here
%   Detailed explanation goes here
errorswitch=0;
if length(directionstr)==1
    if directionstr=='r'
        directionnum=1;
    elseif directionstr=='t'
        directionnum=2;
    elseif directionstr=='l'
        directionnum=3;
    else
        errorswitch=1;
    end
elseif length(directionstr)==2
    if directionstr=='rt'
        directionnum=4;
    elseif directionstr=='tr'
        directionnum=4;
    elseif directionstr=='tl'
        directionnum=5;
    elseif directionstr=='lt'
        directionnum=5;
    elseif directionstr=='rl'
        directionnum=6;
    elseif directionstr=='lr'
        directionnum=6;
    else
        errorswitch=1;
    end
else
    errorswitch=1;
end
if errorswitch==1
    disp('direction error');
    pause
end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function printvector(thevector,vectorname,indexes)
if exist('indexes')
    texttodisplay=[vectorname '=['];
    for i=1:length(indexes)
        if i>1
            texttodisplay=[texttodisplay ','];
        end
        texttodisplay=[texttodisplay num2str(thevector(indexes(i)))];
    end
    texttodisplay=[texttodisplay ']'];
    disp(texttodisplay)
else
    texttodisplay=[vectorname '=['];
    for i=1:length(thevector)
        if i>1
            texttodisplay=[texttodisplay ','];
        end
        texttodisplay=[texttodisplay num2str(thevector(i))];
    end
    texttodisplay=[texttodisplay ']'];
    disp(texttodisplay)
end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MatOut=MatReorder(MatIn,Order)
    MatOut=zeros(size(MatIn));
    for i=1:size(MatOut,1)
        for j=1:size(MatOut,2)
            MatOut(i,j)=MatIn(Order(i),Order(j));
        end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function soundplay
    amp=1 ;
    fs=48000;  % sampling frequency
    duration=0.25;
    freq=1000;
    values=0:1/fs:16*duration;
    for i=1:length(values)
        if values(i)<=duration
            a(i)=amp*sin(2*pi* freq*values(i));
        elseif values(i)<=2*duration
            a(i)=0;
        elseif values(i)<=3*duration
            a(i)=amp*sin(2*pi* freq*values(i));
        elseif values(i)<=4*duration
            a(i)=0;
        elseif values(i)<=5*duration
            a(i)=amp*sin(2*pi* freq*values(i));
        elseif values(i)<=6*duration
            a(i)=0;
        elseif values(i)<=7*duration
            a(i)=amp*sin(2*pi* freq*values(i));
        elseif values(i)<=8*duration
            a(i)=0;
        elseif values(i)<=9*duration
            a(i)=amp*sin(2*pi* freq*values(i));
        elseif values(i)<=10*duration
            a(i)=0;
        elseif values(i)<=11*duration
            a(i)=amp*sin(2*pi* freq*values(i));
        elseif values(i)<=12*duration
            a(i)=0;
        elseif values(i)<=13*duration
            a(i)=amp*sin(2*pi* freq*values(i));
        elseif values(i)<=14*duration
            a(i)=0;
        elseif values(i)<=15*duration
            a(i)=amp*sin(2*pi* freq*values(i));
        elseif values(i)<=16*duration
            a(i)=0;
        elseif values(i)<=17*duration
            a(i)=amp*sin(2*pi* freq*values(i));
        elseif values(i)<=18*duration
            a(i)=0;
        elseif values(i)<=19*duration
            a(i)=amp*sin(2*pi* freq*values(i));
        elseif values(i)<=20*duration
            a(i)=0;
        end
    end
    sound(a,fs);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function vectorout=cutvector(vectorin,listdirection,ignorelist)
%{
example:
x(sp,1:2), listdirection=1
x(1:2,sp), listdirection=2
%}
if listdirection==0
    if size(vectorin,1)>size(vectorin,2)
        listdirection=1;
    elseif size(vectorin,2)>size(vectorin,1)
        listdirection=2;
    else
        disp('vectorin is a square matrix!');
        pause;
    end
end
if listdirection==1
    vectorout=zeros(size(vectorin,1)-sum(ignorelist),size(vectorin,2));
elseif listdirection==2
    vectorout=zeros(size(vectorin,1),size(vectorin,2)-sum(ignorelist));
else
    disp('incorrect list direction input!');
    pause;
end
newnumbering=0;
for i=1:size(vectorin,listdirection)
    if ignorelist(i)
        continue;
    end
    newnumbering=newnumbering+1;
    if listdirection==1
        vectorout(newnumbering,:)=vectorin(i,:);
    elseif listdirection==2
        vectorout(:,newnumbering)=vectorin(:,i);
    else
        disp('incorrect list direction input!');
    end
end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function outputangle=reliableatan(deltax,deltay)
	if deltax==0
		if deltay==0
			outputangle=0;
		elseif deltay>0
			outputangle=pi/2;
		elseif deltay<0
			outputangle=-pi/2;
		end
	elseif deltax>0
		outputangle=atan(deltay/deltax);
	elseif deltay>0
		outputangle=atan(deltay/deltax)+pi;
	elseif deltay<0
		outputangle=atan(deltay/deltax)-pi;
	elseif deltay==0
		outputangle=pi;
	else
		disp('scenario not considered!');
		pause;
	end
	%outputangle=outputangle*180/pi;
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MinNum=FindMin(VectorIn)
    MinVal=VectorIn(1);
    MinNum=1;
    for i=2:length(VectorIn)
        if VectorIn(i)<MinVal
            MinVal=VectorIn(i);
            MinNum=i;
        end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MinNum=FindMinMatrix(MatrixIn)
    MinVal=MatrixIn(1,1);
    MinNum(2)=1;
	MinNum(1)=1;
    for i=1:size(MatrixIn,1)
		for j=1:size(MatrixIn,2)
			if MatrixIn(i,j)<MinVal
				MinVal=MatrixIn(i,j);
				MinNum(1)=i;
				MinNum(2)=j;
			end
		end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MaxNum=FindMax(VectorIn)
    MaxVal=VectorIn(1);
    MaxNum=1;
    for i=2:length(VectorIn)
        if VectorIn(i)>MaxVal
            MaxVal=VectorIn(i);
            MaxNum=i;
        end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [R U V] = poldecomp(F,UVrequest)
    %POLDECOMP  Performs the polar decomposition of a regular square matrix.
    %   [R U V] = POLDECOMP(F) factorizes a non-singular square matrix F such
    %   that F=R*U and F=V*R, where
    %   U and V are symmetric, positive definite matrices and
    %   R is a rotational matrix
    %
    %   See also EIG, DIAG, REPMAT


    % This kind of decomposition is often used in continuum mechanics so it is
    % convenient to comment the code that way. From now, we use the matrix 
    % formalism of tensors. C is the right Cauchy-Green deformation tensor, 
    % F is the deformation tensor, lambda is the stretch.

    % Check input
    [m n] = size(F);
    if m ~= n
        error('Matrix must be square.');
    end

    C = F'*F;
    [Q0 lambdasquare] = eig(C);
    lambda = sqrt(diag((lambdasquare))); % extract the components
    % Uinv is the inverse of U and is constructed with the help of Q0. Uinv is
    % produced in the same base as F not in the base of its eigenvectors.
    Uinv = repmat(1./lambda',size(F,1),1).*Q0*Q0';
    % Using the definition, R, U and V can now be calculated
    R = F*Uinv;
    if UVrequest==1
        U = R'*F;
        V = F*R';
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function TexttoPrint=PrintMatrixVectorized(MatrixInput,MatrixName,DisplayKah)
    TexttoPrint=[MatrixName '=['];
    for i=1:size(MatrixInput,1)
        if i>1
            TexttoPrint=[TexttoPrint ';'];
        end
        for j=1:size(MatrixInput,2)
            if j>1
                TexttoPrint=[TexttoPrint ','];
            end
            TexttoPrint=[TexttoPrint num2str(MatrixInput(i,j))];
        end
    end
    TexttoPrint=[TexttoPrint ']; det(' MatrixName ')=' num2str(det(MatrixInput))];
    if DisplayKah==1
        disp(TexttoPrint);
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function Result=CompareTexts(Text1,Text2)
    Result=0;
    if length(Text1)==length(Text2)
        if Text1==Text2
            Result=1;
        end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function TheVerdict=CloseEnough(val1,val2,val2tolerance,absoluteput1_relativeput2)
    if exist('absoluteput1_relativeput2')
    else
        absoluteput1_relativeput2=2;
    end
    if exist('val2tolerance')
    else
        val2tolerance=1e-10;
    end
    TheVerdict=0;
    if absoluteput1_relativeput2==1
        if val1>=val2-abs(val2tolerance/2) && val1<=val2+abs(val2tolerance/2)
            TheVerdict=1;
        end
    elseif absoluteput1_relativeput2==2
        if val2>0
            if val1>=val2*(1-abs(val2tolerance/2)) && val1<=val2*(1+abs(val2tolerance/2))
                TheVerdict=1;
            end
        else
            if val1<=val2*(1-abs(val2tolerance/2)) && val1>=val2*(1+abs(val2tolerance/2))
                TheVerdict=1;
            end
        end            
    else
        disp('wrong input!')
        pause
        1;
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [affectedvector sortedvector]=affectsort(toaffectvector,tosortvector,direction)
    %direction=0: ascending
    %direction=1: descending
    sortedvector=tosortvector;
    affectedvector=toaffectvector;
    
    if exist('direction')==0
        direction=0;
    end
    
    for j=1:length(tosortvector)^2
        allsorted=1;
        for i=1:length(tosortvector)-1
            if direction==0
                if sortedvector(i)>sortedvector(i+1)
                    allsorted=0;
                    dummy=sortedvector(i);
                    sortedvector(i)=sortedvector(i+1);
                    sortedvector(i+1)=dummy;
                    
                    dummy=affectedvector(i);
                    affectedvector(i)=affectedvector(i+1);
                    affectedvector(i+1)=dummy;
                end
            elseif direction==1
                if sortedvector(i)<sortedvector(i+1)
                    allsorted=0;
                    dummy=sortedvector(i);
                    sortedvector(i)=sortedvector(i+1);
                    sortedvector(i+1)=dummy;
                    
                    dummy=affectedvector(i);
                    affectedvector(i)=affectedvector(i+1);
                    affectedvector(i+1)=dummy;
                end
            else
                disp('direction input error!');
                pause;
                1;
            end
        end
        if allsorted
            break;
        end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function secspassed = clockallsec()
    dateinput=clock;
    month(1)=31;
    if mod(dateinput(1),4)==0
        month(2)=29;
    else
        month(2)=28;
    end
    month(3)=31;
    month(4)=30;
    month(5)=31;
    month(6)=30;
    month(7)=31;
    month(8)=31;
    month(9)=30;
    month(10)=31;
    month(11)=30;
    month(12)=31;

    dayspassed=floor((dateinput(1)-1)/4)*4*365.25+(dateinput(1)-1-floor((dateinput(1)-1)/4)*4)*365;
    for i=1:dateinput(2)-1
        dayspassed=dayspassed+month(i);
    end
    dayspassed=dayspassed+dateinput(3)-1;
    hourspassed=dayspassed*24+dateinput(4);
    minutespassed=hourspassed*60+dateinput(5);
    secspassed=minutespassed*60+dateinput(6);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function angletaken=gerhardangles(xstart,ystart,xtrial_global,ytrial_global)
    xtrial=xtrial_global-xstart;
    ytrial=ytrial_global-ystart;
    if ytrial<0 || ytrial>150
        angletaken=-inf;
        disp('wrong y trial! pausing...');
        pause;
        1;
        return
    end
    positions=[	3	6	11	13.5	18.5	22.5	27.5	35	42.3	47.5	60	87.5	101.5	107	112	118.3	122.5	;
        2.5	6.5	10.5	13.5	18.5	23	27.5	35	42.5	47.5	60.5	87.5	101.5	107	112	118.5	122.5	;
        2.5	6.5	10.5	13.5	18.5	23.5	28	35	42.5	47	59.5	87.8	101.5	107	112	119	122	;
        2.4	5.5	10	12.2	18.5	23.5	28.4	35.5	42.5	47.4	59.5	88.2	101.5	107.3	112.1	119.1	122.5	;
        1.8	5.5	9.5	12.5	18.1	23.1	28	35	42.5	47	59	88.5	101.5	107.3	112.5	118.6	122.5	;
        1.5	5.5	9.5	12.5	18	23.6	28	35	42	47	58.5	88.5	102	107.5	114	119	123	;
        1.5	6.5	9.8	13	18	23	27.7	35	42	47	58.5	89	102.5	107.7	114.6	119.4	123	;
        1.4	5.4	9.7	12.6	17.8	23.4	27.7	35	42.1	47	57.6	89.5	102.6	108	115.4	119.6	123.5	;
        1.2	5.3	9.7	12.8	17.7	22.6	28	34.8	41.6	46.8	57.5	89.5	103.5	108.4	115.5	120	123.8	;
        1	4.6	9.5	12.5	17.5	22.5	27.7	34.6	41.5	47	56.5	90.5	104	108.5	116.5	120.5	124.5	;
        1	4	9.5	12.5	17	22.5	27.5	34.5	41.5	47.2	55.5	91.4	104.5	108.7	116.6	121.5	126	;
        0.8	3.4	9.1	12.4	16.9	21.7	27.4	33.8	41.5	46.5	55.2	92.5	104.5	109.5	117	122	126.5	;
        -1	3.2	8.8	11.5	16.7	21.1	27.1	33.5	41.5	46.4	56	93.7	104.9	109.6	117.1	122.5	127	;
        -2	3.1	8.5	11.2	16.5	20.1	26.5	33	40.9	45.6	57.5	93.4	105	110.1	116.9	122.5	127.3	;
        -3	2.5	7.9	10.5	16.5	19.5	25	32.5	39.2	45.1	59	93.5	105.5	110.5	117.1	122.8	127.7	;
        -3.4	1.9	7.5	10.4	16.3	19.6	24.4	32.1	38	44.6	59.5	93.6	105.6	110.6	117.3	122.9	127.9	;
        -3.9	1.6	7.1	9.8	15.4	18.6	23.5	30.8	35.5	44.5	59.5	93.5	105.6	110.6	117	122.6	127.9	;
        -4.1	1	6.5	9.4	14.5	18	21.5	29	33.5	46.7	59.8	93.4	105.6	110.8	117.3	122.7	127.8	;
        -4.5	0.5	5.7	8.5	14	17.2	19.5	25.5	31.5	47.5	60	92.6	105.8	111.3	117.4	123	127.9	;
        -4.9	-0.6	4.6	8.4	13.1	16	17.8	22	28.5	47.9	60	92.1	105.9	111.4	117.5	123.5	127.9	;
        -5.2	-1.1	3.8	8	12	14	16.6	20	24.5	47.8	59.5	91.5	106.5	111	117.4	123.4	127.8	;
        -5.6	-1.7	2.8	7.4	10.5	12.5	14.5	16.8	19.8	47.6	59.4	91.1	106.5	110.5	117.1	123.5	127.8	;
        -5.7	-1.9	2.3	7	9.2	11.4	13.5	15.4	17.4	47.5	58.6	90.6	105.7	110.4	116.9	123.4	127.7	;
        -5.8	-2	1.6	7	9	10.6	12.8	14.5	15.8	46.4	58.8	90.6	105.6	110	116.6	123.2	127.6	;
        -5.9	-2	1.4	6.8	9.1	10.6	12.7	14.1	15.6	45.5	58.5	90.1	105.4	109.6	116.6	123	127.3	;
        -5.9	-2.1	1.5	6.6	9.9	11.8	13.5	14.6	16.4	44	59	89.6	104.8	109.1	116.5	123	127	;
        -5.9	-2.1	1.5	6.8	11.4	13.4	15.1	16.4	18.9	42.4	59.6	89.6	104.3	108.5	116.5	122.6	126.6	;
        -5.9	-2	1.6	7.4	12.4	15.1	17.2	22.5	35	45.1	60.5	89.5	104	108.1	116.4	122.1	126	;
        -5.8	-1.9	1.7	7.4	13.1	16.4	19.5	30.1	39.5	46.4	61	89.1	103.4	107.4	115.8	121.4	124.9	;
        -5.7	-1.9	1.8	7.7	14.4	18.4	22.6	34.1	42.4	48.3	61.5	88.9	102.9	107.5	115.4	120.8	124.5	;
        -5.6	-1.8	1.9	8	15.4	19.6	24.5	36.1	43.6	49.2	61.9	88.8	102.5	107.6	114.5	120.5	124.2	;
        -5.4	-1	2.6	9.1	16.6	21.4	27.5	37.8	45.2	51.1	62.6	88.1	101.7	107.6	113.6	120.4	124	;
        -5.1	-0.1	4.8	10.5	18.1	22.4	28.7	39.2	46	52.1	63.4	88.7	101.5	107.5	113.3	119.8	123.4	;
        -4.2	1.2	7.1	11.6	18.7	23.4	29.7	39.6	46.1	52.8	63.1	88.5	101.5	107.5	113.4	119.5	123.4	;
        -3.4	2.1	9.4	12.6	19.5	24.1	30.5	40	46.4	53	63	88.4	101.5	107.5	113.4	119.4	123	;
        -2.1	2.7	10	12.8	20	24.6	31.4	40.1	46.7	52.8	62.8	88.4	102.3	107.5	113.6	119.4	123.4	;
        -0.8	3.6	10.1	13.4	20.6	25.1	31.5	40.4	46.4	52.8	62.6	88.6	102.6	107.5	113.8	119.5	123.4	;
        0.9	4.1	10	13.7	20.7	25.4	31.5	40.4	46.4	52.5	62.4	89.6	102.8	107.5	114.1	119.5	123.5	;
        0.9	4.5	10	13.8	20.8	25.4	31.5	40	46.1	52.6	62.7	89.6	102.8	107.6	114.3	119.5	123.5	];

    verticals=[	0	...
        5	...
        10	...
        15	...
        20	...
        25	...
        30	...
        35	...
        40	...
        45	...
        50	...
        55	...
        60	...
        65	...
        70	...
        72.5	...
        75	...
        77.5	...
        80	...
        82.5	...
        85	...
        87.5	...
        90	...
        92.5	...
        95	...
        97.5	...
        100	...
        102.5	...
        105	...
        107.5	...
        110	...
        115	...
        120	...
        125	...
        130	...
        135	...
        140	...
        145	...
        150	];


    %xtrial=45;
    %ytrial=85;

    for i=1:length(verticals)-1
        if ((ytrial>=verticals(i) && ytrial<=verticals(i+1)) || (ytrial<=verticals(i) && ytrial>=verticals(i+1)))
            vernumberbefore=i;
            yextrafactor=(ytrial-verticals(vernumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
            break;
        end
    end
    for i=1:size(positions,2)-1
        xbefore=positions(vernumberbefore,i)+(ytrial-verticals(vernumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore))*(positions(vernumberbefore+1,i)-positions(vernumberbefore,i));
        xafter=positions(vernumberbefore,i+1)+(ytrial-verticals(vernumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore))*(positions(vernumberbefore+1,i+1)-positions(vernumberbefore,i+1));
        if i==1 && xtrial<xbefore
            oneovergradient=(positions(vernumberbefore+1,i)-positions(vernumberbefore,i))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
            angletaken=atan(1/oneovergradient);
            if angletaken<0
                angletaken=angletaken+pi;
            end
            break;
        elseif i==(size(positions,2)-1) && xtrial>xafter
            oneovergradient=(positions(vernumberbefore+1,i+1)-positions(vernumberbefore,i+1))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
            angletaken=atan(1/oneovergradient);
            if angletaken<0
                angletaken=angletaken+pi;
            end
            break;
        elseif ((xtrial>=xbefore && xtrial<=xafter) || (xtrial<=xbefore && xtrial>=xafter))
            hornumberbefore=i;
            xextrafactor=(xtrial-xbefore)/(xafter-xbefore);
            oneovergradientbefore=(positions(vernumberbefore+1,hornumberbefore)-positions(vernumberbefore,hornumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
            anglebefore=atan(1/oneovergradientbefore);
            if anglebefore<0
                anglebefore=anglebefore+pi;
            end
            oneovergradientafter=(positions(vernumberbefore+1,hornumberbefore+1)-positions(vernumberbefore,hornumberbefore+1))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
            angleafter=atan(1/oneovergradientafter);
            if angleafter<0
                angleafter=angleafter+pi;
            end
            angletaken=anglebefore+xextrafactor*(angleafter-anglebefore);
            break;
        end    
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function angletaken=gerhardanglesellipseonly(xtrial,ytrial,knot)
    %if ytrial<0 || ytrial>150
    %    angletaken=-inf;
    %    disp('wrong y trial! pausing...');
    %    pause;
    %    1;
    %    return
    %end
    knotnum=2;
    angletaken=mod(pi/2 + atan(((2*cos(knot(knotnum).theta)*(cos(knot(knotnum).theta)*(knot(knotnum).y - ytrial) - sin(knot(knotnum).theta)*(knot(knotnum).x - xtrial)))/knot(knotnum).ry^2 + (2*sin(knot(knotnum).theta)*(cos(knot(knotnum).theta)*(knot(knotnum).x - xtrial) + sin(knot(knotnum).theta)*(knot(knotnum).y - ytrial)))/knot(knotnum).rx^2)/((2*cos(knot(knotnum).theta)*(cos(knot(knotnum).theta)*(knot(knotnum).x - xtrial) + sin(knot(knotnum).theta)*(knot(knotnum).y - ytrial)))/knot(knotnum).rx^2 - (2*sin(knot(knotnum).theta)*(cos(knot(knotnum).theta)*(knot(knotnum).y - ytrial) - sin(knot(knotnum).theta)*(knot(knotnum).x - xtrial)))/knot(knotnum).ry^2)), pi);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function angletaken=gerhardanglescombined(xstart,ystart,xtrial_global,ytrial_global,knot,CasetoRun)
    xtrial=xtrial_global-xstart;
    ytrial=ytrial_global-ystart;
    if ytrial<0 || ytrial>150
        angletaken1=-inf;
        disp('wrong y trial! pausing...');
        pause;
        1;
        return
    end
    positions=[	3	6	11	13.5	18.5	22.5	27.5	35	42.3	47.5	60	87.5	101.5	107	112	118.3	122.5	;
        2.5	6.5	10.5	13.5	18.5	23	27.5	35	42.5	47.5	60.5	87.5	101.5	107	112	118.5	122.5	;
        2.5	6.5	10.5	13.5	18.5	23.5	28	35	42.5	47	59.5	87.8	101.5	107	112	119	122	;
        2.4	5.5	10	12.2	18.5	23.5	28.4	35.5	42.5	47.4	59.5	88.2	101.5	107.3	112.1	119.1	122.5	;
        1.8	5.5	9.5	12.5	18.1	23.1	28	35	42.5	47	59	88.5	101.5	107.3	112.5	118.6	122.5	;
        1.5	5.5	9.5	12.5	18	23.6	28	35	42	47	58.5	88.5	102	107.5	114	119	123	;
        1.5	6.5	9.8	13	18	23	27.7	35	42	47	58.5	89	102.5	107.7	114.6	119.4	123	;
        1.4	5.4	9.7	12.6	17.8	23.4	27.7	35	42.1	47	57.6	89.5	102.6	108	115.4	119.6	123.5	;
        1.2	5.3	9.7	12.8	17.7	22.6	28	34.8	41.6	46.8	57.5	89.5	103.5	108.4	115.5	120	123.8	;
        1	4.6	9.5	12.5	17.5	22.5	27.7	34.6	41.5	47	56.5	90.5	104	108.5	116.5	120.5	124.5	;
        1	4	9.5	12.5	17	22.5	27.5	34.5	41.5	47.2	55.5	91.4	104.5	108.7	116.6	121.5	126	;
        0.8	3.4	9.1	12.4	16.9	21.7	27.4	33.8	41.5	46.5	55.2	92.5	104.5	109.5	117	122	126.5	;
        -1	3.2	8.8	11.5	16.7	21.1	27.1	33.5	41.5	46.4	56	93.7	104.9	109.6	117.1	122.5	127	;
        -2	3.1	8.5	11.2	16.5	20.1	26.5	33	40.9	45.6	57.5	93.4	105	110.1	116.9	122.5	127.3	;
        -3	2.5	7.9	10.5	16.5	19.5	25	32.5	39.2	45.1	59	93.5	105.5	110.5	117.1	122.8	127.7	;
        -3.4	1.9	7.5	10.4	16.3	19.6	24.4	32.1	38	44.6	59.5	93.6	105.6	110.6	117.3	122.9	127.9	;
        -3.9	1.6	7.1	9.8	15.4	18.6	23.5	30.8	35.5	44.5	59.5	93.5	105.6	110.6	117	122.6	127.9	;
        -4.1	1	6.5	9.4	14.5	18	21.5	29	33.5	46.7	59.8	93.4	105.6	110.8	117.3	122.7	127.8	;
        -4.5	0.5	5.7	8.5	14	17.2	19.5	25.5	31.5	47.5	60	92.6	105.8	111.3	117.4	123	127.9	;
        -4.9	-0.6	4.6	8.4	13.1	16	17.8	22	28.5	47.9	60	92.1	105.9	111.4	117.5	123.5	127.9	;
        -5.2	-1.1	3.8	8	12	14	16.6	20	24.5	47.8	59.5	91.5	106.5	111	117.4	123.4	127.8	;
        -5.6	-1.7	2.8	7.4	10.5	12.5	14.5	16.8	19.8	47.6	59.4	91.1	106.5	110.5	117.1	123.5	127.8	;
        -5.7	-1.9	2.3	7	9.2	11.4	13.5	15.4	17.4	47.5	58.6	90.6	105.7	110.4	116.9	123.4	127.7	;
        -5.8	-2	1.6	7	9	10.6	12.8	14.5	15.8	46.4	58.8	90.6	105.6	110	116.6	123.2	127.6	;
        -5.9	-2	1.4	6.8	9.1	10.6	12.7	14.1	15.6	45.5	58.5	90.1	105.4	109.6	116.6	123	127.3	;
        -5.9	-2.1	1.5	6.6	9.9	11.8	13.5	14.6	16.4	44	59	89.6	104.8	109.1	116.5	123	127	;
        -5.9	-2.1	1.5	6.8	11.4	13.4	15.1	16.4	18.9	42.4	59.6	89.6	104.3	108.5	116.5	122.6	126.6	;
        -5.9	-2	1.6	7.4	12.4	15.1	17.2	22.5	35	45.1	60.5	89.5	104	108.1	116.4	122.1	126	;
        -5.8	-1.9	1.7	7.4	13.1	16.4	19.5	30.1	39.5	46.4	61	89.1	103.4	107.4	115.8	121.4	124.9	;
        -5.7	-1.9	1.8	7.7	14.4	18.4	22.6	34.1	42.4	48.3	61.5	88.9	102.9	107.5	115.4	120.8	124.5	;
        -5.6	-1.8	1.9	8	15.4	19.6	24.5	36.1	43.6	49.2	61.9	88.8	102.5	107.6	114.5	120.5	124.2	;
        -5.4	-1	2.6	9.1	16.6	21.4	27.5	37.8	45.2	51.1	62.6	88.1	101.7	107.6	113.6	120.4	124	;
        -5.1	-0.1	4.8	10.5	18.1	22.4	28.7	39.2	46	52.1	63.4	88.7	101.5	107.5	113.3	119.8	123.4	;
        -4.2	1.2	7.1	11.6	18.7	23.4	29.7	39.6	46.1	52.8	63.1	88.5	101.5	107.5	113.4	119.5	123.4	;
        -3.4	2.1	9.4	12.6	19.5	24.1	30.5	40	46.4	53	63	88.4	101.5	107.5	113.4	119.4	123	;
        -2.1	2.7	10	12.8	20	24.6	31.4	40.1	46.7	52.8	62.8	88.4	102.3	107.5	113.6	119.4	123.4	;
        -0.8	3.6	10.1	13.4	20.6	25.1	31.5	40.4	46.4	52.8	62.6	88.6	102.6	107.5	113.8	119.5	123.4	;
        0.9	4.1	10	13.7	20.7	25.4	31.5	40.4	46.4	52.5	62.4	89.6	102.8	107.5	114.1	119.5	123.5	;
        0.9	4.5	10	13.8	20.8	25.4	31.5	40	46.1	52.6	62.7	89.6	102.8	107.6	114.3	119.5	123.5	];

    verticals=[	0	...
        5	...
        10	...
        15	...
        20	...
        25	...
        30	...
        35	...
        40	...
        45	...
        50	...
        55	...
        60	...
        65	...
        70	...
        72.5	...
        75	...
        77.5	...
        80	...
        82.5	...
        85	...
        87.5	...
        90	...
        92.5	...
        95	...
        97.5	...
        100	...
        102.5	...
        105	...
        107.5	...
        110	...
        115	...
        120	...
        125	...
        130	...
        135	...
        140	...
        145	...
        150	];


    %xtrial=45;
    %ytrial=85;

    for i=1:length(verticals)-1
        if ((ytrial>=verticals(i) && ytrial<=verticals(i+1)) || (ytrial<=verticals(i) && ytrial>=verticals(i+1)))
            vernumberbefore=i;
            yextrafactor=(ytrial-verticals(vernumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
            break;
        end
    end
    for i=1:size(positions,2)-1
        xbefore=positions(vernumberbefore,i)+(ytrial-verticals(vernumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore))*(positions(vernumberbefore+1,i)-positions(vernumberbefore,i));
        xafter=positions(vernumberbefore,i+1)+(ytrial-verticals(vernumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore))*(positions(vernumberbefore+1,i+1)-positions(vernumberbefore,i+1));
        if i==1 && xtrial<xbefore
            oneovergradient=(positions(vernumberbefore+1,i)-positions(vernumberbefore,i))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
            angletaken1=atan(1/oneovergradient);
            if angletaken1<0
                angletaken1=angletaken1+pi;
            end
            break;
        elseif i==(size(positions,2)-1) && xtrial>xafter
            oneovergradient=(positions(vernumberbefore+1,i+1)-positions(vernumberbefore,i+1))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
            angletaken1=atan(1/oneovergradient);
            if angletaken1<0
                angletaken1=angletaken1+pi;
            end
            break;
        elseif ((xtrial>=xbefore && xtrial<=xafter) || (xtrial<=xbefore && xtrial>=xafter))
            hornumberbefore=i;
            xextrafactor=(xtrial-xbefore)/(xafter-xbefore);
            oneovergradientbefore=(positions(vernumberbefore+1,hornumberbefore)-positions(vernumberbefore,hornumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
            anglebefore=atan(1/oneovergradientbefore);
            if anglebefore<0
                anglebefore=anglebefore+pi;
            end
            oneovergradientafter=(positions(vernumberbefore+1,hornumberbefore+1)-positions(vernumberbefore,hornumberbefore+1))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
            angleafter=atan(1/oneovergradientafter);
            if angleafter<0
                angleafter=angleafter+pi;
            end
            angletaken1=anglebefore+xextrafactor*(angleafter-anglebefore);
            break;
        end    
    end
    if CasetoRun==36 || CasetoRun==37 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63
        angletaken=angletaken1;
        for knotnum=1:2
            f=(cos(knot(knotnum).theta)*(knot(knotnum).x - xtrial_global) + sin(knot(knotnum).theta)*(knot(knotnum).y - ytrial_global))^2/knot(knotnum).rx^2 + (cos(knot(knotnum).theta)*(knot(knotnum).y - ytrial_global) - sin(knot(knotnum).theta)*(knot(knotnum).x - xtrial_global))^2/knot(knotnum).ry^2 - 1;
            angletaken2=mod(pi/2 + atan(((2*cos(knot(knotnum).theta)*(cos(knot(knotnum).theta)*(knot(knotnum).y - ytrial_global) - sin(knot(knotnum).theta)*(knot(knotnum).x - xtrial_global)))/knot(knotnum).ry^2 + (2*sin(knot(knotnum).theta)*(cos(knot(knotnum).theta)*(knot(knotnum).x - xtrial_global) + sin(knot(knotnum).theta)*(knot(knotnum).y - ytrial_global)))/knot(knotnum).rx^2)/((2*cos(knot(knotnum).theta)*(cos(knot(knotnum).theta)*(knot(knotnum).x - xtrial_global) + sin(knot(knotnum).theta)*(knot(knotnum).y - ytrial_global)))/knot(knotnum).rx^2 - (2*sin(knot(knotnum).theta)*(cos(knot(knotnum).theta)*(knot(knotnum).y - ytrial_global) - sin(knot(knotnum).theta)*(knot(knotnum).x - xtrial_global)))/knot(knotnum).ry^2)), pi);
            if knotnum==1
                flimit1=1;
                flimit2=5;
            elseif knotnum==2
                flimit1=1;
                flimit2=flimit1;
            end
                
            if f<flimit1
                angletaken=angletaken2;
            elseif f<flimit2
                anglefactor=(f-flimit1)/(flimit2-flimit1);
                angletaken=angletaken2*(1-anglefactor)+angletaken*anglefactor;
            end
        end
    else
        knotnum=1;
        f=(cos(knot(knotnum).theta)*(knot(knotnum).x - xtrial_global) + sin(knot(knotnum).theta)*(knot(knotnum).y - ytrial_global))^2/knot(knotnum).rx^2 + (cos(knot(knotnum).theta)*(knot(knotnum).y - ytrial_global) - sin(knot(knotnum).theta)*(knot(knotnum).x - xtrial_global))^2/knot(knotnum).ry^2 - 1;
        angletaken2=mod(pi/2 + atan(((2*cos(knot(knotnum).theta)*(cos(knot(knotnum).theta)*(knot(knotnum).y - ytrial_global) - sin(knot(knotnum).theta)*(knot(knotnum).x - xtrial_global)))/knot(knotnum).ry^2 + (2*sin(knot(knotnum).theta)*(cos(knot(knotnum).theta)*(knot(knotnum).x - xtrial_global) + sin(knot(knotnum).theta)*(knot(knotnum).y - ytrial_global)))/knot(knotnum).rx^2)/((2*cos(knot(knotnum).theta)*(cos(knot(knotnum).theta)*(knot(knotnum).x - xtrial_global) + sin(knot(knotnum).theta)*(knot(knotnum).y - ytrial_global)))/knot(knotnum).rx^2 - (2*sin(knot(knotnum).theta)*(cos(knot(knotnum).theta)*(knot(knotnum).y - ytrial_global) - sin(knot(knotnum).theta)*(knot(knotnum).x - xtrial_global)))/knot(knotnum).ry^2)), pi);
        flimit1=1;
        flimit2=5;
        if f<flimit1
            angletaken=angletaken2;
        elseif f<flimit2
            anglefactor=(f-flimit1)/(flimit2-flimit1);
            angletaken=angletaken2*(1-anglefactor)+angletaken1*anglefactor;
        else
            angletaken=angletaken1;
        end
    end

end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [connectivity] = CrackParticleClustering(x_sp,distancelimit,justcrackedlist)
	%--------------------------Determining cenection between particles--------------------%
	nspCount=length(justcrackedlist);
	nspconnectivity=cell(nspCount,1);
	nspconnectivity_temp=cell(nspCount,1);
	for i=1:nspCount
		for j=1:nspCount
			distance=x_sp(justcrackedlist(j),:)-x_sp(justcrackedlist(i),:);
			distancemag=sqrt(dot(distance,distance));
			if distancemag<distancelimit
				nspconnectivity{i}=[nspconnectivity{i} j];
			end
		end
	end
	%--------------------------------------------------------------------------------%
	%----------------------Forming velocity fields based on nspconnectivity---------------%
	stopcounter=0;                          %inital value for the counter calculation
	stop=0;                   %inital value for the counter
	while stop<1   %These calculation countiues until number of filled rows in nspconnectivity become unchanged.
		for i=1:length (nspconnectivity)                                                %Moving on the rows of nspconnectivity
			for j=1:length (nspconnectivity{i})                                           %Moving on the columns of nspconnectivity
				for k=i+1:length (nspconnectivity)                                        %Elements of next lines should be checked for finding element (i,j). Moving on the rows of nspconnectivity in next lines.
					m=1;                                                                %Elements of next lines should be checked for finding element (i,j). Moving on the columns of nspconnectivity in next lines. 
					while m<=length (nspconnectivity{k})                                  %This check can be stooped as soon as one element is found, since founding one conection is enough. While is used to easily stop this loop.

						if nspconnectivity{i}(j)<nspconnectivity{k}(m)               %If bigger than (i,j). Then there is no point in checking more.               
							m=length (nspconnectivity{k})+1;       
						elseif nspconnectivity{i}(j)>nspconnectivity{k}(m)                %If smaller than (i,j, then next one should be checked                                               %If not equal to (i,j)and smaller. Then go to next and check again.             
							m=m+1;                                                    
						elseif nspconnectivity{i}(j)==nspconnectivity{k}(m)               %If  equal to (i,j). This means that all particles on i and k are connected. Therefore, all particles of k will be moved to i. This will result in repeated particle on i which will be taken care of in the end of checking row i                     
							nspconnectivity{i}=[nspconnectivity{i} nspconnectivity{k}];   
							nspconnectivity{k}=[]; 
						end                
					end                        
				end
			end
			if ~isempty (nspconnectivity{i})   ==1       
				nspconnectivity{i}=unique(nspconnectivity{i}); %This will take care of repeated particle on row i
			end
		end
		%-------------While loop control------------%
		nspconnectivity=nspconnectivity(~cellfun('isempty',nspconnectivity));                  %Removing empty cells
		if stopcounter==length (nspconnectivity);                                      %If size of nspconnectivity is the same as the last loop. Then finish the while loop
			stop=1;
		else                                                                       %If not, then put the stopcounter equal to size of nspconnectivity. 
			stopcounter=length (nspconnectivity);
		end
		%-------------While loop control end------------%
	end
	
	connectivity=nspconnectivity;
	for i=1:length(nspconnectivity)
		for j=1:length(nspconnectivity{i})
			connectivity{i}(j)=justcrackedlist(nspconnectivity{i}(j));
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit,maplist]=Base3Mapping(TheFieldSplitBase3,CONNECTpn,maplist)
    ncrackpath=size(TheFieldSplitBase3,3);
    maplistcounter=size(maplist,1);
    TheFieldSplit=ones(size(TheFieldSplitBase3,1),size(TheFieldSplitBase3,2));
    for i=1:length(CONNECTpn)
        for nsp=1:length(CONNECTpn{i});
            sp=CONNECTpn{i}(nsp);
            matchfound=0;
            for imaplist=1:size(maplist,1);
                if sum(maplist(imaplist,1,:)==TheFieldSplitBase3(i,sp,:))==ncrackpath;
                    matchfound=1;
                    TheFieldSplit(i,sp)=imaplist;
                    break;
                end
            end
            if matchfound==0
                TheFieldSplit(i,sp)=size(maplist,1)+1;
                maplist(size(maplist,1)+1,1,:)=TheFieldSplitBase3(i,sp,:);
            end
        end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function integeroutput=integermapping(integerinput,integermapper)
    for i=1:length(integermapper)
        if integerinput==integermapper(i)
            integeroutput=i;
            break;
        end
        if i==length(integermapper)
            disp('integer mapping failed! code 1904201805');
        end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function newtensor=rotatetensorfromold(oldtensor,oldn1)
    oldn1=oldn1/sqrt(dot(oldn1,oldn1));
    
    %newn1=newn1/sqrt(dot(newn1,newn1));
    
    oldn13d=[oldn1(1) oldn1(2) 0];
    oldn23d=cross([0 0 1],oldn13d);
    oldn2=[oldn23d(1) oldn23d(2)];
    
    %newn13d=[newn1(1) newn1(2) 0];
    %newn23d=cross([0 0 1],newn13d);
    %newn2=[newn23d(1) newn23d(2)];
    
    a=[oldn1(1) oldn2(1);
       oldn1(2) oldn2(2)];
    
    newtensor=zeros(2,2);
    for i=1:2
        for j=1:2
            for m=1:2
                for n=1:2
                    newtensor(i,j)=newtensor(i,j)+a(i,m)*a(j,n)*oldtensor(m,n);
                end
            end
        end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function newtensor=rotatetensorfromoldtonew(oldtensor,oldn1,newn1)
    oldn1=oldn1/sqrt(dot(oldn1,oldn1));
    
    newn1=newn1/sqrt(dot(newn1,newn1));
    
    oldn13d=[oldn1(1) oldn1(2) 0];
    oldn23d=cross([0 0 1],oldn13d);
    oldn2=[oldn23d(1) oldn23d(2)];
    
    newn13d=[newn1(1) newn1(2) 0];
    newn23d=cross([0 0 1],newn13d);
    newn2=[newn23d(1) newn23d(2)];
    
    afromold=[oldn1(1) oldn2(1);
       oldn1(2) oldn2(2)];
    atonew=[newn1(1) newn1(2);
       newn2(1) newn2(2)];
    
    a=atonew*afromold;

    newtensor=zeros(2,2);
    for i=1:2
        for j=1:2
            for m=1:2
                for n=1:2
                    newtensor(i,j)=newtensor(i,j)+a(i,m)*a(j,n)*oldtensor(m,n);
                end
            end
        end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function newtensor=rotatetensortonew(oldtensor,newn1)
    %oldn1=oldn1/sqrt(dot(oldn1,oldn1));
    
    newn1=newn1/sqrt(dot(newn1,newn1));
    
    %oldn13d=[oldn1(1) oldn1(2) 0];
    %oldn23d=cross([0 0 1],oldn13d);
    %oldn2=[oldn23d(1) oldn23d(2)];
    
    newn13d=[newn1(1) newn1(2) 0];
    newn23d=cross([0 0 1],newn13d);
    newn2=[newn23d(1) newn23d(2)];
    
    %a=[oldn1(1) oldn2(1);
    %   oldn1(2) oldn2(2)];
    a=[newn1(1) newn1(2);
       newn2(1) newn2(2)];
    
    newtensor=zeros(2,2);
    for i=1:2
        for j=1:2
            for m=1:2
                for n=1:2
                    newtensor(i,j)=newtensor(i,j)+a(i,m)*a(j,n)*oldtensor(m,n);
                end
            end
        end
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%------------------------------------------------------------------------ START - ALTMANY EXPORT FIG - START ---------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [imageData, alpha] = export_fig(varargin) %#ok<*STRCL1>
%EXPORT_FIG  Exports figures in a publication-quality format
%
% Examples:
%   imageData = export_fig
%   [imageData, alpha] = export_fig
%   export_fig filename
%   export_fig filename -format1 -format2
%   export_fig ... -nocrop
%   export_fig ... -c[<val>,<val>,<val>,<val>]
%   export_fig ... -transparent
%   export_fig ... -native
%   export_fig ... -m<val>
%   export_fig ... -r<val>
%   export_fig ... -a<val>
%   export_fig ... -q<val>
%   export_fig ... -p<val>
%   export_fig ... -d<gs_option>
%   export_fig ... -depsc
%   export_fig ... -<renderer>
%   export_fig ... -<colorspace>
%   export_fig ... -append
%   export_fig ... -bookmark
%   export_fig ... -clipboard
%   export_fig ... -update
%   export_fig ... -nofontswap
%   export_fig ... -font_space <char>
%   export_fig ... -linecaps
%   export_fig ... -noinvert
%   export_fig(..., handle)
%
% This function saves a figure or single axes to one or more vector and/or
% bitmap file formats, and/or outputs a rasterized version to the workspace,
% with the following properties:
%   - Figure/axes reproduced as it appears on screen
%   - Cropped borders (optional)
%   - Embedded fonts (vector formats)
%   - Improved line and grid line styles
%   - Anti-aliased graphics (bitmap formats)
%   - Render images at native resolution (optional for bitmap formats)
%   - Transparent background supported (pdf, eps, png, tiff)
%   - Semi-transparent patch objects supported (png, tiff)
%   - RGB, CMYK or grayscale output (CMYK only with pdf, eps, tiff)
%   - Variable image compression, including lossless (pdf, eps, jpg)
%   - Optional rounded line-caps (pdf, eps)
%   - Optionally append to file (pdf, tiff)
%   - Vector formats: pdf, eps
%   - Bitmap formats: png, tiff, jpg, bmp, export to workspace
%
% This function is especially suited to exporting figures for use in
% publications and presentations, because of the high quality and
% portability of media produced.
%
% Note that the background color and figure dimensions are reproduced
% (the latter approximately, and ignoring cropping & magnification) in the
% output file. For transparent background (and semi-transparent patch
% objects), use the -transparent option or set the figure 'Color' property
% to 'none'. To make axes transparent set the axes 'Color' property to
% 'none'. PDF, EPS, TIF & PNG are the only formats that support a transparent
% background; only TIF & PNG formats support transparency of patch objects.
%
% The choice of renderer (opengl, zbuffer or painters) has a large impact
% on the quality of output. The default value (opengl for bitmaps, painters
% for vector formats) generally gives good results, but if you aren't
% satisfied then try another renderer.  Notes: 1) For vector formats (EPS,
% PDF), only painters generates vector graphics. 2) For bitmaps, only
% opengl can render transparent patch objects correctly. 3) For bitmaps,
% only painters will correctly scale line dash and dot lengths when
% magnifying or anti-aliasing. 4) Fonts may be substitued with Courier when
% using painters.
%
% When exporting to vector format (PDF & EPS) and bitmap format using the
% painters renderer, this function requires that ghostscript is installed
% on your system. You can download this from:
%   http://www.ghostscript.com
% When exporting to eps it additionally requires pdftops, from the Xpdf
% suite of functions. You can download this from: http://xpdfreader.com
%
% Inputs:
%   filename - string containing the name (optionally including full or
%              relative path) of the file the figure is to be saved as. If
%              a path is not specified, the figure is saved in the current
%              directory. If no name and no output arguments are specified,
%              the default name, 'export_fig_out', is used. If neither a
%              file extension nor a format are specified, a ".png" is added
%              and the figure saved in that format.
%   -format1, -format2, etc. - strings containing the extensions of the
%                              file formats the figure is to be saved as.
%                              Valid options are: '-pdf', '-eps', '-png',
%                              '-tif', '-jpg' and '-bmp'. All combinations
%                              of formats are valid.
%   -nocrop - option indicating that the borders of the output are not to
%             be cropped.
%   -c[<val>,<val>,<val>,<val>] - option indicating crop amounts. Must be
%             a 4-element vector of numeric values: [top,right,bottom,left]
%             where NaN/Inf indicate auto-cropping, 0 means no cropping,
%             and any other value mean cropping in pixel amounts.
%   -transparent - option indicating that the figure background is to be
%                  made transparent (png, pdf, tif and eps output only).
%   -m<val> - option where val indicates the factor to magnify the
%             on-screen figure pixel dimensions by when generating bitmap
%             outputs (does not affect vector formats). Default: '-m1'.
%   -r<val> - option val indicates the resolution (in pixels per inch) to
%             export bitmap and vector outputs at, keeping the dimensions
%             of the on-screen figure. Default: '-r864' (for vector output
%             only). Note that the -m option overides the -r option for
%             bitmap outputs only.
%   -native - option indicating that the output resolution (when outputting
%             a bitmap format) should be such that the vertical resolution
%             of the first suitable image found in the figure is at the
%             native resolution of that image. To specify a particular
%             image to use, give it the tag 'export_fig_native'. Notes:
%             This overrides any value set with the -m and -r options. It
%             also assumes that the image is displayed front-to-parallel
%             with the screen. The output resolution is approximate and
%             should not be relied upon. Anti-aliasing can have adverse
%             effects on image quality (disable with the -a1 option).
%   -a1, -a2, -a3, -a4 - option indicating the amount of anti-aliasing to
%                        use for bitmap outputs. '-a1' means no anti-
%                        aliasing; '-a4' is the maximum amount (default).
%   -<renderer> - option to force a particular renderer (painters, opengl or
%                 zbuffer). Default value: opengl for bitmap formats or
%                 figures with patches and/or transparent annotations;
%                 painters for vector formats without patches/transparencies.
%   -<colorspace> - option indicating which colorspace color figures should
%                   be saved in: RGB (default), CMYK or gray. CMYK is only
%                   supported in pdf, eps and tiff output.
%   -q<val> - option to vary bitmap image quality (in pdf, eps and jpg
%             files only).  Larger val, in the range 0-100, gives higher
%             quality/lower compression. val > 100 gives lossless
%             compression. Default: '-q95' for jpg, ghostscript prepress
%             default for pdf & eps. Note: lossless compression can
%             sometimes give a smaller file size than the default lossy
%             compression, depending on the type of images.
%   -p<val> - option to pad a border of width val to exported files, where
%             val is either a relative size with respect to cropped image
%             size (i.e. p=0.01 adds a 1% border). For EPS & PDF formats,
%             val can also be integer in units of 1/72" points (abs(val)>1).
%             val can be positive (padding) or negative (extra cropping).
%             If used, the -nocrop flag will be ignored, i.e. the image will
%             always be cropped and then padded. Default: 0 (i.e. no padding).
%   -append - option indicating that if the file (pdfs only) already
%             exists, the figure is to be appended as a new page, instead
%             of being overwritten (default).
%   -bookmark - option to indicate that a bookmark with the name of the
%               figure is to be created in the output file (pdf only).
%   -clipboard - option to save output as an image on the system clipboard.
%                Note: background transparency is not preserved in clipboard
%   -d<gs_option> - option to indicate a ghostscript setting. For example,
%                   -dMaxBitmap=0 or -dNoOutputFonts (Ghostscript 9.15+).
%   -depsc -  option to use EPS level-3 rather than the default level-2 print
%             device. This solves some bugs with Matlab's default -depsc2 device
%             such as discolored subplot lines on images (vector formats only).
%   -update - option to download and install the latest version of export_fig
%   -nofontswap - option to avoid font swapping. Font swapping is automatically
%             done in vector formats (only): 11 standard Matlab fonts are
%             replaced by the original figure fonts. This option prevents this.
%   -font_space <char> - option to set a spacer character for font-names that
%             contain spaces, used by EPS/PDF. Default: ''
%   -linecaps - option to create rounded line-caps (vector formats only).
%   -noinvert - option to avoid setting figure's InvertHardcopy property to
%             'off' during output (this solves some problems of empty outputs).
%   handle -  The handle of the figure, axes or uipanels (can be an array of
%             handles, but the objects must be in the same figure) to be
%             saved. Default: gcf.
%
% Outputs:
%   imageData - MxNxC uint8 image array of the exported image.
%   alpha     - MxN single array of alphamatte values in the range [0,1],
%               for the case when the background is transparent.
%
%   Some helpful examples and tips can be found at:
%      https://github.com/altmany/export_fig
%
%   See also PRINT, SAVEAS, ScreenCapture (on the Matlab File Exchange)

%{
% Copyright (C) Oliver Woodford 2008-2014, Yair Altman 2015-

% The idea of using ghostscript is inspired by Peder Axensten's SAVEFIG
% (fex id: 10889) which is itself inspired by EPS2PDF (fex id: 5782).
% The idea for using pdftops came from the MATLAB newsgroup (id: 168171).
% The idea of editing the EPS file to change line styles comes from Jiro
% Doke's FIXPSLINESTYLE (fex id: 17928).
% The idea of changing dash length with line width came from comments on
% fex id: 5743, but the implementation is mine :)
% The idea of anti-aliasing bitmaps came from Anders Brun's MYAA (fex id:
% 20979).
% The idea of appending figures in pdfs came from Matt C in comments on the
% FEX (id: 23629)

% Thanks to Roland Martin for pointing out the colour MATLAB
% bug/feature with colorbar axes and transparent backgrounds.
% Thanks also to Andrew Matthews for describing a bug to do with the figure
% size changing in -nodisplay mode. I couldn't reproduce it, but included a
% fix anyway.
% Thanks to Tammy Threadgill for reporting a bug where an axes is not
% isolated from gui objects.
%}
%{
% 23/02/12: Ensure that axes limits don't change during printing
% 14/03/12: Fix bug in fixing the axes limits (thanks to Tobias Lamour for reporting it).
% 02/05/12: Incorporate patch of Petr Nechaev (many thanks), enabling bookmarking of figures in pdf files.
% 09/05/12: Incorporate patch of Arcelia Arrieta (many thanks), to keep tick marks fixed.
% 12/12/12: Add support for isolating uipanels. Thanks to michael for suggesting it.
% 25/09/13: Add support for changing resolution in vector formats. Thanks to Jan Jaap Meijer for suggesting it.
% 07/05/14: Add support for '~' at start of path. Thanks to Sally Warner for suggesting it.
% 24/02/15: Fix Matlab R2014b bug (issue #34): plot markers are not displayed when ZLimMode='manual'
% 25/02/15: Fix issue #4 (using HG2 on R2014a and earlier)
% 25/02/15: Fix issue #21 (bold TeX axes labels/titles in R2014b)
% 26/02/15: If temp dir is not writable, use the user-specified folder for temporary EPS/PDF files (Javier Paredes)
% 27/02/15: Modified repository URL from github.com/ojwoodford to /altmany
%           Indented main function
%           Added top-level try-catch block to display useful workarounds
% 28/02/15: Enable users to specify optional ghostscript options (issue #36)
% 06/03/15: Improved image padding & cropping thanks to Oscar Hartogensis
% 26/03/15: Fixed issue #49 (bug with transparent grayscale images); fixed out-of-memory issue
% 26/03/15: Fixed issue #42: non-normalized annotations on HG1
% 26/03/15: Fixed issue #46: Ghostscript crash if figure units <> pixels
% 27/03/15: Fixed issue #39: bad export of transparent annotations/patches
% 28/03/15: Fixed issue #50: error on some Matlab versions with the fix for issue #42
% 29/03/15: Fixed issue #33: bugs in Matlab's print() function with -cmyk
% 29/03/15: Improved processing of input args (accept space between param name & value, related to issue #51)
% 30/03/15: When exporting *.fig files, then saveas *.fig if figure is open, otherwise export the specified fig file
% 30/03/15: Fixed edge case bug introduced yesterday (commit #ae1755bd2e11dc4e99b95a7681f6e211b3fa9358)
% 09/04/15: Consolidated header comment sections; initialize output vars only if requested (nargout>0)
% 14/04/15: Workaround for issue #45: lines in image subplots are exported in invalid color
% 15/04/15: Fixed edge-case in parsing input parameters; fixed help section to show the -depsc option (issue #45)
% 21/04/15: Bug fix: Ghostscript croaks on % chars in output PDF file (reported by Sven on FEX page, 15-Jul-2014)
% 22/04/15: Bug fix: Pdftops croaks on relative paths (reported by Tintin Milou on FEX page, 19-Jan-2015)
% 04/05/15: Merged fix #63 (Kevin Mattheus Moerman): prevent tick-label changes during export
% 07/05/15: Partial fix for issue #65: PDF export used painters rather than opengl renderer (thanks Nguyenr)
% 08/05/15: Fixed issue #65: bad PDF append since commit #e9f3cdf 21/04/15 (thanks Robert Nguyen)
% 12/05/15: Fixed issue #67: exponent labels cropped in export, since fix #63 (04/05/15)
% 28/05/15: Fixed issue #69: set non-bold label font only if the string contains symbols (\beta etc.), followup to issue #21
% 29/05/15: Added informative error message in case user requested SVG output (issue #72)
% 09/06/15: Fixed issue #58: -transparent removed anti-aliasing when exporting to PNG
% 19/06/15: Added -update option to download and install the latest version of export_fig
% 07/07/15: Added -nofontswap option to avoid font-swapping in EPS/PDF
% 16/07/15: Fixed problem with anti-aliasing on old Matlab releases
% 11/09/15: Fixed issue #103: magnification must never become negative; also fixed reported error msg in parsing input params
% 26/09/15: Alert if trying to export transparent patches/areas to non-PNG outputs (issue #108)
% 04/10/15: Do not suggest workarounds for certain errors that have already been handled previously
% 01/11/15: Fixed issue #112: use same renderer in print2eps as export_fig (thanks to Jess Pestana Puerta)
% 10/11/15: Custom GS installation webpage for MacOS. Thanks to Andy Hueni via FEX
% 19/11/15: Fixed clipboard export in R2015b (thanks to Dan K via FEX)
% 21/02/16: Added -c option for indicating specific crop amounts (idea by Cedric Noordam on FEX)
% 08/05/16: Added message about possible error reason when groot.Units~=pixels (issue #149)
% 17/05/16: Fixed case of image YData containing more than 2 elements (issue #151)
% 08/08/16: Enabled exporting transparency to TIF, in addition to PNG/PDF (issue #168)
% 11/12/16: Added alert in case of error creating output PDF/EPS file (issue #179)
% 13/12/16: Minor fix to the commit for issue #179 from 2 days ago
% 22/03/17: Fixed issue #187: only set manual ticks when no exponent is present
% 09/04/17: Added -linecaps option (idea by Baron Finer, issue #192)
% 15/09/17: Fixed issue #205: incorrect tick-labels when Ticks number don't match the TickLabels number
% 15/09/17: Fixed issue #210: initialize alpha map to ones instead of zeros when -transparent is not used
% 18/09/17: Added -font_space option to replace font-name spaces in EPS/PDF (workaround for issue #194)
% 18/09/17: Added -noinvert option to solve some export problems with some graphic cards (workaround for issue #197)
% 08/11/17: Fixed issue #220: axes exponent is removed in HG1 when TickMode is 'manual' (internal Matlab bug)
% 08/11/17: Fixed issue #221: alert if the requested folder does not exist
% 19/11/17: Workaround for issue #207: alert when trying to use transparent bgcolor with -opengl
% 29/11/17: Workaround for issue #206: warn if exporting PDF/EPS for a figure that contains an image
% 11/12/17: Fixed issue #230: use OpenGL renderer when exported image contains transparency (also see issue #206)
% 30/01/18: Updated SVG message to point to https://github.com/kupiqu/plot2svg and display user-selected filename if available
% 27/02/18: Fixed issue #236: axes exponent cropped from output if on right-hand axes
% 29/05/18: Fixed issue #245: process "string" inputs just like 'char' inputs
% 13/08/18: Fixed issue #249: correct black axes color to off-black to avoid extra cropping with -transparent
% 27/08/18: Added a possible file-open reason in EPS/PDF write-error message (suggested by "craq" on FEX page)
% 22/09/18: Xpdf website changed to xpdfreader.com
% 23/09/18: Fixed issue #243: only set non-bold font (workaround for issue #69) in R2015b or earlier; warn if changing font
% 23/09/18: Workaround for issue #241: don't use -r864 in EPS/PDF outputs when -native is requested (solves black lines problem)
% 18/11/18: Issue #261: Added informative alert when trying to export a uifigure (which is not currently supported)
% 13/12/18: Issue #261: Fixed last commit for cases of specifying axes/panel handle as input, rather than a figure handle
%}

    if nargout
        [imageData, alpha] = deal([]);
    end
    hadError = false;
    displaySuggestedWorkarounds = true;

    % Ensure the figure is rendered correctly _now_ so that properties like axes limits are up-to-date
    drawnow;
    pause(0.05);  % this solves timing issues with Java Swing's EDT (http://undocumentedmatlab.com/blog/solving-a-matlab-hang-problem)

    % Parse the input arguments
    fig = get(0, 'CurrentFigure');
    [fig, options] = parse_args(nargout, fig, varargin{:});

    % Ensure that we have a figure handle
    if isequal(fig,-1)
        return;  % silent bail-out
    elseif isempty(fig)
        error('No figure found');
    else
        oldWarn = warning('off','MATLAB:HandleGraphics:ObsoletedProperty:JavaFrame');
        try jf = get(handle(ancestor(fig,'figure')),'JavaFrame'); catch, jf=1; end
        warning(oldWarn);
        if isempty(jf)
            error('Figures created using the uifigure command or App Designer are not supported by export_fig. See <a href="https://github.com/altmany/export_fig/issues/261">issue #261</a> for details.');
        end
    end

    % Isolate the subplot, if it is one
    cls = all(ismember(get(fig, 'Type'), {'axes', 'uipanel'}));
    if cls
        % Given handles of one or more axes, so isolate them from the rest
        fig = isolate_axes(fig);
    else
        % Check we have a figure
        if ~isequal(get(fig, 'Type'), 'figure')
            error('Handle must be that of a figure, axes or uipanel');
        end
        % Get the old InvertHardcopy mode
        old_mode = get(fig, 'InvertHardcopy');
    end

    % Hack the font units where necessary (due to a font rendering bug in print?).
    % This may not work perfectly in all cases.
    % Also it can change the figure layout if reverted, so use a copy.
    magnify = options.magnify * options.aa_factor;
    if isbitmap(options) && magnify ~= 1
        fontu = findall(fig, 'FontUnits', 'normalized');
        if ~isempty(fontu)
            % Some normalized font units found
            if ~cls
                fig = copyfig(fig);
                set(fig, 'Visible', 'off');
                fontu = findall(fig, 'FontUnits', 'normalized');
                cls = true;
            end
            set(fontu, 'FontUnits', 'points');
        end
    end

    try
        % MATLAB "feature": axes limits and tick marks can change when printing
        Hlims = findall(fig, 'Type', 'axes');
        if ~cls
            % Record the old axes limit and tick modes
            Xlims = make_cell(get(Hlims, 'XLimMode'));
            Ylims = make_cell(get(Hlims, 'YLimMode'));
            Zlims = make_cell(get(Hlims, 'ZLimMode'));
            Xtick = make_cell(get(Hlims, 'XTickMode'));
            Ytick = make_cell(get(Hlims, 'YTickMode'));
            Ztick = make_cell(get(Hlims, 'ZTickMode'));
            Xlabel = make_cell(get(Hlims, 'XTickLabelMode')); 
            Ylabel = make_cell(get(Hlims, 'YTickLabelMode')); 
            Zlabel = make_cell(get(Hlims, 'ZTickLabelMode')); 
        end

        % Set all axes limit and tick modes to manual, so the limits and ticks can't change
        % Fix Matlab R2014b bug (issue #34): plot markers are not displayed when ZLimMode='manual'
        set(Hlims, 'XLimMode', 'manual', 'YLimMode', 'manual');
        set_tick_mode(Hlims, 'X');
        set_tick_mode(Hlims, 'Y');
        if ~using_hg2(fig)
            set(Hlims,'ZLimMode', 'manual');
            set_tick_mode(Hlims, 'Z');
        end
    catch
        % ignore - fix issue #4 (using HG2 on R2014a and earlier)
    end

    % Fix issue #21 (bold TeX axes labels/titles in R2014b when exporting to EPS/PDF)
    try
        if using_hg2(fig) && isvector(options)
            % Set the FontWeight of axes labels/titles to 'normal'
            % Fix issue #69: set non-bold font only if the string contains symbols (\beta etc.)
            % Issue #243: only set non-bold font (workaround for issue #69) in R2015b or earlier
            try isPreR2016a = verLessThan('matlab','8.7'); catch, isPreR2016a = true; end
            if isPreR2016a
                texLabels = findall(fig, 'type','text', 'FontWeight','bold');
                symbolIdx = ~cellfun('isempty',strfind({texLabels.String},'\'));
                if ~isempty(symbolIdx)
                    set(texLabels(symbolIdx), 'FontWeight','normal');
                    warning('export_fig:BoldTexLabels', 'Bold labels with Tex symbols converted into non-bold in export_fig (fix for issue #69)');
                end
            end
        end
    catch
        % ignore
    end

    % Fix issue #42: non-normalized annotations on HG1 (internal Matlab bug)
    annotationHandles = [];
    try
        if ~using_hg2(fig)
            annotationHandles = findall(fig,'Type','hggroup','-and','-property','Units','-and','-not','Units','norm');
            try  % suggested by Jess Pestana Puerta (jespestana) 30/9/2015
                originalUnits = get(annotationHandles,'Units');
                set(annotationHandles,'Units','norm');
            catch
            end
        end
    catch
        % should never happen, but ignore in any case - issue #50
    end

    % Fix issue #46: Ghostscript crash if figure units <> pixels
    oldFigUnits = get(fig,'Units');
    set(fig,'Units','pixels');

    % Set to print exactly what is there
    if options.invert_hardcopy
        try set(fig, 'InvertHardcopy', 'off'); catch, end  % fail silently in uifigures
    end

    % Set the renderer
    switch options.renderer
        case 1
            renderer = '-opengl';
        case 2
            renderer = '-zbuffer';
        case 3
            renderer = '-painters';
        otherwise
            renderer = '-opengl'; % Default for bitmaps
    end

    hImages = findall(fig,'type','image');

    % Handle transparent patches
    hasTransparency = ~isempty(findall(fig,'-property','FaceAlpha','-and','-not','FaceAlpha',1));
    hasPatches      = ~isempty(findall(fig,'type','patch'));
    if hasTransparency
        % Alert if trying to export transparent patches/areas to non-supported outputs (issue #108)
        % http://www.mathworks.com/matlabcentral/answers/265265-can-export_fig-or-else-draw-vector-graphics-with-transparent-surfaces
        % TODO - use transparency when exporting to PDF by not passing via print2eps
        msg = 'export_fig currently supports transparent patches/areas only in PNG output. ';
        if options.pdf
            warning('export_fig:transparency', '%s\nTo export transparent patches/areas to PDF, use the print command:\n print(gcf, ''-dpdf'', ''%s.pdf'');', msg, options.name);
        elseif ~options.png && ~options.tif  % issue #168
            warning('export_fig:transparency', '%s\nTo export the transparency correctly, try using the ScreenCapture utility on the Matlab File Exchange: http://bit.ly/1QFrBip', msg);
        end
    elseif ~isempty(hImages)
        % Fix for issue #230: use OpenGL renderer when exported image contains transparency
        for idx = 1 : numel(hImages)
            cdata = get(hImages(idx),'CData');
            if any(isnan(cdata(:)))
                hasTransparency = true;
                break
            end
        end
    end

    try
        % Do the bitmap formats first
        if isbitmap(options)
            if abs(options.bb_padding) > 1
                displaySuggestedWorkarounds = false;
                error('For bitmap output (png,jpg,tif,bmp) the padding value (-p) must be between -1<p<1')
            end
            % Get the background colour
            if options.transparent && (options.png || options.alpha)
                % Get out an alpha channel
                % MATLAB "feature": black colorbar axes can change to white and vice versa!
                hCB = findall(fig, 'Type','axes', 'Tag','Colorbar');
                if isempty(hCB)
                    yCol = [];
                    xCol = [];
                else
                    yCol = get(hCB, 'YColor');
                    xCol = get(hCB, 'XColor');
                    if iscell(yCol)
                        yCol = cell2mat(yCol);
                        xCol = cell2mat(xCol);
                    end
                    yCol = sum(yCol, 2);
                    xCol = sum(xCol, 2);
                end
                % MATLAB "feature": apparently figure size can change when changing
                % colour in -nodisplay mode
                pos = get(fig, 'Position');
                % Set the background colour to black, and set size in case it was
                % changed internally
                tcol = get(fig, 'Color');
                set(fig, 'Color', 'k', 'Position', pos);
                % Correct the colorbar axes colours
                set(hCB(yCol==0), 'YColor', [0 0 0]);
                set(hCB(xCol==0), 'XColor', [0 0 0]);
                % Correct black axes color to off-black (issue #249)
                hAxes = findall(fig, 'Type','axes');
                hXs = fixBlackAxle(hAxes, 'XColor');
                hYs = fixBlackAxle(hAxes, 'YColor');
                hZs = fixBlackAxle(hAxes, 'ZColor');

                % The following code might cause out-of-memory errors
                try
                    % Print large version to array
                    B = print2array(fig, magnify, renderer);
                    % Downscale the image
                    B = downsize(single(B), options.aa_factor);
                catch
                    % This is more conservative in memory, but kills transparency (issue #58)
                    B = single(print2array(fig, magnify/options.aa_factor, renderer));
                end

                % Set background to white (and set size)
                set(fig, 'Color', 'w', 'Position', pos);
                % Correct the colorbar axes colours
                set(hCB(yCol==3), 'YColor', [1 1 1]);
                set(hCB(xCol==3), 'XColor', [1 1 1]);
                % Revert the black axes colors
                set(hXs, 'XColor', [0,0,0]);
                set(hYs, 'YColor', [0,0,0]);
                set(hZs, 'ZColor', [0,0,0]);

                % The following code might cause out-of-memory errors
                try
                    % Print large version to array
                    A = print2array(fig, magnify, renderer);
                    % Downscale the image
                    A = downsize(single(A), options.aa_factor);
                catch
                    % This is more conservative in memory, but kills transparency (issue #58)
                    A = single(print2array(fig, magnify/options.aa_factor, renderer));
                end

                % Set the background colour (and size) back to normal
                set(fig, 'Color', tcol, 'Position', pos);
                % Compute the alpha map
                alpha = round(sum(B - A, 3)) / (255 * 3) + 1;
                A = alpha;
                A(A==0) = 1;
                A = B ./ A(:,:,[1 1 1]);
                clear B
                % Convert to greyscale
                if options.colourspace == 2
                    A = rgb2grey(A);
                end
                A = uint8(A);
                % Crop the background
                if options.crop
                    %[alpha, v] = crop_borders(alpha, 0, 1, options.crop_amounts);
                    %A = A(v(1):v(2),v(3):v(4),:);
                    [alpha, vA, vB] = crop_borders(alpha, 0, options.bb_padding, options.crop_amounts);
                    if ~any(isnan(vB)) % positive padding
                        B = repmat(uint8(zeros(1,1,size(A,3))),size(alpha));
                        B(vB(1):vB(2), vB(3):vB(4), :) = A(vA(1):vA(2), vA(3):vA(4), :); % ADDED BY OH
                        A = B;
                    else  % negative padding
                        A = A(vA(1):vA(2), vA(3):vA(4), :);
                    end
                end
                if options.png
                    % Compute the resolution
                    res = options.magnify * get(0, 'ScreenPixelsPerInch') / 25.4e-3;
                    % Save the png
                    imwrite(A, [options.name '.png'], 'Alpha', double(alpha), 'ResolutionUnit', 'meter', 'XResolution', res, 'YResolution', res);
                    % Clear the png bit
                    options.png = false;
                end
                % Return only one channel for greyscale
                if isbitmap(options)
                    A = check_greyscale(A);
                end
                if options.alpha
                    % Store the image
                    imageData = A;
                    % Clear the alpha bit
                    options.alpha = false;
                end
                % Get the non-alpha image
                if isbitmap(options)
                    alph = alpha(:,:,ones(1, size(A, 3)));
                    A = uint8(single(A) .* alph + 255 * (1 - alph));
                    clear alph
                end
                if options.im
                    % Store the new image
                    imageData = A;
                end
            else
                % Print large version to array
                if options.transparent
                    % MATLAB "feature": apparently figure size can change when changing
                    % colour in -nodisplay mode
                    pos = get(fig, 'Position');
                    tcol = get(fig, 'Color');
                    set(fig, 'Color', 'w', 'Position', pos);
                    A = print2array(fig, magnify, renderer);
                    set(fig, 'Color', tcol, 'Position', pos);
                    tcol = 255;
                else
                    [A, tcol] = print2array(fig, magnify, renderer);
                end
                % Crop the background
                if options.crop
                    A = crop_borders(A, tcol, options.bb_padding, options.crop_amounts);
                end
                % Downscale the image
                A = downsize(A, options.aa_factor);
                if options.colourspace == 2
                    % Convert to greyscale
                    A = rgb2grey(A);
                else
                    % Return only one channel for greyscale
                    A = check_greyscale(A);
                end
                % Outputs
                if options.im
                    imageData = A;
                end
                if options.alpha
                    imageData = A;
                    alpha = ones(size(A, 1), size(A, 2), 'single');
                end
            end
            % Save the images
            if options.png
                res = options.magnify * get(0, 'ScreenPixelsPerInch') / 25.4e-3;
                imwrite(A, [options.name '.png'], 'ResolutionUnit', 'meter', 'XResolution', res, 'YResolution', res);
            end
            if options.bmp
                imwrite(A, [options.name '.bmp']);
            end
            % Save jpeg with given quality
            if options.jpg
                quality = options.quality;
                if isempty(quality)
                    quality = 95;
                end
                if quality > 100
                    imwrite(A, [options.name '.jpg'], 'Mode', 'lossless');
                else
                    imwrite(A, [options.name '.jpg'], 'Quality', quality);
                end
            end
            % Save tif images in cmyk if wanted (and possible)
            if options.tif
                if options.colourspace == 1 && size(A, 3) == 3
                    A = double(255 - A);
                    K = min(A, [], 3);
                    K_ = 255 ./ max(255 - K, 1);
                    C = (A(:,:,1) - K) .* K_;
                    M = (A(:,:,2) - K) .* K_;
                    Y = (A(:,:,3) - K) .* K_;
                    A = uint8(cat(3, C, M, Y, K));
                    clear C M Y K K_
                end
                append_mode = {'overwrite', 'append'};
                imwrite(A, [options.name '.tif'], 'Resolution', options.magnify*get(0, 'ScreenPixelsPerInch'), 'WriteMode', append_mode{options.append+1});
            end
        end

        % Now do the vector formats
        if isvector(options)
            % Set the default renderer to painters
            if ~options.renderer
                if hasTransparency || hasPatches
                    % This is *MUCH* slower, but more accurate for patches and transparent annotations (issue #39)
                    renderer = '-opengl';
                else
                    renderer = '-painters';
                end
            end
            options.rendererStr = renderer;  % fix for issue #112
            % Generate some filenames
            tmp_nam = [tempname '.eps'];
            try
                % Ensure that the temp dir is writable (Javier Paredes 30/1/15)
                fid = fopen(tmp_nam,'w');
                fwrite(fid,1);
                fclose(fid);
                delete(tmp_nam);
                isTempDirOk = true;
            catch
                % Temp dir is not writable, so use the user-specified folder
                [dummy,fname,fext] = fileparts(tmp_nam); %#ok<ASGLU>
                fpath = fileparts(options.name);
                tmp_nam = fullfile(fpath,[fname fext]);
                isTempDirOk = false;
            end
            if isTempDirOk
                pdf_nam_tmp = [tempname '.pdf'];
            else
                pdf_nam_tmp = fullfile(fpath,[fname '.pdf']);
            end
            if options.pdf
                pdf_nam = [options.name '.pdf'];
                try copyfile(pdf_nam, pdf_nam_tmp, 'f'); catch, end  % fix for issue #65
            else
                pdf_nam = pdf_nam_tmp;
            end
            % Generate the options for print
            p2eArgs = {renderer};
            if ~isempty(options.resolution)  % issue #241
                p2eArgs{end+1} = sprintf('-r%d', options.resolution);
            end
            if options.colourspace == 1  % CMYK
                % Issue #33: due to internal bugs in Matlab's print() function, we can't use its -cmyk option
                %p2eArgs{end+1} = '-cmyk';
            end
            if ~options.crop
                % Issue #56: due to internal bugs in Matlab's print() function, we can't use its internal cropping mechanism,
                % therefore we always use '-loose' (in print2eps.m) and do our own cropping (in crop_borders)
                %p2eArgs{end+1} = '-loose';
            end
            if any(strcmpi(varargin,'-depsc'))
                % Issue #45: lines in image subplots are exported in invalid color.
                % The workaround is to use the -depsc parameter instead of the default -depsc2
                p2eArgs{end+1} = '-depsc';
            end
            try
                % Remove background if requested (issue #207)
                [hXs, hYs, hZs] = deal([]);
                if options.transparent %&& ~isequal(get(fig, 'Color'), 'none')
                    if options.renderer == 1  % OpenGL
                        warning('export_fig:openglTransparentBG', '-opengl sometimes fails to produce transparent backgrounds; try -painters instead');
                    else
                        originalBgColor = get(fig, 'Color');
                        set(fig,'Color','none');

                        % Correct black axes color to off-black (issue #249)
                        hAxes = findall(fig, 'Type','axes');
                        hXs = fixBlackAxle(hAxes, 'XColor');
                        hYs = fixBlackAxle(hAxes, 'YColor');
                        hZs = fixBlackAxle(hAxes, 'ZColor');
                    end
                end
                % Generate an eps
                print2eps(tmp_nam, fig, options, p2eArgs{:});
                % {
                % Remove the background, if desired
                if options.transparent %&& ~isequal(get(fig, 'Color'), 'none')
                    eps_remove_background(tmp_nam, 1 + using_hg2(fig));

                    % Revert the black axes colors
                    set(hXs, 'XColor', [0,0,0]);
                    set(hYs, 'YColor', [0,0,0]);
                    set(hZs, 'ZColor', [0,0,0]);
                end
                %}
                % Restore the figure's previous background color (if modified)
                try set(fig,'Color',originalBgColor); drawnow; catch, end
                % Fix colorspace to CMYK, if requested (workaround for issue #33)
                if options.colourspace == 1  % CMYK
                    % Issue #33: due to internal bugs in Matlab's print() function, we can't use its -cmyk option
                    change_rgb_to_cmyk(tmp_nam);
                end
                % Add a bookmark to the PDF if desired
                if options.bookmark
                    fig_nam = get(fig, 'Name');
                    if isempty(fig_nam)
                        warning('export_fig:EmptyBookmark', 'Bookmark requested for figure with no name. Bookmark will be empty.');
                    end
                    add_bookmark(tmp_nam, fig_nam);
                end
                % Generate a pdf
                eps2pdf(tmp_nam, pdf_nam_tmp, 1, options.append, options.colourspace==2, options.quality, options.gs_options);
                % Ghostscript croaks on % chars in the output PDF file, so use tempname and then rename the file
                try
                    % Rename the file (except if it is already the same)
                    % Abbie K's comment on the commit for issue #179 (#commitcomment-20173476)
                    if ~isequal(pdf_nam_tmp, pdf_nam)
                        movefile(pdf_nam_tmp, pdf_nam, 'f');
                    end
                catch
                    % Alert in case of error creating output PDF/EPS file (issue #179)
                    if exist(pdf_nam_tmp, 'file')
                        errMsg = ['Could not create ' pdf_nam ' - perhaps the folder does not exist, or you do not have write permissions, or the file is open in another application'];
                        error(errMsg);
                    else
                        error('Could not generate the intermediary EPS file.');
                    end
                end
            catch ex
                % Delete the eps
                delete(tmp_nam);
                rethrow(ex);
            end
            % Delete the eps
            delete(tmp_nam);
            if options.eps || options.linecaps
                try
                    % Generate an eps from the pdf
                    % since pdftops can't handle relative paths (e.g., '..\'), use a temp file
                    eps_nam_tmp = strrep(pdf_nam_tmp,'.pdf','.eps');
                    pdf2eps(pdf_nam, eps_nam_tmp);

                    % Issue #192: enable rounded line-caps
                    if options.linecaps
                        fstrm = read_write_entire_textfile(eps_nam_tmp);
                        fstrm = regexprep(fstrm, '[02] J', '1 J');
                        read_write_entire_textfile(eps_nam_tmp, fstrm);
                        if options.pdf
                            eps2pdf(eps_nam_tmp, pdf_nam, 1, options.append, options.colourspace==2, options.quality, options.gs_options);
                        end
                    end

                    if options.eps
                        movefile(eps_nam_tmp, [options.name '.eps'], 'f');
                    else  % if options.pdf
                        try delete(eps_nam_tmp); catch, end
                    end
                catch ex
                    if ~options.pdf
                        % Delete the pdf
                        delete(pdf_nam);
                    end
                    try delete(eps_nam_tmp); catch, end
                    rethrow(ex);
                end
                if ~options.pdf
                    % Delete the pdf
                    delete(pdf_nam);
                end
            end
            % Issue #206: warn if the figure contains an image
            if ~isempty(hImages) && strcmpi(renderer,'-opengl')  % see addendum to issue #206
                warnMsg = ['exporting images to PDF/EPS may result in blurry images on some viewers. ' ...
                           'If so, try to change viewer, or increase the image''s CData resolution, or use -opengl renderer, or export via the print function. ' ...
                           'See <a href="matlab:web(''https://github.com/altmany/export_fig/issues/206'',''-browser'');">issue #206</a> for details.'];
                warning('export_fig:pdf_eps:blurry_image', warnMsg);
            end
        end

        % Revert the figure or close it (if requested)
        if cls || options.closeFig
            % Close the created figure
            close(fig);
        else
            % Reset the hardcopy mode
            try set(fig, 'InvertHardcopy', old_mode); catch, end  % fail silently in uifigures
            % Reset the axes limit and tick modes
            for a = 1:numel(Hlims)
                try
                    set(Hlims(a), 'XLimMode', Xlims{a}, 'YLimMode', Ylims{a}, 'ZLimMode', Zlims{a},... 
                                  'XTickMode', Xtick{a}, 'YTickMode', Ytick{a}, 'ZTickMode', Ztick{a},...
                                  'XTickLabelMode', Xlabel{a}, 'YTickLabelMode', Ylabel{a}, 'ZTickLabelMode', Zlabel{a}); 
                catch
                    % ignore - fix issue #4 (using HG2 on R2014a and earlier)
                end
            end
            % Revert the tex-labels font weights
            try set(texLabels, 'FontWeight','bold'); catch, end
            % Revert annotation units
            for handleIdx = 1 : numel(annotationHandles)
                try
                    oldUnits = originalUnits{handleIdx};
                catch
                    oldUnits = originalUnits;
                end
                try set(annotationHandles(handleIdx),'Units',oldUnits); catch, end
            end
            % Revert figure units
            set(fig,'Units',oldFigUnits);
        end

        % Output to clipboard (if requested)
        if options.clipboard
            % Delete the output file if unchanged from the default name ('export_fig_out.png')
            if strcmpi(options.name,'export_fig_out')
                try
                    fileInfo = dir('export_fig_out.png');
                    if ~isempty(fileInfo)
                        timediff = now - fileInfo.datenum;
                        ONE_SEC = 1/24/60/60;
                        if timediff < ONE_SEC
                            delete('export_fig_out.png');
                        end
                    end
                catch
                    % never mind...
                end
            end

            % Save the image in the system clipboard
            % credit: Jiro Doke's IMCLIPBOARD: http://www.mathworks.com/matlabcentral/fileexchange/28708-imclipboard
            try
                error(javachk('awt', 'export_fig -clipboard output'));
            catch
                warning('export_fig:clipboardJava', 'export_fig -clipboard output failed: requires Java to work');
                return;
            end
            try
                % Import necessary Java classes
                import java.awt.Toolkit
                import java.awt.image.BufferedImage
                import java.awt.datatransfer.DataFlavor

                % Get System Clipboard object (java.awt.Toolkit)
                cb = Toolkit.getDefaultToolkit.getSystemClipboard();

                % Add java class (ImageSelection) to the path
                if ~exist('ImageSelection', 'class')
                    javaaddpath(fileparts(which(mfilename)), '-end');
                end

                % Get image size
                ht = size(imageData, 1);
                wd = size(imageData, 2);

                % Convert to Blue-Green-Red format
                try
                    imageData2 = imageData(:, :, [3 2 1]);
                catch
                    % Probably gray-scaled image (2D, without the 3rd [RGB] dimension)
                    imageData2 = imageData(:, :, [1 1 1]);
                end

                % Convert to 3xWxH format
                imageData2 = permute(imageData2, [3, 2, 1]);

                % Append Alpha data (unused - transparency is not supported in clipboard copy)
                alphaData2 = uint8(permute(255*alpha,[3,2,1])); %=255*ones(1,wd,ht,'uint8')
                imageData2 = cat(1, imageData2, alphaData2);

                % Create image buffer
                imBuffer = BufferedImage(wd, ht, BufferedImage.TYPE_INT_RGB);
                imBuffer.setRGB(0, 0, wd, ht, typecast(imageData2(:), 'int32'), 0, wd);

                % Create ImageSelection object from the image buffer
                imSelection = ImageSelection(imBuffer);

                % Set clipboard content to the image
                cb.setContents(imSelection, []);
            catch
                warning('export_fig:clipboardFailed', 'export_fig -clipboard output failed: %s', lasterr); %#ok<LERR>
            end
        end

        % Don't output the data to console unless requested
        if ~nargout
            clear imageData alpha
        end
    catch err
        % Display possible workarounds before the error message
        if displaySuggestedWorkarounds && ~strcmpi(err.message,'export_fig error')
            if ~hadError,  fprintf(2, 'export_fig error. ');  end
            fprintf(2, 'Please ensure:\n');
            fprintf(2, '  that you are using the <a href="https://github.com/altmany/export_fig/archive/master.zip">latest version</a> of export_fig\n');
            if ismac
                fprintf(2, '  and that you have <a href="http://pages.uoregon.edu/koch">Ghostscript</a> installed\n');
            else
                fprintf(2, '  and that you have <a href="http://www.ghostscript.com">Ghostscript</a> installed\n');
            end
            try
                if options.eps
                    fprintf(2, '  and that you have <a href="http://xpdfreader.com/download.html">pdftops</a> installed\n');
                end
            catch
                % ignore - probably an error in parse_args
            end
            fprintf(2, '  and that you do not have <a href="matlab:which export_fig -all">multiple versions</a> of export_fig installed by mistake\n');
            fprintf(2, '  and that you did not made a mistake in the <a href="matlab:help export_fig">expected input arguments</a>\n');
            try
                % Alert per issue #149
                if ~strncmpi(get(0,'Units'),'pixel',5)
                    fprintf(2, '  or try to set groot''s Units property back to its default value of ''pixels'' (<a href="matlab:web(''https://github.com/altmany/export_fig/issues/149'',''-browser'');">details</a>)\n');
                end
            catch
                % ignore - maybe an old MAtlab release
            end
            fprintf(2, '\nIf the problem persists, then please <a href="https://github.com/altmany/export_fig/issues">report a new issue</a>.\n\n');
        end
        rethrow(err)
    end
end

function options = default_options()
    % Default options used by export_fig
    options = struct(...
        'name',         'export_fig_out', ...
        'crop',         true, ...
        'crop_amounts', nan(1,4), ...  % auto-crop all 4 image sides
        'transparent',  false, ...
        'renderer',     0, ...         % 0: default, 1: OpenGL, 2: ZBuffer, 3: Painters
        'pdf',          false, ...
        'eps',          false, ...
        'png',          false, ...
        'tif',          false, ...
        'jpg',          false, ...
        'bmp',          false, ...
        'clipboard',    false, ...
        'colourspace',  0, ...         % 0: RGB/gray, 1: CMYK, 2: gray
        'append',       false, ...
        'im',           false, ...
        'alpha',        false, ...
        'aa_factor',    0, ...
        'bb_padding',   0, ...
        'magnify',      [], ...
        'resolution',   [], ...
        'bookmark',     false, ...
        'closeFig',     false, ...
        'quality',      [], ...
        'update',       false, ...
        'fontswap',     true, ...
        'font_space',   '', ...
        'linecaps',     false, ...
        'invert_hardcopy', true, ...
        'gs_options',   {{}});
end

function [fig, options] = parse_args(nout, fig, varargin)
    % Parse the input arguments

    % Convert strings => chars
    varargin = cellfun(@str2char,varargin,'un',false);

    % Set the defaults
    native = false; % Set resolution to native of an image
    options = default_options();
    options.im =    (nout == 1);  % user requested imageData output
    options.alpha = (nout == 2);  % user requested alpha output

    % Go through the other arguments
    skipNext = false;
    for a = 1:nargin-2
        if skipNext
            skipNext = false;
            continue;
        end
        if all(ishandle(varargin{a}))
            fig = varargin{a};
        elseif ischar(varargin{a}) && ~isempty(varargin{a})
            if varargin{a}(1) == '-'
                switch lower(varargin{a}(2:end))
                    case 'nocrop'
                        options.crop = false;
                        options.crop_amounts = [0,0,0,0];
                    case {'trans', 'transparent'}
                        options.transparent = true;
                    case 'opengl'
                        options.renderer = 1;
                    case 'zbuffer'
                        options.renderer = 2;
                    case 'painters'
                        options.renderer = 3;
                    case 'pdf'
                        options.pdf = true;
                    case 'eps'
                        options.eps = true;
                    case 'png'
                        options.png = true;
                    case {'tif', 'tiff'}
                        options.tif = true;
                    case {'jpg', 'jpeg'}
                        options.jpg = true;
                    case 'bmp'
                        options.bmp = true;
                    case 'rgb'
                        options.colourspace = 0;
                    case 'cmyk'
                        options.colourspace = 1;
                    case {'gray', 'grey'}
                        options.colourspace = 2;
                    case {'a1', 'a2', 'a3', 'a4'}
                        options.aa_factor = str2double(varargin{a}(3));
                    case 'append'
                        options.append = true;
                    case 'bookmark'
                        options.bookmark = true;
                    case 'native'
                        native = true;
                    case 'clipboard'
                        options.clipboard = true;
                        options.im = true;
                        options.alpha = true;
                    case 'svg'
                        filename = strrep(options.name,'export_fig_out','filename');
                        msg = ['SVG output is not supported by export_fig. Use one of the following alternatives:\n' ...
                               '  1. saveas(gcf,''' filename '.svg'')\n' ...
                               '  2. plot2svg utility: https://github.com/kupiqu/plot2svg\n' ...  % Note: replaced defunct https://github.com/jschwizer99/plot2svg with up-to-date fork on https://github.com/kupiqu/plot2svg
                               '  3. export_fig to EPS/PDF, then convert to SVG using generic (non-Matlab) tools\n'];
                        error(sprintf(msg)); %#ok<SPERR>
                    case 'update'
                        % Download the latest version of export_fig into the export_fig folder
                        try
                            zipFileName = 'https://github.com/altmany/export_fig/archive/master.zip';
                            folderName = fileparts(which(mfilename('fullpath')));
                            targetFileName = fullfile(folderName, datestr(now,'yyyy-mm-dd.zip'));
                            urlwrite(zipFileName,targetFileName);
                        catch
                            error('Could not download %s into %s\n',zipFileName,targetFileName);
                        end

                        % Unzip the downloaded zip file in the export_fig folder
                        try
                            unzip(targetFileName,folderName);
                        catch
                            error('Could not unzip %s\n',targetFileName);
                        end
                    case 'nofontswap'
                        options.fontswap = false;
                    case 'font_space'
                        options.font_space = varargin{a+1};
                        skipNext = true;
                    case 'linecaps'
                        options.linecaps = true;
                    case 'noinvert'
                        options.invert_hardcopy = false;
                    otherwise
                        try
                            wasError = false;
                            if strcmpi(varargin{a}(1:2),'-d')
                                varargin{a}(2) = 'd';  % ensure lowercase 'd'
                                options.gs_options{end+1} = varargin{a};
                            elseif strcmpi(varargin{a}(1:2),'-c')
                                if numel(varargin{a})==2
                                    skipNext = true;
                                    vals = str2num(varargin{a+1}); %#ok<ST2NM>
                                else
                                    vals = str2num(varargin{a}(3:end)); %#ok<ST2NM>
                                end
                                if numel(vals)~=4
                                    wasError = true;
                                    error('option -c cannot be parsed: must be a 4-element numeric vector');
                                end
                                options.crop_amounts = vals;
                                options.crop = true;
                            else  % scalar parameter value
                                val = str2double(regexp(varargin{a}, '(?<=-(m|M|r|R|q|Q|p|P))-?\d*.?\d+', 'match'));
                                if isempty(val) || isnan(val)
                                    % Issue #51: improved processing of input args (accept space between param name & value)
                                    val = str2double(varargin{a+1});
                                    if isscalar(val) && ~isnan(val)
                                        skipNext = true;
                                    end
                                end
                                if ~isscalar(val) || isnan(val)
                                    wasError = true;
                                    error('option %s is not recognised or cannot be parsed', varargin{a});
                                end
                                switch lower(varargin{a}(2))
                                    case 'm'
                                        % Magnification may never be negative
                                        if val <= 0
                                            wasError = true;
                                            error('Bad magnification value: %g (must be positive)', val);
                                        end
                                        options.magnify = val;
                                    case 'r'
                                        options.resolution = val;
                                    case 'q'
                                        options.quality = max(val, 0);
                                    case 'p'
                                        options.bb_padding = val;
                                end
                            end
                        catch err
                            % We might have reached here by raising an intentional error
                            if wasError  % intentional raise
                                rethrow(err)
                            else  % unintentional
                                error(['Unrecognized export_fig input option: ''' varargin{a} '''']);
                            end
                        end
                end
            else
                [p, options.name, ext] = fileparts(varargin{a});
                if ~isempty(p)
                    % Issue #221: alert if the requested folder does not exist
                    if ~exist(p,'dir'),  error(['Folder ' p ' does not exist!']);  end
                    options.name = [p filesep options.name];
                end
                switch lower(ext)
                    case {'.tif', '.tiff'}
                        options.tif = true;
                    case {'.jpg', '.jpeg'}
                        options.jpg = true;
                    case '.png'
                        options.png = true;
                    case '.bmp'
                        options.bmp = true;
                    case '.eps'
                        options.eps = true;
                    case '.pdf'
                        options.pdf = true;
                    case '.fig'
                        % If no open figure, then load the specified .fig file and continue
                        if isempty(fig)
                            fig = openfig(varargin{a},'invisible');
                            varargin{a} = fig;
                            options.closeFig = true;
                        else
                            % save the current figure as the specified .fig file and exit
                            saveas(fig(1),varargin{a});
                            fig = -1;
                            return
                        end
                    case '.svg'
                        filename = strrep(options.name,'export_fig_out','filename');
                        msg = ['SVG output is not supported by export_fig. Use one of the following alternatives:\n' ...
                               '  1. saveas(gcf,''' filename '.svg'')\n' ...
                               '  2. plot2svg utility: https://github.com/kupiqu/plot2svg\n' ...  % Note: replaced defunct https://github.com/jschwizer99/plot2svg with up-to-date fork on https://github.com/kupiqu/plot2svg
                               '  3. export_fig to EPS/PDF, then convert to SVG using generic (non-Matlab) tools\n'];
                        error(sprintf(msg)); %#ok<SPERR>
                    otherwise
                        options.name = varargin{a};
                end
            end
        end
    end

    % Quick bail-out if no figure found
    if isempty(fig),  return;  end

    % Do border padding with repsect to a cropped image
    if options.bb_padding
        options.crop = true;
    end

    % Set default anti-aliasing now we know the renderer
    if options.aa_factor == 0
        try isAA = strcmp(get(ancestor(fig, 'figure'), 'GraphicsSmoothing'), 'on'); catch, isAA = false; end
        options.aa_factor = 1 + 2 * (~(using_hg2(fig) && isAA) | (options.renderer == 3));
    end

    % Convert user dir '~' to full path
    if numel(options.name) > 2 && options.name(1) == '~' && (options.name(2) == '/' || options.name(2) == '\')
        options.name = fullfile(char(java.lang.System.getProperty('user.home')), options.name(2:end));
    end

    % Compute the magnification and resolution
    if isempty(options.magnify)
        if isempty(options.resolution)
            options.magnify = 1;
            options.resolution = 864;
        else
            options.magnify = options.resolution ./ get(0, 'ScreenPixelsPerInch');
        end
    elseif isempty(options.resolution)
        options.resolution = 864;
    end

    % Set the default format
    if ~isvector(options) && ~isbitmap(options)
        options.png = true;
    end

    % Check whether transparent background is wanted (old way)
    if isequal(get(ancestor(fig(1), 'figure'), 'Color'), 'none')
        options.transparent = true;
    end

    % If requested, set the resolution to the native vertical resolution of the
    % first suitable image found
    if native
        if isbitmap(options)
            % Find a suitable image
            list = findall(fig, 'Type','image', 'Tag','export_fig_native');
            if isempty(list)
                list = findall(fig, 'Type','image', 'Visible','on');
            end
            for hIm = list(:)'
                % Check height is >= 2
                height = size(get(hIm, 'CData'), 1);
                if height < 2
                    continue
                end
                % Account for the image filling only part of the axes, or vice versa
                yl = get(hIm, 'YData');
                if isscalar(yl)
                    yl = [yl(1)-0.5 yl(1)+height+0.5];
                else
                    yl = [min(yl), max(yl)];  % fix issue #151 (case of yl containing more than 2 elements)
                    if ~diff(yl)
                        continue
                    end
                    yl = yl + [-0.5 0.5] * (diff(yl) / (height - 1));
                end
                hAx = get(hIm, 'Parent');
                yl2 = get(hAx, 'YLim');
                % Find the pixel height of the axes
                oldUnits = get(hAx, 'Units');
                set(hAx, 'Units', 'pixels');
                pos = get(hAx, 'Position');
                set(hAx, 'Units', oldUnits);
                if ~pos(4)
                    continue
                end
                % Found a suitable image
                % Account for stretch-to-fill being disabled
                pbar = get(hAx, 'PlotBoxAspectRatio');
                pos = min(pos(4), pbar(2)*pos(3)/pbar(1));
                % Set the magnification to give native resolution
                options.magnify = abs((height * diff(yl2)) / (pos * diff(yl)));  % magnification must never be negative: issue #103
                break
            end
        elseif options.resolution == 864  % don't use -r864 in vector mode if user asked for -native
            options.resolution = []; % issue #241 (internal Matlab bug produces black lines with -r864)
        end
    end
end

% Convert a possible string => char (issue #245)
function value = str2char(value)
    if isa(value,'string')
        value = char(value);
    end
end

function A = downsize(A, factor)
    % Downsample an image
    if factor == 1
        % Nothing to do
        return
    end
    try
        % Faster, but requires image processing toolbox
        A = imresize(A, 1/factor, 'bilinear');
    catch
        % No image processing toolbox - resize manually
        % Lowpass filter - use Gaussian as is separable, so faster
        % Compute the 1d Gaussian filter
        filt = (-factor-1:factor+1) / (factor * 0.6);
        filt = exp(-filt .* filt);
        % Normalize the filter
        filt = single(filt / sum(filt));
        % Filter the image
        padding = floor(numel(filt) / 2);
        for a = 1:size(A, 3)
            A(:,:,a) = conv2(filt, filt', single(A([ones(1, padding) 1:end repmat(end, 1, padding)],[ones(1, padding) 1:end repmat(end, 1, padding)],a)), 'valid');
        end
        % Subsample
        A = A(1+floor(mod(end-1, factor)/2):factor:end,1+floor(mod(end-1, factor)/2):factor:end,:);
    end
end

function A = rgb2grey(A)
    A = cast(reshape(reshape(single(A), [], 3) * single([0.299; 0.587; 0.114]), size(A, 1), size(A, 2)), class(A)); % #ok<ZEROLIKE>
end

function A = check_greyscale(A)
    % Check if the image is greyscale
    if size(A, 3) == 3 && ...
            all(reshape(A(:,:,1) == A(:,:,2), [], 1)) && ...
            all(reshape(A(:,:,2) == A(:,:,3), [], 1))
        A = A(:,:,1); % Save only one channel for 8-bit output
    end
end

function eps_remove_background(fname, count)
    % Remove the background of an eps file
    % Open the file
    fh = fopen(fname, 'r+');
    if fh == -1
        error('Not able to open file %s.', fname);
    end
    % Read the file line by line
    while count
        % Get the next line
        l = fgets(fh);
        if isequal(l, -1)
            break; % Quit, no rectangle found
        end
        % Check if the line contains the background rectangle
        if isequal(regexp(l, ' *0 +0 +\d+ +\d+ +r[fe] *[\n\r]+', 'start'), 1)
            % Set the line to whitespace and quit
            l(1:regexp(l, '[\n\r]', 'start', 'once')-1) = ' ';
            fseek(fh, -numel(l), 0);
            fprintf(fh, l);
            % Reduce the count
            count = count - 1;
        end
    end
    % Close the file
    fclose(fh);
end

function b = isvector(options)
    b = options.pdf || options.eps;
end

function b = isbitmap(options)
    b = options.png || options.tif || options.jpg || options.bmp || options.im || options.alpha;
end

% Helper function
function A = make_cell(A)
    if ~iscell(A)
        A = {A};
    end
end

function add_bookmark(fname, bookmark_text)
    % Adds a bookmark to the temporary EPS file after %%EndPageSetup
    % Read in the file
    fh = fopen(fname, 'r');
    if fh == -1
        error('File %s not found.', fname);
    end
    try
        fstrm = fread(fh, '*char')';
    catch ex
        fclose(fh);
        rethrow(ex);
    end
    fclose(fh);

    % Include standard pdfmark prolog to maximize compatibility
    fstrm = strrep(fstrm, '%%BeginProlog', sprintf('%%%%BeginProlog\n/pdfmark where {pop} {userdict /pdfmark /cleartomark load put} ifelse'));
    % Add page bookmark
    fstrm = strrep(fstrm, '%%EndPageSetup', sprintf('%%%%EndPageSetup\n[ /Title (%s) /OUT pdfmark',bookmark_text));

    % Write out the updated file
    fh = fopen(fname, 'w');
    if fh == -1
        error('Unable to open %s for writing.', fname);
    end
    try
        fwrite(fh, fstrm, 'char*1');
    catch ex
        fclose(fh);
        rethrow(ex);
    end
    fclose(fh);
end

function set_tick_mode(Hlims, ax)
    % Set the tick mode of linear axes to manual
    % Leave log axes alone as these are tricky
    M = get(Hlims, [ax 'Scale']);
    if ~iscell(M)
        M = {M};
    end
    %idx = cellfun(@(c) strcmp(c, 'linear'), M);
    idx = find(strcmp(M,'linear'));
    %set(Hlims(idx), [ax 'TickMode'], 'manual');  % issue #187
    %set(Hlims(idx), [ax 'TickLabelMode'], 'manual');  % this hides exponent label in HG2!
    for idx2 = 1 : numel(idx)
        try
            % Fix for issue #187 - only set manual ticks when no exponent is present
            hAxes = Hlims(idx(idx2));
            props = {[ax 'TickMode'],'manual', [ax 'TickLabelMode'],'manual'};
            tickVals = get(hAxes,[ax 'Tick']);
            tickStrs = get(hAxes,[ax 'TickLabel']);
            try % Fix issue #236
                exponents = [hAxes.([ax 'Axis']).SecondaryLabel];
            catch
                exponents = [hAxes.([ax 'Ruler']).SecondaryLabel];
            end
            if isempty([exponents.String])
                % Fix for issue #205 - only set manual ticks when the Ticks number match the TickLabels number
                if numel(tickVals) == numel(tickStrs)
                    set(hAxes, props{:});  % no exponent and matching ticks, so update both ticks and tick labels to manual
                end
            end
        catch  % probably HG1
            % Fix for issue #220 - exponent is removed in HG1 when TickMode is 'manual' (internal Matlab bug)
            if isequal(tickVals, str2num(tickStrs)') %#ok<ST2NM>
                set(hAxes, props{:});  % revert back to old behavior
            end
        end
    end
end

function change_rgb_to_cmyk(fname)  % convert RGB => CMYK within an EPS file
    % Do post-processing on the eps file
    try
        % Read the EPS file into memory
        fstrm = read_write_entire_textfile(fname);

        % Replace all gray-scale colors
        fstrm = regexprep(fstrm, '\n([\d.]+) +GC\n', '\n0 0 0 ${num2str(1-str2num($1))} CC\n');
        
        % Replace all RGB colors
        fstrm = regexprep(fstrm, '\n[0.]+ +[0.]+ +[0.]+ +RC\n', '\n0 0 0 1 CC\n');  % pure black
        fstrm = regexprep(fstrm, '\n([\d.]+) +([\d.]+) +([\d.]+) +RC\n', '\n${sprintf(''%.4g '',[1-[str2num($1),str2num($2),str2num($3)]/max([str2num($1),str2num($2),str2num($3)]),1-max([str2num($1),str2num($2),str2num($3)])])} CC\n');

        % Overwrite the file with the modified contents
        read_write_entire_textfile(fname, fstrm);
    catch
        % never mind - leave as is...
    end
end

function hBlackAxles = fixBlackAxle(hAxes, axleName)
    hBlackAxles = [];
    for idx = 1 : numel(hAxes)
        ax = hAxes(idx);
        axleColor = get(ax, axleName);
        if isequal(axleColor,[0,0,0]) || isequal(axleColor,'k')
            hBlackAxles(end+1) = ax; %#ok<AGROW>
        end
    end
    set(hBlackAxles, axleName, [0,0,0.01]);  % off-black
end

%APPEND_PDFS Appends/concatenates multiple PDF files
%
% Example:
%   append_pdfs(output, input1, input2, ...)
%   append_pdfs(output, input_list{:})
%   append_pdfs test.pdf temp1.pdf temp2.pdf
%
% This function appends multiple PDF files to an existing PDF file, or
% concatenates them into a PDF file if the output file doesn't yet exist.
%
% This function requires that you have ghostscript installed on your
% system. Ghostscript can be downloaded from: http://www.ghostscript.com
%
% IN:
%    output - string of output file name (including the extension, .pdf).
%             If it exists it is appended to; if not, it is created.
%    input1 - string of an input file name (including the extension, .pdf).
%             All input files are appended in order.
%    input_list - cell array list of input file name strings. All input
%                 files are appended in order.

% Copyright: Oliver Woodford, 2011

% Thanks to Reinhard Knoll for pointing out that appending multiple pdfs in
% one go is much faster than appending them one at a time.

% Thanks to Michael Teo for reporting the issue of a too long command line.
% Issue resolved on 5/5/2011, by passing gs a command file.

% Thanks to Martin Wittmann for pointing out the quality issue when
% appending multiple bitmaps.
% Issue resolved (to best of my ability) 1/6/2011, using the prepress
% setting

% 26/02/15: If temp dir is not writable, use the output folder for temp
%           files when appending (Javier Paredes); sanity check of inputs
% 24/01/18: Fixed error in case of existing output file (append mode)
% 24/01/18: Fixed issue #213: non-ASCII characters in folder names on Windows
% 06/12/18: Avoid an "invalid escape-char" warning upon error

function append_pdfs(varargin)

    if nargin < 2,  return;  end  % sanity check

    % Are we appending or creating a new file
    append = exist(varargin{1}, 'file') == 2;
    output = [tempname '.pdf'];
    try
        % Ensure that the temp dir is writable (Javier Paredes 26/2/15)
        fid = fopen(output,'w');
        fwrite(fid,1);
        fclose(fid);
        delete(output);
        isTempDirOk = true;
    catch
        % Temp dir is not writable, so use the output folder
        [dummy,fname,fext] = fileparts(output); %#ok<ASGLU>
        fpath = fileparts(varargin{1});
        output = fullfile(fpath,[fname fext]);
        isTempDirOk = false;
    end
    if ~append
        output = varargin{1};
        varargin = varargin(2:end);
    end

    % Create the command file
    if isTempDirOk
        cmdfile = [tempname '.txt'];
    else
        cmdfile = fullfile(fpath,[fname '.txt']);
    end
    prepareCmdFile(cmdfile, output, varargin{:});

    % Call ghostscript
    [status, errMsg] = ghostscript(['@"' cmdfile '"']);

    % Check for ghostscript execution errors
    if status && ~isempty(strfind(errMsg,'undefinedfile')) && ispc %#ok<STREMP>
        % Fix issue #213: non-ASCII characters in folder names on Windows
        for fileIdx = 2 : numel(varargin)
            [fpath,fname,fext] = fileparts(varargin{fileIdx});
            varargin{fileIdx} = fullfile(normalizePath(fpath),[fname fext]);
        end
        % Rerun ghostscript with the normalized folder names
        prepareCmdFile(cmdfile, output, varargin{:});
        [status, errMsg] = ghostscript(['@"' cmdfile '"']);
    end

    % Delete the command file
    delete(cmdfile);

    % Check for ghostscript execution errors
    if status
        errMsg = strrep(errMsg,'\','\\');  % Avoid an "invalid escape-char" warning
        error('YMA:export_fig:append_pdf',errMsg);
    end

    % Rename the file if needed
    if append
        movefile(output, varargin{1}, 'f');
    end
end

% Prepare a text file with ghostscript directives
function prepareCmdFile(cmdfile, output, varargin)
    fh = fopen(cmdfile, 'w');
    fprintf(fh, '-q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -dPDFSETTINGS=/prepress -sOutputFile="%s" -f', output);
    fprintf(fh, ' "%s"', varargin{:});
    fclose(fh);
end

% Convert long/non-ASCII folder names into their short ASCII equivalents
function pathStr = normalizePath(pathStr)
    [fpath,fname,fext] = fileparts(pathStr);
    if isempty(fpath) || strcmpi(fpath,pathStr), return, end
    dirOutput = evalc(['system(''dir /X /AD "' pathStr '*"'')']);
    shortName = strtrim(regexprep(dirOutput,{'.*> *',[fname fext '.*']},''));
    if isempty(shortName)
        shortName = [fname fext];
    end
    fpath = normalizePath(fpath);  %recursive until entire fpath is processed
    pathStr = fullfile(fpath, shortName);
end

function fh = copyfig(fh)
%COPYFIG Create a copy of a figure, without changing the figure
%
% Examples:
%   fh_new = copyfig(fh_old)
%
% This function will create a copy of a figure, but not change the figure,
% as copyobj sometimes does, e.g. by changing legends.
%
% IN:
%    fh_old - The handle of the figure to be copied. Default: gcf.
%
% OUT:
%    fh_new - The handle of the created figure.

% Copyright (C) Oliver Woodford 2012, Yair Altman 2015

% 26/02/15: If temp dir is not writable, use the dest folder for temp
%           destination files (Javier Paredes)
% 15/04/15: Suppress warnings during copyobj (Dun Kirk comment on FEX page 2013-10-02)
% 09/09/18: Fix issue #252: Workaround for cases where copyobj() fails for any reason

    % Set the default
    if nargin == 0
        fh = gcf;
    end
    % Is there a legend?
    useCopyobj = isempty(findall(fh, 'Type', 'axes', 'Tag', 'legend'));
    if useCopyobj
        % Safe to copy using copyobj
        oldWarn = warning('off'); %Suppress warnings during copyobj (Dun Kirk comment on FEX page 2013-10-02)
        try
            fh = copyobj(fh, 0);
        catch
            % Fix issue #252: Workaround for cases where copyobj() fails for any reason
            useCopyobj = false;  % if copyobj() croaks, use file save/load below
        end
        warning(oldWarn);
    end
    if ~useCopyobj
        % copyobj will change the figure, so save and then load it instead
        tmp_nam = [tempname '.fig'];
        try
            % Ensure that the temp dir is writable (Javier Paredes 26/2/15)
            fid = fopen(tmp_nam,'w');
            fwrite(fid,1);
            fclose(fid);
            delete(tmp_nam);  % cleanup
        catch
            % Temp dir is not writable, so use the current folder
            [dummy,fname,fext] = fileparts(tmp_nam); %#ok<ASGLU>
            fpath = pwd;
            tmp_nam = fullfile(fpath,[fname fext]);
        end
        hgsave(fh, tmp_nam);
        fh = hgload(tmp_nam);
        delete(tmp_nam);
    end
end

function [A, vA, vB, bb_rel] = crop_borders(A, bcol, padding, crop_amounts)
%CROP_BORDERS Crop the borders of an image or stack of images
%
%   [B, vA, vB, bb_rel] = crop_borders(A, bcol, [padding])
%
%IN:
%   A - HxWxCxN stack of images.
%   bcol - Cx1 background colour vector.
%   padding - scalar indicating how much padding to have in relation to
%             the cropped-image-size (0<=padding<=1). Default: 0
%   crop_amounts - 4-element vector of crop amounts: [top,right,bottom,left]
%             where NaN/Inf indicate auto-cropping, 0 means no cropping,
%             and any other value mean cropping in pixel amounts.
%
%OUT:
%   B - JxKxCxN cropped stack of images.
%   vA     - coordinates in A that contain the cropped image
%   vB     - coordinates in B where the cropped version of A is placed
%   bb_rel - relative bounding box (used for eps-cropping)

%{
% 06/03/15: Improved image cropping thanks to Oscar Hartogensis
% 08/06/15: Fixed issue #76: case of transparent figure bgcolor
% 21/02/16: Enabled specifying non-automated crop amounts
% 04/04/16: Fix per Luiz Carvalho for old Matlab releases
% 23/10/16: Fixed issue #175: there used to be a 1px minimal padding in case of crop, now removed
%}

    if nargin < 3
        padding = 0;
    end
    if nargin < 4
        crop_amounts = nan(1,4);  % =auto-cropping
    end
    crop_amounts(end+1:4) = NaN;  % fill missing values with NaN

    [h, w, c, n] = size(A);
    if isempty(bcol)  % case of transparent bgcolor
        bcol = A(ceil(end/2),1,:,1);
    end
    if isscalar(bcol)
        bcol = bcol(ones(c, 1));
    end

    % Crop margin from left
    if ~isfinite(crop_amounts(4))
        bail = false;
        for l = 1:w
            for a = 1:c
                if ~all(col(A(:,l,a,:)) == bcol(a))
                    bail = true;
                    break;
                end
            end
            if bail
                break;
            end
        end
    else
        l = 1 + abs(crop_amounts(4));
    end

    % Crop margin from right
    if ~isfinite(crop_amounts(2))
        bcol = A(ceil(end/2),w,:,1);
        bail = false;
        for r = w:-1:l
            for a = 1:c
                if ~all(col(A(:,r,a,:)) == bcol(a))
                    bail = true;
                    break;
                end
            end
            if bail
                break;
            end
        end
    else
        r = w - abs(crop_amounts(2));
    end

    % Crop margin from top
    if ~isfinite(crop_amounts(1))
        bcol = A(1,ceil(end/2),:,1);
        bail = false;
        for t = 1:h
            for a = 1:c
                if ~all(col(A(t,:,a,:)) == bcol(a))
                    bail = true;
                    break;
                end
            end
            if bail
                break;
            end
        end
    else
        t = 1 + abs(crop_amounts(1));
    end

    % Crop margin from bottom
    bcol = A(h,ceil(end/2),:,1);
    if ~isfinite(crop_amounts(3))
        bail = false;
        for b = h:-1:t
            for a = 1:c
                if ~all(col(A(b,:,a,:)) == bcol(a))
                    bail = true;
                    break;
                end
            end
            if bail
                break;
            end
        end
    else
        b = h - abs(crop_amounts(3));
    end

    if padding == 0  % no padding
        % Issue #175: there used to be a 1px minimal padding in case of crop, now removed
        %{
        if ~isequal([t b l r], [1 h 1 w]) % Check if we're actually croppping
            padding = 1; % Leave one boundary pixel to avoid bleeding on resize
            bcol(:) = nan;  % make the 1px padding transparent
        end
        %}
    elseif abs(padding) < 1  % pad value is a relative fraction of image size
        padding = sign(padding)*round(mean([b-t r-l])*abs(padding)); % ADJUST PADDING
    else  % pad value is in units of 1/72" points
        padding = round(padding);  % fix cases of non-integer pad value
    end

    if padding > 0  % extra padding
        % Create an empty image, containing the background color, that has the
        % cropped image size plus the padded border
        B = repmat(bcol,[(b-t)+1+padding*2,(r-l)+1+padding*2,1,n]);  % Fix per Luiz Carvalho
        % vA - coordinates in A that contain the cropped image
        vA = [t b l r];
        % vB - coordinates in B where the cropped version of A will be placed
        vB = [padding+1, (b-t)+1+padding, padding+1, (r-l)+1+padding];
        % Place the original image in the empty image
        B(vB(1):vB(2), vB(3):vB(4), :, :) = A(vA(1):vA(2), vA(3):vA(4), :, :);
        A = B;
    else  % extra cropping
        vA = [t-padding b+padding l-padding r+padding];
        A = A(vA(1):vA(2), vA(3):vA(4), :, :);
        vB = [NaN NaN NaN NaN];
    end

    % For EPS cropping, determine the relative BoundingBox - bb_rel
    bb_rel = [l-1 h-b-1 r+1 h-t+1]./[w h w h];
end

function A = col(A)
    A = A(:);
end

function eps2pdf(source, dest, crop, append, gray, quality, gs_options)
%EPS2PDF  Convert an eps file to pdf format using ghostscript
%
% Examples:
%   eps2pdf source dest
%   eps2pdf(source, dest, crop)
%   eps2pdf(source, dest, crop, append)
%   eps2pdf(source, dest, crop, append, gray)
%   eps2pdf(source, dest, crop, append, gray, quality)
%   eps2pdf(source, dest, crop, append, gray, quality, gs_options)
%
% This function converts an eps file to pdf format. The output can be
% optionally cropped and also converted to grayscale. If the output pdf
% file already exists then the eps file can optionally be appended as a new
% page on the end of the eps file. The level of bitmap compression can also
% optionally be set.
%
% This function requires that you have ghostscript installed on your
% system. Ghostscript can be downloaded from: http://www.ghostscript.com
%
% Inputs:
%   source  - filename of the source eps file to convert. The filename is
%             assumed to already have the extension ".eps".
%   dest    - filename of the destination pdf file. The filename is assumed
%             to already have the extension ".pdf".
%   crop    - boolean indicating whether to crop the borders off the pdf.
%             Default: true.
%   append  - boolean indicating whether the eps should be appended to the
%             end of the pdf as a new page (if the pdf exists already).
%             Default: false.
%   gray    - boolean indicating whether the output pdf should be grayscale
%             or not. Default: false.
%   quality - scalar indicating the level of image bitmap quality to
%             output. A larger value gives a higher quality. quality > 100
%             gives lossless output. Default: ghostscript prepress default.
%   gs_options - optional ghostscript options (e.g.: '-dNoOutputFonts'). If
%                multiple options are needed, enclose in call array: {'-a','-b'}

% Copyright (C) Oliver Woodford 2009-2014, Yair Altman 2015-

% Suggestion of appending pdf files provided by Matt C at:
% http://www.mathworks.com/matlabcentral/fileexchange/23629

% Thank you to Fabio Viola for pointing out compression artifacts, leading
% to the quality setting.
% Thank you to Scott for pointing out the subsampling of very small images,
% which was fixed for lossless compression settings.

% 09/12/11: Pass font path to ghostscript
% 26/02/15: If temp dir is not writable, use the dest folder for temp
%           destination files (Javier Paredes)
% 28/02/15: Enable users to specify optional ghostscript options (issue #36)
% 01/03/15: Upon GS error, retry without the -sFONTPATH= option (this might solve
%           some /findfont errors according to James Rankin, FEX Comment 23/01/15)
% 23/06/15: Added extra debug info in case of ghostscript error; code indentation
% 04/10/15: Suggest a workaround for issue #41 (missing font path; thanks Mariia Fedotenkova)
% 22/02/16: Bug fix from latest release of this file (workaround for issue #41)
% 20/03/17: Added informational message in case of GS croak (issue #186)
% 16/01/18: Improved appending of multiple EPS files into single PDF (issue #233; thanks @shartjen)

    % Intialise the options string for ghostscript
    options = ['-q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -dPDFSETTINGS=/prepress -sOutputFile="' dest '"'];
    % Set crop option
    if nargin < 3 || crop
        options = [options ' -dEPSCrop'];
    end
    % Set the font path
    fp = font_path();
    if ~isempty(fp)
        options = [options ' -sFONTPATH="' fp '"'];
    end
    % Set the grayscale option
    if nargin > 4 && gray
        options = [options ' -sColorConversionStrategy=Gray -dProcessColorModel=/DeviceGray'];
    end
    % Set the bitmap quality
    if nargin > 5 && ~isempty(quality)
        options = [options ' -dAutoFilterColorImages=false -dAutoFilterGrayImages=false'];
        if quality > 100
            options = [options ' -dColorImageFilter=/FlateEncode -dGrayImageFilter=/FlateEncode -c ".setpdfwrite << /ColorImageDownsampleThreshold 10 /GrayImageDownsampleThreshold 10 >> setdistillerparams"'];
        else
            options = [options ' -dColorImageFilter=/DCTEncode -dGrayImageFilter=/DCTEncode'];
            v = 1 + (quality < 80);
            quality = 1 - quality / 100;
            s = sprintf('<< /QFactor %.2f /Blend 1 /HSample [%d 1 1 %d] /VSample [%d 1 1 %d] >>', quality, v, v, v, v);
            options = sprintf('%s -c ".setpdfwrite << /ColorImageDict %s /GrayImageDict %s >> setdistillerparams"', options, s, s);
        end
    end
    % Enable users to specify optional ghostscript options (issue #36)
    if nargin > 6 && ~isempty(gs_options)
        if iscell(gs_options)
            gs_options = sprintf(' %s',gs_options{:});
        elseif ~ischar(gs_options)
            error('gs_options input argument must be a string or cell-array of strings');
        else
            gs_options = [' ' gs_options];
        end
        options = [options gs_options];
    end
    % Check if the output file exists
    if nargin > 3 && append && exist(dest, 'file') == 2
        % File exists - append current figure to the end
        tmp_nam = [tempname '.pdf'];
        [fpath,fname,fext] = fileparts(tmp_nam);
        try
            % Ensure that the temp dir is writable (Javier Paredes 26/2/15)
            fid = fopen(tmp_nam,'w');
            fwrite(fid,1);
            fclose(fid);
            delete(tmp_nam);
        catch
            % Temp dir is not writable, so use the dest folder
            fpath = fileparts(dest);
            tmp_nam = fullfile(fpath,[fname fext]);
        end
        % Copy the existing (dest) pdf file to temporary folder
        copyfile(dest, tmp_nam);
        % Produce an interim pdf of the source eps, rather than adding the eps directly (issue #233)
        ghostscript([options ' -f "' source '"']);
        [~,fname] = fileparts(tempname);
        tmp_nam2 = fullfile(fpath,[fname fext]); % ensure using a writable folder (not necessarily tempdir)
        copyfile(dest, tmp_nam2);
        % Add the existing pdf and interim pdf as inputs to ghostscript
        %options = [options ' -f "' tmp_nam '" "' source '"'];  % append the source eps to dest pdf
        options = [options ' -f "' tmp_nam '" "' tmp_nam2 '"']; % append the interim pdf to dest pdf
        try
            % Convert to pdf using ghostscript
            [status, message] = ghostscript(options);
        catch me
            % Delete the intermediate files and rethrow the error
            delete(tmp_nam);
            delete(tmp_nam2);
            rethrow(me);
        end
        % Delete the intermediate (temporary) files
        delete(tmp_nam);
        delete(tmp_nam2);
    else
        % File doesn't exist or should be over-written
        % Add the source eps file as input to ghostscript
        options = [options ' -f "' source '"'];
        % Convert to pdf using ghostscript
        [status, message] = ghostscript(options);
    end
    % Check for error
    if status
        % Retry without the -sFONTPATH= option (this might solve some GS
        % /findfont errors according to James Rankin, FEX Comment 23/01/15)
        orig_options = options;
        if ~isempty(fp)
            options = regexprep(options, ' -sFONTPATH=[^ ]+ ',' ');
            status = ghostscript(options);
            if ~status, return; end  % hurray! (no error)
        end
        % Report error
        if isempty(message)
            error('Unable to generate pdf. Check destination directory is writable.');
        elseif ~isempty(strfind(message,'/typecheck in /findfont'))
            % Suggest a workaround for issue #41 (missing font path)
            font_name = strtrim(regexprep(message,'.*Operand stack:\s*(.*)\s*Execution.*','$1'));
            fprintf(2, 'Ghostscript error: could not find the following font(s): %s\n', font_name);
            fpath = fileparts(mfilename('fullpath'));
            gs_fonts_file = fullfile(fpath, '.ignore', 'gs_font_path.txt');
            fprintf(2, '  try to add the font''s folder to your %s file\n\n', gs_fonts_file);
            error('export_fig error');
        else
            fprintf(2, '\nGhostscript error: perhaps %s is open by another application\n', dest);
            if ~isempty(gs_options)
                fprintf(2, '  or maybe the%s option(s) are not accepted by your GS version\n', gs_options);
            end
            fprintf(2, '  or maybe you have another gs executable in your system''s path\n');
            fprintf(2, 'Ghostscript options: %s\n\n', orig_options);
            error(message);
        end
    end
end

% Function to return (and create, where necessary) the font path
function fp = font_path()
    fp = user_string('gs_font_path');
    if ~isempty(fp)
        return
    end
    % Create the path
    % Start with the default path
    fp = getenv('GS_FONTPATH');
    % Add on the typical directories for a given OS
    if ispc
        if ~isempty(fp)
            fp = [fp ';'];
        end
        fp = [fp getenv('WINDIR') filesep 'Fonts'];
    else
        if ~isempty(fp)
            fp = [fp ':'];
        end
        fp = [fp '/usr/share/fonts:/usr/local/share/fonts:/usr/share/fonts/X11:/usr/local/share/fonts/X11:/usr/share/fonts/truetype:/usr/local/share/fonts/truetype'];
    end
    user_string('gs_font_path', fp);
end

%FIX_LINES  Improves the line style of eps files generated by print
%
% Examples:
%   fix_lines fname
%   fix_lines fname fname2
%   fstrm_out = fixlines(fstrm_in)
%
% This function improves the style of lines in eps files generated by
% MATLAB's print function, making them more similar to those seen on
% screen. Grid lines are also changed from a dashed style to a dotted
% style, for greater differentiation from dashed lines.
% 
% The function also places embedded fonts after the postscript header, in
% versions of MATLAB which place the fonts first (R2006b and earlier), in
% order to allow programs such as Ghostscript to find the bounding box
% information.
%
%IN:
%   fname - Name or path of source eps file.
%   fname2 - Name or path of destination eps file. Default: same as fname.
%   fstrm_in - File contents of a MATLAB-generated eps file.
%
%OUT:
%   fstrm_out - Contents of the eps file with line styles fixed.

% Copyright: (C) Oliver Woodford, 2008-2014

% The idea of editing the EPS file to change line styles comes from Jiro
% Doke's FIXPSLINESTYLE (fex id: 17928)
% The idea of changing dash length with line width came from comments on
% fex id: 5743, but the implementation is mine :)

% Thank you to Sylvain Favrot for bringing the embedded font/bounding box
% interaction in older versions of MATLAB to my attention.
% Thank you to D Ko for bringing an error with eps files with tiff previews
% to my attention.
% Thank you to Laurence K for suggesting the check to see if the file was
% opened.

% 01/03/15: Issue #20: warn users if using this function in HG2 (R2014b+)
% 27/03/15: Fixed out of memory issue with enormous EPS files (generated by print() with OpenGL renderer), related to issue #39

function fstrm = fix_lines(fstrm, fname2)

% Issue #20: warn users if using this function in HG2 (R2014b+)
if using_hg2
    warning('export_fig:hg2','The fix_lines function should not be used in this Matlab version.');
end
    
if nargout == 0 || nargin > 1
    if nargin < 2
        % Overwrite the input file
        fname2 = fstrm;
    end
    % Read in the file
    fstrm = read_write_entire_textfile(fstrm);
end

% Move any embedded fonts after the postscript header
if strcmp(fstrm(1:15), '%!PS-AdobeFont-')
    % Find the start and end of the header
    ind = regexp(fstrm, '[\n\r]%!PS-Adobe-');
    [ind2, ind2] = regexp(fstrm, '[\n\r]%%EndComments[\n\r]+');
    % Put the header first
    if ~isempty(ind) && ~isempty(ind2) && ind(1) < ind2(1)
        fstrm = fstrm([ind(1)+1:ind2(1) 1:ind(1) ind2(1)+1:end]);
    end
end

% Make sure all line width commands come before the line style definitions,
% so that dash lengths can be based on the correct widths
% Find all line style sections
ind = [regexp(fstrm, '[\n\r]SO[\n\r]'),... % This needs to be here even though it doesn't have dots/dashes!
       regexp(fstrm, '[\n\r]DO[\n\r]'),...
       regexp(fstrm, '[\n\r]DA[\n\r]'),...
       regexp(fstrm, '[\n\r]DD[\n\r]')];
ind = sort(ind);
% Find line width commands
[ind2, ind3] = regexp(fstrm, '[\n\r]\d* w[\n\r]');
% Go through each line style section and swap with any line width commands
% near by
b = 1;
m = numel(ind);
n = numel(ind2);
for a = 1:m
    % Go forwards width commands until we pass the current line style
    while b <= n && ind2(b) < ind(a)
        b = b + 1;
    end
    if b > n
        % No more width commands
        break;
    end
    % Check we haven't gone past another line style (including SO!)
    if a < m && ind2(b) > ind(a+1)
        continue;
    end
    % Are the commands close enough to be confident we can swap them?
    if (ind2(b) - ind(a)) > 8
        continue;
    end
    % Move the line style command below the line width command
    fstrm(ind(a)+1:ind3(b)) = [fstrm(ind(a)+4:ind3(b)) fstrm(ind(a)+1:ind(a)+3)];
    b = b + 1;
end

% Find any grid line definitions and change to GR format
% Find the DO sections again as they may have moved
ind = int32(regexp(fstrm, '[\n\r]DO[\n\r]'));
if ~isempty(ind)
    % Find all occurrences of what are believed to be axes and grid lines
    ind2 = int32(regexp(fstrm, '[\n\r] *\d* *\d* *mt *\d* *\d* *L[\n\r]'));
    if ~isempty(ind2)
        % Now see which DO sections come just before axes and grid lines
        ind2 = repmat(ind2', [1 numel(ind)]) - repmat(ind, [numel(ind2) 1]);
        ind2 = any(ind2 > 0 & ind2 < 12); % 12 chars seems about right
        ind = ind(ind2);
        % Change any regions we believe to be grid lines to GR
        fstrm(ind+1) = 'G';
        fstrm(ind+2) = 'R';
    end
end

% Define the new styles, including the new GR format
% Dot and dash lengths have two parts: a constant amount plus a line width
% variable amount. The constant amount comes after dpi2point, and the
% variable amount comes after currentlinewidth. If you want to change
% dot/dash lengths for a one particular line style only, edit the numbers
% in the /DO (dotted lines), /DA (dashed lines), /DD (dot dash lines) and
% /GR (grid lines) lines for the style you want to change.
new_style = {'/dom { dpi2point 1 currentlinewidth 0.08 mul add mul mul } bdef',... % Dot length macro based on line width
             '/dam { dpi2point 2 currentlinewidth 0.04 mul add mul mul } bdef',... % Dash length macro based on line width
             '/SO { [] 0 setdash 0 setlinecap } bdef',... % Solid lines
             '/DO { [1 dom 1.2 dom] 0 setdash 0 setlinecap } bdef',... % Dotted lines
             '/DA { [4 dam 1.5 dam] 0 setdash 0 setlinecap } bdef',... % Dashed lines
             '/DD { [1 dom 1.2 dom 4 dam 1.2 dom] 0 setdash 0 setlinecap } bdef',... % Dot dash lines
             '/GR { [0 dpi2point mul 4 dpi2point mul] 0 setdash 1 setlinecap } bdef'}; % Grid lines - dot spacing remains constant

% Construct the output
% This is the original (memory-intensive) code:
%first_sec = strfind(fstrm, '% line types:'); % Isolate line style definition section
%[second_sec, remaining] = strtok(fstrm(first_sec+1:end), '/');
%[remaining, remaining] = strtok(remaining, '%');
%fstrm = [fstrm(1:first_sec) second_sec sprintf('%s\r', new_style{:}) remaining];
fstrm = regexprep(fstrm,'(% line types:.+?)/.+?%',['$1',sprintf('%s\r',new_style{:}),'%']);

% Write the output file
if nargout == 0 || nargin > 1
    read_write_entire_textfile(fname2, fstrm);
end
end

function varargout = ghostscript(cmd)
%GHOSTSCRIPT  Calls a local GhostScript executable with the input command
%
% Example:
%   [status result] = ghostscript(cmd)
%
% Attempts to locate a ghostscript executable, finally asking the user to
% specify the directory ghostcript was installed into. The resulting path
% is stored for future reference.
% 
% Once found, the executable is called with the input command string.
%
% This function requires that you have Ghostscript installed on your
% system. You can download this from: http://www.ghostscript.com
%
% IN:
%   cmd - Command string to be passed into ghostscript.
%
% OUT:
%   status - 0 iff command ran without problem.
%   result - Output from ghostscript.

% Copyright: Oliver Woodford, 2009-2015, Yair Altman 2015-
%{
% Thanks to Jonas Dorn for the fix for the title of the uigetdir window on Mac OS.
% Thanks to Nathan Childress for the fix to default location on 64-bit Windows systems.
% 27/04/11 - Find 64-bit Ghostscript on Windows. Thanks to Paul Durack and
%            Shaun Kline for pointing out the issue
% 04/05/11 - Thanks to David Chorlian for pointing out an alternative
%            location for gs on linux.
% 12/12/12 - Add extra executable name on Windows. Thanks to Ratish
%            Punnoose for highlighting the issue.
% 28/06/13 - Fix error using GS 9.07 in Linux. Many thanks to Jannick
%            Steinbring for proposing the fix.
% 24/10/13 - Fix error using GS 9.07 in Linux. Many thanks to Johannes 
%            for the fix.
% 23/01/14 - Add full path to ghostscript.txt in warning. Thanks to Koen
%            Vermeer for raising the issue.
% 27/02/15 - If Ghostscript croaks, display suggested workarounds
% 30/03/15 - Improved performance by caching status of GS path check, if ok
% 14/05/15 - Clarified warning message in case GS path could not be saved
% 29/05/15 - Avoid cryptic error in case the ghostscipt path cannot be saved (issue #74)
% 10/11/15 - Custom GS installation webpage for MacOS. Thanks to Andy Hueni via FEX
%}

    try
        % Call ghostscript
        [varargout{1:nargout}] = system([gs_command(gs_path()) cmd]);
    catch err
        % Display possible workarounds for Ghostscript croaks
        url1 = 'https://github.com/altmany/export_fig/issues/12#issuecomment-61467998';  % issue #12
        url2 = 'https://github.com/altmany/export_fig/issues/20#issuecomment-63826270';  % issue #20
        hg2_str = ''; if using_hg2, hg2_str = ' or Matlab R2014a'; end
        fprintf(2, 'Ghostscript error. Rolling back to GS 9.10%s may possibly solve this:\n * <a href="%s">%s</a> ',hg2_str,url1,url1);
        if using_hg2
            fprintf(2, '(GS 9.10)\n * <a href="%s">%s</a> (R2014a)',url2,url2);
        end
        fprintf('\n\n');
        if ismac || isunix
            url3 = 'https://github.com/altmany/export_fig/issues/27';  % issue #27
            fprintf(2, 'Alternatively, this may possibly be due to a font path issue:\n * <a href="%s">%s</a>\n\n',url3,url3);
            % issue #20
            fpath = which(mfilename);
            if isempty(fpath), fpath = [mfilename('fullpath') '.m']; end
            fprintf(2, 'Alternatively, if you are using csh, modify shell_cmd from "export..." to "setenv ..."\nat the bottom of <a href="matlab:opentoline(''%s'',174)">%s</a>\n\n',fpath,fpath);
        end
        rethrow(err);
    end
end

function path_ = gs_path
    % Return a valid path
    % Start with the currently set path
    path_ = user_string('ghostscript');
    % Check the path works
    if check_gs_path(path_)
        return
    end
    % Check whether the binary is on the path
    if ispc
        bin = {'gswin32c.exe', 'gswin64c.exe', 'gs'};
    else
        bin = {'gs'};
    end
    for a = 1:numel(bin)
        path_ = bin{a};
        if check_store_gs_path(path_)
            return
        end
    end
    % Search the obvious places
    if ispc
        default_location = 'C:\Program Files\gs\';
        dir_list = dir(default_location);
        if isempty(dir_list)
            default_location = 'C:\Program Files (x86)\gs\'; % Possible location on 64-bit systems
            dir_list = dir(default_location);
        end
        executable = {'\bin\gswin32c.exe', '\bin\gswin64c.exe'};
        ver_num = 0;
        % If there are multiple versions, use the newest
        for a = 1:numel(dir_list)
            ver_num2 = sscanf(dir_list(a).name, 'gs%g');
            if ~isempty(ver_num2) && ver_num2 > ver_num
                for b = 1:numel(executable)
                    path2 = [default_location dir_list(a).name executable{b}];
                    if exist(path2, 'file') == 2
                        path_ = path2;
                        ver_num = ver_num2;
                    end
                end
            end
        end
        if check_store_gs_path(path_)
            return
        end
    else
        executable = {'/usr/bin/gs', '/usr/local/bin/gs'};
        for a = 1:numel(executable)
            path_ = executable{a};
            if check_store_gs_path(path_)
                return
            end
        end
    end
    % Ask the user to enter the path
    while true
        if strncmp(computer, 'MAC', 3) % Is a Mac
            % Give separate warning as the uigetdir dialogue box doesn't have a
            % title
            uiwait(warndlg('Ghostscript not found. Please locate the program.'))
        end
        base = uigetdir('/', 'Ghostcript not found. Please locate the program.');
        if isequal(base, 0)
            % User hit cancel or closed window
            break;
        end
        base = [base filesep]; %#ok<AGROW>
        bin_dir = {'', ['bin' filesep], ['lib' filesep]};
        for a = 1:numel(bin_dir)
            for b = 1:numel(bin)
                path_ = [base bin_dir{a} bin{b}];
                if exist(path_, 'file') == 2
                    if check_store_gs_path(path_)
                        return
                    end
                end
            end
        end
    end
    if ismac
        error('Ghostscript not found. Have you installed it (http://pages.uoregon.edu/koch)?');
    else
        error('Ghostscript not found. Have you installed it from www.ghostscript.com?');
    end
end

function good = check_store_gs_path(path_)
    % Check the path is valid
    good = check_gs_path(path_);
    if ~good
        return
    end
    % Update the current default path to the path found
    if ~user_string('ghostscript', path_)
        filename = fullfile(fileparts(which('user_string.m')), '.ignore', 'ghostscript.txt');
        warning('Path to ghostscript installation could not be saved in %s (perhaps a permissions issue). You can manually create this file and set its contents to %s, to improve performance in future invocations (this warning is safe to ignore).', filename, path_);
        return
    end
end

function good = check_gs_path(path_)
    persistent isOk
    if isempty(path_)
        isOk = false;
    elseif ~isequal(isOk,true)
        % Check whether the path is valid
        [status, message] = system([gs_command(path_) '-h']); %#ok<ASGLU>
        isOk = status == 0;
    end
    good = isOk;
end

function cmd = gs_command(path_)
    % Initialize any required system calls before calling ghostscript
    % TODO: in Unix/Mac, find a way to determine whether to use "export" (bash) or "setenv" (csh/tcsh)
    shell_cmd = '';
    if isunix
        shell_cmd = 'export LD_LIBRARY_PATH=""; '; % Avoids an error on Linux with GS 9.07
    end
    if ismac
        shell_cmd = 'export DYLD_LIBRARY_PATH=""; ';  % Avoids an error on Mac with GS 9.07
    end
    % Construct the command string
    cmd = sprintf('%s"%s" ', shell_cmd, path_);
end

%IM2GIF Convert a multiframe image to an animated GIF file
%
% Examples:
%   im2gif infile
%   im2gif infile outfile
%   im2gif(A, outfile)
%   im2gif(..., '-nocrop')
%   im2gif(..., '-nodither')
%   im2gif(..., '-ncolors', n)
%   im2gif(..., '-loops', n)
%   im2gif(..., '-delay', n) 
%   
% This function converts a multiframe image to an animated GIF.
%
% To create an animation from a series of figures, export to a multiframe
% TIFF file using export_fig, then convert to a GIF, as follows:
%
%    for a = 2 .^ (3:6)
%       peaks(a);
%       export_fig test.tif -nocrop -append
%    end
%    im2gif('test.tif', '-delay', 0.5);
%
%IN:
%   infile - string containing the name of the input image.
%   outfile - string containing the name of the output image (must have the
%             .gif extension). Default: infile, with .gif extension.
%   A - HxWxCxN array of input images, stacked along fourth dimension, to
%       be converted to gif.
%   -nocrop - option indicating that the borders of the output are not to
%             be cropped.
%   -nodither - option indicating that dithering is not to be used when
%               converting the image.
%   -ncolors - option pair, the value of which indicates the maximum number
%              of colors the GIF can have. This can also be a quantization
%              tolerance, between 0 and 1. Default/maximum: 256.
%   -loops - option pair, the value of which gives the number of times the
%            animation is to be looped. Default: 65535.
%   -delay - option pair, the value of which gives the time, in seconds,
%            between frames. Default: 1/15.

% Copyright (C) Oliver Woodford 2011

%{
% 14/02/18: Merged issue #235: reduced memory usage, improved performance (thanks to @numb7rs)
%}

function im2gif(A, varargin)

% Parse the input arguments
[A, options] = parse_args_im2gif(A, varargin{:});

if options.crop ~= 0
    % Crop
    A = crop_borders(A, A(ceil(end/2),1,:,1));
end

% Convert to indexed image
[h, w, c, n] = size(A);

% Issue #235: Using unique(A,'rows') on the whole image stack at once causes
% massive memory usage when dealing with large images (at least on Matlab 2017b).
% Running unique(...) on individual frames, then again on the results drastically
% reduces the memory usage & slightly improves the execution time (@numb7rs).
uns = cell(1,size(A,4));
for nn=1:size(A,4)
    uns{nn}=unique(reshape(A(:,:,:,nn), h*w, c),'rows');
end
map=unique(cell2mat(uns'),'rows');

A = reshape(permute(A, [1 2 4 3]), h, w*n, c);

if size(map, 1) > 256
    dither_str = {'dither', 'nodither'};
    dither_str = dither_str{1+(options.dither==0)};
    if options.ncolors <= 1
        [B, map] = rgb2ind(A, options.ncolors, dither_str);
        if size(map, 1) > 256
            [B, map] = rgb2ind(A, 256, dither_str);
        end
    else
        [B, map] = rgb2ind(A, min(round(options.ncolors), 256), dither_str);
    end
else
    if max(map(:)) > 1
        map = double(map) / 255;
        A = double(A) / 255;
    end
    B = rgb2ind(im2double(A), map);
end
B = reshape(B, h, w, 1, n);

% Bug fix to rgb2ind
map(B(1)+1,:) = im2double(A(1,1,:));

% Save as a gif
imwrite(B, map, options.outfile, 'LoopCount', round(options.loops(1)), 'DelayTime', options.delay);
end

%% Parse the input arguments
function [A, options] = parse_args_im2gif(A, varargin)
% Set the defaults
options = struct('outfile', '', ...
                 'dither', true, ...
                 'crop', true, ...
                 'ncolors', 256, ...
                 'loops', 65535, ...
                 'delay', 1/15);

% Go through the arguments
a = 0;
n = numel(varargin);
while a < n
    a = a + 1;
    if ischar(varargin{a}) && ~isempty(varargin{a})
        if varargin{a}(1) == '-'
            opt = lower(varargin{a}(2:end));
            switch opt
                case 'nocrop'
                    options.crop = false;
                case 'nodither'
                    options.dither = false;
                otherwise
                    if ~isfield(options, opt)
                        error('Option %s not recognized', varargin{a});
                    end
                    a = a + 1;
                    if ischar(varargin{a}) && ~ischar(options.(opt))
                        options.(opt) = str2double(varargin{a});
                    else
                        options.(opt) = varargin{a};
                    end
            end
        else
            options.outfile = varargin{a};
        end
    end
end

if isempty(options.outfile)
    if ~ischar(A)
        error('No output filename given.');
    end
    % Generate the output filename from the input filename
    [path, outfile] = fileparts(A);
    options.outfile = fullfile(path, [outfile '.gif']);
end

if ischar(A)
    % Read in the image
    A = imread_rgb(A);
end
end

%% Read image to uint8 rgb array
function [A, alpha] = imread_rgb(name)
% Get file info
info = imfinfo(name);
% Special case formats
switch lower(info(1).Format)
    case 'gif'
        [A, map] = imread(name, 'frames', 'all');
        if ~isempty(map)
            map = uint8(map * 256 - 0.5); % Convert to uint8 for storage
            A = reshape(map(uint32(A)+1,:), [size(A) size(map, 2)]); % Assume indexed from 0
            A = permute(A, [1 2 5 4 3]);
        end
    case {'tif', 'tiff'}
        A = cell(numel(info), 1);
        for a = 1:numel(A)
            [A{a}, map] = imread(name, 'Index', a, 'Info', info);
            if ~isempty(map)
                map = uint8(map * 256 - 0.5); % Convert to uint8 for storage
                A{a} = reshape(map(uint32(A{a})+1,:), [size(A) size(map, 2)]); % Assume indexed from 0
            end
            if size(A{a}, 3) == 4
                % TIFF in CMYK colourspace - convert to RGB
                if isfloat(A{a})
                    A{a} = A{a} * 255;
                else
                    A{a} = single(A{a});
                end
                A{a} = 255 - A{a};
                A{a}(:,:,4) = A{a}(:,:,4) / 255;
                A{a} = uint8(A(:,:,1:3) .* A{a}(:,:,[4 4 4]));
            end
        end
        A = cat(4, A{:});
    otherwise
        [A, map, alpha] = imread(name);
        A = A(:,:,:,1); % Keep only first frame of multi-frame files
        if ~isempty(map)
            map = uint8(map * 256 - 0.5); % Convert to uint8 for storage
            A = reshape(map(uint32(A)+1,:), [size(A) size(map, 2)]); % Assume indexed from 0
        elseif size(A, 3) == 4
            % Assume 4th channel is an alpha matte
            alpha = A(:,:,4);
            A = A(:,:,1:3);
        end
end
end

function fh = isolate_axes(ah, vis)
%ISOLATE_AXES Isolate the specified axes in a figure on their own
%
% Examples:
%   fh = isolate_axes(ah)
%   fh = isolate_axes(ah, vis)
%
% This function will create a new figure containing the axes/uipanels
% specified, and also their associated legends and colorbars. The objects
% specified must all be in the same figure, but they will generally only be
% a subset of the objects in the figure.
%
% IN:
%    ah - An array of axes and uipanel handles, which must come from the
%         same figure.
%    vis - A boolean indicating whether the new figure should be visible.
%          Default: false.
%
% OUT:
%    fh - The handle of the created figure.

% Copyright (C) Oliver Woodford 2011-2013

% Thank you to Rosella Blatt for reporting a bug to do with axes in GUIs
% 16/03/12: Moved copyfig to its own function. Thanks to Bob Fratantonio
%           for pointing out that the function is also used in export_fig.m
% 12/12/12: Add support for isolating uipanels. Thanks to michael for suggesting it
% 08/10/13: Bug fix to allchildren suggested by Will Grant (many thanks!)
% 05/12/13: Bug fix to axes having different units. Thanks to Remington Reid for reporting
% 21/04/15: Bug fix for exporting uipanels with legend/colorbar on HG1 (reported by Alvaro
%           on FEX page as a comment on 24-Apr-2014); standardized indentation & help section
% 22/04/15: Bug fix: legends and colorbars were not exported when exporting axes handle in HG2

    % Make sure we have an array of handles
    if ~all(ishandle(ah))
        error('ah must be an array of handles');
    end
    % Check that the handles are all for axes or uipanels, and are all in the same figure
    fh = ancestor(ah(1), 'figure');
    nAx = numel(ah);
    for a = 1:nAx
        if ~ismember(get(ah(a), 'Type'), {'axes', 'uipanel'})
            error('All handles must be axes or uipanel handles.');
        end
        if ~isequal(ancestor(ah(a), 'figure'), fh)
            error('Axes must all come from the same figure.');
        end
    end
    % Tag the objects so we can find them in the copy
    old_tag = get(ah, 'Tag');
    if nAx == 1
        old_tag = {old_tag};
    end
    set(ah, 'Tag', 'ObjectToCopy');
    % Create a new figure exactly the same as the old one
    fh = copyfig(fh); %copyobj(fh, 0);
    if nargin < 2 || ~vis
        set(fh, 'Visible', 'off');
    end
    % Reset the object tags
    for a = 1:nAx
        set(ah(a), 'Tag', old_tag{a});
    end
    % Find the objects to save
    ah = findall(fh, 'Tag', 'ObjectToCopy');
    if numel(ah) ~= nAx
        close(fh);
        error('Incorrect number of objects found.');
    end
    % Set the axes tags to what they should be
    for a = 1:nAx
        set(ah(a), 'Tag', old_tag{a});
    end
    % Keep any legends and colorbars which overlap the subplots
    % Note: in HG1 these are axes objects; in HG2 they are separate objects, therefore we
    %       don't test for the type, only the tag (hopefully nobody but Matlab uses them!)
    lh = findall(fh, 'Tag', 'legend', '-or', 'Tag', 'Colorbar');
    nLeg = numel(lh);
    if nLeg > 0
        set([ah(:); lh(:)], 'Units', 'normalized');
        try
            ax_pos = get(ah, 'OuterPosition'); % axes and figures have the OuterPosition property
        catch
            ax_pos = get(ah, 'Position'); % uipanels only have Position, not OuterPosition
        end
        if nAx > 1
            ax_pos = cell2mat(ax_pos(:));
        end
        ax_pos(:,3:4) = ax_pos(:,3:4) + ax_pos(:,1:2);
        try
            leg_pos = get(lh, 'OuterPosition');
        catch
            leg_pos = get(lh, 'Position');  % No OuterPosition in HG2, only in HG1
        end
        if nLeg > 1;
            leg_pos = cell2mat(leg_pos);
        end
        leg_pos(:,3:4) = leg_pos(:,3:4) + leg_pos(:,1:2);
        ax_pos = shiftdim(ax_pos, -1);
        % Overlap test
        M = bsxfun(@lt, leg_pos(:,1), ax_pos(:,:,3)) & ...
            bsxfun(@lt, leg_pos(:,2), ax_pos(:,:,4)) & ...
            bsxfun(@gt, leg_pos(:,3), ax_pos(:,:,1)) & ...
            bsxfun(@gt, leg_pos(:,4), ax_pos(:,:,2));
        ah = [ah; lh(any(M, 2))];
    end
    % Get all the objects in the figure
    axs = findall(fh);
    % Delete everything except for the input objects and associated items
    delete(axs(~ismember(axs, [ah; allchildren(ah); allancestors(ah)])));
end

function ah = allchildren(ah)
    ah = findall(ah);
    if iscell(ah)
        ah = cell2mat(ah);
    end
    ah = ah(:);
end

function ph = allancestors(ah)
    ph = [];
    for a = 1:numel(ah)
        h = get(ah(a), 'parent');
        while h ~= 0
            ph = [ph; h];
            h = get(h, 'parent');
        end
    end
end

%PDF2EPS  Convert a pdf file to eps format using pdftops
%
% Examples:
%   pdf2eps source dest
%
% This function converts a pdf file to eps format.
%
% This function requires that you have pdftops, from the Xpdf suite of
% functions, installed on your system. This can be downloaded from:
% http://xpdfreader.com
%
% Inputs:
%   source - filename of the source pdf file to convert. The filename is
%            assumed to already have the extension ".pdf".
%   dest - filename of the destination eps file. The filename is assumed to
%          already have the extension ".eps".

% Copyright (C) Oliver Woodford 2009-2010, Yair Altman 2015-

% Thanks to Aldebaro Klautau for reporting a bug when saving to
% non-existant directories.

% 22/09/2018 - Xpdf website changed to xpdfreader.com

function pdf2eps(source, dest)
    % Construct the options string for pdftops
    options = ['-q -paper match -eps -level2 "' source '" "' dest '"'];

    % Convert to eps using pdftops
    [status, message] = pdftops(options);

    % Check for error
    if status
        % Report error
        if isempty(message)
            error('Unable to generate eps. Check destination directory is writable.');
        else
            error(message);
        end
    end

    % Fix the DSC error created by pdftops
    fid = fopen(dest, 'r+');
    if fid == -1
        % Cannot open the file
        return
    end
    fgetl(fid); % Get the first line
    str = fgetl(fid); % Get the second line
    if strcmp(str(1:min(13, end)), '% Produced by')
        fseek(fid, -numel(str)-1, 'cof');
        fwrite(fid, '%'); % Turn ' ' into '%'
    end
    fclose(fid);
end

function varargout = pdftops(cmd)
%PDFTOPS  Calls a local pdftops executable with the input command
%
% Example:
%   [status result] = pdftops(cmd)
%
% Attempts to locate a pdftops executable, finally asking the user to
% specify the directory pdftops was installed into. The resulting path is
% stored for future reference.
% 
% Once found, the executable is called with the input command string.
%
% This function requires that you have pdftops (from the Xpdf package)
% installed on your system. You can download this from: http://xpdfreader.com
%
% IN:
%   cmd - Command string to be passed into pdftops (e.g. '-help').
%
% OUT:
%   status - 0 iff command ran without problem.
%   result - Output from pdftops.

% Copyright: Oliver Woodford, 2009-2010

% Thanks to Jonas Dorn for the fix for the title of the uigetdir window on Mac OS.
% Thanks to Christoph Hertel for pointing out a bug in check_xpdf_path under linux.
% 23/01/2014 - Add full path to pdftops.txt in warning.
% 27/05/2015 - Fixed alert in case of missing pdftops; fixed code indentation
% 02/05/2016 - Added possible error explanation suggested by Michael Pacer (issue #137)
% 02/05/2016 - Search additional possible paths suggested by Jonas Stein (issue #147)
% 03/05/2016 - Display the specific error message if pdftops fails for some reason (issue #148)
% 22/09/2018 - Xpdf website changed to xpdfreader.com; improved popup logic

    % Call pdftops
    [varargout{1:nargout}] = system([xpdf_command(xpdf_path()) cmd]);
end

function path_ = xpdf_path
    % Return a valid path
    % Start with the currently set path
    path_ = user_string('pdftops');
    % Check the path works
    if check_xpdf_path(path_)
        return
    end
    % Check whether the binary is on the path
    if ispc
        bin = 'pdftops.exe';
    else
        bin = 'pdftops';
    end
    if check_store_xpdf_path(bin)
        path_ = bin;
        return
    end
    % Search the obvious places
    if ispc
        paths = {'C:\Program Files\xpdf\pdftops.exe', 'C:\Program Files (x86)\xpdf\pdftops.exe'};
    else
        paths = {'/usr/bin/pdftops', '/usr/local/bin/pdftops'};
    end
    for a = 1:numel(paths)
        path_ = paths{a};
        if check_store_xpdf_path(path_)
            return
        end
    end

    % Ask the user to enter the path
    errMsg1 = 'Pdftops not found. Please locate the program, or install xpdf-tools from ';
    url1 = 'http://xpdfreader.com/download.html'; %='http://foolabs.com/xpdf';
    fprintf(2, '%s\n', [errMsg1 '<a href="matlab:web(''-browser'',''' url1 ''');">' url1 '</a>']);
    errMsg1 = [errMsg1 url1];
    %if strncmp(computer,'MAC',3) % Is a Mac
    %    % Give separate warning as the MacOS uigetdir dialogue box doesn't have a title
    %    uiwait(warndlg(errMsg1))
    %end

    % Provide an alternative possible explanation as per issue #137
    errMsg2 = 'If you have pdftops installed, perhaps Matlab is shaddowing it as described in ';
    url2 = 'https://github.com/altmany/export_fig/issues/137';
    fprintf(2, '%s\n', [errMsg2 '<a href="matlab:web(''-browser'',''' url2 ''');">issue #137</a>']);
    errMsg2 = [errMsg2 url1];

    state = 1;
    while 1
        if state
            option1 = 'Install pdftops';
        else
            option1 = 'Issue #137';
        end
        answer = questdlg({errMsg1,'',errMsg2},'Pdftops error',option1,'Locate pdftops','Cancel','Cancel');
        drawnow;  % prevent a Matlab hang: http://undocumentedmatlab.com/blog/solving-a-matlab-hang-problem
        switch answer
            case 'Install pdftops'
                web('-browser',url1);
                state = 0;
            case 'Issue #137'
                web('-browser',url2);
                state = 1;
            case 'Locate pdftops'
                base = uigetdir('/', errMsg1);
                if isequal(base, 0)
                    % User hit cancel or closed window
                    break
                end
                base = [base filesep]; %#ok<AGROW>
                bin_dir = {'', ['bin' filesep], ['lib' filesep]};
                for a = 1:numel(bin_dir)
                    path_ = [base bin_dir{a} bin];
                    if exist(path_, 'file') == 2
                        break
                    end
                end
                if check_store_xpdf_path(path_)
                    return
                end

            otherwise  % User hit Cancel or closed window
                break
        end
    end
    error('pdftops executable not found.');
end

function good = check_store_xpdf_path(path_)
    % Check the path is valid
    good = check_xpdf_path(path_);
    if ~good
        return
    end
    % Update the current default path to the path found
    if ~user_string('pdftops', path_)
        warning('Path to pdftops executable could not be saved. Enter it manually in %s.', fullfile(fileparts(which('user_string.m')), '.ignore', 'pdftops.txt'));
        return
    end
end

function good = check_xpdf_path(path_)
    % Check the path is valid
    [good, message] = system([xpdf_command(path_) '-h']); %#ok<ASGLU>
    % system returns good = 1 even when the command runs
    % Look for something distinct in the help text
    good = ~isempty(strfind(message, 'PostScript')); %#ok<STREMP>

    % Display the error message if the pdftops executable exists but fails for some reason
    if ~good && exist(path_,'file')  % file exists but generates an error
        fprintf('Error running %s:\n', path_);
        fprintf(2,'%s\n\n',message);
    end
end

function cmd = xpdf_command(path_)
    % Initialize any required system calls before calling ghostscript
    % TODO: in Unix/Mac, find a way to determine whether to use "export" (bash) or "setenv" (csh/tcsh)
    shell_cmd = '';
    if isunix
        % Avoids an error on Linux with outdated MATLAB lib files
        % R20XXa/bin/glnxa64/libtiff.so.X
        % R20XXa/sys/os/glnxa64/libstdc++.so.X
        shell_cmd = 'export LD_LIBRARY_PATH=""; ';
    end
    if ismac
        shell_cmd = 'export DYLD_LIBRARY_PATH=""; ';
    end
    % Construct the command string
    cmd = sprintf('%s"%s" ', shell_cmd, path_);
end

function [A, bcol] = print2array(fig, res, renderer, gs_options)
%PRINT2ARRAY  Exports a figure to an image array
%
% Examples:
%   A = print2array
%   A = print2array(figure_handle)
%   A = print2array(figure_handle, resolution)
%   A = print2array(figure_handle, resolution, renderer)
%   A = print2array(figure_handle, resolution, renderer, gs_options)
%   [A bcol] = print2array(...)
%
% This function outputs a bitmap image of the given figure, at the desired
% resolution.
%
% If renderer is '-painters' then ghostcript needs to be installed. This
% can be downloaded from: http://www.ghostscript.com
%
% IN:
%   figure_handle - The handle of the figure to be exported. Default: gcf.
%   resolution - Resolution of the output, as a factor of screen
%                resolution. Default: 1.
%   renderer - string containing the renderer paramater to be passed to
%              print. Default: '-opengl'.
%   gs_options - optional ghostscript options (e.g.: '-dNoOutputFonts'). If
%                multiple options are needed, enclose in call array: {'-a','-b'}
%
% OUT:
%   A - MxNx3 uint8 image of the figure.
%   bcol - 1x3 uint8 vector of the background color

% Copyright (C) Oliver Woodford 2008-2014, Yair Altman 2015-
%{
% 05/09/11: Set EraseModes to normal when using opengl or zbuffer
%           renderers. Thanks to Pawel Kocieniewski for reporting the issue.
% 21/09/11: Bug fix: unit8 -> uint8! Thanks to Tobias Lamour for reporting it.
% 14/11/11: Bug fix: stop using hardcopy(), as it interfered with figure size
%           and erasemode settings. Makes it a bit slower, but more reliable.
%           Thanks to Phil Trinh and Meelis Lootus for reporting the issues.
% 09/12/11: Pass font path to ghostscript.
% 27/01/12: Bug fix affecting painters rendering tall figures. Thanks to
%           Ken Campbell for reporting it.
% 03/04/12: Bug fix to median input. Thanks to Andy Matthews for reporting it.
% 26/10/12: Set PaperOrientation to portrait. Thanks to Michael Watts for
%           reporting the issue.
% 26/02/15: If temp dir is not writable, use the current folder for temp
%           EPS/TIF files (Javier Paredes)
% 27/02/15: Display suggested workarounds to internal print() error (issue #16)
% 28/02/15: Enable users to specify optional ghostscript options (issue #36)
% 10/03/15: Fixed minor warning reported by Paul Soderlind; fixed code indentation
% 28/05/15: Fixed issue #69: patches with LineWidth==0.75 appear wide (internal bug in Matlab's print() func)
% 07/07/15: Fixed issue #83: use numeric handles in HG1
% 11/12/16: Fixed cropping issue reported by Harry D.
% 29/09/18: Fixed issue #254: error in print2array>read_tif_img
%}

    % Generate default input arguments, if needed
    if nargin < 2
        res = 1;
        if nargin < 1
            fig = gcf;
        end
    end
    % Warn if output is large
    old_mode = get(fig, 'Units');
    set(fig, 'Units', 'pixels');
    px = get(fig, 'Position');
    set(fig, 'Units', old_mode);
    npx = prod(px(3:4)*res)/1e6;
    if npx > 30
        % 30M pixels or larger!
        warning('MATLAB:LargeImage', 'print2array generating a %.1fM pixel image. This could be slow and might also cause memory problems.', npx);
    end
    % Retrieve the background colour
    bcol = get(fig, 'Color');
    % Set the resolution parameter
    res_str = ['-r' num2str(ceil(get(0, 'ScreenPixelsPerInch')*res))];
    % Generate temporary file name
    tmp_nam = [tempname '.tif'];
    try
        % Ensure that the temp dir is writable (Javier Paredes 26/2/15)
        fid = fopen(tmp_nam,'w');
        fwrite(fid,1);
        fclose(fid);
        delete(tmp_nam);  % cleanup
        isTempDirOk = true;
    catch
        % Temp dir is not writable, so use the current folder
        [dummy,fname,fext] = fileparts(tmp_nam); %#ok<ASGLU>
        fpath = pwd;
        tmp_nam = fullfile(fpath,[fname fext]);
        isTempDirOk = false;
    end
    % Enable users to specify optional ghostscript options (issue #36)
    if nargin > 3 && ~isempty(gs_options)
        if iscell(gs_options)
            gs_options = sprintf(' %s',gs_options{:});
        elseif ~ischar(gs_options)
            error('gs_options input argument must be a string or cell-array of strings');
        else
            gs_options = [' ' gs_options];
        end
    else
        gs_options = '';
    end
    if nargin > 2 && strcmp(renderer, '-painters')
        % First try to print directly to tif file
        try
            % Print the file into a temporary TIF file and read it into array A
            [A, err, ex] = read_tif_img(fig, res_str, renderer, tmp_nam);
            if err, rethrow(ex); end
        catch  % error - try to print to EPS and then using Ghostscript to TIF
            % Print to eps file
            if isTempDirOk
                tmp_eps = [tempname '.eps'];
            else
                tmp_eps = fullfile(fpath,[fname '.eps']);
            end
            print2eps(tmp_eps, fig, 0, renderer, '-loose');
            try
                % Initialize the command to export to tiff using ghostscript
                cmd_str = ['-dEPSCrop -q -dNOPAUSE -dBATCH ' res_str ' -sDEVICE=tiff24nc'];
                % Set the font path
                fp = font_path_print2array();
                if ~isempty(fp)
                    cmd_str = [cmd_str ' -sFONTPATH="' fp '"'];
                end
                % Add the filenames
                cmd_str = [cmd_str ' -sOutputFile="' tmp_nam '" "' tmp_eps '"' gs_options];
                % Execute the ghostscript command
                ghostscript(cmd_str);
            catch me
                % Delete the intermediate file
                delete(tmp_eps);
                rethrow(me);
            end
            % Delete the intermediate file
            delete(tmp_eps);
            % Read in the generated bitmap
            A = imread(tmp_nam);
            % Delete the temporary bitmap file
            delete(tmp_nam);
        end
        % Set border pixels to the correct colour
        if isequal(bcol, 'none')
            bcol = [];
        elseif isequal(bcol, [1 1 1])
            bcol = uint8([255 255 255]);
        else
            for l = 1:size(A, 2)
                if ~all(reshape(A(:,l,:) == 255, [], 1))
                    break;
                end
            end
            for r = size(A, 2):-1:l
                if ~all(reshape(A(:,r,:) == 255, [], 1))
                    break;
                end
            end
            for t = 1:size(A, 1)
                if ~all(reshape(A(t,:,:) == 255, [], 1))
                    break;
                end
            end
            for b = size(A, 1):-1:t
                if ~all(reshape(A(b,:,:) == 255, [], 1))
                    break;
                end
            end
            bcol = uint8(median(single([reshape(A(:,[l r],:), [], size(A, 3)); reshape(A([t b],:,:), [], size(A, 3))]), 1));
            for c = 1:size(A, 3)
                A(:,[1:l-1, r+1:end],c) = bcol(c);
                A([1:t-1, b+1:end],:,c) = bcol(c);
            end
        end
    else
        if nargin < 3
            renderer = '-opengl';
        end
        % Print the file into a temporary TIF file and read it into array A
        [A, err, ex] = read_tif_img(fig, res_str, renderer, tmp_nam);
        % Throw any error that occurred
        if err
            % Display suggested workarounds to internal print() error (issue #16)
            fprintf(2, 'An error occured with Matlab''s builtin print function.\nTry setting the figure Renderer to ''painters'' or use opengl(''software'').\n\n');
            rethrow(ex);
        end
        % Set the background color
        if isequal(bcol, 'none')
            bcol = [];
        else
            bcol = bcol * 255;
            if isequal(bcol, round(bcol))
                bcol = uint8(bcol);
            else
                bcol = squeeze(A(1,1,:));
            end
        end
    end
    % Check the output size is correct
    if isequal(res, round(res))
        px = round([px([4 3])*res 3]);  % round() to avoid an indexing warning below
        if ~isequal(size(A), px)
            % Correct the output size
            A = A(1:min(end,px(1)),1:min(end,px(2)),:);
        end
    end
end

% Function to create a TIF image of the figure and read it into an array
function [A, err, ex] = read_tif_img(fig, res_str, renderer, tmp_nam)
    A =  [];  % fix for issue #254
    err = false;
    ex = [];
    % Temporarily set the paper size
    old_pos_mode    = get(fig, 'PaperPositionMode');
    old_orientation = get(fig, 'PaperOrientation');
    set(fig, 'PaperPositionMode','auto', 'PaperOrientation','portrait');
    try
        % Workaround for issue #69: patches with LineWidth==0.75 appear wide (internal bug in Matlab's print() function)
        fp = [];  % in case we get an error below
        fp = findall(fig, 'Type','patch', 'LineWidth',0.75);
        set(fp, 'LineWidth',0.5);
        % Fix issue #83: use numeric handles in HG1
        if ~using_hg2(fig),  fig = double(fig);  end
        % Print to tiff file
        print(fig, renderer, res_str, '-dtiff', tmp_nam);
        % Read in the printed file
        A = imread(tmp_nam);
        % Delete the temporary file
        delete(tmp_nam);
    catch ex
        err = true;
    end
    set(fp, 'LineWidth',0.75);  % restore original figure appearance
    % Reset the paper size
    set(fig, 'PaperPositionMode',old_pos_mode, 'PaperOrientation',old_orientation);
end

% Function to return (and create, where necessary) the font path
function fp = font_path_print2array()
    fp = user_string('gs_font_path');
    if ~isempty(fp)
        return
    end
    % Create the path
    % Start with the default path
    fp = getenv('GS_FONTPATH');
    % Add on the typical directories for a given OS
    if ispc
        if ~isempty(fp)
            fp = [fp ';'];
        end
        fp = [fp getenv('WINDIR') filesep 'Fonts'];
    else
        if ~isempty(fp)
            fp = [fp ':'];
        end
        fp = [fp '/usr/share/fonts:/usr/local/share/fonts:/usr/share/fonts/X11:/usr/local/share/fonts/X11:/usr/share/fonts/truetype:/usr/local/share/fonts/truetype'];
    end
    user_string('gs_font_path', fp);
end

function print2eps(name, fig, export_options, varargin)
%PRINT2EPS  Prints figures to eps with improved line styles
%
% Examples:
%   print2eps filename
%   print2eps(filename, fig_handle)
%   print2eps(filename, fig_handle, export_options)
%   print2eps(filename, fig_handle, export_options, print_options)
%
% This function saves a figure as an eps file, with two improvements over
% MATLAB's print command. First, it improves the line style, making dashed
% lines more like those on screen and giving grid lines a dotted line style.
% Secondly, it substitutes original font names back into the eps file,
% where these have been changed by MATLAB, for up to 11 different fonts.
%
%IN:
%   filename - string containing the name (optionally including full or
%              relative path) of the file the figure is to be saved as. A
%              ".eps" extension is added if not there already. If a path is
%              not specified, the figure is saved in the current directory.
%   fig_handle - The handle of the figure to be saved. Default: gcf().
%   export_options - array or struct of optional scalar values:
%       bb_padding - Scalar value of amount of padding to add to border around
%                    the cropped image, in points (if >1) or percent (if <1).
%                    Can be negative as well as positive; Default: 0
%       crop       - Cropping flag. Deafult: 0
%       fontswap   - Whether to swap non-default fonts in figure. Default: true
%       font_space - Character used to separate font-name terms in the EPS output
%                    e.g. "Courier New" => "Courier-New". Default: ''
%                    (available only via the struct alternative)
%       renderer   - Renderer used to generate bounding-box. Default: 'opengl'
%                    (available only via the struct alternative)
%       crop_amounts - 4-element vector of crop amounts: [top,right,bottom,left]
%                    (available only via the struct alternative)
%   print_options - Additional parameter strings to be passed to the print command

%{
% Copyright (C) Oliver Woodford 2008-2014, Yair Altman 2015-

% The idea of editing the EPS file to change line styles comes from Jiro
% Doke's FIXPSLINESTYLE (fex id: 17928)
% The idea of changing dash length with line width came from comments on
% fex id: 5743, but the implementation is mine :)
%}
%{
% 14/11/11: Fix a MATLAB bug rendering black or white text incorrectly.
%           Thanks to Mathieu Morlighem for reporting the issue and
%           obtaining a fix from TMW.
% 08/12/11: Added ability to correct fonts. Several people have requested
%           this at one time or another, and also pointed me to printeps
%           (fex id: 7501), so thank you to them. My implementation (which
%           was not inspired by printeps - I'd already had the idea for my
%           approach) goes slightly further in that it allows multiple
%           fonts to be swapped.
% 14/12/11: Fix bug affecting font names containing spaces. Thanks to David
%           Szwer for reporting the issue.
% 25/01/12: Add a font not to be swapped. Thanks to Anna Rafferty and Adam
%           Jackson for reporting the issue. Also fix a bug whereby using a
%           font alias can lead to another font being swapped in.
% 10/04/12: Make the font swapping case insensitive.
% 26/10/12: Set PaperOrientation to portrait. Thanks to Michael Watts for
%           reporting the issue.
% 26/10/12: Fix issue to do with swapping fonts changing other fonts and
%           sizes we don't want, due to listeners. Thanks to Malcolm Hudson
%           for reporting the issue.
% 22/03/13: Extend font swapping to axes labels. Thanks to Rasmus Ischebeck
%           for reporting the issue.
% 23/07/13: Bug fix to font swapping. Thanks to George for reporting the
%           issue.
% 13/08/13: Fix MATLAB feature of not exporting white lines correctly.
%           Thanks to Sebastian Hesslinger for reporting it.
% 24/02/15: Fix for Matlab R2014b bug (issue #31): LineWidths<0.75 are not
%           set in the EPS (default line width is used)
% 25/02/15: Fixed issue #32: BoundingBox problem caused uncropped EPS/PDF files
% 05/03/15: Fixed issue #43: Inability to perform EPS file post-processing
% 06/03/15: Improved image padding & cropping thanks to Oscar Hartogensis
% 21/03/15: Fixed edge-case of missing handles having a 'FontName' property
% 26/03/15: Attempt to fix issue #45: white lines in subplots do not print correctly
% 27/03/15: Attempt to fix issue #44: white artifact lines appearing in patch exports
% 30/03/15: Fixed issue #52: improved performance on HG2 (R2014b+)
% 09/04/15: Comment blocks consolidation and minor code cleanup (no real code change)
% 12/04/15: Fixed issue #56: bad cropping
% 14/04/15: Workaround for issue #45: lines in image subplots are exported in invalid color
% 07/07/15: Added option to avoid font-swapping in EPS/PDF
% 07/07/15: Fixed issue #83: use numeric handles in HG1
% 22/07/15: Fixed issue #91 (thanks to Carlos Moffat)
% 28/09/15: Fixed issue #108 (thanks to JacobD10)
% 01/11/15: Fixed issue #112: optional renderer for bounding-box computation (thanks to Jess Pestana Puerta)
% 21/02/16: Enabled specifying non-automated crop amounts
% 22/02/16: Better support + backward compatibility for transparency (issue #108)
% 10/06/16: Fixed issue #159: text handles get cleared by Matlab in the print() command
% 12/06/16: Improved the fix for issue #159 (in the previous commit)
% 12/06/16: Fixed issue #158: transparent patch color in PDF/EPS
% 18/09/17: Fixed issue #194: incorrect fonts in EPS/PDF output
% 18/09/17: Fixed issue #195: relaxed too-tight cropping in EPS/PDF
% 14/11/17: Workaround for issue #211: dashed/dotted lines in 3D axes appear solid
% 15/11/17: Updated issue #211: only set SortMethod='ChildOrder' in HG2, and when it looks the same onscreen; support multiple figure axes
% 18/11/17: Fixed issue #225: transparent/translucent dashed/dotted lines appear solid in EPS/PDF
% 24/03/18: Fixed issue #239: black title meshes with temporary black background figure bgcolor, causing bad cropping
%}

    options = {'-loose'};
    if nargin > 3
        options = [options varargin];
    elseif nargin < 3
        export_options = 0;
        if nargin < 2
            fig = gcf();
        end
    end

    % Retrieve padding, crop & font-swap values
    crop_amounts = nan(1,4);  % auto-crop all 4 sides by default
    if isstruct(export_options)
        try fontswap     = export_options.fontswap;     catch, fontswap = true;     end
        try font_space   = export_options.font_space;   catch, font_space = '';     end
        font_space(2:end) = '';
        try bb_crop      = export_options.crop;         catch, bb_crop = 0;         end
        try crop_amounts = export_options.crop_amounts; catch,                      end
        try bb_padding   = export_options.bb_padding;   catch, bb_padding = 0;      end
        try renderer     = export_options.rendererStr;  catch, renderer = 'opengl'; end  % fix for issue #110
        if renderer(1)~='-',  renderer = ['-' renderer];  end
    else
        if numel(export_options) > 2  % font-swapping
            fontswap = export_options(3);
        else
            fontswap = true;
        end
        if numel(export_options) > 1  % cropping
            bb_crop = export_options(2);
        else
            bb_crop = 0;  % scalar value, so use default bb_crop value of 0
        end
        if numel(export_options) > 0  % padding
            bb_padding = export_options(1);
        else
            bb_padding = 0;
        end
        renderer = '-opengl';
        font_space = '';
    end

    % Construct the filename
    if numel(name) < 5 || ~strcmpi(name(end-3:end), '.eps')
        name = [name '.eps']; % Add the missing extension
    end

    % Set paper size
    old_pos_mode = get(fig, 'PaperPositionMode');
    old_orientation = get(fig, 'PaperOrientation');
    set(fig, 'PaperPositionMode', 'auto', 'PaperOrientation', 'portrait');

    % Find all the used fonts in the figure
    font_handles = findall(fig, '-property', 'FontName');
    fonts = get(font_handles, 'FontName');
    if isempty(fonts)
        fonts = {};
    elseif ~iscell(fonts)
        fonts = {fonts};
    end

    % Map supported font aliases onto the correct name
    fontsl = lower(fonts);
    for a = 1:numel(fonts)
        f = fontsl{a};
        f(f==' ') = [];
        switch f
            case {'times', 'timesnewroman', 'times-roman'}
                fontsl{a} = 'times-roman';
            case {'arial', 'helvetica'}
                fontsl{a} = 'helvetica';
            case {'newcenturyschoolbook', 'newcenturyschlbk'}
                fontsl{a} = 'newcenturyschlbk';
            otherwise
        end
    end
    fontslu = unique(fontsl);

    % Determine the font swap table
    if fontswap
        matlab_fonts = {'Helvetica', 'Times-Roman', 'Palatino', 'Bookman', 'Helvetica-Narrow', 'Symbol', ...
                        'AvantGarde', 'NewCenturySchlbk', 'Courier', 'ZapfChancery', 'ZapfDingbats'};
        matlab_fontsl = lower(matlab_fonts);
        require_swap = find(~ismember(fontslu, matlab_fontsl));
        unused_fonts = find(~ismember(matlab_fontsl, fontslu));
        font_swap = cell(3, min(numel(require_swap), numel(unused_fonts)));
        fonts_new = fonts;
        for a = 1:size(font_swap, 2)
            font_swap{1,a} = find(strcmp(fontslu{require_swap(a)}, fontsl));
            font_swap{2,a} = matlab_fonts{unused_fonts(a)};
            font_swap{3,a} = fonts{font_swap{1,a}(1)};
            fonts_new(font_swap{1,a}) = font_swap(2,a);
        end
    else
        font_swap = [];
    end

    % Swap the fonts
    if ~isempty(font_swap)
        fonts_size = get(font_handles, 'FontSize');
        if iscell(fonts_size)
            fonts_size = cell2mat(fonts_size);
        end
        M = false(size(font_handles));

        % Loop because some changes may not stick first time, due to listeners
        c = 0;
        update = zeros(1000, 1);
        for b = 1:10 % Limit number of loops to avoid infinite loop case
            for a = 1:numel(M)
                M(a) = ~isequal(get(font_handles(a), 'FontName'), fonts_new{a}) || ~isequal(get(font_handles(a), 'FontSize'), fonts_size(a));
                if M(a)
                    set(font_handles(a), 'FontName', fonts_new{a}, 'FontSize', fonts_size(a));
                    c = c + 1;
                    update(c) = a;
                end
            end
            if ~any(M)
                break;
            end
        end

        % Compute the order to revert fonts later, without the need of a loop
        [update, M] = unique(update(1:c));
        [dummy, M] = sort(M); %#ok<ASGLU>
        update = reshape(update(M), 1, []);
    end

    % MATLAB bug fix - black and white text can come out inverted sometimes
    % Find the white and black text
    black_text_handles = findall(fig, 'Type', 'text', 'Color', [0 0 0]);
    white_text_handles = findall(fig, 'Type', 'text', 'Color', [1 1 1]);
    % Set the font colors slightly off their correct values
    set(black_text_handles, 'Color', [0 0 0] + eps);
    set(white_text_handles, 'Color', [1 1 1] - eps);

    % MATLAB bug fix - white lines can come out funny sometimes
    % Find the white lines
    white_line_handles = findall(fig, 'Type', 'line', 'Color', [1 1 1]);
    % Set the line color slightly off white
    set(white_line_handles, 'Color', [1 1 1] - 0.00001);

    % MATLAB bug fix (issue #211): dashed/dotted lines in 3D axes appear solid
    % Note: this "may limit other functionality in plotting such as hidden line/surface removal"
    % reference: Technical Support Case #02838114, https://mail.google.com/mail/u/0/#inbox/15fb7659f70e7bd8
    hAxes = findall(fig, 'Type', 'axes');
    if using_hg2 && ~isempty(hAxes)  % issue #211 presumably happens only in HG2, not HG1
        try
            % If there are any axes using SortMethod~='ChildOrder'
            oldSortMethods = get(hAxes,{'SortMethod'});  % use {'SortMethod'} to ensure we get a cell array, even for single axes
            if any(~strcmpi('ChildOrder',oldSortMethods))  % i.e., any oldSortMethods=='depth'
                % Check if the axes look visually different onscreen when SortMethod='ChildOrder'
                imgBefore = print2array(fig);
                set(hAxes,'SortMethod','ChildOrder');
                imgAfter  = print2array(fig);
                if isequal(imgBefore, imgAfter)
                    % They look the same, so use SortMethod='ChildOrder' when generating the EPS
                else
                    % They look different, so revert SortMethod and issue a warning message
                    warning('YMA:export_fig:issue211', ...
                            ['You seem to be using axes that have overlapping/hidden graphic elements. ' 10 ...
                             'Setting axes.SortMethod=''ChildOrder'' may solve potential problems in EPS/PDF export. ' 10 ...
                             'Additional info: https://github.com/altmany/export_fig/issues/211'])
                    set(hAxes,{'SortMethod'},oldSortMethods);
                end
            end
        catch err
            % ignore
            a=err;  %#ok<NASGU> % debug breakpoint
        end
    end

    % Workaround for issue #45: lines in image subplots are exported in invalid color
    % In this case the -depsc driver solves the problem, but then all the other workarounds
    % below (for all the other issues) will fail, so it's better to let the user decide by
    % just issuing a warning and accepting the '-depsc' input parameter
    epsLevel2 = ~any(strcmpi(options,'-depsc'));
    if epsLevel2
        % Use -depsc2 (EPS color level-2) if -depsc (EPS color level-3) was not specifically requested
        options{end+1} = '-depsc2';
        % Issue a warning if multiple images & lines were found in the figure, and HG1 with painters renderer is used
        isPainters = any(strcmpi(options,'-painters'));
        if isPainters && ~using_hg2 && numel(findall(fig,'Type','image'))>1 && ~isempty(findall(fig,'Type','line'))
            warning('YMA:export_fig:issue45', ...
                    ['Multiple images & lines detected. In such cases, the lines might \n' ...
                     'appear with an invalid color due to an internal MATLAB bug (fixed in R2014b). \n' ...
                     'Possible workaround: add a ''-depsc'' or ''-opengl'' parameter to the export_fig command.']);
        end
    end

    % Fix issue #83: use numeric handles in HG1
    if ~using_hg2(fig),  fig = double(fig);  end

    % Workaround for when transparency is lost through conversion fig>EPS>PDF (issue #108)
    % Replace transparent patch RGB values with an ID value (rare chance that ID color is being used already)
    if using_hg2
        origAlphaColors = eps_maintainAlpha(fig);
    end

    % Print to eps file
    print(fig, options{:}, name);

    % Restore the original axes SortMethods (if updated)
    try set(hAxes,{'SortMethod'},oldSortMethods); catch, end

    % Do post-processing on the eps file
    try
        % Read the EPS file into memory
        fstrm = read_write_entire_textfile(name);
    catch
        fstrm = '';
    end

    % Restore colors for transparent patches/lines and apply the
    % setopacityalpha setting in the EPS file (issue #108)
    if using_hg2
        [~,fstrm,foundFlags] = eps_maintainAlpha(fig, fstrm, origAlphaColors);

        % If some of the transparencies were not found in the EPS file, then rerun the
        % export with only the found transparencies modified (backward compatibility)
        if ~isempty(fstrm) && ~all(foundFlags)
            foundIdx = find(foundFlags);
            for objIdx = 1 : sum(foundFlags)
                colorsIdx = foundIdx(objIdx);
                colorsData = origAlphaColors{colorsIdx};
                hObj     = colorsData{1};
                propName = colorsData{2};
                newColor = colorsData{4};
                hObj.(propName).ColorData = newColor;
            end
            delete(name);
            print(fig, options{:}, name);
            fstrm = read_write_entire_textfile(name);
            [~,fstrm] = eps_maintainAlpha(fig, fstrm, origAlphaColors(foundFlags));
        end
    end

    % Fix for Matlab R2014b bug (issue #31): LineWidths<0.75 are not set in the EPS (default line width is used)
    try
        if ~isempty(fstrm) && using_hg2(fig)
            % Convert miter joins to line joins
            %fstrm = regexprep(fstrm, '\n10.0 ML\n', '\n1 LJ\n');
            % This is faster (the original regexprep could take many seconds when the axes contains many lines):
            fstrm = strrep(fstrm, sprintf('\n10.0 ML\n'), sprintf('\n1 LJ\n'));

            % In HG2, grid lines and axes Ruler Axles have a default LineWidth of 0.5 => replace en-bulk (assume that 1.0 LineWidth = 1.333 LW)
            %   hAxes=gca; hAxes.YGridHandle.LineWidth, hAxes.YRuler.Axle.LineWidth
            %fstrm = regexprep(fstrm, '(GC\n2 setlinecap\n1 LJ)\nN', '$1\n0.667 LW\nN');
            % This is faster:
            fstrm = strrep(fstrm, sprintf('GC\n2 setlinecap\n1 LJ\nN'), sprintf('GC\n2 setlinecap\n1 LJ\n0.667 LW\nN'));

            % This is more accurate but *MUCH* slower (issue #52)
            %{
            % Modify all thin lines in the figure to have 10x LineWidths
            hLines = findall(fig,'Type','line');
            hThinLines = [];
            for lineIdx = 1 : numel(hLines)
                thisLine = hLines(lineIdx);
                if thisLine.LineWidth < 0.75 && strcmpi(thisLine.Visible,'on')
                    hThinLines(end+1) = thisLine; %#ok<AGROW>
                    thisLine.LineWidth = thisLine.LineWidth * 10;
                end
            end

            % If any thin lines were found
            if ~isempty(hThinLines)
                % Prepare an EPS with large-enough line widths
                print(fig, options{:}, name);
                % Restore the original LineWidths in the figure
                for lineIdx = 1 : numel(hThinLines)
                    thisLine = handle(hThinLines(lineIdx));
                    thisLine.LineWidth = thisLine.LineWidth / 10;
                end

                % Compare the original and the new EPS files and correct the original stream's LineWidths
                fstrm_new = read_write_entire_textfile(name);
                idx = 500;  % skip heading with its possibly-different timestamp
                markerStr = sprintf('10.0 ML\nN');
                markerLen = length(markerStr);
                while ~isempty(idx) && idx < length(fstrm)
                    lastIdx = min(length(fstrm), length(fstrm_new));
                    delta = fstrm(idx+1:lastIdx) - fstrm_new(idx+1:lastIdx);
                    idx = idx + find(delta,1);
                    if ~isempty(idx) && ...
                            isequal(fstrm(idx-markerLen+1:idx), markerStr) && ...
                            ~isempty(regexp(fstrm_new(idx-markerLen+1:idx+12),'10.0 ML\n[\d\.]+ LW\nN')) %#ok<RGXP1>
                        value = str2double(regexprep(fstrm_new(idx:idx+12),' .*',''));
                        if isnan(value), break; end  % something's wrong... - bail out
                        newStr = sprintf('%0.3f LW\n',value/10);
                        fstrm = [fstrm(1:idx-1) newStr fstrm(idx:end)];
                        idx = idx + 12;
                    else
                        break;
                    end
                end
            end
            %}

            % This is much faster although less accurate: fix all non-gray lines to have a LineWidth of 0.75 (=1 LW)
            % Note: This will give incorrect LineWidth of 075 for lines having LineWidth<0.75, as well as for non-gray grid-lines (if present)
            %       However, in practice these edge-cases are very rare indeed, and the difference in LineWidth should not be noticeable
            %fstrm = regexprep(fstrm, '([CR]C\n2 setlinecap\n1 LJ)\nN', '$1\n1 LW\nN');
            % This is faster (the original regexprep could take many seconds when the axes contains many lines):
            fstrm = strrep(fstrm, sprintf('\n2 setlinecap\n1 LJ\nN'), sprintf('\n2 setlinecap\n1 LJ\n1 LW\nN'));
        end
    catch err
        fprintf(2, 'Error fixing LineWidths in EPS file: %s\n at %s:%d\n', err.message, err.stack(1).file, err.stack(1).line);
    end

    % Reset the font and line colors
    try
        set(black_text_handles, 'Color', [0 0 0]);
        set(white_text_handles, 'Color', [1 1 1]);
    catch
        % Fix issue #159: redo findall() '*text_handles'
        black_text_handles = findall(fig, 'Type', 'text', 'Color', [0 0 0]+eps);
        white_text_handles = findall(fig, 'Type', 'text', 'Color', [1 1 1]-eps);
        set(black_text_handles, 'Color', [0 0 0]);
        set(white_text_handles, 'Color', [1 1 1]);
    end
    set(white_line_handles, 'Color', [1 1 1]);

    % Reset paper size
    set(fig, 'PaperPositionMode', old_pos_mode, 'PaperOrientation', old_orientation);

    % Reset the font names in the figure
    if ~isempty(font_swap)
        for a = update
            set(font_handles(a), 'FontName', fonts{a}, 'FontSize', fonts_size(a));
        end
    end

    % Bail out if EPS post-processing is not possible
    if isempty(fstrm)
        warning('Loading EPS file failed, so unable to perform post-processing. This is usually because the figure contains a large number of patch objects. Consider exporting to a bitmap format in this case.');
        return
    end

    % Replace the font names
    if ~isempty(font_swap)
        for a = 1:size(font_swap, 2)
            fontName = font_swap{3,a};
            %fontName = fontName(~isspace(font_swap{3,a}));
            if length(fontName) > 29
                warning('YMA:export_fig:font_name','Font name ''%s'' is longer than 29 characters. This might cause problems in some EPS/PDF readers. Consider using a different font.',fontName);
            end
            if isempty(font_space)
                fontName(fontName==' ') = '';
            else
                fontName(fontName==' ') = char(font_space);
            end
            %fstrm = regexprep(fstrm, [font_swap{1,a} '-?[a-zA-Z]*\>'], fontName);
            fstrm = regexprep(fstrm, font_swap{2,a}, fontName);
        end
    end

    % Move the bounding box to the top of the file (HG2 only), or fix the line styles (HG1 only)
    if using_hg2(fig)
        % Move the bounding box to the top of the file (HG2 only)
        [s, e] = regexp(fstrm, '%%BoundingBox: [^%]*%%');
        if numel(s) == 2
            fstrm = fstrm([1:s(1)-1 s(2):e(2)-2 e(1)-1:s(2)-1 e(2)-1:end]);
        end
    else
        % Fix the line styles (HG1 only)
        fstrm = fix_lines(fstrm);
    end

    % Apply the bounding box padding & cropping, replacing Matlab's print()'s bounding box
    if bb_crop
        % Calculate a new bounding box based on a bitmap print using crop_border.m
        % 1. Determine the Matlab BoundingBox and PageBoundingBox
        [s,e] = regexp(fstrm, '%%BoundingBox: [^%]*%%'); % location BB in eps file
        if numel(s)==2, s=s(2); e=e(2); end
        aa = fstrm(s+15:e-3); % dimensions bb - STEP1
        bb_matlab = cell2mat(textscan(aa,'%f32%f32%f32%f32'));  % dimensions bb - STEP2

        [s,e] = regexp(fstrm, '%%PageBoundingBox: [^%]*%%'); % location bb in eps file
        if numel(s)==2, s=s(2); e=e(2); end
        aa = fstrm(s+19:e-3); % dimensions bb - STEP1
        pagebb_matlab = cell2mat(textscan(aa,'%f32%f32%f32%f32'));  % dimensions bb - STEP2

        % 1b. Fix issue #239: black title meshes with temporary black background figure bgcolor, causing bad cropping
        hTitles = [];
        if isequal(get(fig,'Color'),'none')
            hAxes = findall(fig,'type','axes');
            for idx = 1 : numel(hAxes)
                hAx = hAxes(idx);
                try
                    hTitle = hAx.Title;
                    oldColor = hTitle.Color;
                    if all(oldColor < 5*eps) || (ischar(oldColor) && lower(oldColor(1))=='k')
                        hTitles(end+1) = hTitle; %#ok<AGROW>
                        hTitle.Color = [0,0,.01];
                    end
                catch
                end
            end
        end

        % 2. Create a bitmap image and use crop_borders to create the relative
        %    bb with respect to the PageBoundingBox
        [A, bcol] = print2array(fig, 1, renderer);
        [aa, aa, aa, bb_rel] = crop_borders(A, bcol, bb_padding, crop_amounts); %#ok<ASGLU>

        try set(hTitles,'Color','k'); catch, end

        % 3. Calculate the new Bounding Box
        pagew = pagebb_matlab(3)-pagebb_matlab(1);
        pageh = pagebb_matlab(4)-pagebb_matlab(2);
        %bb_new = [pagebb_matlab(1)+pagew*bb_rel(1) pagebb_matlab(2)+pageh*bb_rel(2) ...
        %          pagebb_matlab(1)+pagew*bb_rel(3) pagebb_matlab(2)+pageh*bb_rel(4)];
        bb_new = pagebb_matlab([1,2,1,2]) + [pagew,pageh,pagew,pageh].*bb_rel;  % clearer
        bb_offset = (bb_new-bb_matlab) + [-2,-2,2,2];  % 2px margin so that cropping is not TOO tight (issue #195)

        % Apply the bounding box padding
        if bb_padding
            if abs(bb_padding)<1
                bb_padding = round((mean([bb_new(3)-bb_new(1) bb_new(4)-bb_new(2)])*bb_padding)/0.5)*0.5; % ADJUST BB_PADDING
            end
            add_padding = @(n1, n2, n3, n4) sprintf(' %.0f', str2double({n1, n2, n3, n4}) + bb_offset + bb_padding*[-1,-1,1,1]); %#ok<NASGU>
        else
            add_padding = @(n1, n2, n3, n4) sprintf(' %.0f', str2double({n1, n2, n3, n4}) + bb_offset); %#ok<NASGU> % fix small but noticeable bounding box shift
        end
        fstrm = regexprep(fstrm, '%%BoundingBox:[ ]+([-]?\d+)[ ]+([-]?\d+)[ ]+([-]?\d+)[ ]+([-]?\d+)', '%%BoundingBox:${add_padding($1, $2, $3, $4)}');
    end

    % Fix issue #44: white artifact lines appearing in patch exports
    % Note: the problem is due to the fact that Matlab's print() function exports patches
    %       as a combination of filled triangles, and a white line appears where the triangles touch
    % In the workaround below, we will modify such dual-triangles into a filled rectangle.
    % We are careful to only modify regexps that exactly match specific patterns - it's better to not
    % correct some white-line artifacts than to change the geometry of a patch, or to corrupt the EPS.
    %   e.g.: '0 -450 937 0 0 450 3 MP PP 937 0 0 -450 0 450 3 MP PP' => '0 -450 937 0 0 450 0 0 4 MP'
    fstrm = regexprep(fstrm, '\n([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) 3 MP\nPP\n\2 \1 \3 3 MP\nPP\n','\n$1 $2 $3 0 0 4 MP\nPP\n');
    fstrm = regexprep(fstrm, '\n([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) 3 MP\nPP\n\2 \3 \1 3 MP\nPP\n','\n$1 $2 $3 0 0 4 MP\nPP\n');
    fstrm = regexprep(fstrm, '\n([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) 3 MP\nPP\n\3 \1 \2 3 MP\nPP\n','\n$1 $2 $3 0 0 4 MP\nPP\n');
    fstrm = regexprep(fstrm, '\n([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) 3 MP\nPP\n\3 \2 \1 3 MP\nPP\n','\n$1 $2 $3 0 0 4 MP\nPP\n');

    % Write out the fixed eps file
    read_write_entire_textfile(name, fstrm);
end

function [StoredColors, fstrm, foundFlags] = eps_maintainAlpha(fig, fstrm, StoredColors)
    if nargin == 1  % in: convert transparency in Matlab figure into unique RGB colors
        hObjs = findall(fig); %findobj(fig,'Type','Area');
        StoredColors = {};
        propNames = {'Face','Edge'};
        for objIdx = 1:length(hObjs)
            hObj = hObjs(objIdx);
            for propIdx = 1 : numel(propNames)
                try
                    propName = propNames{propIdx};
                    if strcmp(hObj.(propName).ColorType, 'truecoloralpha')
                        nColors = length(StoredColors);
                        oldColor = hObj.(propName).ColorData;
                        newColor = uint8([101; 102+floor(nColors/255); mod(nColors,255); 255]);
                        StoredColors{end+1} = {hObj, propName, oldColor, newColor}; %#ok<AGROW>
                        hObj.(propName).ColorData = newColor;
                    end
                catch
                    % Never mind - ignore (either doesn't have the property or cannot change it)
                end
            end
        end
    else  % restore transparency in Matlab figure by converting back from the unique RGBs
        %Find the transparent patches
        wasError = false;
        nColors = length(StoredColors);
        foundFlags = false(1,nColors);
        for objIdx = 1 : nColors
            colorsData = StoredColors{objIdx};
            hObj      = colorsData{1};
            propName  = colorsData{2};
            origColor = colorsData{3};
            newColor  = colorsData{4};
            try
                %Restore the EPS files patch color
                colorID   = num2str(round(double(newColor(1:3)') /255,3),'%.3g %.3g %.3g'); %ID for searching
                origRGB   = num2str(round(double(origColor(1:3)')/255,3),'%.3g %.3g %.3g'); %Replace with original color
                origAlpha = num2str(round(double(origColor(end)) /255,3),'%.3g'); %Convert alpha value for EPS

                %Find and replace the RGBA values within the EPS text fstrm
                if strcmpi(propName,'Face')
                    oldStr = sprintf(['\n' colorID ' RC\n']);  % ...N\n (removed to fix issue #225)
                    newStr = sprintf(['\n' origRGB ' RC\n' origAlpha ' .setopacityalpha true\n']);  % ...N\n
                else  %'Edge'
                    oldStr = sprintf(['\n' colorID ' RC\n']);  % ...1 LJ\n (removed to fix issue #225)
                    newStr = sprintf(['\n' origRGB ' RC\n' origAlpha ' .setopacityalpha true\n']);
                end
                foundFlags(objIdx) = ~isempty(strfind(fstrm, oldStr)); %#ok<STREMP>
                fstrm = strrep(fstrm, oldStr, newStr);

                %Restore the figure object's original color
                hObj.(propName).ColorData = origColor;
            catch err
                % something is wrong - cannot restore transparent color...
                if ~wasError
                    fprintf(2, 'Error maintaining transparency in EPS file: %s\n at %s:%d\n', err.message, err.stack(1).file, err.stack(1).line);
                    wasError = true;
                end
            end
        end
    end
end

%READ_WRITE_ENTIRE_TEXTFILE Read or write a whole text file to/from memory
%
% Read or write an entire text file to/from memory, without leaving the
% file open if an error occurs.
%
% Reading:
%   fstrm = read_write_entire_textfile(fname)
% Writing:
%   read_write_entire_textfile(fname, fstrm)
%
%IN:
%   fname - Pathname of text file to be read in.
%   fstrm - String to be written to the file, including carriage returns.
%
%OUT:
%   fstrm - String read from the file. If an fstrm input is given the
%           output is the same as that input. 

function fstrm = read_write_entire_textfile(fname, fstrm)
modes = {'rt', 'wt'};
writing = nargin > 1;
fh = fopen(fname, modes{1+writing});
if fh == -1
    error('Unable to open file %s.', fname);
end
try
    if writing
        fwrite(fh, fstrm, 'char*1');
    else
        fstrm = fread(fh, '*char')';
    end
catch ex
    fclose(fh);
    rethrow(ex);
end
fclose(fh);
end

function string = user_string(string_name, string)
%USER_STRING  Get/set a user specific string
%
% Examples:
%   string  = user_string(string_name)
%   isSaved = user_string(string_name, new_string)
%
% Function to get and set a string in a system or user specific file. This
% enables, for example, system specific paths to binaries to be saved.
%
% The specified string will be saved in a file named <string_name>.txt,
% either in a subfolder named .ignore under this file's folder, or in the
% user's prefdir folder (in case this file's folder is non-writable).
%
% IN:
%   string_name - String containing the name of the string required, which
%                 sets the filename storing the string: <string_name>.txt
%   new_string  - The new string to be saved in the <string_name>.txt file
%
% OUT:
%   string  - The currently saved string. Default: ''
%   isSaved - Boolean indicating whether the save was succesful

% Copyright (C) Oliver Woodford 2011-2014, Yair Altman 2015-

% This method of saving paths avoids changing .m files which might be in a
% version control system. Instead it saves the user dependent paths in
% separate files with a .txt extension, which need not be checked in to
% the version control system. Thank you to Jonas Dorn for suggesting this
% approach.

% 10/01/2013 - Access files in text, not binary mode, as latter can cause
%              errors. Thanks to Christian for pointing this out.
% 29/05/2015 - Save file in prefdir if current folder is non-writable (issue #74)
% 09/01/2018 - Fix issue #232: if the string looks like a file/folder path, ensure it actually exists

    if ~ischar(string_name)
        error('string_name must be a string.');
    end
    % Create the full filename
    fname = [string_name '.txt'];
    dname = fullfile(fileparts(mfilename('fullpath')), '.ignore');
    file_name = fullfile(dname, fname);
    if nargin > 1
        % Set string
        if ~ischar(string)
            error('new_string must be a string.');
        end
        % Make sure the save directory exists
        %dname = fileparts(file_name);
        if ~exist(dname, 'dir')
            % Create the directory
            try
                if ~mkdir(dname)
                    string = false;
                    return
                end
            catch
                string = false;
                return
            end
            % Make it hidden
            try
                fileattrib(dname, '+h');
            catch
            end
        end
        % Write the file
        fid = fopen(file_name, 'wt');
        if fid == -1
            % file cannot be created/updated - use prefdir if file does not already exist
            % (if file exists but is simply not writable, don't create a duplicate in prefdir)
            if ~exist(file_name,'file')
                file_name = fullfile(prefdir, fname);
                fid = fopen(file_name, 'wt');
            end
            if fid == -1
                string = false;
                return;
            end
        end
        try
            fprintf(fid, '%s', string);
        catch
            fclose(fid);
            string = false;
            return
        end
        fclose(fid);
        string = true;
    else
        % Get string
        fid = fopen(file_name, 'rt');
        if fid == -1
            % file cannot be read, try to read the file in prefdir
            file_name = fullfile(prefdir, fname);
            fid = fopen(file_name, 'rt');
            if fid == -1
                string = '';
                return
            end
        end
        string = fgetl(fid);
        fclose(fid);

        % Fix issue #232: if the string looks like a file/folder path, ensure it actually exists
        if ~isempty(string) && any(string=='\' | string=='/') && ~exist(string) %#ok<EXIST>
            string = '';
        end
    end
end

%USING_HG2 Determine if the HG2 graphics engine is used
%
%   tf = using_hg2(fig)
%
%IN:
%   fig - handle to the figure in question.
%
%OUT:
%   tf - boolean indicating whether the HG2 graphics engine is being used
%        (true) or not (false).

% 19/06/2015 - Suppress warning in R2015b; cache result for improved performance
% 06/06/2016 - Fixed issue #156 (bad return value in R2016b)

function tf = using_hg2(fig)
    persistent tf_cached
    if isempty(tf_cached)
        try
            if nargin < 1,  fig = figure('visible','off');  end
            oldWarn = warning('off','MATLAB:graphicsversion:GraphicsVersionRemoval');
            try
                % This generates a [supressed] warning in R2015b:
                tf = ~graphicsversion(fig, 'handlegraphics');
            catch
                tf = ~verLessThan('matlab','8.4');  % =R2014b
            end
            warning(oldWarn);
        catch
            tf = false;
        end
        if nargin < 1,  delete(fig);  end
        tf_cached = tf;
    else
        tf = tf_cached;
    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------- END - ALTMANY EXPORT FIG - END -----------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- UNUSED MAINS BELOW -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


%{
% LambertW Investigation
function gettingfandthetat()
    syms xtrial
    syms knot_x
    syms knot_theta
    syms ytrial
    syms knot_y
    syms knot_rx
    syms knot_theta
    syms knot_ry

    f=((xtrial-knot_x)*cos(knot_theta)+(ytrial-knot_y)*sin(knot_theta))^2/knot_rx^2+((xtrial-knot_x)*sin(knot_theta)-(ytrial-knot_y)*cos(knot_theta))^2/knot_ry^2-1;
    df_x=diff(f,xtrial);
    df_y=diff(f,ytrial);
    tanthetar=simplify(df_y/df_x);
    thetar=atan(tanthetar);
    thetat=thetar+pi/2;
    thetat=mod(thetat,pi)

    %{
    syms knot_x knot(knotnum).x
    syms knot_theta knot(knotnum).theta
    syms knot_y knot(knotnum).y
    syms knot_rx knot(knotnum).rx
    syms knot_theta knot(knotnum).theta
    syms knot_ry knot(knotnum).ry
    %}

    f=char(f);
    f=strrep(f,'knot_x','knot(knotnum).x');
    f=strrep(f,'knot_theta','knot(knotnum).theta');
    f=strrep(f,'knot_y','knot(knotnum).y');
    f=strrep(f,'knot_rx','knot(knotnum).rx');
    f=strrep(f,'knot_theta','knot(knotnum).theta');
    f=strrep(f,'knot_ry','knot(knotnum).ry');
    f=strrep(f,'xtrial','xtrial_global');
    f=strrep(f,'ytrial','ytrial_global');
    disp(['f=' f ';']);

    thetat=char(thetat);
    thetat=strrep(thetat,'knot_x','knot(knotnum).x');
    thetat=strrep(thetat,'knot_theta','knot(knotnum).theta');
    thetat=strrep(thetat,'knot_y','knot(knotnum).y');
    thetat=strrep(thetat,'knot_rx','knot(knotnum).rx');
    thetat=strrep(thetat,'knot_theta','knot(knotnum).theta');
    thetat=strrep(thetat,'knot_ry','knot(knotnum).ry');
    thetat=strrep(thetat,'xtrial','xtrial_global');
    thetat=strrep(thetat,'ytrial','ytrial_global');
    disp(['thetat=' thetat ';']);
end

function LambertWInvestigate()
    ftl=65.5;
    ftr=3.75;
    ftt=2.79;
    fcl=-50.3;
    fcr=-6;
    fct=-6;
    fvrt=1.83/20; %replacereplacereplace
    fvrl=6.34/20; %replacereplacereplace
    fvtl=5.34/20; %replacereplacereplace
    Er=820/1; %replacereplacereplace
    Et=430/1; %replacereplacereplace
    El=13200/1; %replacereplacereplace

    kappa1=0.00001;
    kappa2=1.2;
    kappa3=0.00001;
    kappa4=1.2;
    kappa5=0.00001;
    kappa6=0.7;
    kappa7=1.2;

    Gftl=1650/1000;
    Gfcl=50000/1000;
    Gftr=300/1000;
    Gftt=Gftr;
    Gfcr=Gftr/Gftl*Gfcl;
    Gfct=Gfcr;
    GII=300/1000;

    Hld=15;
    Hrd=2;
    Htd=Hrd;

    %{
    beta0tl=65;
    beta0cl=49.9;
    beta0tr=4.5;
    beta0cr=beta0tr/beta0tl*beta0cl;
    beta0tt=beta0tr;
    beta0ct=beta0cr;
    %}

    beta0tl=abs(ftl);
    beta0cl=abs(fcl);
    beta0tr=abs(ftr);
    beta0cr=abs(fcr);
    beta0tt=abs(ftt);
    beta0ct=abs(fct);

    lccrit=El*Gftl/beta0tl^2;
    lc(1)=0.8*lccrit;
    lc(2)=lccrit;
    lc(3)=1.25*lccrit;

    zeta2=Hrd/beta0cr^2;
    zeta4=Htd/beta0ct^2;
    zeta6=Hld/beta0cl^2;
    zeta7=zeta2;

    alpha2d=0.1*abs(fcr);
    alpha2max=0.75*abs(fcr);
    alpha4d=0.1*abs(fct);
    alpha4max=0.75*abs(fct);
    alpha6d=0.5*abs(fcl);
    alpha6max=0.75*abs(fcl);
    alpha7d=0.1*abs(1/3*(fvrt+fvrl+fvtl));
    alpha7max=0.75*abs(1/3*(fvrt+fvrl+fvtl));
    
    f=ftl;
    E=El;
    epsilon=linspace(f/E-1e-3,f/E+4e-3,1001);
    for j=1:3
        eta=lc(j)/Gftl;
        for i=1:length(epsilon)
            alphahp{1}{j}(i)=f*epsilon(i)+Gftl/lc(j)*(lambertw(0,-f^2*lc(j)/(E*Gftl)*exp(-f*lc(j)*epsilon(i)/Gftl)));
            alphahp{2}{j}(i)=f*epsilon(i)+Gftl/lc(j)*(lambertw(-1,-f^2*lc(j)/(E*Gftl)*exp(-f*lc(j)*epsilon(i)/Gftl)));
            epsilonminusepsilony(i)=epsilon(i)-f/E;
        end
    end
    plot(epsilonminusepsilony,alphahp{1}{1},'DisplayName','l_c=0.8*l_{c,crit},0');
    hold on
    plot(epsilonminusepsilony,alphahp{2}{1},'DisplayName','l_c=0.8*l_{c,crit},-1');
    plot(epsilonminusepsilony,alphahp{1}{2},'DisplayName','l_c=1.0*l_{c,crit},0');
    plot(epsilonminusepsilony,alphahp{2}{2},'DisplayName','l_c=1.0*l_{c,crit},-1');
    plot(epsilonminusepsilony,alphahp{1}{3},'DisplayName','l_c=1.25*l_{c,crit},0');
    plot(epsilonminusepsilony,alphahp{2}{3},'DisplayName','l_c=1.25*l_{c,crit},-1');
    ylabel('\alphahp (MPa)','FontSize',15);
    xlabel('\epsilon - \epsilon_y','FontSize',15)
    grid on
    legend show
    hold off
    %{
    alphahp=linspace(-0.006*f*3/4,0.01*f*3/4,1001);
    for j=1:3
        eta=lc(j)/Gftl;
        for i=1:length(alphahp)
            epsilonminusepsilony{j}(i)=alphahp(i)/f+f/E*exp(-eta*alphahp(i))-f/E;
            depsilondalpha{j}(i)=1/f-eta*f/E*exp(-eta*alphahp(i));
            dalphadepsilon{j}(i)=1/depsilondalpha{j}(i);
        end
    end
    plot(epsilonminusepsilony{1},alphahp,'DisplayName','l_c=0.8*l_{c,crit}');
    hold on
    plot(epsilonminusepsilony{2},alphahp,'DisplayName','l_c=1.0*l_{c,crit}');
    plot(epsilonminusepsilony{3},alphahp,'DisplayName','l_c=1.25*l_{c,crit}');
    ylabel('\alphahp (MPa)','FontSize',15);
    xlabel('\epsilon - \epsilon_y','FontSize',15)
    grid on
    legend show
    hold off
    
    
    %{
    pause
    plot(epsilonminusepsilony,dalphadepsilon);
    hold on
    ylabel('d\alphahp/d(\epsilon - \epsilony) (MPa)','FontSize',15);
    xlabel('\epsilon - \epsilon_y','FontSize',15)
    grid on
    hold off
    %}
    lc=linspace(0.5*lccrit,1.75*lccrit,1001);
    for i=1:length(lc)
        insidelambert(i)=-f^2*lc(i)/(E*Gftl)*exp(-f*lc(i)*(f/E)/Gftl);
    end
    plot(lc/lccrit,insidelambert)
    hold on
    xlabel('l_c/l_{c,crit}');
    ylabel('LambertW Input');
    grid on
    hold off
    %}
end


function OnePointTens3()
    TimeStampedName=['OnePointTens3' datestr(now,'yymmdd-HH.MM.SS')];
    theta=linspace(0,360,36001); %degrees
    sigmaRplot12=zeros(1,length(theta));
    sigmaTplot12=zeros(1,length(theta));
    sigmaRplot34=zeros(1,length(theta));
    sigmaTplot34=zeros(1,length(theta));
    parfor angleiter=1:length(theta)
        [sigmaRplot12(angleiter) sigmaTplot12(angleiter)]=OnePointTens3Ronly(theta(angleiter));
        [sigmaRplot34(angleiter) sigmaTplot34(angleiter)]=OnePointTens3Tonly(theta(angleiter));
    end
    save([TimeStampedName '.mat'])
    
    plot(sigmaRplot12,sigmaTplot12,'DisplayName','Surface 1 & 2','Color','blue');
    hold on;
    plot(sigmaRplot34,sigmaTplot34,'DisplayName','Surface 3 & 4','Color','red');
    xlabel('\sigma_R','FontSize',15);
    ylabel('\sigma_T','FontSize',15);
    legend('show');
    set(gca,'color','none');
    set(legend,'color','none');
    hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [sigmaR sigmaT]=OnePointTens3Ronly(theta)
        sigmabase(1)=2.79/2;
        for i=1:9999
            sigmaR=sigmabase(i)*cos(theta/180*pi);
            sigmaT=sigmabase(i)*sin(theta/180*pi);
            sigmatrial=[sigmaR;sigmaT;0;0;0;0];
            F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
            F{3}=-inf;
            F{4}=-inf;
            Fmax=CellMax(F);
            if Fmax<=0
                sigmabase(i+1)=sigmabase(i)*2;
            else
                sigmaminus=sigmabase(i-1);
                sigmaplus=sigmabase(i);
                break;
            end
        end
        for i=i+1:999999
            sigmabase(i)=0.5*(sigmaminus+sigmaplus);
            sigmaR=sigmabase(i)*cos(theta/180*pi);
            sigmaT=sigmabase(i)*sin(theta/180*pi);
            sigmatrial=[sigmaR;sigmaT;0;0;0;0];
            F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
            F{3}=-inf;
            F{4}=-inf;
            Fmax=CellMax(F);
            if abs(Fmax)<1e-6
                break;
            end
            if Fmax>0
                sigmaplus=sigmabase(i);
            else
                sigmaminus=sigmabase(i);
            end
        end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [sigmaR sigmaT]=OnePointTens3Tonly(theta)
        sigmabase(1)=2.79/2;
        for i=1:9999
            sigmaR=sigmabase(i)*cos(theta/180*pi);
            sigmaT=sigmabase(i)*sin(theta/180*pi);
            sigmatrial=[sigmaR;sigmaT;0;0;0;0];
            F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
            F{1}=-inf;
            F{2}=-inf;
            Fmax=CellMax(F);
            if Fmax<=0
                sigmabase(i+1)=sigmabase(i)*2;
            else
                sigmaminus=sigmabase(i-1);
                sigmaplus=sigmabase(i);
                break;
            end
        end
        for i=i+1:999999
            sigmabase(i)=0.5*(sigmaminus+sigmaplus);
            sigmaR=sigmabase(i)*cos(theta/180*pi);
            sigmaT=sigmabase(i)*sin(theta/180*pi);
            sigmatrial=[sigmaR;sigmaT;0;0;0;0];
            F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
            F{1}=-inf;
            F{2}=-inf;
            Fmax=CellMax(F);
            if abs(Fmax)<1e-6
                break;
            end
            if Fmax>0
                sigmaplus=sigmabase(i);
            else
                sigmaminus=sigmabase(i);
            end
        end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function OnePointTens2()
    ftl=65.5;
    ftr=3.75;
    ftt=2.79;
    fcl=-50.3;
    fcr=-6;
    fct=-6;
    fvrt=1.83/20; %replacereplacereplace
    fvrl=6.34/20; %replacereplacereplace
    fvtl=5.34/20; %replacereplacereplace
    
    TimeStampedName=['OnePointTens2' datestr(now,'yymmdd-HH.MM.SS')];
    theta=linspace(0,90,9001); %degrees
    sigmaouttens=zeros(1,length(theta));
    parfor angleiter=1:length(theta)
        [sigmaouttens(angleiter)]=OnePointTens2InsideParfor(theta(angleiter),1);
        [sigmaoutcomp(angleiter)]=OnePointTens2InsideParfor(theta(angleiter),-1);
    end
    save([TimeStampedName '.mat'])
    
    plot(theta,sigmaouttens/abs(ftl),'LineWidth',1.5,'Color','red');
    hold on;
    title('Tension Loading')
    xlabel('Angle (degrees)','FontSize',15);
    ylabel('\sigma_{load,tens}/f_{t,L}','FontSize',15);
    set(gca,'color','none')
    hold off;
    pause;
    
    plot(theta,sigmaoutcomp/fcl,'LineWidth',1.5,'Color','red');
    hold on;
    title('Compression Loading')
    xlabel('Angle (degrees)','FontSize',15);
    ylabel('\sigma_{load,comp}/f_{c,L}','FontSize',15);
    set(gca,'color','none')
    hold off;
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [sigmaout]=OnePointTens2InsideParfor(theta,sign)
        sigmabase(1)=sign*2.79/2;
        for i=1:9999
            sigmaL=sigmabase(i)/2+sigmabase(i)/2*cos(2*theta/180*pi);
            sigmaR=sigmabase(i)/2-sigmabase(i)/2*cos(2*theta/180*pi);
            sigmaRL=-(sigmabase(i)/2)*sin(2*theta/180*pi);
            sigmatrial=[sigmaR;0;sigmaL;0;0;sigmaRL];
            F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
            Fmax=CellMax(F);
            if Fmax<=0
                sigmabase(i+1)=sigmabase(i)*2;
            else
                sigmaminus=sigmabase(i-1);
                sigmaplus=sigmabase(i);
                break;
            end
        end
        for i=i+1:999999
            sigmabase(i)=0.5*(sigmaminus+sigmaplus);
            sigmaL=sigmabase(i)/2+sigmabase(i)/2*cos(2*theta/180*pi);
            sigmaR=sigmabase(i)/2-sigmabase(i)/2*cos(2*theta/180*pi);
            sigmaRL=-(sigmabase(i)/2)*sin(2*theta/180*pi);
            sigmatrial=[sigmaR;0;sigmaL;0;0;sigmaRL];
            F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
            Fmax=CellMax(F);
            if abs(Fmax)<1e-6
                break;
            end
            if Fmax>0
                sigmaplus=sigmabase(i);
            else
                sigmaminus=sigmabase(i);
            end
        end
        sigmaout=sigmabase(i);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function OnePointTens1()
    TimeStampedName=['OnePointTens1' datestr(now,'yymmdd-HH.MM.SS')];
    theta=linspace(0,360,36001); %degrees
    sigmaLplot=zeros(1,length(theta));
    sigmaRplot=zeros(1,length(theta));
    parfor angleiter=1:length(theta)
        [sigmaLplot(angleiter) sigmaRplot(angleiter)]=OnePointTens1InsideParfor(theta(angleiter));
    end
    plot(sigmaLplot,sigmaRplot,'LineWidth',2,'Color','red');
    hold on;
    xlabel('\sigma_L','FontSize',15);
    ylabel('\sigma_R','FontSize',15);
    set(gca,'color','none')
    hold off
    save([TimeStampedName '.mat'])
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [sigmaL sigmaR]=OnePointTens1InsideParfor(theta)
        sigmabase(1)=2.79/2;
        for i=1:9999
            sigmaL=sigmabase(i)*cos(theta/180*pi);
            sigmaR=sigmabase(i)*sin(theta/180*pi);
            sigmatrial=[sigmaR;0;sigmaL;0;0;0];
            F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
            Fmax=CellMax(F);
            if Fmax<=0
                sigmabase(i+1)=sigmabase(i)*2;
            else
                sigmaminus=sigmabase(i-1);
                sigmaplus=sigmabase(i);
                break;
            end
        end
        for i=i+1:999999
            sigmabase(i)=0.5*(sigmaminus+sigmaplus);
            sigmaL=sigmabase(i)*cos(theta/180*pi);
            sigmaR=sigmabase(i)*sin(theta/180*pi);
            sigmatrial=[sigmaR;0;sigmaL;0;0;0];
            F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
            Fmax=CellMax(F);
            if abs(Fmax)<1e-6
                break;
            end
            if Fmax>0
                sigmaplus=sigmabase(i);
            else
                sigmaminus=sigmabase(i);
            end
        end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function OnePointPull()
    TimeStampedName=['MatModelTestbed' datestr(now,'yymmdd-HH.MM.SS')];
    ftl=65.5;
    ftr=3.75;
    ftt=2.79;
    fcl=-50.3;
    fcr=-6;
    fct=-6;
    fvrt=1.83/20; %replacereplacereplace
    fvrl=6.34/20; %replacereplacereplace
    fvtl=5.34/20; %replacereplacereplace
    Er=820/1; %replacereplacereplace
    Et=430/1; %replacereplacereplace
    El=13200/1; %replacereplacereplace
    Grt=40/1; %replacereplacereplace
    Gtl=730/1; %replacereplacereplace
    Grl=660/1; %replacereplacereplace
    nurt=0.24;
    nutl=0.45;
    nurl=0.45;


    Comp=[1/Er -nurt/Et -nurl/El 0 0 0;
         -nurt/Et 1/Et -nutl/El 0 0 0;
         -nurl/El -nutl/El 1/El 0 0 0;
         0 0 0 1/Grt 0 0;
         0 0 0 0 1/Gtl 0;
         0 0 0 0 0 1/Grl];
     
    xdir=RTLtranslator('r');
    ydir=RTLtranslator('t');
    zdir=RTLtranslator('l');
    xydir=RTLtranslator('rt');
    yzdir=RTLtranslator('tl');
    xzdir=RTLtranslator('rl');
    
    Comp=MatReorder(Comp,[xdir ydir zdir xydir yzdir xzdir]);
    C=Comp^-1;
    
    %sigma_global_big=transpose([3.75 2.79 0 0 0 0]);

    %for surface 1&3
    %sigma_global_big=transpose([3.4687600422317030890440037182998,2.3237485210648975986202913190937,0,0,0,0])*0.9999;

    %for surface 1 only
    sigma_global_big=transpose([0 0 0 0 0 0]);

    %for surface 2 and 4
    %sigma_global_big=transpose([ -4.593386622447824585435682820389 -4.593386622447824585435682820389 0 0 0 0]);

    %sigma_global_big=transpose([0 0 0 0 0 0]);
    e_t_global_big=Comp*sigma_global_big;
    e_pl_global_big=transpose([0 0 0 0 0 0]);
    alphahp=[0 0 0 0 0 0 0];
    [sigmaplot2 epsilonplot2]=AnalyticalLoadDisplacementPlot;
    for i=1:9999999
        if i==1
            dESP=[0 0;0 0];
        else
            dESP=[-0.0001 0;0 0.000];
        end
        if i>2
            if alphaplot(i-1)<alphaplot(i-2)
                disp('hey!')
            end
        end

        [s_sp,e_pl,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax]=Wood_Schmidt17(dESP,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp);
        s_sp_trace{i}=s_sp;
        e_pl_trace{i}=e_pl;
        sigma_global_big_trace{i}=sigma_global_big;
        e_t_global_big_trace{i}=e_t_global_big;
        e_pl_global_big_trace{i}=e_pl_global_big;
        alpha_trace{i}=alphahp;
        f_final_vect_trace{i}=f_final_vect;
        surfacewithfmax_trace{i}=surfacewithfmax;
        
        epsilonplot(i)=e_t_global_big(1);
        sigmaplot(i)=sigma_global_big(1);
        alphaplot(i)=alphahp(2);
        if abs(e_t_global_big(1))>=1
            break;
        end
    end
    save([TimeStampedName '.mat'])
    
    
    plot(epsilonplot2,sigmaplot2,'DisplayName','Analytical','LineWidth',2,'Color','cyan');
    hold on;
    plot(-epsilonplot,-sigmaplot,'DisplayName','Numerical','color','black');
    title('R compression');
    xlabel('\epsilon','FontSize',15);
    ylabel('\sigma','FontSize',15);
    legend('show');
    hold off
    pause

    plot(-epsilonplot,alphaplot);
    
    %printvector(sigma_global_big,'sigma_global_big')
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [sigma epsilon]=AnalyticalLoadDisplacementPlot()
    ftl=65.5;
    ftr=3.75;
    ftt=2.79;
    fcl=-50.3;
    fcr=-6;
    fct=-6;
    fvrt=1.83/20; %replacereplacereplace
    fvrl=6.34/20; %replacereplacereplace
    fvtl=5.34/20; %replacereplacereplace
    Er=820/1; %replacereplacereplace
    Et=430/1; %replacereplacereplace
    El=13200/1; %replacereplacereplace

    kappa1=0.00001;
    kappa2=1.2;
    kappa3=0.00001;
    kappa4=1.2;
    kappa5=0.00001;
    kappa6=0.7;
    kappa7=1.2;

    Gftl=1650/1000;
    Gfcl=50000/1000;
    Gftr=300/1000;
    Gftt=Gftr;
    Gfcr=Gftr/Gftl*Gfcl;
    Gfct=Gfcr;
    GII=300/1000;

    Hld=15;
    Hrd=2;
    Htd=Hrd;

    %{
    beta0tl=65;
    beta0cl=49.9;
    beta0tr=4.5;
    beta0cr=beta0tr/beta0tl*beta0cl;
    beta0tt=beta0tr;
    beta0ct=beta0cr;
    %}

    beta0tl=abs(ftl);
    beta0cl=abs(fcl);
    beta0tr=abs(ftr);
    beta0cr=abs(fcr);
    beta0tt=abs(ftt);
    beta0ct=abs(fct);

    lccrit=El*Gftl/beta0tl;
    lc=lccrit/100;
    lc=4;

    zeta2=Hrd/beta0cr^2;
    zeta4=Htd/beta0ct^2;
    zeta6=Hld/beta0cl^2;
    zeta7=zeta2;

    alpha2d=0.1*abs(fcr);
    alpha2max=0.75*abs(fcr);
    alpha4d=0.1*abs(fct);
    alpha4max=0.75*abs(fct);
    alpha6d=0.5*abs(fcl);
    alpha6max=0.75*abs(fcl);
    alpha7d=0.1*abs(1/3*(fvrt+fvrl+fvtl));
    alpha7max=0.75*abs(1/3*(fvrt+fvrl+fvtl));

    f=abs(fcr)
    E=Er
    eta=abs(lc)/abs(Gfcr)
    kappa=kappa2
    alphad=alpha2d
    alphainf=alpha2max
    zeta=zeta2

    % before yielding
    epsilon1=linspace(0,f/E,11);
    sigma1=E.*epsilon1;

    % after yielding before densification
    epsilond=alphad/f+f/E*(1-kappa)*(exp(-eta*alphad)-1)+f/E;
    %epsilond=0.3;
    epsilon2=linspace(f/E,epsilond,101);
    for i=1:length(epsilon2)
        sigma2(i)=f*(kappa+(1-kappa)*exp(eta*(kappa*f^2/E-f*epsilon2(i))-lambertw((kappa-1)*(eta*f^2/E)*exp(eta*(kappa*f^2/E-f*epsilon2(i))))));
    end

    % after densification
    %{{
    alphahp=linspace(alphad,0.99*alphainf,101);
    for i=1:length(alphahp)
        q=(1-kappa)*(1-exp(-eta*alphahp(i)))-zeta*((alphahp(i)-alphad)^2/(alphainf-alphahp(i)));
        sigma3(i)=f*(1-q);
        epsilon3(i)=epsilond+(alphahp(i)-alphad)/f-f*((kappa-1)*(exp(-eta*alphahp(i))-exp(-eta*alphad))-zeta*(alphahp(i)-alphad)^2/(alphainf-alphahp(i)))/E;
    end
    %}}
    sigma=[sigma1 sigma2 sigma3];
    %sigma=[sigma1 sigma2];
    epsilon=[epsilon1 epsilon2 epsilon3];
    %epsilon=[epsilon1 epsilon2];
end

if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
elseif CasetoRun==4
elseif CasetoRun==5 || CasetoRun==6
elseif CasetoRun==7
elseif CasetoRun==8 || CasetoRun==9
end

%}

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function plotsigmainfconvergence()
	%meant to be copy-pasted
	%clear all
	close all
	clc
	convergence=[transpose(spCount) transpose(sigmainf)];

	loglog(convergence(:,1),convergence(:,2),'-x');
	hold on
	xlabel('number of particles');
	ylabel('sigma inf at propagation (MPa)');
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function plotnormsigmavsparticle()
	%meant to be copy-pasted
	%clear all
	close all
	clc
	convergence=[transpose(spCount) transpose(stressnormpersigmainf)];

	loglog(convergence(:,1),convergence(:,2),'-x');
	hold on
	xlabel('number of particles');
	ylabel('stressnormpersigmainf');
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function plotnormsigmavsgridsize()
	%meant to be copy-pasted
	%clear all
	close all
	clc
	convergence=[transpose(gridsize) transpose(stressnormpersigmainf)];

	loglog(convergence(:,1),convergence(:,2),'-x');
	hold on
	xlabel('grid size (mm)');
	ylabel('relative stress norm');
	set(gca,'XDir','reverse')
	set(gca,'xlim',[0.1 10]);
	n=length(gridsize);
	slope=log(stressnormpersigmainf(n)/stressnormpersigmainf(n-1))/log(gridsize(n)/gridsize(n-1))
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function plotGerror()
	%meant to be copy-pasted
	%clear all
	close all
	clc
	convergence=[transpose(gridsize) transpose(Grelativeerror)];

	loglog(convergence(:,1),convergence(:,2),'-x');
	hold on
	xlabel('grid size (mm)');
	ylabel('G relative error');
	set(gca,'XDir','reverse')
	set(gca,'xlim',[0.1 10]);
	n=length(gridsize);
	slope=log(Grelativeerror(n)/Grelativeerror(n-1))/log(gridsize(n)/gridsize(n-1))
end


















