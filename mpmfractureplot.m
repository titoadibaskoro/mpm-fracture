
%nmap ,cq :set scrolloff=999<CR>:,$s/\<runoff\>\\|asdf//gc<Left><Left><Left>

function MainHandler2()
	%{
	%switchable1
	%main calculation mechanism MATLAB for NOT ready
	fprintf('%s','switchable1 NOT c ready!');
	%}
	%switchable1
	%[
	%switchable1
	%main calculation mechanism MATLAB for NOT ready
	fprintf('%s','switchable1 minimalistic with c ready!');
	%]
	%switchable1
	%[
	%switchable2
	%print mechanism on for NOT ready
	fprintf('%s','switchable2 NOT c ready!');
	%]
	%switchable2
	
	%{
	%switchable2
	parfor i=1:20
		fprintf('%s',['i=' int2txt(i) char(10)]);
	end
	%}
	%switchable2
	
	%{
	%switchable3
	%load txt MATLAB error handling for not ready
	fprintf('%s','switchable3 NOT c ready!');
	%}
	%switchable3
	
	%INPUTS HERE:
	CasetoRun=230;
	%'Refinement factor? (for CasetoRun==26 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117)'
	if CasetoRun==118 || CasetoRun==173 || CasetoRun==192
		refinementfactor=16;
	elseif CasetoRun==125 || CasetoRun==126 || CasetoRun==127
		refinementfactor=30;
	elseif CasetoRun==128 || CasetoRun==130 || CasetoRun==132 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==129 || CasetoRun==136 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
		refinementfactor=4;
	elseif CasetoRun==134
		refinementfactor=20;
	elseif CasetoRun==131
		refinementfactor=36;
	elseif CasetoRun==137
		refinementfactor=4;
	elseif CasetoRun==138
		refinementfactor=4.5;
	elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
		refinementfactor=1;
	elseif CasetoRun==150 || CasetoRun==152
		refinementfactor=2;
	elseif CasetoRun==155 || CasetoRun==158 || CasetoRun==156 || CasetoRun==159
		refinementfactor=4;
	elseif CasetoRun==162
		refinementfactor=8;
	elseif CasetoRun==164 || CasetoRun==172 || CasetoRun==174
		refinementfactor=8;
	elseif CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180
		%refinement adjust
		refinementfactor=2;
	elseif CasetoRun==153
		refinementfactor=2;
	elseif CasetoRun==161
		refinementfactor=zeros(1,1);
	elseif CasetoRun==154
		refinementfactor=8;
	elseif CasetoRun==123 || CasetoRun==151
		refinementfactor=1;
	elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166
		refinementfactor=10;
	elseif CasetoRun==187 || CasetoRun==190
		refinementfactor=10;
	elseif CasetoRun==188
		refinementfactor=8;
	elseif CasetoRun==214 || CasetoRun==221 || CasetoRun==220
		refinementfactor=4;
	elseif CasetoRun==222 || CasetoRun==225
		refinementfactor=1;
	elseif CasetoRun==229
		refinementfactor=1;
	elseif CasetoRun==230
		%Edit point start: definent the refinement factor:
		refinementfactor=2;
		fprintf('%s',['before refinementfactor loadvariable' char(10)]);
		refinementfactor_loaded=loadvariable('refinementfactor');
		%fprintf('%s',['after refinementfactor loadvariable' char(10)]);
		fprintf('%s',['refinementfactor_loaded.found=' int2txt(refinementfactor_loaded.found) char(10)]);
		fprintf('%s',['refinementfactor_loaded.valuetext=' refinementfactor_loaded.valuetext char(10)]);
		if refinementfactor_loaded.found
			refinementfactor=str2long(refinementfactor_loaded.valuetext);
		end
		fprintf('%s',['refinementfactor=' float2scitxt(5,refinementfactor) char(10)]);
		%Edit point end
	elseif CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217
		refinementfactor=9; %TDL 210527 used to be 6 for normal runs
	elseif CasetoRun==228
		refinementfactor=6;
	elseif CasetoRun==213
		refinementfactor=10;
	elseif CasetoRun==191 || CasetoRun==212
		refinementfactor=10;
	elseif CasetoRun==197
		refinementfactor=10;
	elseif CasetoRun==198 || CasetoRun==196 || CasetoRun==195
		refinementfactor=20;
	elseif CasetoRun==189
		refinementfactor=10;
	elseif CasetoRun==181
		refinementfactor=16;
	elseif CasetoRun==186
		refinementfactor=3;
	elseif CasetoRun==185
		refinementfactor=4;
	elseif CasetoRun==184 || CasetoRun==193
		refinementfactor=4;
	elseif CasetoRun==183
		refinementfactor=4;
	elseif CasetoRun==182
		refinementfactor=16;
	elseif CasetoRun==201
		refinementfactor=2;
	elseif CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209
		%TDL refinement switcher here!	
		refinementfactor=1;
	elseif CasetoRun==227
		refinementfactor=6;
	elseif CasetoRun==226
		refinementfactor=6;
	elseif CasetoRun==219 || CasetoRun==224 || CasetoRun==223
		refinementfactor=2;
	elseif CasetoRun==205 || CasetoRun==210 || CasetoRun==207
		refinementfactor=3;
	elseif CasetoRun==20
		refinementfactor=3;
	elseif CasetoRun==203
		refinementfactor=2;
	elseif CasetoRun==211
		refinementfactor=8;
	elseif CasetoRun==200 
		refinementfactor=2;
	elseif CasetoRun==199 
		refinementfactor=10;
	elseif CasetoRun==179
		refinementfactor=2;
	elseif CasetoRun==165
		refinementfactor=10.5;
	elseif CasetoRun==124
		refinementfactor=3;
	else
		refinementfactor=1;
	end
	
	%for plotting purposes only, but harmless for coder
	frameskip=0; %stopping potential coder whine
	if CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169
		frameskip=9;
	elseif CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
		frameskip=0;
	elseif CasetoRun==229
		frameskip=19;
	elseif CasetoRun==230
		frameskip=0;
	elseif CasetoRun==228
		frameskip=0;
	elseif CasetoRun==179 || CasetoRun==199 
		frameskip=9;
	elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==178 || CasetoRun==169 || CasetoRun==165 || CasetoRun==164
		frameskip=9;
	elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==193
		frameskip=4;
	elseif CasetoRun==192
		frameskip=4;
	elseif CasetoRun==186 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
		frameskip=0;
	elseif CasetoRun==183
		frameskip=9;
	elseif CasetoRun==172 || CasetoRun==174
		frameskip=0;
	elseif CasetoRun==166
		frameskip=9;
	else
		frameskip=9;
	end
	if CasetoRun==153 || CasetoRun==154
		dumpresult=1; %no cracking on the ring, need to dump result anyway
	elseif CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==161
		dumpresult=0;
	elseif CasetoRun==165
		dumpresult=0;
	elseif CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==207
		dumpresult=1;
	elseif CasetoRun==222 || CasetoRun==225
		dumpresult=1;
	elseif CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==220
		dumpresult=0;
	elseif CasetoRun==229 || CasetoRun==230
		dumpresult=1;
	elseif CasetoRun==210
		dumpresult=1;
	elseif CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227
		dumpresult=1;
	elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211
		dumpresult=1;
	elseif CasetoRun==201
		dumpresult=0;
	elseif CasetoRun==183
		dumpresult=1;
	elseif CasetoRun==184 || CasetoRun==193
		dumpresult=1;
	elseif CasetoRun==192
		dumpresult=0;
	elseif CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
		dumpresult=0;
	elseif CasetoRun==185 || CasetoRun==186
		dumpresult=0;
	elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166
		dumpresult=0; %just test
	else
		dumpresult=1; %the initial state of whether data is dumped, for case 136 and 139 dumpresult=1 starts if about to crack
	end
	
	%'Run (0) or just plot (1) or just plot last (2)? '
	%[
	%switchable2
	runorjustplot=0;
	%]
	%switchable2
	%{
	%switchable2
	runorjustplot=0;
	%}
	%switchable2
	%[
	%switchable2
	runorjustplot=1;
	%]
	%switchable2
	%'Number of Cores? ' (for CasetoRun==14)
	numberofcores=4;
	
	%start of practical override
	mfilename='mpmfracture';
	%mkdir('SimOutput');
	%end of practical override
	VersionNum=mfilename;
	
	if CasetoRun==161
		for refinementfactorpower=0:9
			refinementfactor=2^(refinementfactorpower);
			anerror=Main(refinementfactor, 2, CasetoRun, runorjustplot, numberofcores, VersionNum, frameskip, dumpresult);
			savesinglefloat(anerror.t_deviation,['anerror.t_deviation' '-' int2txt(refinementfactor) '.txt']);
			savesinglefloat(anerror.u_err_relative,['anerror.u_err_relative' '-' int2txt(refinementfactor) '.txt']);
			savesinglefloat(anerror.gridsize,['anerror.gridsize' '-' int2txt(refinementfactor) '.txt']);
			
			savesinglefloat(anerror.u_srsserror,['anerror.u_srsserror' '-' int2txt(refinementfactor) '.txt']);
			savesinglefloat(anerror.u_srssan,['anerror.u_srssan' '-' int2txt(refinementfactor) '.txt']);
			savematrixfloat(anerror.u_sp_an,['anerror.u_sp_an' '-' int2txt(refinementfactor) '.txt']);
			savematrixfloat(anerror.u_sp,['anerror.u_sp' '-' int2txt(refinementfactor) '.txt']);
		end
	else
		DUMMY=Main(refinementfactor, 2, CasetoRun, runorjustplot, numberofcores, VersionNum, frameskip, dumpresult);
	end
end

%{
function ParticlePull()
	dESP=[0.001 0;0 0.00];
	sigma_global_big=[ 0, 0, 0, 0, 0, 0];
	e_t_global_big=[ 0, 0, 0, 0, 0, 0];
	e_pl_global_big=[ 0, 0, 0, 0, 0, 0];
	alpha_in=[ 0, 0, 0, 0, 0, 0, 0];
	xdirletter='t';
	ydirletter='r';
	zdirletter='l';
	xydirletter='tr';
	yzdirletter='rl';
	xzdirletter='tl';
	dudx_rtl=dESP;
	
	%input override from the real one
	%{
	dESP=[                0.0000092273517047498537947810767767542, -0.000000000000000000029876886326961723138418417955969; -0.000000000000000000029876886326961723138418417955969,                0.0000022292111761709296263646740837716];
	sigma_global_big=[ 2.627556919609589591857456980506, 0.92505782873414932332423177285818, 1.5986766367546838552016197354533, -0.00000000000000015427464434694612636524586431389, 0, 0];
	e_t_global_big=[ 0.0055397858013045749719927002274744, -0.00039292443354643563028366637368549, 0, -0.0000000000000000038568661086736565487678487293823, 0, 0];
	e_pl_global_big=[ 0, -0.0000000000000000011384122811097796557078254409134, -0.000000000000000000099083023677830163349792639533181, -3.0814879110195773648895647081359e-33, 0, 0];
	alpha_in=[ 0, 0, 0, 0, 0, 0, 0];
	dudx_rtl=[                0.0036774742874255972324704089260194, 0.000000000000000020968140727901620878357464091193; -0.000000000000000028536079657031517936656558982959,              -0.0022579939820457362031902448507026];
	xdirletter =    't'
	ydirletter =    'r'
	zdirletter =    'l'
	xydirletter =    'tr'
	yzdirletter =    'rl'
	xzdirletter =    'tl'
	%}
	%end of input override from the real one
	
	ftl=65.5;
	ftr=3.75;
	ftt=2.79;
	fcl=-50.3;
	fcr=-2.75;
	fct=-5;
	fvrt=1.83;
	fvrl=6.34;
	fvtl=5.34;
	Er=820;
	Et=430;
	El=13200;
	Grt=40;
	Gtl=730;
	Grl=660;
	nurt=0.24;
	nutl=0.45;
	nurl=0.45;
	kappa1=0.00001;
	kappa2=1.2;
	kappa3=0.00001;
	kappa4=1.2;
	kappa5=0.00001;
	kappa6=0.7;
	kappa7=1.0;
	Gftl=1.65;
	Gfcl=50.0;
	Gftr=0.3;
	Gftt=0.3;
	Gfcr=9.0909090909090909090909090909091;
	Gfct=9.0909090909090909090909090909091;
	GII=0.3;
	Hld=15.0;
	Hrd=2.0;
	Htd=2.0;
	lc=8.3333333333333333333333333333333;
	alpha2dnounit=0.1;
	alpha2maxnounit=0.75;
	alpha4dnounit=0.1;
	alpha4maxnounit=0.75;
	alpha6dnounit=0.5;
	alpha6maxnounit=0.75;
	alpha7dnounit=1.0;
	alpha7maxnounit=1.5;
	CasetoRun=-99;
	t_time=0;
	dt=0.00019462473604038075625059789341975;
	spid=1;
	Debugging.Active= 0;
	Debugging.Case= 25;
	Debugging.FileName= 'A201810121045-GerhardMultiManualEllipse-ms=100-Dump.mat';
	Debugging.Time= 5.2234;
	Debugging.Particle= 2649;
	Debugging.DesignatedStopRepeater= 158;
	
	for i=1:inf
		[s_sp,e_pl,sigma_global_big,e_t_global_big,e_pl_global_big,alpha_out,f_final_vect,surfacewithfmax,sigma_local_big,evaltimes,thetacrackrtl,Ktangent_global,Ktangent_global_2D,Ktangent_global_tens,Ktangent_global_tens_2D,activesurfacelist,AbeforeQ_rtl,lambdamin,thetamin,Ktangent_local]= ...
			Wood_Schmidt17(dESP,sigma_global_big,e_t_global_big,e_pl_global_big,alpha_in,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,t_time,dt,spid,Debugging,NaN,dudx_rtl);
		alpha_in=alpha_out;
		%{
		if i==5
			dESP=dESP/10;
		end
		if i==10
			dESP=dESP/10;
		end
		if i==14
			dESP=dESP/10;
		end
		%}
		disp(['s_sp=' num2str(s_sp)]);
		disp(['i=' num2str(i)]);
		Ktangent_global_2D;
		lambdamin;
		thetamin;
		disp(['lambdamin=' num2str(lambdamin) ', thetacrackrtl=' num2str(thetacrackrtl*180/pi) ' degrees']);
		%pause
		1;
		L=dESP/dt;
		dudx_rtl=dudx_rtl+L*dt;
	end
end
%}
%{
function MainHandler()
	% THE INPUTS here:
	CasetoRun=122;
	refinementfactorlist=[2:2:100];
	runorjustplot=0;
	%'Number of Cores? ' (for CasetoRun==14)
	numberofcores=4;
	
	
	spCount=[];
	lastindex=0;
	uiload;
	if exist('TimeStampedNameBasic');
		lastindex=newindex;
		if mfilename==TimeStampedNameBasic(1:length(mfilename));
		else
			for i=1:lastindex+1
				try
					copyfile([TimeStampedNameBasic '-ms=100-RefLvl=' num2str(refinementfactorlist(i)) '-Master.mat'],[mfilename TimeStampedNameBasic(length(mfilename)+1:length(TimeStampedNameBasic)) '-ms=100-RefLvl=' num2str(refinementfactorlist(i)) '-Master.mat']);
					copyfile([TimeStampedNameBasic '-ms=100-RefLvl=' num2str(refinementfactorlist(i))],[mfilename TimeStampedNameBasic(length(mfilename)+1:length(TimeStampedNameBasic)) '-ms=100-RefLvl=' num2str(refinementfactorlist(i))]);
				catch
					disp([TimeStampedNameBasic '-ms=100-RefLvl=' num2str(refinementfactorlist(i)) ' not found!']);
				end
			end
			TimeStampedNameBasic=[mfilename TimeStampedNameBasic(length(mfilename)+1:length(TimeStampedNameBasic))];
			save([TimeStampedNameBasic '-MainHandler.mat'],'-v7.3',...
			'spCount', ...
			'sigmainf', ...
			'pforce_sp', ...
			'stressnorm', ...
			'stressnormpersigmainf', ...
			'dispnorm', ...
			'gridsize', ...
			'G', ...
			'Ga', ...
			'Grelativeerror', ...
			'e_t_global_big', ...
			'e_sp', ...
			'Dmatrix', ...
			's_sp', ...
			'newindex', ...
			'TimeStampedNameBasic');
		end
	end
	for i=1:length(refinementfactorlist)
		if i<=lastindex
			continue;
		end
		newindex=length(spCount)+1;
		refinementfactor=refinementfactorlist(i);
		[spCount(newindex) sigmainf(newindex) TimeStampedNameBasic pforce_sp{newindex} stressnorm(newindex) dispnorm(newindex) gridsize(newindex) G(newindex) Ga(newindex) Grelativeerror(newindex) e_t_global_big{newindex} e_sp{newindex} Dmatrix s_sp{newindex}]=Main(refinementfactor,1,CasetoRun,runorjustplot,numberofcores);
		stressnormpersigmainf(newindex)=stressnorm(newindex)/sigmainf(newindex);
		save([TimeStampedNameBasic '-MainHandler.mat'],'-v7.3',...
		'spCount', ...
		'sigmainf', ...
		'pforce_sp', ...
		'stressnorm', ...
		'stressnormpersigmainf', ...
		'dispnorm', ...
		'gridsize', ...
		'G', ...
		'Ga', ...
		'Grelativeerror', ...
		'e_t_global_big', ...
		'e_sp', ...
		'Dmatrix', ...
		's_sp', ...
		'newindex', ...
		'TimeStampedNameBasic');
		1;
	end
end
%}

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [anerror spCount sigmainf TimeStampedNameBasic pforce_sp stressnorm dispnorm gridsize G Ga Grelativeerror, e_t_global_big e_sp Dmatrix s_sp]=Main(refinementfactor, HandlerNumber, CasetoRun, runorjustplot, numberofcores, VersionNum, frameskip, dumpresult)
	close all;
	Debugging.Active=0;
	Debugging.Case=111;
	Debugging.FileName='zz1904252320-111_CTSpecimen-ms=100-Dump.mat';
	Debugging.Time=0.32206501319960556539712115409202;
	Debugging.Particle=265;
	Debugging.DesignatedStopRepeater=1;
	
	ttstart=1;
	%clear all;
	%tic;
	%{
	addpath('SubFunctions/Cores');ressm
	addpath('SubFunctions/Constitutive_Models');
	addpath('SubFunctions/CPDI_solvers');
	addpath('SubFunctions/MPM_solvers');
	addpath('SubFunctions/TLS_MPM_solvers');
	addpath('SubFunctions/TLS_CPDI_solvers');
	addpath('SubFunctions/TLS');
	addpath('Particle_generation_input');
	%}
	
	%Remark='FlexiBeamLRTlocalstress';
	casenamelist=cell(1,230);
	casenamelist{1}='R_comp_MassScale';
	casenamelist{2}='T_comp_by_rotation_MassScale';
	casenamelist{3}='Radial_Fine';
	casenamelist{4}='Connection_TnSignored';
	casenamelist{5}='3-point_SEN';
	casenamelist{6}='3-point_SEN_touch';
	casenamelist{7}='Energy_Absorb';
	casenamelist{8}='3-point_SEN_lvar';
	casenamelist{9}='3-point_SEN_touch_lvar';
	casenamelist{10}='R_tension_dampnignore';
	casenamelist{11}='GerhardTensKnot';
	casenamelist{12}='StevenCompKnotCPDIFine';
	casenamelist{13}='GerhardMultiKnotFine';
	casenamelist{14}='GerhardCoreTest';
	casenamelist{15}='GerhardMultiKnotChopedOffFine';
	casenamelist{16}='StevenCompKnotOffsetFine';
	casenamelist{17}='RadialOldPerfectPlastic_EvalCounter';
	casenamelist{18}='StevenOffsetNoWeakening';
	casenamelist{19}='Radial_Elasticer';
	casenamelist{20}='GerhardMultiManualOrient';
	casenamelist{21}='Radial_Hover';
	casenamelist{22}='Radial_QuickHardening';
	casenamelist{23}='StevenOffNoWeakQuickHrdnig';
	casenamelist{24}='Radial_SlowHardening';
	casenamelist{25}='GerhardMultiManualEllipse';
	casenamelist{26}='Radial_RefineTest';
	casenamelist{27}='Radial_Scheduling_Test';
	casenamelist{28}='Radial_f_switcheroo';
	casenamelist{29}='Radial_f_switcheroo66';
	casenamelist{30}='Radial_f_noswitchRT36';
	casenamelist{31}='Radial_f_poissonedit';
	casenamelist{32}='GerhardTedManual';
	casenamelist{33}='Radial_CoarseTestBed';
	casenamelist{34}='Radial_fcMiksic';
	casenamelist{35}='GerhardTedManual_mfMiksic';
	casenamelist{36}='GerhardMoreOvalMiksic';
	casenamelist{37}='GerhardOvalSchmidt';
	casenamelist{38}='Steven_Birch';
	casenamelist{39}='Radial_Miksic_vreduced';
	casenamelist{40}='Radial_Miksic_widetop';
	casenamelist{41}='Steven_Birch_adjust';
	casenamelist{42}='Radial_MkcWide_ftrless';
	casenamelist{43}='Steven_Birch_AllowxMoveAtBot';
	casenamelist{44}='Steven_Birch_AllowxMoveAtTop';
	casenamelist{45}='Radial_MkcWide_fvHardeningIsBack';
	casenamelist{46}='Steven_Birch_normalshearhardening';
	casenamelist{47}='Steven_Birch_stronger_ftt';
	casenamelist{48}='Radial_MkcWide_ftrless_fttmore';
	casenamelist{49}='Steven_Birch_fclDown_ftlDownfcrUp';
	casenamelist{50}='Steven_Birch_ShearSoftening';
	casenamelist{51}='Steven_Birch_LinearScaling';
	casenamelist{52}='Radial_WideTop_Repositioned';
	casenamelist{53}='Steven_Birch_LinScale_xbotfree';
	casenamelist{54}='Radial_WideTop_Repositioned2_linearloading';
	casenamelist{55}='Gerhard_squishyball_2ndway_ortho2';
	casenamelist{56}='Gerhard_squishyball_3rdway_ortho2';
	casenamelist{57}='Gerhard_squishyball_1stway_ortho2';
	casenamelist{58}='Gerhard_squishyball_1stway_ortextreme';
	casenamelist{59}='Gerhard_squishyball_2ndway_ortextreme';
	casenamelist{60}='Gerhard_squishyball_3rdway_ortextreme';
	casenamelist{61}='Gerhard_squishyball_1stway_ortex2';
	casenamelist{62}='Gerhard_squishyball_2ndway_ortex2';
	casenamelist{63}='Gerhard_squishyball_3ndway_ortex2';
	casenamelist{64}='CRAMP Double Beam';
	casenamelist{65}='CRAMP_Double_Beam_Asymmetrical';
	casenamelist{66}='CRAMP_Double_Beam_Long';
	casenamelist{67}='ShrinkingBlob';
	casenamelist{68}='XYShrinkThickBlob';
	casenamelist{69}='CRAMP_Double_Beam_Force';
	casenamelist{70}='CRAMP_Double_Beam_Asymmetrical';
	casenamelist{71}='XYShrinkThinInitial';
	casenamelist{72}='XYShrinkThickInitiation';
	casenamelist{73}='XYShrinkAcousticInitiation';
	casenamelist{74}='XYShrinkDiscreteandQ';
	casenamelist{77}='Forceatcrackparticles';
	casenamelist{78}='XYShrinkDiscreteandQ_steel';
	casenamelist{79}='XYShrinkDiscreteandQ_steel_asym';
	casenamelist{80}='XYShrinkNairnQavg_steel_asym';
	casenamelist{81}='XYShrinkDiscreteandQ_steel'; %78 but refined
	casenamelist{82}='XYShrinkNairnQavg_steel_sym'; %80 but symmetrical initial crack
	casenamelist{83}='ShrinkNoSteelAvgQ_MultiCrackFail';
	casenamelist{84}='ShrinkNoSteelAvgQ_MultiCrackTestBed'; %2 crack cross split
	casenamelist{85}='SmallSpecimenDoubleCracks';
	casenamelist{86}='MediumSpecimenDoubleCracks';
	casenamelist{87}='MediumSpecimenDoubleCrackshalf';
	casenamelist{88}='ShrinkDoubleCrackSteel';
	casenamelist{89}='MediumSpecimenSingleCrackshalf';
	casenamelist{90}='MediumSpecimenDoubleCracksEdge';
	casenamelist{91}='MediumSpecimenDoubleCracksHalfnOut';
	casenamelist{92}='MediumSpecimenDoubleCracksHalfnOutCross';
	casenamelist{93}='MPMCheckupFrom92';
	casenamelist{94}='MediumSpecimenDoubleCracksHalfnEdge';
	casenamelist{95}='MediumSpecimenDoubleCracksHalfnHalf';
	casenamelist{96}='ShrinkBranchCrackSteel';
	casenamelist{97}='MediumSpecimenDoubleCracksCellCut';
	casenamelist{98}='DoubleCrackPropagate';
	casenamelist{99}='MediumSpecimenDoubleCracksEights';
	casenamelist{100}='XYShrinkNairnQavg_steel_sym_multi'; %80 but symmetrical initial crack
	casenamelist{101}='XYShrinkNairnQavg_singlecrack_multioptimized'; %100 but using quan's and optimized
	casenamelist{102}='XYShrinkNairnQavg_triplecrack_optimized';
	casenamelist{103}='DoubleCrackEdgeTest';
	casenamelist{104}='NoInitialCrack';
	casenamelist{105}='SingleInitialRefined'; %101 but refined
	casenamelist{106}='XYShrinkNairnQavg_doublecrack_optimized';
	casenamelist{107}='XYShrinkNairnQavg_doublecrackequal';
	casenamelist{108}='NoInitialCrack_randomtop';
	casenamelist{109}='SingleInitialFlippityFlop';
	casenamelist{110}='NoInitialRandomRefined';
	casenamelist{111}='CTSpecimen';
	casenamelist{112}='CantileverBeam';
	casenamelist{113}='CTSpecimen_slow';
	casenamelist{114}='NoInitialNoRandomNoSideroller';
	casenamelist{115}='InfinitePlate';
	casenamelist{116}='InfinitePlate2x2';
	casenamelist{117}='InfinitePlate2x2CrackParticleTest';
	casenamelist{118}='DanasPlate';
	casenamelist{119}='InfinitePlate2x2Norms';
	casenamelist{120}='InfinitePlate2x2Norms_pfconst'; %constant traction force
	casenamelist{121}='InfinitePlate2x2Norms_pgrid'; %traction on grid 
	casenamelist{122}='InfinitePlate2x2NormsAngled'; %angled crack infinite plane
	casenamelist{123}='CrackIntersectionTestBench';
	casenamelist{124}='NairnRadial';
	casenamelist{125}='AsymSingleLowDamp';
	casenamelist{126}='AsymSingleHighDamp';
	casenamelist{127}='SymNodeLeft';
	casenamelist{128}='SymNodeRight';
	casenamelist{129}='SymFloatLeft';
	casenamelist{130}='SymFloatRight';
	casenamelist{131}='SymFloatLeft_LongBeamPin';
	casenamelist{132}='SymFloatLeft_PullUpHorizontal';
	casenamelist{133}='SymFloatLeft_LongBeamPin_Directional';
	casenamelist{134}='SymFloatLeft_LongBeamShear';
	casenamelist{135}='SymLeft_LongBeamDir_Slow';
	casenamelist{136}='SymLeft_LongBeamShear_Slow';
	casenamelist{137}='InfinitePlate2x2Norms_revived';
	casenamelist{138}='InfinitePlate2x2Norms_revived2';
	casenamelist{139}='SymFloatLeft_LongBeamPin_FEM';
	casenamelist{140}='SymFloat_LongBeam_FEM_MixMode';
	casenamelist{141}='SymFloat_LongBeam_FEM_Mode1Only';
	casenamelist{142}='SymFloat_LongBeam_FEM_Mode2Only';
	casenamelist{143}='SymFloat_LongBeam_FEM_MixMode_revcomp';
	casenamelist{144}='PullColumnRegular';
	casenamelist{145}='PullColumnTwoSlices';
	casenamelist{146}='PullColumnNearDirichlet';
	casenamelist{147}='PullColumnNearPull';
	casenamelist{148}='PullColumnVeryNearDirichlet';
	casenamelist{149}='PullColumnNoCrack';
	casenamelist{150}='Cracked_Donut';
	casenamelist{151}='CrackMergePerpendicular';
	casenamelist{152}='Custom_Donut';
	casenamelist{153}='Donut_RingnoPetals';
	casenamelist{154}='Vortex';
	casenamelist{155}='DonutFixedLoad';
	casenamelist{156}='DonutPhasedPump';
	casenamelist{157}='DonutFixedLoadSoft';
	casenamelist{158}='DonutExploding';
	casenamelist{159}='DonutPhasedPumpRotate';
	casenamelist{160}='DonutSoftF=kDrcollective';
	casenamelist{161}='Vortex_Convergence';
	casenamelist{162}='DonutStableRotateActuator';
	casenamelist{163}='InitiationShow';
	casenamelist{164}='DonutCanRotateInitiation';
	casenamelist{165}='InitiationShow3';
	casenamelist{166}='InitiationShowPoint';
	casenamelist{167}='InitiationSquat';
	casenamelist{168}='Merging';
	casenamelist{169}='InitiationDouble';
	casenamelist{170}='InitiationOriginal163';
	casenamelist{171}='InitiationShearTract';
	casenamelist{172}='DonutRotateInitiatePerturbed';
	casenamelist{173}='DanasAsympLoading';
	casenamelist{174}='DonutRotateInitiateToughness';
	casenamelist{175}='DonutSoftF=kDrpropagate';
	casenamelist{176}='InitiationSquatPlasticCoder';
	casenamelist{177}='SimpleCrack';
	casenamelist{178}='SimpleMixedMode';
	casenamelist{179}='WoodStretchY';
	casenamelist{180}='DonutNoPropagation';
	casenamelist{181}='Merging_Convergence';
	casenamelist{182}='Merging_Convergence_Circle';
	casenamelist{183}='EnergyAbsorbingMovingTest';
	casenamelist{184}='CohesionTest1';
	casenamelist{185}='CohesionTest2_propagation';
	casenamelist{186}='CohesionTest2_propagation';
	casenamelist{187}='InitiationSquatCohesive';
	casenamelist{188}='MergingCohesive';
	casenamelist{189}='MergingCircleCohesive';
	casenamelist{190}='InitiationDouble';
	casenamelist{191}='MergingUpright';
	casenamelist{192}='DanasCohesive';
	casenamelist{193}='PizzaCheese';
	casenamelist{194}='DonutCohesive';
	casenamelist{195}='MergingTopRoller';
	casenamelist{196}='MergingAngled';
	casenamelist{197}='MergingSlightAngle';
	casenamelist{198}='MergingOffset';
	casenamelist{199}='AcousticRevivalOriginal';
	casenamelist{200}='AcousticRevivalAlt1'; %alternative method 1
	casenamelist{201}='PlInitiation'; %alternative method 2
	casenamelist{202}='ShrinkageGeneric'; 
	casenamelist{203}='PullVertical';	
	casenamelist{204}='ShrinkageConeSpec'; 
	casenamelist{205}='ShrinkLogWoodEP'; 
	casenamelist{206}='ShrinkageConeBackrotate'; 
	casenamelist{207}='ShrinkLogElasticNoCrack'; 
	casenamelist{208}='ShrinkBlockElEPTip'; 
	casenamelist{209}='ShrinkBlockElEPTipBackRotate'; 
	casenamelist{210}='ShrinkLogWoodEPBoxProp'; 
	casenamelist{211}='PullVerticalBoxProp';	
	casenamelist{212}='MergingUprightEP';
	casenamelist{213}='MergingUprightEP2';
	casenamelist{214}='StraightInitialCrackEP2';
	casenamelist{215}='MergingUprightBoxElastic1';
	casenamelist{216}='MergingUprightBoxElastictilted';
	casenamelist{217}='InitiationBoxEP';
	casenamelist{218}='MergingUprightBoxElasticmuchtilted';
	casenamelist{219}='ShrinkBlockBoxEP';
	casenamelist{220}='MixModetInitialCrackEP2';
	casenamelist{221}='StraightInitialCrackHighTaper';
	casenamelist{222}='MaterialPullTest';
	casenamelist{223}='ShrinkBlockBoxEPLeftHalf';
	casenamelist{224}='ShrinkBlockBoxEPTopHalf';
	casenamelist{225}='MaterialPullTestOneCell';
	casenamelist{226}='BlockHalfDoubleFDS';
	casenamelist{227}='BlockFullDoubleFDSElShow';
	casenamelist{228}='GerhardswithCrack';
	casenamelist{229}='DMTAtension';
	casenamelist{230}='SimpleCase';
	
	fprintf('%s',['Case ' int2txt(CasetoRun) ': ' casenamelist{CasetoRun} ' selected' char(10)]);
	
	% Case 1: L Compression
	% Case 2: Connection
	casename=casenamelist{CasetoRun};
	
	if runorjustplot==0
		simulationbreaksignal=0;
	elseif runorjustplot==1 || runorjustplot==2
		simulationbreaksignal=1;
	end
	% Unit
	% Newton - seconds - metre
	% Unit Change In Progress: to N-mm-s
	
	%% Please select the versions of MPM!!!!!!!!!!!!!!!!!
	% Original MPM: 'MPM'
	% CPDI: 'CPDI'
	% Taylor least square MPM: 'TLS_MPM' 
	% Taylor least square CPDI: 'TLS_CPDI'
	
	% Please remember to change the output video file!!
	
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==8 || CasetoRun==9 || CasetoRun==10 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		Version = 'CPDI';
	else
		Version = 'MPM';
	end
	
	%% Constutitive model
	% Linear_Elastic
	
	% Neo_Hookean_Elastic
	% Mises
	% Mises_Softening
	CModel = 'Wood_Schmidt17';
	%CModel = 'Linear_Elastic';
	%% Material porperties
	if CasetoRun==64 || CasetoRun==66 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		E=400;
	elseif CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==117 || CasetoRun==113
		E=8000;
	elseif CasetoRun==230
		%Edit point start: define youngs modulus
		E=8000;
		fprintf('%s',['before E loadvariable' char(10)]);
		E_loaded=loadvariable('E');
		%fprintf('%s',['after E loadvariable' char(10)]);
		fprintf('%s',['E_loaded.found=' int2txt(E_loaded.found) char(10)]);
		fprintf('%s',['E_loaded.valuetext=' E_loaded.valuetext char(10)]);
		if E_loaded.found
			E=str2float(E_loaded.valuetext);
		end
		fprintf('%s',['E=' float2scitxt(5,E) char(10)]);
		%Edit point end
	elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153
		E=800;
	elseif CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180
		E=8;
	elseif CasetoRun==154 || CasetoRun==161
		E=1000;                  % Young modulus of solid
	elseif CasetoRun==127
		E=4000;
	elseif CasetoRun==124
		E=1200;
	elseif CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==8 || CasetoRun==9 || CasetoRun==10 || CasetoRun==11 || CasetoRun==12 || CasetoRun==13 || CasetoRun==14 || CasetoRun==15 || CasetoRun==16 || CasetoRun==17 || CasetoRun==18 || CasetoRun==19 || CasetoRun==20 || CasetoRun==21 || CasetoRun==22 || CasetoRun==23 || CasetoRun==24 || CasetoRun==25 || CasetoRun==26 || CasetoRun==27 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==32 || CasetoRun==33 || CasetoRun==34 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==38 || CasetoRun==39 || CasetoRun==40 || CasetoRun==41 || CasetoRun==42 || CasetoRun==43 || CasetoRun==44 || CasetoRun==45 || CasetoRun==46 || CasetoRun==47 || CasetoRun==48 || CasetoRun==49 || CasetoRun==50 || CasetoRun==51 || CasetoRun==52 || CasetoRun==53 || CasetoRun==54 || CasetoRun==55 || CasetoRun==56 || CasetoRun==57 || CasetoRun==58 || CasetoRun==59 || CasetoRun==60 || CasetoRun==61 || CasetoRun==62 || CasetoRun==63 || CasetoRun==69
		E=200e3          ;                  % Young modulus of steel 200 GPa = 200e3 MPa = 200e3 N/mm2
	end
	%psp                     = 8e-7*1000            ;                  % solid density 800 kg/m3 = 800/1e9 kg/mm3 = 8e-7; scaled by the factor of 1000
	nu                      = 0.3           ;                  % Poison ratio
	
	fprintf('%s',['before nu loadvariable' char(10)]);
	nu_loaded=loadvariable('nu');
	%fprintf('%s',['after nu loadvariable' char(10)]);
	fprintf('%s',['nu_loaded.found=' int2txt(nu_loaded.found) char(10)]);
	fprintf('%s',['nu_loaded.valuetext=' nu_loaded.valuetext char(10)]);
	if nu_loaded.found
		nu=str2float(nu_loaded.valuetext);
	end
	fprintf('%s',['nu=' float2scitxt(5,nu) char(10)]);
	
	g                       = 0            ;                  % gravity acceleration
	%b_sp                    = [0 0];                                % body force
	%Edit point start: define body force
	b_1=0;
	b_2=0;
	
	fprintf('%s',['before b_1 loadvariable' char(10)]);
	b_1_loaded=loadvariable('b_1');
	%fprintf('%s',['after b_1 loadvariable' char(10)]);
	fprintf('%s',['b_1_loaded.found=' int2txt(b_1_loaded.found) char(10)]);
	fprintf('%s',['b_1_loaded.valuetext=' b_1_loaded.valuetext char(10)]);
	if b_1_loaded.found
		b_1=str2float(b_1_loaded.valuetext);
	end
	fprintf('%s',['b_1=' float2scitxt(5,b_1) char(10)]);
	
	fprintf('%s',['before b_2 loadvariable' char(10)]);
	b_2_loaded=loadvariable('b_2');
	%fprintf('%s',['after b_2 loadvariable' char(10)]);
	fprintf('%s',['b_2_loaded.found=' int2txt(b_2_loaded.found) char(10)]);
	fprintf('%s',['b_2_loaded.valuetext=' b_2_loaded.valuetext char(10)]);
	if b_2_loaded.found
		b_2=str2float(b_2_loaded.valuetext);
	end
	fprintf('%s',['b_2=' float2scitxt(5,b_2) char(10)]);
	
	b_sp_base=zeros(1,2);
	b_sp_base(1)=b_1;
	b_sp_base(2)=b_2;
	
	%Edit point end
	
	if CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		ftl_spruce=65.5;
		fcl_spruce=-50.3;
		fcl=-47.6;
		ftl=ftl_spruce/fcl_spruce*fcl;
	else
		ftl=65.5;
		fcl=-50.3;
	end
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==37 || CasetoRun==23
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		fcr=-6;
		fct=-6;
	elseif CasetoRun==28
		ftr=2.79;
		ftt=3.75;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		fcr=-3;
		fct=-6;
	elseif CasetoRun==29
		ftr=2.79;
		ftt=3.75;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		fcr=-6;
		fct=-6;
	elseif CasetoRun==30
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		fcr=-3;
		fct=-6;
	elseif CasetoRun==31
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		fcr=-6;
		fct=-6;
	elseif CasetoRun==33
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		%fcr=-5.333333333333333333333333333333;
		%fct=-4;
		fcr=-3;
		fct=-6;
	elseif CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==39 || CasetoRun==35 || CasetoRun==36 || CasetoRun==45
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		%fcr=-3;
		%fct=-6;
		fcr=-(1.5+4)/2;
		fct=-5;
	elseif CasetoRun==42
		ftr=3.75*0.7;
		ftt=2.79;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		%fcr=-3;
		%fct=-6;
		fcr=-(1.5+4)/2;
		fct=-5;
	elseif CasetoRun==4
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83; %replacereplacereplace
		fvrl=6.34; %replacereplacereplace
		fvtl=5.34; %replacereplacereplace
		fcr=-6;
		fct=-6;
	elseif CasetoRun==5 || CasetoRun==6
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83; %replacereplacereplace
		fvrl=6.34; %replacereplacereplace
		fvtl=5.34; %replacereplacereplace
		fcr=-6;
		fct=-6;
	elseif CasetoRun==7
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83; %replacereplacereplace
		fvrl=6.34; %replacereplacereplace
		fvtl=5.34; %replacereplacereplace
		fcr=-6;
		fct=-6;
	elseif CasetoRun==8 || CasetoRun==9
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83; %replacereplacereplace
		fvrl=6.34; %replacereplacereplace
		fvtl=5.34; %replacereplacereplace
		fcr=-6;
		fct=-6;
	elseif CasetoRun==10
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		fcr=-6;
		fct=-3;
	elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==15 || CasetoRun==14
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		fcr=-6;
		fct=-3;
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		fcr=-6;
		fct=-3;
	elseif CasetoRun==38 || CasetoRun==50 || CasetoRun==46
		ftr_spruce=3.75;
		ftt_spruce=2.79;
		ftper_spruce=(ftr_spruce+ftt_spruce)/2;
		fvrt_spruce=1.83/1; %replacereplacereplace
		fvrl_spruce=6.34/1; %replacereplacereplace
		fvtl_spruce=5.34/1; %replacereplacereplace
		fcr_spruce=-(1.5+4)/2;
		fct_spruce=-5;
		fcper_spruce=(fcr_spruce+fct_spruce)/2;
		
		
		fcl_yellow=-144;
		fcper_yellow=-6.7;
		fcr_yellow=fcper_yellow/fcper_spruce*fcr_spruce;
		fct_yellow=fcper_yellow/fcper_spruce*fct_spruce;
		
		fcr=fcl/fcl_yellow*fcr_yellow;
		fct=fcl/fcl_yellow*fct_yellow;
		
		fvrt=fcl/fcl_spruce*fvrt_spruce;
		fvrl=fcl/fcl_spruce*fvrl_spruce;
		fvtl=fcl/fcl_spruce*fvtl_spruce;
		
		ftper_yellow=6.3;
		ftr_yellow=ftr_spruce/ftper_spruce*ftper_yellow;
		ftt_yellow=ftt_spruce/ftper_spruce*ftper_yellow;
		
		ftr=ftr_yellow/fcl_yellow*fcl;
		ftt=ftt_yellow/fcl_yellow*fcl;
	elseif CasetoRun==51 || CasetoRun==53
		ftr_spruce=3.75;
		ftt_spruce=2.79;
		fvrt_spruce=1.83/1; %replacereplacereplace
		fvrl_spruce=6.34/1; %replacereplacereplace
		fvtl_spruce=5.34/1; %replacereplacereplace
		fcr_spruce=-(1.5+4)/2;
		fct_spruce=-5;
		fcl=47.6;
		fcr=fcl/fcl_spruce*fcr_spruce;
		fct=fcl/fcl_spruce*fct_spruce;
		ftl=fcl/fcl_spruce*ftl_spruce;
		ftr=fcl/fcl_spruce*ftr_spruce;
		ftt=fcl/fcl_spruce*ftt_spruce;
		fvrt=fcl/fcl_spruce*fvrt_spruce;
		fvrl=fcl/fcl_spruce*fvrl_spruce;
		fvtl=fcl/fcl_spruce*fvtl_spruce;
	elseif CasetoRun==49
		ftr_spruce=3.75;
		ftt_spruce=2.79;
		ftper_spruce=(ftr_spruce+ftt_spruce)/2;
		fvrt_spruce=1.83/1; %replacereplacereplace
		fvrl_spruce=6.34/1; %replacereplacereplace
		fvtl_spruce=5.34/1; %replacereplacereplace
		fcr_spruce=-(1.5+4)/2;
		fct_spruce=-5;
		fcper_spruce=(fcr_spruce+fct_spruce)/2;
		
		
		fcl_yellow=-144;
		fcper_yellow=-6.7;
		fcr_yellow=fcper_yellow/fcper_spruce*fcr_spruce;
		fct_yellow=fcper_yellow/fcper_spruce*fct_spruce;
		
		fcr=fcl/fcl_yellow*fcr_yellow;
		fct=fcl/fcl_yellow*fct_yellow;
		
		fvrt=fcl/fcl_spruce*fvrt_spruce;
		fvrl=fcl/fcl_spruce*fvrl_spruce;
		fvtl=fcl/fcl_spruce*fvtl_spruce;
		
		ftper_yellow=6.3;
		ftr_yellow=ftr_spruce/ftper_spruce*ftper_yellow;
		ftt_yellow=ftt_spruce/ftper_spruce*ftper_yellow;
		
		ftr=ftr_yellow/fcl_yellow*fcl;
		ftt=ftt_yellow/fcl_yellow*fcl;
		fcr=fcr*1.3;
		ftl=ftl*0.7;

	elseif CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		ftr_spruce=3.75;
		ftt_spruce=2.79;
		ftper_spruce=(ftr_spruce+ftt_spruce)/2;
		fvrt_spruce=1.83/1; %replacereplacereplace
		fvrl_spruce=6.34/1; %replacereplacereplace
		fvtl_spruce=5.34/1; %replacereplacereplace
		fvrltl_spruce=(fvrl_spruce+fvtl_spruce)/2;
		
		fcr_spruce=-(1.5+4)/2;
		fct_spruce=-5;
		fcper_spruce=(fcr_spruce+fct_spruce)/2;
		
		fvrltl_yellow=13;
		fvrl_yellow=fvrltl_yellow/fvrltl_spruce*fvrl_spruce;
		fvtl_yellow=fvrltl_yellow/fvrltl_spruce*fvtl_spruce;
		fvrt_yellow=fvrltl_yellow/fvrltl_spruce*fvrt_spruce;
		
		fcl_yellow=-144;
		fcper_yellow=-6.7;
		fcr_yellow=fcper_yellow/fcper_spruce*fcr_spruce;
		fct_yellow=fcper_yellow/fcper_spruce*fct_spruce;
		
		fcr=fcl/fcl_yellow*fcr_yellow;
		fct=fcl/fcl_yellow*fct_yellow;
		
		fvrt=fcl/fcl_yellow*fvrt_yellow;
		fvrl=fcl/fcl_yellow*fvrl_yellow;
		fvtl=fcl/fcl_yellow*fvtl_yellow;
		
		ftper_yellow=6.3;
		ftr_yellow=ftr_spruce/ftper_spruce*ftper_yellow;
		ftt_yellow=ftt_spruce/ftper_spruce*ftper_yellow;
		
		ftr=ftr_yellow/fcl_yellow*fcl;
		ftt=ftt_yellow/fcl_yellow*fcl;
	elseif CasetoRun==47
		ftr_spruce=3.75;
		ftt_spruce=2.79;
		ftper_spruce=(ftr_spruce+ftt_spruce)/2;
		fvrt_spruce=1.83/1; %replacereplacereplace
		fvrl_spruce=6.34/1; %replacereplacereplace
		fvtl_spruce=5.34/1; %replacereplacereplace
		fcr_spruce=-(1.5+4)/2;
		fct_spruce=-5;
		fcper_spruce=(fcr_spruce+fct_spruce)/2;
		
		
		fcl_yellow=-144;
		fcper_yellow=-6.7;
		fcr_yellow=fcper_yellow/fcper_spruce*fcr_spruce;
		fct_yellow=fcper_yellow/fcper_spruce*fct_spruce;
		
		fcr=fcl/fcl_yellow*fcr_yellow;
		fct=fcl/fcl_yellow*fct_yellow;
		
		fvrt=fcl/fcl_spruce*fvrt_spruce;
		fvrl=fcl/fcl_spruce*fvrl_spruce;
		fvtl=fcl/fcl_spruce*fvtl_spruce;
		
		ftper_yellow=6.3;
		ftr_yellow=ftr_spruce/ftper_spruce*ftper_yellow;
		ftt_yellow=ftt_spruce/ftper_spruce*ftper_yellow;
		
		ftr=ftr_yellow/fcl_yellow*fcl;
		ftt=ftt_yellow/fcl_yellow*fcl;
		ftt=ftt*1.5;
	elseif CasetoRun==48
		ftr=3.75;
		ftt=2.79*1.6;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		%fcr=-3;
		%fct=-6;
		fcr=-(1.5+4)/2;
		fct=-5;
	elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		%fcr=-3;
		%fct=-6;
		fcr=-(1.5+4)/2;
		fct=-5;
	else
		ftr=3.75;
		ftt=2.79;
		fvrt=1.83/1; %replacereplacereplace
		fvrl=6.34/1; %replacereplacereplace
		fvtl=5.34/1; %replacereplacereplace
		%fcr=-3;
		%fct=-6;
		fcr=-(1.5+4)/2;
		fct=-5;
	end
	
	if CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		El=14804;
		Et=0.050*El;
		Er=0.078*El;
		Grt=0.074*El;
		Gtl=0.068*El;
		Grl=0.017*El;
	else
		Er=820/1; %replacereplacereplace
		Et=430/1; %replacereplacereplace
		El=13200/1; %replacereplacereplace
		Grt=40/1; %replacereplacereplace
		Gtl=730/1; %replacereplacereplace
		Grl=660/1; %replacereplacereplace
	end
	if CasetoRun==19 || CasetoRun==21
		ReductionFactor=1;
		Er=820/ReductionFactor; %replacereplacereplace
		Et=430/ReductionFactor; %replacereplacereplace
		El=13200/ReductionFactor; %replacereplacereplace
		Grt=40/ReductionFactor; %replacereplacereplace
		Gtl=730/ReductionFactor; %replacereplacereplace
		Grl=660/ReductionFactor; %replacereplacereplace
	end

	if CasetoRun==31 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
		nurt=0.24;
		nutl=0.47;
		nurl=0.42;
	elseif CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		nurt=0.426;
		nutl=0.451;
		nurl=0.426;
	else
		nurt=0.24;
		nutl=0.45;
		nurl=0.45;
	end

	%Er=El;
	%Et=El;
	%Grt=Grl;
	%Gtl=Grl;
	%nurt=nurl;
	%nutl=nurl;

	kappa1=0.00001;
	kappa2=1.2;
	kappa3=0.00001;
	kappa4=1.2;
	kappa5=0.00001;
	kappa6=0.7;
	kappa7=1.2;
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		kappa7=1.0;
	elseif CasetoRun==39 || CasetoRun==50
		kappa7=0.2;
	elseif CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227
		kappa1=0.01;
		kappa3=0.01;
		kappa5=0.01;
		kappa7=1.2;
	end
	woodelasticonly=0;
	if woodelasticonly==1
		ftr=9999999;
		ftt=9999999;
		fvrt=9999999;
		fvrl=9999999;
		fvtl=9999999;
		fcr=9999999;
		fct=9999999;
	end

	Gftl=1650/1000;
	Gfcl=50000/1000;
	Gftr=300/1000;
	Gftt=Gftr;
	Gfcr=Gftr/Gftl*Gfcl;
	Gfct=Gfcr;
	GII=300/1000;

	Hld=15;
	Hrd=2;
	Htd=Hrd;

	lccrit=El*Gftl/abs(ftl);
	lccrit1=lccrit;
	lccrit2=Et*Gftt/abs(ftt);
	lccrit3=Er*Gftr/abs(ftr);
	%lc=lccrit/100;
	%lc=10;
	
	
	
	if CasetoRun==22 || CasetoRun==23
		alpha2dnounit=0.1;
		alpha2maxnounit=0.2;
		alpha4dnounit=0.1;
		alpha4maxnounit=0.2;
		alpha6dnounit=0.1;
		alpha6maxnounit=0.2;
	elseif CasetoRun==24
		alpha2dnounit=0.5;
		alpha2maxnounit=0.75;
		alpha4dnounit=0.5;
		alpha4maxnounit=0.75;
		alpha6dnounit=0.5;
		alpha6maxnounit=0.75;
	else
		alpha2dnounit=0.1;
		alpha2maxnounit=0.75;
		alpha4dnounit=0.1;
		alpha4maxnounit=0.75;
		alpha6dnounit=0.5;
		alpha6maxnounit=0.75;
	end
	if CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==8 || CasetoRun==9 || CasetoRun==10 || CasetoRun==11 || CasetoRun==17 || CasetoRun==45 || CasetoRun==46
		%the default value
		alpha7dnounit=0.1;
		alpha7maxnounit=0.75;
	elseif CasetoRun==4
		alpha7dnounit=0.05;
		alpha7maxnounit=0.1;
	elseif CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==49 || CasetoRun==47 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		alpha7dnounit=1.0;
		alpha7maxnounit=1.5;
	elseif CasetoRun==39 || CasetoRun==50
		alpha7dnounit=inf;
		alpha7maxnounit=inf;
	elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		alpha7dnounit=0.1;
		alpha7maxnounit=0.75;
	else
		alpha7dnounit=0.1;
		alpha7maxnounit=0.75;
	end
	

	
	%Intended specimen: L = 10 cm, t = 2 cm, delta_u = 1 cm
	NN=zeros(1,2);
	NN_base=zeros(1,2);
	le=zeros(1,2);
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
		%% Structured Grid input
		if CasetoRun==26
		elseif CasetoRun==33 || CasetoRun==34 || CasetoRun==39
			refinementfactor      = 1;
		else
			refinementfactor      = 2;
		end
		NN(1)                 = (11-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (17-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 10;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==4
		%% Structured Grid input
		NN(1)                 = 15;%33;                               % number of nodes in X direction
		NN(2)                 = 22;%13;                               % number of nodes in Y direction
		le(1)                 = 10;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
		le_base=10;
	elseif CasetoRun==5 || CasetoRun==6
		 NN(1)                = 24;
		 NN(2)                = 14;
		 le_base              = 6.25;
		 le(1)                = le_base;
		 le(2)                = le(1);
		 lc=le(1);
	elseif CasetoRun==7
		%% Structured Grid input
		NN(1)                 = 11;%33;                               % number of nodes in X direction
		NN(2)                 = 17;%13;                               % number of nodes in Y direction
		le_base               = 12;
		le(1)                 = le_base;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==8 || CasetoRun==9
		le_x=[];
		le_y=[];
		le_base              = 6.25;
		notchwidth=le_base/5;
		for i=1:11
			le_x=VectorInsertion(le_x,i,le_base);
			le_x=VectorInsertion(le_x,i+14,le_base);
		end
		le_x=VectorInsertion(le_x,12,(le_base-notchwidth)/2);
		le_x=VectorInsertion(le_x,13,notchwidth);
		le_x=VectorInsertion(le_x,14,le_x(12));
		for i=1:6
			le_y=VectorInsertion(le_y,i,le_base)
		end
		le_y=VectorInsertion(le_y,7,notchwidth);
		le_y=VectorInsertion(le_y,8,le_base-notchwidth);
		for j=9:14
			le_y=VectorInsertion(le_y,j,le_base);
		end
		NN(1)                = length(le_x)+1;
		NN(2)                = length(le_y)+1;
		le(1)                = le_base;
		le(2)                = le(1);
		lc=le(1);
	elseif CasetoRun==10
		%% Structured Grid input
		NN(1)                 = 11;%33;                               % number of nodes in X direction
		NN(2)                 = 19;%13;                               % number of nodes in Y direction
		le_base               = 12;
		le(1)                 = le_base;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==11
		%% Structured Grid input
		refinementfactor=1;
		NN(1)                 = (10-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (23-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 25;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		%% Structured Grid input
		refinementfactor=2;
		NN(1)                 = (11-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (23-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 15;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		%% Structured Grid input
		refinementfactor=3;
		NN(1)                 = (10-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (23-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 25;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==64 || CasetoRun==65 || CasetoRun==70
		%% Structured Grid input
		refinementfactor=1;
		NN(1)                 = (11-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (12-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 10;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==66 || CasetoRun==69
		%% Structured Grid input
		refinementfactor=1;
		NN(1)                 = (16-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (12-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 10;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==67
		%% Structured Grid input
		refinementfactor=1;
		NN(1)                 = (25-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (9-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 5;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==68 || CasetoRun==71 || CasetoRun==74 || CasetoRun==78 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==110 || CasetoRun==96
		%% Structured Grid input
		if CasetoRun==105 || CasetoRun==110
			refinementfactor=2;
		else
			refinementfactor=1;
		end
		NN(1)                 = (25-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (13-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 5;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==111 || CasetoRun==113
		%% Structured Grid input
		refinementfactor=1;
		NN(1)                 = (20-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (21-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 3;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==115
		%% Structured Grid input
		%refinementfactor=1;
		NN(1)                 = (8-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (8-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 3;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==117
		%% Structured Grid input
		%refinementfactor=1;
		NN(1)                 = (7-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (7-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 5;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==138
		%% Structured Grid input
		%refinementfactor=1;
		NN(1)                 = (7-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (7-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 4.5;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==192
		NN(1)                 = (7-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (7-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 1000;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==118 || CasetoRun==173
		NN(1)                 = (7-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (7-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 1;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==205 || CasetoRun==210 || CasetoRun==207
		NN(1)                 = (15-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (15-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 100/15;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=lccrit/2;	
		%lc=le(1);
	elseif CasetoRun==223 || CasetoRun==226
		NN(1)                 = (10-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (7-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 10;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
		%lc=min([lccrit1 lccrit2 lccrit3])/2;
	elseif CasetoRun==224
		NN(1)                 = (15-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (6-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 10;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
		%lc=min([lccrit1 lccrit2 lccrit3])/2;
	elseif CasetoRun==204 || CasetoRun==208 || CasetoRun==219 || CasetoRun==206 || CasetoRun==209 || CasetoRun==227
		NN(1)                 = (15-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (7-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 10;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
		%lc=min([lccrit1 lccrit2 lccrit3])/2;
	elseif CasetoRun==202
		NN(1)                 = (9-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (7-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 10;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==201
		NN(1)                 = (8-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (8-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 200;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==177 || CasetoRun==178
		NN(1)                 = (8-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (8-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 1;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==225
		NN(1)                 = (6-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (6-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 100;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=min([lccrit1 lccrit2 lccrit3])/2;
		lc=lc/refinementfactor;
		fprintf('%s',['lccrit1=' float2scitxt(5,lccrit1) char(10)]);
		fprintf('%s',['lccrit2=' float2scitxt(5,lccrit2) char(10)]);
		fprintf('%s',['lccrit3=' float2scitxt(5,lccrit3) char(10)]);
		fprintf('%s',['lc=' float2scitxt(5,lc) char(10)]);
	elseif CasetoRun==221 || CasetoRun==222
		NN(1)                 = (8-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (8-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 100;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=lccrit/100;
	elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==169 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==214 || CasetoRun==220
		NN(1)                 = (8-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (8-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 100;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
		lc=min([lccrit1 lccrit2 lccrit3])/2;
	elseif CasetoRun==229
		NN(1)                 = (5-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (10-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 3;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
		lc=min([lccrit1 lccrit2 lccrit3])/2;
	elseif CasetoRun==230
		%Edit point start: define number of nodes in x and y directions
		NN_base_1=6;
		NN_base_2=5;
		
		fprintf('%s',['before NN_base_1 loadvariable' char(10)]);
		NN_base_1_loaded=loadvariable('NN_base_1');
		%fprintf('%s',['after NN_base_1 loadvariable' char(10)]);
		fprintf('%s',['NN_base_1_loaded.found=' int2txt(NN_base_1_loaded.found) char(10)]);
		fprintf('%s',['NN_base_1_loaded.valuetext=' NN_base_1_loaded.valuetext char(10)]);
		if NN_base_1_loaded.found
			NN_base_1=str2long(NN_base_1_loaded.valuetext);
		end
		fprintf('%s',['NN_base_1=' float2scitxt(5,NN_base_1) char(10)]);
		
		fprintf('%s',['before NN_base_2 loadvariable' char(10)]);
		NN_base_2_loaded=loadvariable('NN_base_2');
		%fprintf('%s',['after NN_base_2 loadvariable' char(10)]);
		fprintf('%s',['NN_base_2_loaded.found=' int2txt(NN_base_2_loaded.found) char(10)]);
		fprintf('%s',['NN_base_2_loaded.valuetext=' NN_base_2_loaded.valuetext char(10)]);
		if NN_base_2_loaded.found
			NN_base_2=str2long(NN_base_2_loaded.valuetext);
		end
		fprintf('%s',['NN_base_2=' float2scitxt(5,NN_base_2) char(10)]);
		
		NN_base=zeros(1,2); %this is redundant safeguard for coder
		
		NN_base(1)            = NN_base_1; %in x direction
		NN_base(2)            = NN_base_2; %in y direction
		le_base               = 100;
		
		le_base_loaded=loadvariable('le_base');
		if le_base_loaded.found
			if CompareTexts(le_base_loaded.type,'long')
				le_base=str2long(le_base_loaded.valuetext);
			else
				le_base=str2float(le_base_loaded.valuetext);
			end
		end
		
		%Edit point end
		NN(1)                 = (NN_base(1)-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (NN_base(2)-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
		lc=min([lccrit1 lccrit2 lccrit3])/2;
	elseif CasetoRun==228
		%% Structured Grid input
		NN(1)                 = (10-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (23-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 25;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
		lc=min([lccrit1/2 lccrit2/2 lccrit3/2 le(1)]);
	elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
		NN(1)                 = (9-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (7-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 1;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==130
		NN(1)                 = (9-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (8-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 1;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
		NN(1)                 = (13-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (8-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 1;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
		NN(1)                 = (16-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (8-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 1;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==194
		NN(1)                 = (15-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (15-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 100;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);	
	elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153
		NN(1)                 = (15-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (15-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 1;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);	
	elseif CasetoRun==154 || CasetoRun==161
		NN(1)                 = (33-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (33-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 0.25;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);	
	elseif CasetoRun==134 || CasetoRun==136
		NN(1)                 = (11-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (8-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 1;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==124
		NN(1)                 = (11-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (10-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 1.3;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==112
		%% Structured Grid input
		refinementfactor=1;
		NN(1)                 = (17-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (18-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 5;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==84
		%% Structured Grid input
		refinementfactor=1;
		NN(1)                 = (26-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (14-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 5;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==90 || CasetoRun==89
		%% Structured Grid input
		refinementfactor=1;
		NN(1)                 = (12-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (11-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 10;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==93
		%% Structured Grid input
		refinementfactor=1;
		NN(1)                 = (12-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (11-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 10;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==85
		%% Structured Grid input
		refinementfactor=1;
		NN(1)                 = (5-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (5-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 10;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==81
		%% Structured Grid input
		refinementfactor=2;
		NN(1)                 = (25-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (13-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 5;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	elseif CasetoRun==72 || CasetoRun==73
		%% Structured Grid input
		refinementfactor=1;
		NN(1)                 = (26-1)*refinementfactor+1;%33;                               % number of nodes in X direction
		NN(2)                 = (13-1)*refinementfactor+1;%13;                               % number of nodes in Y direction
		le_base               = 5;
		le(1)                 = le_base/refinementfactor;%0.5;                              % size of element in X direction
		le(2)                 = le(1);                          % size of element in Y direction
		lc=le(1);
	end
	
	niCount=NN(1)*NN(2);
	fbcx=zeros(1,niCount);
	coder.varsize('fbcx');
	fbcy=zeros(1,niCount);
	coder.varsize('fbcy');
	%% Grid generation
	le_c=[];
	LOCX=[];
	LOCY=[];
	
	
	%[] early definitions
	%start of predvel vectorized definitions
	PredVelVect.XNodes=zeros(1,niCount);
	PredVelVect.YNodes=zeros(1,niCount);
	PredVelVect.XDisp=zeros(1,niCount);
	PredVelVect.YDisp=zeros(1,niCount);
	PredVelVect.XVel=zeros(1,niCount);
	PredVelVect.YVel=zeros(1,niCount);
	PredVelVect.XAcc=zeros(1,niCount);
	PredVelVect.YAcc=zeros(1,niCount);
	PredVelVect.XPhase=zeros(1,niCount);
	PredVelVect.YPhase=zeros(1,niCount);
	PredVelVect.nX=zeros(1,1);
	PredVelVect.nY=zeros(1,1);
	
	PredXVelVect=[];
	PredYVelVect=[];
	PredXAccVect=[];
	PredYAccVect=[];
	NodeswithPredXVelVect=[];
	NodeswithPredYVelVect=[];
	PredXVelPhase=[];
	PredYVelPhase=[];
	%end of predvel vectorized definitions
	
	N0.CONNECTpn.values=zeros(niCount,100);
	N0.CONNECTpn.nrparticles=zeros(1,niCount);
	N0.Npn.values=zeros(niCount,100);
	N0.Npn.nrparticles=zeros(1,niCount);
	

	
	
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		[LOC,LOCC,cellCount,nodeCount] = Grid_Generation(NN,le);
	elseif CasetoRun==8 || CasetoRun==9
		[LOC,LOCC,cellCount,nodeCount,LOCX,LOCY,le_c] = Grid_Generation_var(NN,le_x,le_y);
		%x_p=le_base*11;
		%y_p=le_base*6;
		%[thecell, thenodes]= ...
		%    identifycellsandnodes([x_p y_p],LOCX,LOCY,[],[],[1 1 0 0]);
	elseif CasetoRun==10
		[LOC,LOCC,cellCount,nodeCount] = Grid_Generation(NN,le);
	else
		[LOC,LOCC,cellCount,nodeCount] = Grid_Generation(NN,le); %Case 64 goes here so far 190128
	end


	% nodeCount: total number of nodes
	% cellCount: total number of elements
	% LOC(n,1:2): localtion coordinate of node "n" in x(1) and y(2) direction
	% LOCC(e,1:2): localtion coordinate of element centroid "e" in x(1) and y(2) direction

	%% Nodes with predefined velocities (conveyer)
	NumberofNodeswithPredXVel=0;
	NodeswithPredXVel=[];

	NumberofNodeswithPredXVel2=0;
	NodeswithPredXVel2=[];

	NumberofNodeswithPredYVel=0;
	NodeswithPredYVel=[];

	NumberofNodeswithPredYVel2=0;
	NodeswithPredYVel2=[];


	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
		for i=1:size(LOC,1)
			if LOC(i,2)>le_base*10-1e-3 & LOC(i,2)<le_base*10+1e-3
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
			%if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
			%    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
			%    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
			%end
		end
	elseif CasetoRun==21
		for i=1:size(LOC,1)
			if LOC(i,2)>le_base*10+2*le(2)-1e-3 & LOC(i,2)<le_base*10+2*le(2)+1e-3
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
			%if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
			%    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
			%    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
			%end
		end    
	elseif CasetoRun==4
		for i=1:size(LOC,1)
			%if (LOC(i,1)-90)^2<1e-6 | (LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-110)^2<1e-6 | (LOC(i,1)-120)^2<1e-6 | (LOC(i,1)-130)^2<1e-6 | (LOC(i,1)-140)^2<1e-6
			%    NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
			%    NodeswithPredXVel(NumberofNodeswithPredXVel)=i;
			%end
			if (LOC(i,2)-170)^2<1e-6
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
		end
	elseif CasetoRun==5 || CasetoRun==6
		for i=1:size(LOC,1)
			if LOC(i,2)>le_base*10-1e-3 & LOC(i,2)<le_base*10+1e-3
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
			%if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
			%    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
			%    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
			%end
		end
	elseif CasetoRun==7
		for i=1:size(LOC,1)
			if LOC(i,2)>le_base*10-1e-3 & LOC(i,2)<le_base*10+1e-3
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
			%if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
			%    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
			%    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
			%end
		end
	elseif CasetoRun==8 || CasetoRun==9
		for i=1:size(LOC,1)
			if LOC(i,2)>le_base*10-1e-3 & LOC(i,2)<le_base*10+1e-3
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
			%if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
			%    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
			%    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
			%end
		end
	elseif CasetoRun==10
		for i=1:size(LOC,1)
			if LOC(i,2)>le_base*11-1e-3 & LOC(i,2)<le_base*11+1e-3
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
			%if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
			%    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
			%    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
			%end
		end
	elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		for i=1:size(LOC,1)
			if CasetoRun==15
				if LOC(i,2)>le_base*16-1e-3 & LOC(i,2)<le_base*16+1e-3
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				end            
			else
				if LOC(i,2)>le_base*19-1e-3 & LOC(i,2)<le_base*19+1e-3
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				end
				%if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
				%    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				%    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
				%end
			end
		end
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		for i=1:size(LOC,1)
			if LOC(i,2)>le_base*18-1e-3 & LOC(i,2)<le_base*18+1e-3
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
			%if ((LOC(i,1)-100)^2<1e-6 | (LOC(i,1)-40)^2<1e-6) & (LOC(i,2)-50)^2<1e-6
			%    NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
			%    NodeswithPredYVel(NumberofNodeswithPredYVel)=i;
			%end
		end
	elseif CasetoRun==64 || CasetoRun==66
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,2),9*le_base,1e-3,1) || CloseEnough(LOC(i,2),10*le_base,1e-3,1)
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			elseif CloseEnough(LOC(i,2),2*le_base,1e-3,1) || CloseEnough(LOC(i,2),1*le_base,1e-3,1)
				NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
				NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
			end
		end
	elseif CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77 || CasetoRun==69 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==154 || CasetoRun==161
	elseif CasetoRun==111 || CasetoRun==113 
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,2),13*le_base,1e-3,1) && CloseEnough(LOC(i,1),6*le_base,1e-3,1)
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			elseif CloseEnough(LOC(i,2),7*le_base,1e-3,1) && CloseEnough(LOC(i,1),6*le_base,1e-3,1)
				NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
				NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
			end
		end
	elseif CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==117 || CasetoRun==138
	elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==192
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),2*le_base,1e-3,1)
				NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
				NodeswithPredXVel(NumberofNodeswithPredXVel)=i;
			elseif CloseEnough(LOC(i,1),4*le_base,1e-3,1)
				NumberofNodeswithPredXVel2=NumberofNodeswithPredXVel2+1;
				NodeswithPredXVel2=VectorInsertion(NodeswithPredXVel2,NumberofNodeswithPredXVel2,i);
			end
			if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			elseif CloseEnough(LOC(i,2),4*le_base,1e-3,1)
				NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
				NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredYVel+NumberofNodeswithPredYVel2;
		PredVelVect.nY=nro;
		PredVelVect.YPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredYVel
				PredVelVect.YNodes(iro)=NodeswithPredYVel(iro);
			else
				PredVelVect.YNodes(iro)=NodeswithPredYVel2(iro-NumberofNodeswithPredYVel);
			end
		end
		
		nro=NumberofNodeswithPredXVel+NumberofNodeswithPredXVel2;
		PredVelVect.nX=nro;
		PredVelVect.XPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredXVel
				PredVelVect.XNodes(iro)=NodeswithPredXVel(iro);
			else
				PredVelVect.XNodes(iro)=NodeswithPredXVel2(iro-NumberofNodeswithPredXVel);
			end
		end
		
	elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if LOC(i,1)>=5.5*le_base
				if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),4*le_base,1e-3,1)
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				end
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
	elseif CasetoRun==178
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			%if LOC(i,1)>=5.5*le_base
				if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
					NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
					NodeswithPredXVel=VectorInsertion(NodeswithPredXVel,NumberofNodeswithPredXVel,i);
					
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),5*le_base,1e-3,1)
					NumberofNodeswithPredXVel2=NumberofNodeswithPredXVel2+1;
					NodeswithPredXVel2=VectorInsertion(NodeswithPredXVel2,NumberofNodeswithPredXVel2,i);
					
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				end
			%end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredXVel+NumberofNodeswithPredXVel2;
		PredVelVect.nX=nro;
		PredVelVect.XPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredXVel
				PredVelVect.XNodes(iro)=NodeswithPredXVel(iro);
			else
				PredVelVect.XNodes(iro)=NodeswithPredXVel2(iro-NumberofNodeswithPredXVel);
			end
		end
		
		nro=NumberofNodeswithPredYVel+NumberofNodeswithPredYVel2;
		PredVelVect.nY=nro;
		PredVelVect.YPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredYVel
				PredVelVect.YNodes(iro)=NodeswithPredYVel(iro);
			else
				PredVelVect.YNodes(iro)=NodeswithPredYVel2(iro-NumberofNodeswithPredYVel);
			end
		end
	elseif CasetoRun==195
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			%if LOC(i,1)>=5.5*le_base
				if CloseEnough(LOC(i,2),5*le_base,1e-3,1)
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				end
			%end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredYVel+NumberofNodeswithPredYVel2;
		PredVelVect.nY=nro;
		PredVelVect.YPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredYVel
				PredVelVect.YNodes(iro)=NodeswithPredYVel(iro);
			else
				PredVelVect.YNodes(iro)=NodeswithPredYVel2(iro-NumberofNodeswithPredYVel);
			end
		end
	elseif CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==207
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			%if LOC(i,1)>=5.5*le_base
			%{
				if CloseEnough(LOC(i,1),2*le_base,1e-3,1)
					NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
					NodeswithPredXVel=VectorInsertion(NodeswithPredXVel,NumberofNodeswithPredXVel,i);
				elseif CloseEnough(LOC(i,1),6*le_base,1e-3,1)
					NumberofNodeswithPredXVel2=NumberofNodeswithPredXVel2+1;
					NodeswithPredXVel2=VectorInsertion(NodeswithPredXVel2,NumberofNodeswithPredXVel2,i);
				end
			%}
			%end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredXVel+NumberofNodeswithPredXVel2;
		PredVelVect.nY=nro;
		PredVelVect.YPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredXVel
				PredVelVect.YNodes(iro)=NodeswithPredXVel(iro);
			else
				PredVelVect.YNodes(iro)=NodeswithPredXVel2(iro-NumberofNodeswithPredXVel);
			end
		end
	elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==201 || CasetoRun==169 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222
		%TDL definition of moving BC nodes
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			%if LOC(i,1)>=5.5*le_base
				if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),5*le_base,1e-3,1)
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				end
			%end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredYVel+NumberofNodeswithPredYVel2;
		PredVelVect.nY=nro;
		PredVelVect.YPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredYVel
				PredVelVect.YNodes(iro)=NodeswithPredYVel(iro);
			else
				PredVelVect.YNodes(iro)=NodeswithPredYVel2(iro-NumberofNodeswithPredYVel);
			end
		end
	elseif CasetoRun==229
		%nothing, theres no displacement controlled boundary (except for the fellow fixed dirichlet defined somewhere else)
	elseif CasetoRun==230
		%Edit point start: define nodes with predetermined velocity
		NodeyPosition_PredYvel=-3*le_base; 
		NodexPosition_PredXvel=-3*le_base; %to deactivate, put it out of bound
		
		fprintf('%s',['before NodeyPosition_PredYvel loadvariable' char(10)]);
		NodeyPosition_PredYvel_loaded=loadvariable('NodeyPosition_PredYvel');
		%fprintf('%s',['after NodeyPosition_PredYvel loadvariable' char(10)]);
		fprintf('%s',['NodeyPosition_PredYvel_loaded.found=' int2txt(NodeyPosition_PredYvel_loaded.found) char(10)]);
		fprintf('%s',['NodeyPosition_PredYvel_loaded.valuetext=' NodeyPosition_PredYvel_loaded.valuetext char(10)]);
		if NodeyPosition_PredYvel_loaded.found
			NodeyPosition_PredYvel=str2float(NodeyPosition_PredYvel_loaded.valuetext);
		end
		fprintf('%s',['NodeyPosition_PredYvel=' float2scitxt(5,NodeyPosition_PredYvel) char(10)]);
		
		fprintf('%s',['before NodexPosition_PredXvel loadvariable' char(10)]);
		NodexPosition_PredXvel_loaded=loadvariable('NodexPosition_PredXvel');
		%fprintf('%s',['after NodexPosition_PredXvel loadvariable' char(10)]);
		fprintf('%s',['NodexPosition_PredXvel_loaded.found=' int2txt(NodexPosition_PredXvel_loaded.found) char(10)]);
		fprintf('%s',['NodexPosition_PredXvel_loaded.valuetext=' NodexPosition_PredXvel_loaded.valuetext char(10)]);
		if NodexPosition_PredXvel_loaded.found
			NodexPosition_PredXvel=str2float(NodexPosition_PredXvel_loaded.valuetext);
		end
		fprintf('%s',['NodexPosition_PredXvel=' float2scitxt(5,NodexPosition_PredXvel) char(10)]);
		
		fprintf('%s',['before NodeyPosition_PredYvel_rel loadvariable' char(10)]);
		NodeyPosition_PredYvel_rel_loaded=loadvariable('NodeyPosition_PredYvel_rel');
		%fprintf('%s',['after NodeyPosition_PredYvel_rel loadvariable' char(10)]);
		fprintf('%s',['NodeyPosition_PredYvel_rel_loaded.found=' int2txt(NodeyPosition_PredYvel_rel_loaded.found) char(10)]);
		fprintf('%s',['NodeyPosition_PredYvel_rel_loaded.valuetext=' NodeyPosition_PredYvel_rel_loaded.valuetext char(10)]);
		NodeyPosition_PredYvel_rel=zeros(1,1);
		if NodeyPosition_PredYvel_rel_loaded.found
			NodeyPosition_PredYvel_rel=str2float(NodeyPosition_PredYvel_rel_loaded.valuetext);
			NodeyPosition_PredYvel=NodeyPosition_PredYvel_rel*le_base; 
		end
		fprintf('%s',['NodeyPosition_PredYvel_rel=' float2scitxt(5,NodeyPosition_PredYvel_rel) char(10)]);
		
		fprintf('%s',['before NodexPosition_PredXvel_rel loadvariable' char(10)]);
		NodexPosition_PredXvel_rel_loaded=loadvariable('NodexPosition_PredXvel_rel');
		%fprintf('%s',['after NodexPosition_PredXvel_rel loadvariable' char(10)]);
		fprintf('%s',['NodexPosition_PredXvel_rel_loaded.found=' int2txt(NodexPosition_PredXvel_rel_loaded.found) char(10)]);
		fprintf('%s',['NodexPosition_PredXvel_rel_loaded.valuetext=' NodexPosition_PredXvel_rel_loaded.valuetext char(10)]);
		NodexPosition_PredXvel_rel=zeros(1,1);
		if NodexPosition_PredXvel_rel_loaded.found
			NodexPosition_PredXvel_rel=str2float(NodexPosition_PredXvel_rel_loaded.valuetext);
			NodexPosition_PredXvel=NodexPosition_PredXvel_rel*le_base;
		end
		fprintf('%s',['NodexPosition_PredXvel_rel=' float2scitxt(5,NodexPosition_PredXvel_rel) char(10)]);
		%Edit point end	
		
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,2),NodeyPosition_PredYvel,1e-3,1)
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
			if CloseEnough(LOC(i,1),NodexPosition_PredXvel,1e-3,1)
				NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
				NodeswithPredXVel=VectorInsertion(NodeswithPredXVel,NumberofNodeswithPredXVel,i);
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredXVel+NumberofNodeswithPredXVel2;
		PredVelVect.nX=nro;
		PredVelVect.XPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredXVel
				PredVelVect.XNodes(iro)=NodeswithPredXVel(iro);
			else
				PredVelVect.XNodes(iro)=NodeswithPredXVel2(iro-NumberofNodeswithPredXVel);
			end
		end
		1;
	elseif CasetoRun==228
		%TDL definition of moving BC nodes
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			%if LOC(i,1)>=5.5*le_base
				if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),19*le_base,1e-3,1)
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				end
			%end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredYVel+NumberofNodeswithPredYVel2;
		PredVelVect.nY=nro;
		PredVelVect.YPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredYVel
				PredVelVect.YNodes(iro)=NodeswithPredYVel(iro);
			else
				PredVelVect.YNodes(iro)=NodeswithPredYVel2(iro-NumberofNodeswithPredYVel);
			end
		end
	elseif CasetoRun==225
		%TDL definition of moving BC nodes
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			%if LOC(i,1)>=5.5*le_base
				if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),3*le_base,1e-3,1)
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				end
			%end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredYVel+NumberofNodeswithPredYVel2;
		PredVelVect.nY=nro;
		PredVelVect.YPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredYVel
				PredVelVect.YNodes(iro)=NodeswithPredYVel(iro);
			else
				PredVelVect.YNodes(iro)=NodeswithPredYVel2(iro-NumberofNodeswithPredYVel);
			end
		end
	elseif CasetoRun==220
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			%if LOC(i,1)>=5.5*le_base
				if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
					NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
					NodeswithPredXVel=VectorInsertion(NodeswithPredXVel,NumberofNodeswithPredXVel,i);
					
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),5*le_base,1e-3,1)
					NumberofNodeswithPredXVel2=NumberofNodeswithPredXVel2+1;
					NodeswithPredXVel2=VectorInsertion(NodeswithPredXVel2,NumberofNodeswithPredXVel2,i);
					
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				end
			%end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredXVel+NumberofNodeswithPredXVel2;
		PredVelVect.nX=nro;
		PredVelVect.XPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredXVel
				PredVelVect.XNodes(iro)=NodeswithPredXVel(iro);
			else
				PredVelVect.XNodes(iro)=NodeswithPredXVel2(iro-NumberofNodeswithPredXVel);
			end
		end
		
		nro=NumberofNodeswithPredYVel+NumberofNodeswithPredYVel2;
		PredVelVect.nY=nro;
		PredVelVect.YPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredYVel
				PredVelVect.YNodes(iro)=NodeswithPredYVel(iro);
			else
				PredVelVect.YNodes(iro)=NodeswithPredYVel2(iro-NumberofNodeswithPredYVel);
			end
		end
	elseif CasetoRun==171
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),6*le_base,1e-3,1) %pulls up
				if LOC(i,2)>3*le_base+0.5*le(2)
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				elseif LOC(i,2)<3*le_base-0.5*le(2) %pulls down
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				end
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredYVel+NumberofNodeswithPredYVel2;
		PredVelVect.nY=nro;
		PredVelVect.YPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredYVel
				PredVelVect.YNodes(iro)=NodeswithPredYVel(iro);
			else
				PredVelVect.YNodes(iro)=NodeswithPredYVel2(iro-NumberofNodeswithPredYVel);
			end
		end
	elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==165
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			%if LOC(i,1)>=5.5*le_base
				if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),4*le_base,1e-3,1)
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				end
			%end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredYVel+NumberofNodeswithPredYVel2;
		PredVelVect.nY=nro;
		PredVelVect.YPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredYVel
				PredVelVect.YNodes(iro)=NodeswithPredYVel(iro);
			else
				PredVelVect.YNodes(iro)=NodeswithPredYVel2(iro-NumberofNodeswithPredYVel);
			end
		end
	elseif CasetoRun==166
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			%if LOC(i,1)>=5.5*le_base
				if CloseEnough(LOC(i,2),2.5*le_base,1e-3,1) && CloseEnough(LOC(i,1),5.8*le_base,1e-3,1)
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),3.5*le_base,1e-3,1) && CloseEnough(LOC(i,1),5.8*le_base,1e-3,1)
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				end
			%end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredYVel+NumberofNodeswithPredYVel2;
		PredVelVect.nY=nro;
		PredVelVect.YPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredYVel
				PredVelVect.YNodes(iro)=NodeswithPredYVel(iro);
			else
				PredVelVect.YNodes(iro)=NodeswithPredYVel2(iro-NumberofNodeswithPredYVel);
			end
		end
	elseif CasetoRun==129 || CasetoRun==130
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if LOC(i,1)>=5.5*le_base
				if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),4.25*le_base,1e-3,1)
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				end
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
        1;
	elseif CasetoRun==132
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			elseif CloseEnough(LOC(i,2),4.25*le_base,1e-3,1)
				NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
				NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
	elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),10*le_base,1e-3,1)
				if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),4.25*le_base,1e-3,1)
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				end
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
	elseif CasetoRun==134 || CasetoRun==136
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),7.5*le_base,1e-3,1)
				if LOC(i,2)>=3.5*le_base && LOC(i,2)<=4.25*le_base
					NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
					NodeswithPredXVel=VectorInsertion(NodeswithPredXVel,NumberofNodeswithPredXVel,i);
				elseif LOC(i,2)>=2.25*le_base && LOC(i,2)<=2.75*le_base
					NumberofNodeswithPredXVel2=NumberofNodeswithPredXVel2+1;
					NodeswithPredXVel2=VectorInsertion(NodeswithPredXVel2,NumberofNodeswithPredXVel2,i);
				end
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
	elseif CasetoRun==140 || CasetoRun==143
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),10*le_base,1e-3,1)
				if LOC(i,2)>=3.5*le_base && LOC(i,2)<=4.25*le_base
					NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
					NodeswithPredXVel=VectorInsertion(NodeswithPredXVel,NumberofNodeswithPredXVel,i);
				elseif LOC(i,2)>=2.25*le_base && LOC(i,2)<=2.75*le_base
					NumberofNodeswithPredXVel2=NumberofNodeswithPredXVel2+1;
					NodeswithPredXVel2=VectorInsertion(NodeswithPredXVel2,NumberofNodeswithPredXVel2,i);
				end
			end
		end
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),10*le_base,1e-3,1)
				if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),4.25*le_base,1e-3,1)
					%NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					%NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
					%only the bottom will be pulled down
				end
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
	elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),10*le_base,1e-3,1)
				NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
				NodeswithPredXVel=VectorInsertion(NodeswithPredXVel,NumberofNodeswithPredXVel,i);
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
	elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));

		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
	elseif CasetoRun==145
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),10*le_base,1e-3,1)
				NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
				NodeswithPredXVel=VectorInsertion(NodeswithPredXVel,NumberofNodeswithPredXVel,i);
			end
		end
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),5*le_base,1e-3,1)
				NumberofNodeswithPredXVel2=NumberofNodeswithPredXVel2+1;
				NodeswithPredXVel2=VectorInsertion(NodeswithPredXVel2,NumberofNodeswithPredXVel2,i);
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
	elseif CasetoRun==141
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),10*le_base,1e-3,1)
				if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),4.25*le_base,1e-3,1)
					%NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					%NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
					%only the bottom will be pulled down
				end
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
	elseif CasetoRun==142
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),10*le_base,1e-3,1)
				if LOC(i,2)>=3.5*le_base && LOC(i,2)<=4.25*le_base
					NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
					NodeswithPredXVel=VectorInsertion(NodeswithPredXVel,NumberofNodeswithPredXVel,i);
				elseif LOC(i,2)>=2.25*le_base && LOC(i,2)<=2.75*le_base
					NumberofNodeswithPredXVel2=NumberofNodeswithPredXVel2+1;
					NodeswithPredXVel2=VectorInsertion(NodeswithPredXVel2,NumberofNodeswithPredXVel2,i);
				end
			end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
	elseif CasetoRun==124
		%124 predvelnodal
		NodeswithPredXVel=zeros(1,size(LOC,1));
		NodeswithPredXVel2=zeros(1,size(LOC,1));
		NodeswithPredYVel=zeros(1,size(LOC,1));
		NodeswithPredYVel2=zeros(1,size(LOC,1));
		for i=1:size(LOC,1)
			%if CloseEnough(LOC(i,1),2*le_base,1e-3,1)
				if CloseEnough(LOC(i,2),2*le_base,1e-3,1)
					NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
					NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
				elseif CloseEnough(LOC(i,2),7*le_base,1e-3,1)
					NumberofNodeswithPredYVel2=NumberofNodeswithPredYVel2+1;
					NodeswithPredYVel2=VectorInsertion(NodeswithPredYVel2,NumberofNodeswithPredYVel2,i);
				end
			%end
		end
		NodeswithPredXVel=ResizeVector(NodeswithPredXVel,NumberofNodeswithPredXVel);
		NodeswithPredXVel2=ResizeVector(NodeswithPredXVel2,NumberofNodeswithPredXVel2);
		NodeswithPredYVel=ResizeVector(NodeswithPredYVel,NumberofNodeswithPredYVel);
		NodeswithPredYVel2=ResizeVector(NodeswithPredYVel2,NumberofNodeswithPredYVel2);
		
		nro=NumberofNodeswithPredYVel+NumberofNodeswithPredYVel2;
		PredVelVect.nY=nro;
		PredVelVect.YPhase(1:nro)=1;
		for iro=1:nro
			if iro<=NumberofNodeswithPredYVel
				PredVelVect.YNodes(iro)=NodeswithPredYVel(iro);
			else
				PredVelVect.YNodes(iro)=NodeswithPredYVel2(iro-NumberofNodeswithPredYVel);
			end
		end
		%NodeswithPredYVelVect=[NodeswithPredYVel NodeswithPredYVel2];
		
		%{
		for nio=1:NumberofNodeswithPredYVel
			NodeswithPredYVelVect=
		end
		for nio=NumberofNodesWithPredYVel+1:NumberofNodeswithPredYVel+NumberofNodeswithPredYVel2)
		end
		%}
	elseif CasetoRun==84
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),22*le_base,1e-5,2)
				NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
				NodeswithPredXVel=VectorInsertion(NodeswithPredXVel,NumberofNodeswithPredXVel,i);
			end
			if CloseEnough(LOC(i,2),10*le_base,1e-5,2)
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
		end
	elseif CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),7*le_base,1e-5,2)
				NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
				NodeswithPredXVel=VectorInsertion(NodeswithPredXVel,NumberofNodeswithPredXVel,i);
			end
			if CloseEnough(LOC(i,2),7*le_base,1e-5,2)
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
		end
	elseif CasetoRun==94
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),8*le_base,1e-5,2)
				NumberofNodeswithPredXVel=NumberofNodeswithPredXVel+1;
				NodeswithPredXVel=VectorInsertion(NodeswithPredXVel,NumberofNodeswithPredXVel,i);
			end
			if CloseEnough(LOC(i,2),7*le_base,1e-5,2)
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
		end
	elseif CasetoRun==85

	elseif CasetoRun==65 || CasetoRun==70
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,2),8*le_base,1e-3,1) || CloseEnough(LOC(i,2),9*le_base,1e-3,1) || CloseEnough(LOC(i,2),10*le_base,1e-3,1)
				NumberofNodeswithPredYVel=NumberofNodeswithPredYVel+1;
				NodeswithPredYVel=VectorInsertion(NodeswithPredYVel,NumberofNodeswithPredYVel,i);
			end
		end
	end

	%%Defining Location of Nodes with Forces from SigmaInf
	tractionedcorner_si=[];
	normalcorner_si=cell(1,1);
	normalcorner_si{1}=0;
	tractionededge_si=[];
	normaledge_si=[];
	ntforce_si=zeros(size(LOC,1),2);

	if CasetoRun==121
		for i=1:size(LOC,1)
			if CloseEnough(LOC(i,1),4*le_base,1e-5,2)
				if CloseEnough(LOC(i,2),4*le_base,1e-5,2)
					tractionedcorner_si=VectorInsertion(tractionedcorner_si,length(tractionedcorner_si)+1,i);
					%tractionedcorner_si=[tractionedcorner_si i];
					normalcorner_si=CellInsertion(normalcorner_si,length(tractionedcorner_si),[1 0;0 -1]);
					%normalcorner_si{length(tractionedcorner_si)}=[1 0;
					%										0 1];
				elseif CloseEnough(LOC(i,2),2*le_base,1e-5,2)
					tractionedcorner_si=VectorInsertion(tractionedcorner_si,length(tractionedcorner_si)+1,i);
					%tractionedcorner_si=[tractionedcorner_si i];
					normalcorner_si=CellInsertion(normalcorner_si,length(tractionedcorner_si),[1 0;0 -1]);
					%normalcorner_si{length(tractionedcorner_si)}=[1 0;
					%										0 -1];
				elseif LOC(i,2)<=4*le_base && LOC(i,2)>=2*le_base
					tractionededge_si=VectorInsertion(tractionededge_si,length(tractionededge_si)+1,i);
					%tractionededge_si=[tractionededge_si i];
					normaledge_si=MatrixInsertion(normaledge_si,length(tractionededge_si),1,1);
					normaledge_si=MatrixInsertion(normaledge_si,length(tractionededge_si),2,0);
					%normaledge_si(length(tractionededge_si),:)=[1 0];
				end
			elseif CloseEnough(LOC(i,1),2*le_base,1e-5,2)
				if CloseEnough(LOC(i,2),4*le_base,1e-5,2)
					tractionedcorner_si=VectorInsertion(tractionedcorner_si,length(tractionedcorner_si)+1,i);
					%tractionedcorner_si=[tractionedcorner_si i];
					normalcorner_si=CellInsertion(normalcorner_si,length(tractionedcorner_si),[-1 0;0 1]);
					%normalcorner_si{length(tractionedcorner_si)}=[-1 0;
					%										0 1];
				elseif CloseEnough(LOC(i,2),2*le_base,1e-5,2)
					tractionedcorner_si=VectorInsertion(tractionedcorner_si,length(tractionedcorner_si)+1,i);
					%tractionedcorner_si=[tractionedcorner_si i];
					normalcorner_si=CellInsertion(normalcorner_si,length(tractionedcorner_si),[-1 0;0 -1]);
					%normalcorner_si{length(tractionedcorner_si)}=[-1 0;
					%										0 -1];
				elseif LOC(i,2)<=4*le_base && LOC(i,2)>=2*le_base
					tractionededge_si=VectorInsertion(tractionededge_si,length(tractionededge_si)+1,i);
					%tractionededge_si=[tractionededge_si i];
					normaledge_si=MatrixInsertion(normaledge_si,length(tractionededge_si),1,-1);
					normaledge_si=MatrixInsertion(normaledge_si,length(tractionededge_si),2,0);
					%normaledge_si(length(tractionededge_si),:)=[-1 0];
				end			
			elseif CloseEnough(LOC(i,2),4*le_base,1e-5,2) && (LOC(i,1)<=4*le_base && LOC(i,1)>=2*le_base)
				tractionededge_si=VectorInsertion(tractionededge_si,length(tractionededge_si)+1,i);
				%tractionededge_si=[tractionededge_si i];
				normaledge_si=MatrixInsertion(normaledge_si,length(tractionededge_si),1,0);
				normaledge_si=MatrixInsertion(normaledge_si,length(tractionededge_si),2,1);			
				%normaledge_si(length(tractionededge_si),:)=[0 1];
			elseif CloseEnough(LOC(i,2),2*le_base,1e-5,2) && (LOC(i,1)<=4*le_base && LOC(i,1)>=2*le_base)
				tractionededge_si=VectorInsertion(tractionededge_si,length(tractionededge_si)+1,i);
				%tractionededge_si=[tractionededge_si i];
				normaledge_si=MatrixInsertion(normaledge_si,length(tractionededge_si),1,0);
				normaledge_si=MatrixInsertion(normaledge_si,length(tractionededge_si),2,-1);			
				%normaledge_si(length(tractionededge_si),:)=[0 -1];
			end
		end
	end

	%%Defining Double-Velocity Nodes
	%definingprocessgoeshere

	%% Time
	%c                       = sqrt(E/psp);
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
		%ftime                   = 20*2+25;
		loadtime                = 15;
		pausetime               = 2;
		repetition              = 1;
		dispload                = -1.25*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 
		%ftime                   = 20*2+25;
		loadtime                = 20;
		pausetime               = 2;
		repetition              = 1;
		dispload                = -20;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==21
		loadtime                = 15;
		pausetime               = 2;
		repetition              = 1;
		dispload                = -1*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==4
		ftime                   = 12;
	elseif CasetoRun==5 || CasetoRun==6
		loadtime                = 20;
		pausetime               = 1;
		repetition              = 2;
		dispload                = -1.25*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==7
		loadtime                = 1;
		pausetime               = 15;
		repetition              = 1;
		dispload                = -1*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==8 || CasetoRun==9
		loadtime                = 4;
		pausetime               = 1;
		repetition              = 10;
		dispload                = -0.25*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==10
		%ftime                   = 20*2+25;
		loadtime                = 10;
		pausetime               = 1;
		repetition              = 1;
		dispload                = 0.2*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==11
		%ftime                   = 20*2+25;
		loadtime                = 5;
		pausetime               = 2;
		repetition              = 1;
		dispload                = 1*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		%ftime                   = 20*2+25;
		loadtime                = 5;
		pausetime               = 2;
		repetition              = 1;
		dispload                = -1.5*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		%ftime                   = 20*2+25;
		loadtime                = 5;
		pausetime               = 2;
		repetition              = 1;
		dispload                = 1*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==65 || CasetoRun==70
		%ftime                   = 20*2+25;
		loadtime                = 3;
		pausetime               = 2;
		repetition              = 1;
		if CasetoRun==65 || CasetoRun==70
			dispload                = 2*le_base;
		elseif CasetoRun==64 || CasetoRun==66
			dispload                = le_base;
		end
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==69
		%ftime                   = 20*2+25;
		loadtime                = 1;
		pausetime               = 999999;
		repetition              = 1;
		dispload                = 0;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==110 || CasetoRun==96
		loadtime                = 9999;
		pausetime               = 0;
		repetition              = 1;
		dispload                = 0*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==111
		loadtime                = 1;
		pausetime               = 5;
		repetition              = 1;
		dispload                = 1*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==117
		loadtime                = 1;
		pausetime               = 5; %not used for CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117
		repetition              = 1;
		sigmainfmax             = 5; %MPa
		%dispload                = 1*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==192
		endcostime              = 0.1*le_base;
		endcosramp              = 0.25;
		dispload                = 0.05*le_base;
		ftime                   = 1024*le_base;
	elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==132 || CasetoRun==130
		endcostime              = 0.5;
		endcosramp              = 0.5;
		dispload                = 0.1*le_base;
		ftime                   = 1024;
	elseif CasetoRun==171
		endcostime              = 2;
		endcosramp              = 0.5;
		dispload                = 0.1/2*le_base;
		ftime                   = 1024;
	elseif CasetoRun==170
		endcostime              = 0.5;
		endcosramp              = 0.5;
		dispload                = 0.1/2*le_base;
		ftime                   = 1024;
	elseif CasetoRun==182
		endcostime              = 0.5;
		endcosramp              = 0.5;
		dispload                = 0.1/16*le_base;
		ftime                   = 1024;	
	elseif CasetoRun==184
		endcostime              = 0.5;
		endcosramp              = 0.5;
		dispload                = 0.2*le_base*200;
		ftime                   = 1024;
	elseif CasetoRun==195
		endcostime              = 0.009*le_base;
		endcosramp              = 0.012;
		dispload                = le_base;
		ftime                   = 1024*le_base;
	elseif CasetoRun==221 || CasetoRun==222 || CasetoRun==225
		endcostime              = 0.009*le_base;
		endcosramp              = 0.006;
		dispload                = le_base;
		ftime                   = 6;
	elseif CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==189 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==214 || CasetoRun==220
		%"normal" for mass-scaled is 0.09
		endcostime              = 0.09*le_base;
		endcosramp              = 0.006;
		dispload                = le_base;
		ftime                   = 1024*le_base;
	elseif CasetoRun==230
		%Edit point start: define displacement magnitude
		endcostime              = 0.1;
		endcosramp              = 1;
		dispload                = le_base/40;
		ftime                   = 1;
		
		fprintf('%s',['before endcostime loadvariable' char(10)]);
		endcostime_loaded=loadvariable('endcostime');
		%fprintf('%s',['after endcostime loadvariable' char(10)]);
		fprintf('%s',['endcostime_loaded.found=' int2txt(endcostime_loaded.found) char(10)]);
		fprintf('%s',['endcostime_loaded.valuetext=' endcostime_loaded.valuetext char(10)]);
		if endcostime_loaded.found
			endcostime=str2float(endcostime_loaded.valuetext);
		end
		fprintf('%s',['endcostime=' float2scitxt(5,endcostime) char(10)]);
		
		fprintf('%s',['before endcosramp loadvariable' char(10)]);
		endcosramp_loaded=loadvariable('endcosramp');
		%fprintf('%s',['after endcosramp loadvariable' char(10)]);
		fprintf('%s',['endcosramp_loaded.found=' int2txt(endcosramp_loaded.found) char(10)]);
		fprintf('%s',['endcosramp_loaded.valuetext=' endcosramp_loaded.valuetext char(10)]);
		if endcosramp_loaded.found
			endcosramp=str2float(endcosramp_loaded.valuetext);
		end
		fprintf('%s',['endcosramp=' float2scitxt(5,endcosramp) char(10)]);
		
		fprintf('%s',['before dispload loadvariable' char(10)]);
		dispload_loaded=loadvariable('dispload');
		%fprintf('%s',['after dispload loadvariable' char(10)]);
		fprintf('%s',['dispload_loaded.found=' int2txt(dispload_loaded.found) char(10)]);
		fprintf('%s',['dispload_loaded.valuetext=' dispload_loaded.valuetext char(10)]);
		if dispload_loaded.found
			dispload=str2float(dispload_loaded.valuetext);
		end
		fprintf('%s',['dispload=' float2scitxt(5,dispload) char(10)]);
		
		fprintf('%s',['before dispload_rel loadvariable' char(10)]);
		dispload_rel_loaded=loadvariable('dispload_rel');
		%fprintf('%s',['after dispload_rel loadvariable' char(10)]);
		fprintf('%s',['dispload_rel_loaded.found=' int2txt(dispload_rel_loaded.found) char(10)]);
		fprintf('%s',['dispload_rel_loaded.valuetext=' dispload_rel_loaded.valuetext char(10)]);
		dispload_rel=zeros(1,1);
		if dispload_rel_loaded.found
			dispload_rel=str2float(dispload_rel_loaded.valuetext);
			dispload=dispload_rel*le_base;
		end
		fprintf('%s',['dispload_rel=' float2scitxt(5,dispload_rel) char(10)]);
		
		fprintf('%s',['before ftime loadvariable' char(10)]);
		ftime_loaded=loadvariable('ftime');
		%fprintf('%s',['after ftime loadvariable' char(10)]);
		fprintf('%s',['ftime_loaded.found=' int2txt(ftime_loaded.found) char(10)]);
		fprintf('%s',['ftime_loaded.valuetext=' ftime_loaded.valuetext char(10)]);
		if ftime_loaded.found
			ftime=str2float(ftime_loaded.valuetext);
		end
		fprintf('%s',['ftime=' float2scitxt(5,ftime) char(10)]);
		
		%Edit point end
	elseif CasetoRun==228
		endcostime              = 0.02*le_base;
		endcosramp              = 0.03;
		%TDL where to adjust loading rate, default is le_base, now with 0.1*le_base
		dispload                = le_base;
		ftime                   = 1024*le_base;
	elseif CasetoRun==186
		endcostime              = 0.009*le_base;
		endcosramp              = 0.003;
		dispload                = le_base;
		ftime                   = 1024*le_base;
	elseif CasetoRun==193
		endcostime              = 0.009*le_base;
		endcosramp              = 0.003;
		dispload                = le_base;
		ftime                   = 1024*le_base;
	elseif CasetoRun==185
		endcostime              = 0.5;
		endcosramp              = 0.5;
		dispload                = 0.1/16*le_base;
		ftime                   = 1024;
	elseif CasetoRun==181 || CasetoRun==183
		endcostime              = 0.5;
		endcosramp              = 0.5;
		dispload                = 0.1/16*le_base;
		ftime                   = 1024;
	elseif CasetoRun==163 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165
		endcostime              = 0.5;
		endcosramp              = 0.5;
		%dispload                = 0.1/2*le_base;
		dispload                = 0.1/16*le_base;
		ftime                   = 1024;
	elseif CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227
		endcostime              = 0.5;
		endcosramp              = 0.5;
		%dispload                = 0.1/2*le_base;
		dispload                = 0.2*le_base/2;
		dispload=0;
		ftime                   = 3;	
	elseif CasetoRun==210
		endcostime              = 0.5;
		endcosramp              = 0.5;
		%dispload                = 0.1/2*le_base;
		dispload                = 0.2*le_base/2;
		dispload=0;
		ftime                   = 3/1;	
	elseif CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==207
		endcostime              = 0.5;
		endcosramp              = 0.5;
		%dispload                = 0.1/2*le_base;
		dispload                = 0.2*le_base/2;
		dispload=0;
		ftime                   = 1024;	
	elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==201
		endcostime              = 0.5;
		endcosramp              = 0.5;
		%dispload                = 0.1/2*le_base;
		dispload                = 0.2*le_base/200;
		ftime                   = 1024;	
	elseif CasetoRun==138
		endcostime              = 0.5;
		endcosramp              = 0.5;
		dispload                = 0.1*le_base;
		ftime                   = 1024;
		sigmainfmax             = 5; %MPa
	elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==134 || CasetoRun==137
		endcostime              = 0.5;
		endcosramp              = 0.5;
		dispload                = 0.2*le_base;
		ftime                   = 1024;
	elseif CasetoRun==139 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
		endcostime              = 10;
		endcosramp              = 0.5;
		dispload                = 0.2*le_base;
		ftime                   = 1024;	
	elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
		endcostime              = 0.25;
		endcosramp              = 0.125;
		dispload                = 1*le_base;
		ftime                   = 2.5;	
	elseif CasetoRun==152
		endcostime              = 0.1;
		endcosramp              = 0.2;
		dispload                = 1*le_base;
		ftime                   = 100;	
	elseif CasetoRun==150 || CasetoRun==153
		endcostime              = 0.75;
		endcosramp              = 0.2;
		dispload                = 1*le_base; % this is irrelevant now
		ftime                   = 100;
	elseif CasetoRun==155 || CasetoRun==158 || CasetoRun==157
		endcostime              = 0.75;
		endcosramp              = 0.2;
		dispload                = 1.5*le_base; % this is irrelevant now
		ftime                   = 100;
	elseif CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180
		endcostime              = 0.75*le_base;
		endcosramp              = 0.5;
		dispload                = 0.5*le_base;
		ftime                   = 100*le_base;
	elseif CasetoRun==156 || CasetoRun==159
		endcostime              = 0.75;
		endcosramp              = 0.2;
		%dispload                = 0.1*le_base;
		dispload                = 0.001*le_base;
		ftime                   = 100;
	elseif CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174
		endcostime              = 0.75;
		endcosramp              = 0.2;
		dispload                = 0.1*le_base;
		ftime                   = 100;
	elseif CasetoRun==154 || CasetoRun==161 %these inputs don't go anywhere, just make sure ftime is large enough to not stop out of nowhere
		endcostime              = 0.75;
		endcosramp              = 0.2;
		dispload                = 1*le_base; % this is irrelevant now
		ftime                   = 100;	
	elseif CasetoRun==135
		endcostime              = 10;
		endcosramp              = 1;
		dispload                = 0.002*le_base;
		ftime                   = 1024;
	elseif CasetoRun==136
		endcostime              = 1;
		endcosramp              = 1;
		dispload                = 0.002*le_base;
		ftime                   = 1024;
	elseif CasetoRun==124
		endcostime              = 0.5;
		endcosramp              = 0.125/40;
		dispload                = 0.02*le_base;
		ftime                   = 1024;	
	elseif CasetoRun==113
		loadtime                = 20;
		pausetime               = 5;
		repetition              = 1;
		dispload                = 1*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==112
		loadtime                = 1;
		pausetime               = 10;
		repetition              = 1;
		dispload                = -4*le_base;
		ftime                   = (loadtime+pausetime)*repetition;
	elseif CasetoRun==84 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
		loadtime=1;
		pausetime=1;
		repetition=1;
		dispload=1*le_base;
		ftime=(loadtime+pausetime)*repetition;
	end
	
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		dtoverride              = 1;
		if CasetoRun==33 || CasetoRun==34 || CasetoRun==39
			massscalingfactor       = 1000;
		else
			massscalingfactor       = 100;
		end
	elseif CasetoRun==111 || CasetoRun==113
		dtoverride              = 0.5;
		massscalingfactor        = 100;
	elseif CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==117
		dtoverride              = 0.25;
		massscalingfactor        = 100;
	elseif CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
		dtoverride					= 0.25;
		massscalingfactor       = 10;
	elseif CasetoRun==217
		dtoverride              = 0; %irrelevant for 217, we dont use dtoverride, but use mass scaling in a straight forward fashion
		%normal mass scaling is 100
		massscalingfactor       = 100;
	elseif CasetoRun==229 || CasetoRun==230
		dtoverride              = 0; %irrelevant for 217, we dont use dtoverride, but use mass scaling in a straight forward fashion
		%normal mass scaling is 100
		massscalingfactor       = 1;
	elseif CasetoRun==228
		dtoverride              = 0; %irrelevant for 228 too, we dont use dtoverride, but use mass scaling in a straight forward fashion
		massscalingfactor       = 2000;
	elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130
		dtoverride              = 0.25;
		massscalingfactor        = 100;
	elseif CasetoRun==154 || CasetoRun==161
		dtoverride              = 0;
		massscalingfactor        = 1;		
	elseif CasetoRun==124
		dtoverride              = 0.25;
		massscalingfactor        = 100;		
	elseif CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==8 || CasetoRun==9 || CasetoRun==10 || CasetoRun==11
		dtoverride              = 0;
		%dtoverride: 0=target time step size; 1=target mass scaling factor, take the more critical; 0.5: calc time step based on mass scaled wood, calc steel mass scaling based on time step; 0.25: mass-scale steel by 100, calc time step, then use time step to calc wood mass scaling.
	end

	dt                      = 0.001;
	ndt                     = round(ftime/dt) +1;
	t_time                       = 0;
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
		t0_plane                = 40;
	elseif CasetoRun==4
		t0_plane=100;
	elseif CasetoRun==5 || CasetoRun==6
		t0_plane=25;
	elseif CasetoRun==7
		t0_plane=50;
	elseif CasetoRun==8 || CasetoRun==9
		t0_plane=25;
	elseif CasetoRun==10
		t0_plane=10;
	elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		t0_plane                = 44;
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		t0_plane                = 40;
	elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==152 || CasetoRun==153 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		t0_plane=10;
	elseif CasetoRun==229
		t0_plane=1.3;
	elseif CasetoRun==230
		t0_plane_pause=0;
		t0_plane_pause_loaded=loadvariable('t0_plane_pause');
		if t0_plane_pause_loaded.found
			t0_plane_pause=str2long(t0_plane_pause_loaded.valuetext);
		end
	
		t0_plane=1;
		t0_plane_loaded=loadvariable('t0_plane');
		if t0_plane_pause
			printfloat(1,t0_plane_loaded.found,'t0_plane_loaded.found');
			printstring(1,t0_plane_loaded.valuetext,'t0_plane_loaded.valuetext');
			printstring(1,t0_plane_loaded.type,'t0_plane_loaded.type');
		end
		if t0_plane_loaded.found
			if CompareTexts(t0_plane_loaded.type,'long')
				if t0_plane_pause
					printtext(1,'about to load t0_plane as long');
				end
				t0_plane=str2long(t0_plane_loaded.valuetext);
				if t0_plane_pause
					printtext(1,'t0_plane loaded as long');
					printfloat(1,t0_plane,'t0_plane');
				end
			else
				if t0_plane_pause
					printtext(1,'about to load t0_plane as float');
				end
				t0_plane=str2float(t0_plane_loaded.valuetext);
				if t0_plane_pause
					printtext(1,'t0_plane loaded as float');
					printfloat(1,t0_plane,'t0_plane');
				end
			end
		end
	elseif CasetoRun==154 || CasetoRun==161 || CasetoRun==124 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174
		t0_plane=1;
	end
	
	Emax1=max([Er El Et]);
	Emax2=E;
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
		k=0.1;
	elseif CasetoRun==4
		k=0.5;
	elseif CasetoRun==5 || CasetoRun==6
		k=0.25;
	elseif CasetoRun==7
		k=0.25;
	elseif CasetoRun==8 || CasetoRun==9
		k=0.25;
	elseif CasetoRun==10
		k=0.25;
	elseif CasetoRun==11
		k=0.5;
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		k=0.5;
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		k=0.5;
	elseif CasetoRun==183
		k=0.25;
	elseif CasetoRun==186
		k=0.5;
	elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==158 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		k=0.5;
	elseif CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228
		k=0.5;
	elseif CasetoRun==155
		k=0.5;
	elseif CasetoRun==194
		k=0.01;
	elseif CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==180
		%curan adjust
		k=0.01;
	elseif CasetoRun==125 %new k right here
		k=0.1;
	end
	psp=0;
	C=0;
	Mu=0;
	A=0;
	
	%start of dt determination (automatic)
	%please put dtoverride value meanings!
	if CasetoRun==154 || CasetoRun==161
		psp=1000;
		psp1=psp;
		C=sqrt(E/psp);
		dt=0.04*le(1)/C;
		Mu=E/2/(1+nu);
		A=1;
	elseif CasetoRun==230
		psp1_base=5e-7; %wood, 500 kg/m3 or 5e-7 kg/mm3
		psp2_base=7.6e-6; %steel, 7600 kg/m3 or 7.6e-6 kg/mm3
		psp1=psp1_base*massscalingfactor;
		psp2=psp2_base*massscalingfactor;
		E1=max([El Et Er]);
		E2=E;
		C1=sqrt(E1/psp1); %speed of sound
		C2=sqrt(E2/psp2); %speed of sound
		dt1=k*le(1)/C1;
		dt2=k*le(1)/C2;
		dt=dt2; %take steel
	elseif CasetoRun==217 || CasetoRun==229 || CasetoRun==228
		psp1_base=5e-7; %wood, 500 kg/m3 or 5e-7 kg/mm3
		psp2_base=7.6e-6; %steel, 7600 kg/m3 or 7.6e-6 kg/mm3
		psp1=psp1_base*massscalingfactor;
		psp2=psp2_base*massscalingfactor;
		E1=max([El Et Er]);
		E2=E;
		C1=sqrt(E1/psp1); %speed of sound
		C2=sqrt(E2/psp2); %speed of sound
		dt1=k*le(1)/C1;
		dt2=k*le(1)/C2;
		dt=dt1;
	else
		if dtoverride==0 || dtoverride==1
			psp_min1=dt^2*Emax1/(k^2*le(1)^2);
			psp_min2=dt^2*Emax2/(k^2*le(1)^2);

			if dtoverride
				psp_min1=0;
				psp_min2=0;
			end
			psp1=max([psp_min1 8e-7]);
			psp2=max([psp_min2 7e-6]);
			if dtoverride
				psp1=psp1*massscalingfactor; %wood
				psp2=psp2*massscalingfactor; %steel
				dt=k*le(1)*sqrt(min([psp1/Emax1 psp2/Emax2]));
			end
		elseif dtoverride==0.5
			psp1=(8e-7)*massscalingfactor;;
			dt=k*le(1)*sqrt(psp1/Emax1);
			psp_min2=dt^2*Emax2/(k^2*le(1)^2);
			psp2=max([psp_min2 7e-6]);
			fprintf('%s',['dtoverride=0.5 implemented' char(10)]);
			1;
		elseif dtoverride==0.25
			psp2=(7e-6)*massscalingfactor; %steel
			dt=k*le(1)*sqrt(psp2/Emax2);
			psp_min1=dt^2*Emax1/(k^2*le(1)^2);
			psp1=max([psp_min1 8e-7]); %wood
			fprintf('%s',['dtoverride=0.25 implemented' char(10)]);
			1;
		end
	end
	%end of dt determination (automatic)
	
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
		%% Boundary nodes
		% Boundary coordination
		x_min = 0;
		x_max = 10*le_base;
		y_min = 2*le_base;
		y_max = 16*le_base;
	elseif CasetoRun==21
		%% Boundary nodes
		% Boundary coordination
		x_min = 0;
		x_max = 10*le_base;
		y_min = 2*le_base-le(2);
		y_max = 16*le_base;
	elseif CasetoRun==4
		%% Boundary nodes
		% Boundary coordination
		x_min = 20;
		x_max = 140;
		y_min = 20;
		y_max = 210;
	elseif CasetoRun==5 || CasetoRun==6
		x_min=-1*le_base;
		x_max=(23+1)*le_base;
		if CasetoRun==5
			y_min=-le_base;
		elseif CasetoRun==6
			y_min=-2*le_base;
		end
		y_max=(13+1)*le_base;
	elseif CasetoRun==7
		x_min = 0;
		x_max = 10*le_base;
		y_min = 0;
		y_max = 16*le_base;
	elseif CasetoRun==8 || CasetoRun==9
		x_min=0;
		x_max=23*le_base;
		if CasetoRun==8
			y_min=le_base;
		elseif CasetoRun==9
			y_min=2*le_base;
		end
		y_max=13*le_base;
	elseif CasetoRun==10
		%% Boundary nodes
		% Boundary coordination
		x_min = 0;
		x_max = 10*le_base;
		y_min = 0*le_base;
		y_max = 18*le_base;
	elseif CasetoRun==11
		%% Boundary nodes
		% Boundary coordination
		x_min = 0;
		x_max = 9*le_base;
		y_min = 2*le_base;
		y_max = 22*le_base;
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		%% Boundary nodes
		% Boundary coordination
		x_min = 0;
		x_max = 10*le_base;
		y_min = 0*le_base;
		y_max = 22*le_base;
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		%% Boundary nodes
		% Boundary coordination
		x_min = 0*le_base;
		x_max = 9*le_base;
		y_min = 0*le_base;
		y_max = 22*le_base;
	elseif CasetoRun==64
		x_min=0*le_base;
		x_max=8*le_base;
		y_min=0*le_base;
		y_max=11*le_base;
	elseif CasetoRun==66 || CasetoRun==69
		x_min=0*le_base;
		x_max=13*le_base;
		y_min=0*le_base;
		y_max=11*le_base;
	elseif CasetoRun==67
		x_min=2*le_base;
		x_max=22*le_base;
		y_min=0*le_base; % energy absorbing will be deployed instead
		y_max=8*le_base;
	elseif CasetoRun==68 || CasetoRun==71 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==110 || CasetoRun==96
		x_min=2*le_base;
		x_max=22*le_base;
		y_min=2*le_base; % energy absorbing will not be deployed
		y_max=12*le_base;
	elseif CasetoRun==114
		x_min=0*le_base;
		x_max=24*le_base;
		y_min=2*le_base; % energy absorbing will not be deployed
		y_max=12*le_base;
	elseif CasetoRun==111 || CasetoRun==113
		x_min=0*le_base;
		x_max=19*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=20*le_base;
	elseif CasetoRun==115
		x_min=2*le_base;
		x_max=7*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=7*le_base;
	elseif CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==117 || CasetoRun==138
		x_min=2*le_base;
		x_max=6*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=6*le_base;
	elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==192
		x_min=0*le_base;
		x_max=6*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=6*le_base;
	elseif CasetoRun==228
		%% Boundary nodes
		% Boundary coordination
		x_min = 0*le_base;
		x_max = 9*le_base;
		y_min = 0*le_base;
		y_max = 22*le_base;
	elseif CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207
		x_min=0*le_base;
		x_max=14*le_base;
		%x_min=5*le_base;
		%x_max=9*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=14*le_base;
	elseif CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209
		x_min=2*le_base;
		x_max=12*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=6*le_base;
	elseif CasetoRun==202
		x_min=0*le_base;
		x_max=8*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=6*le_base;
	elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169
		x_min=0*le_base;
		x_max=7*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=7*le_base;
	elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==132 || CasetoRun==130
		x_min=2*le_base;
		x_max=8*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=6*le_base;
    elseif CasetoRun==129
		x_min=2*le_base;
		x_max=8*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=6.25*le_base;        
	elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135
		x_min=0*le_base;
		x_max=12*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=6.25*le_base;
	elseif CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
		x_min=0*le_base;
		x_max=12*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=4.25*le_base;		
	elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
		x_min=0*le_base;
		x_max=15*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=7*le_base;		
	elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153
		x_min=0*le_base;
		x_max=14*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=14*le_base;
	elseif CasetoRun==154 || CasetoRun==161
		x_min=0*le_base;
		x_max=32*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=32*le_base;
	elseif CasetoRun==124
		x_min=0*le_base;
		x_max=10*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=9*le_base;
	elseif CasetoRun==112
		x_min=0*le_base;
		x_max=16*le_base;
		y_min=0*le_base; % energy absorbing will not be deployed
		y_max=17*le_base;
	elseif CasetoRun==84
		x_min=2*le_base;
		x_max=25*le_base;
		y_min=2*le_base; % energy absorbing will not be deployed
		y_max=13*le_base;
	elseif CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89
		x_min=2*le_base;
		x_max=10*le_base;
		y_min=2*le_base; % energy absorbing will not be deployed
		y_max=10*le_base;
	elseif CasetoRun==94
		x_min=2*le_base;
		x_max=11*le_base;
		y_min=2*le_base; % energy absorbing will not be deployed
		y_max=10*le_base;
	elseif CasetoRun==85
		x_min=0*le_base;
		x_max=4*le_base;
		y_min=0*le_base;
		y_max=4*le_base;
	elseif CasetoRun==72 || CasetoRun==73
		x_min=2*le_base;
		x_max=23*le_base;
		y_min=2*le_base; % energy absorbing will not be deployed
		y_max=12*le_base;
	elseif CasetoRun==65 || CasetoRun==70
		x_min=0*le_base;
		x_max=8*le_base;
		y_min=1*le_base;
		y_max=11*le_base;
	end

	[nfbcx,nfbcy,fbcx,fbcy]=Compute_Boundary_Nodes(nodeCount,LOC,x_max,x_min,y_max,y_min);
	% nfbcx: number of boundary nodes in X direction
	% nfbcy: number of boundary nodes in Y direction
	% fbcx: index of all boundary nodes in X direction
	% fbcy: index of all boundary nodes in Y direction

	% Specimen's Extra restraint
	ynodedamped=[];
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
		for n=1:nodeCount
			if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) || ((LOC(n,2)<=10*le_base+1e-3 & LOC(n,2)>=10*le_base-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
		end
	elseif CasetoRun==21
		for n=1:nodeCount
			if ((LOC(n,2)<=2*le_base-le(2)+1e-3 & LOC(n,2)>=2*le_base-le(2)-1e-3)) || ((LOC(n,2)<=10*le_base+2*le(2)+1e-3 & LOC(n,2)>=10*le_base+2*le(2)-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
		end
	elseif CasetoRun==4
		for n=1:nodeCount
			%if (LOC(n,1)<=140+1e-3 & LOC(n,1)>=40-1e-3) & (LOC(n,2)<=50+1e-3 & LOC(n,2)>=50-1e-3)
			%    nfbcy = nfbcy+1;
			%    fbcy = [fbcy n];
			%end
			%if (LOC(n,1)<=40+1e-3 & LOC(n,1)>=40-1e-3) & (LOC(n,2)<=150+1e-3 & LOC(n,2)>=140-1e-3)
			%    nfbcy = nfbcy+1;
			%    fbcy = [fbcy n];
			%end
		end
	elseif CasetoRun==5 || CasetoRun==6
		for n=1:nodeCount
			if CasetoRun==5
				if ((LOC(n,2)<=10*le_base+1e-3 && LOC(n,2)>=10*le_base-1e-3)) && ((LOC(n,1)<=13*le_base+1e-3 && LOC(n,1)>=10*le_base-1e-3))
					nfbcx = nfbcx+1;
					fbcx = [fbcx n];
				end
				if ((LOC(n,2)<=1*le_base+1e-3 & LOC(n,2)>=1*le_base-1e-3)) && ((LOC(n,1)<=5*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3) || (LOC(n,1)<=21*le_base+1e-3 & LOC(n,1)>=18*le_base-1e-3))
					ynodedamped=[ynodedamped n];
				end
			elseif CasetoRun==6
				if ((LOC(n,2)<=10*le_base+1e-3 && LOC(n,2)>=10*le_base-1e-3)) && ((LOC(n,1)<=13*le_base+1e-3 && LOC(n,1)>=10*le_base-1e-3))
					nfbcx = nfbcx+1;
					fbcx = [fbcx n];
				end
				if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=5*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3) || (LOC(n,1)<=21*le_base+1e-3 & LOC(n,1)>=18*le_base-1e-3))
					ynodedamped=[ynodedamped n];
				end
			end
		end
	elseif CasetoRun==7
		for n=1:nodeCount
			if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) || ((LOC(n,2)<=10*le_base+1e-3 & LOC(n,2)>=10*le_base-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
			if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=7*le_base+1e-3 & LOC(n,1)>=3*le_base-1e-3))
				ynodedamped=[ynodedamped n];
			end
		end
	elseif CasetoRun==8 || CasetoRun==9
		for n=1:nodeCount
			if CasetoRun==8
				if ((LOC(n,2)<=10*le_base+1e-3 && LOC(n,2)>=10*le_base-1e-3)) && ((LOC(n,1)<=13*le_base+1e-3 && LOC(n,1)>=10*le_base-1e-3))
					nfbcx = nfbcx+1;
					fbcx = [fbcx n];
				end        
			elseif CasetoRun==9
				if ((LOC(n,2)<=10*le_base+1e-3 && LOC(n,2)>=10*le_base-1e-3)) && ((LOC(n,1)<=13*le_base+1e-3 && LOC(n,1)>=10*le_base-1e-3))
					nfbcx = nfbcx+1;
					fbcx = [fbcx n];
				end        
			end
		end
	elseif CasetoRun==10
		for n=1:nodeCount
			%wheres it holding?
			if ((LOC(n,2)<=14*le_base+1e-3 && LOC(n,2)>=14*le_base-1e-3)) || ((LOC(n,2)<=2*le_base+1e-3 && LOC(n,2)>=2*le_base-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
			if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=7*le_base+1e-3 & LOC(n,1)>=3*le_base-1e-3))
				ynodedamped=[ynodedamped n];
			end

		end
	elseif CasetoRun==11
		for n=1:nodeCount
			if ((LOC(n,2)<=19*le_base+1e-3 & LOC(n,2)>=19*le_base-1e-3)) && ((LOC(n,2)<=4*le_base+1e-3 & LOC(n,2)>=4*le_base-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
			%if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=7*le_base+1e-3 & LOC(n,1)>=3*le_base-1e-3))
			%    ynodedamped=[ynodedamped n];
			%end
		end
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41
		for n=1:nodeCount
			if ((LOC(n,2)<=18*le_base+1e-3 & LOC(n,2)>=18*le_base-1e-3) || (LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
			if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
				ynodedamped=[ynodedamped n];
			end
		end
	elseif CasetoRun==53
		for n=1:nodeCount
			if ((LOC(n,2)<=18*le_base+1e-3 & LOC(n,2)>=18*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
			if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
				ynodedamped=[ynodedamped n];
			end
		end    
	elseif CasetoRun==43
		for n=1:nodeCount
			if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
			if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
				ynodedamped=[ynodedamped n];
			end
		end
	elseif CasetoRun==44
		for n=1:nodeCount
			if ((LOC(n,2)<=18*le_base+1e-3 & LOC(n,2)>=18*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
			if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
				ynodedamped=[ynodedamped n];
			end
		end
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		for n=1:nodeCount
			if CasetoRun==15
				if ((LOC(n,2)<=16*le_base+1e-3 & LOC(n,2)>=16*le_base-1e-3)) && ((LOC(n,1)<=4*le_base+1e-3 & LOC(n,1)>=4*le_base-1e-3))
					nfbcx = nfbcx+1;
					fbcx = [fbcx n];
				end
				if ((LOC(n,2)<=5*le_base+1e-3 & LOC(n,2)>=5*le_base-1e-3)) && ((LOC(n,1)<=7*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
					ynodedamped=[ynodedamped n];
				end
			else
				if ((LOC(n,2)<=19*le_base+1e-3 & LOC(n,2)>=19*le_base-1e-3)) && ((LOC(n,1)<=4*le_base+1e-3 & LOC(n,1)>=4*le_base-1e-3))
					nfbcx = nfbcx+1;
					fbcx = [fbcx n];
				end
				if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=7*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
					ynodedamped=[ynodedamped n];
				end
			end
		end
	elseif CasetoRun==64
		for n=1:nodeCount
			if ((LOC(n,2)<=7*le_base+1e-3 & LOC(n,2)>=4*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=8*le_base-1e-3))
				ynodedamped=[ynodedamped n];
			end
		end
	elseif CasetoRun==66 || CasetoRun==68
		%{
		for n=1:nodeCount
			if ((LOC(n,2)<=7*le_base+1e-3 & LOC(n,2)>=4*le_base-1e-3)) && ((LOC(n,1)<=13*le_base+1e-3 & LOC(n,1)>=13*le_base-1e-3))
				ynodedamped=[ynodedamped n];
			end
		end
		%}
	elseif CasetoRun==71
		for n=1:nodeCount
			if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=22*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
		end
	elseif CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77
	%{
		for n=1:nodeCount
			if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=23*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
		end
		%}
	elseif CasetoRun==111 || CasetoRun==113
		for n=1:nodeCount
			if ((LOC(n,2)<=7*le_base+1e-3 & LOC(n,2)>=7*le_base-1e-3) || (LOC(n,2)<=13*le_base+1e-3 & LOC(n,2)>=13*le_base-1e-3)) && ((LOC(n,1)<=6*le_base+1e-3 & LOC(n,1)>=6*le_base-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
		end
	elseif CasetoRun==195
		for n=1:size(LOC,1)
			if CloseEnough(LOC(n,2),2*le_base,1e-3,1) %pulls down
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
				nfbcy=nfbcy+1;
				fbcy = [fbcy n];
			elseif CloseEnough(LOC(n,2),5*le_base,1e-3,1) %pulls up
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			end
		end			
	elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==189
		for n=1:size(LOC,1)
			if CloseEnough(LOC(n,2),2*le_base,1e-3,1) %pulls down
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			elseif CloseEnough(LOC(n,2),5*le_base,1e-3,1) %pulls up
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			end
		end			
	elseif CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==130 || CasetoRun==117 || CasetoRun==192
	elseif CasetoRun==223 || CasetoRun==226
		for n=1:size(LOC,1)
			if (CloseEnough(LOC(n,1),2*le_base,1e-3,1) || CloseEnough(LOC(n,1),12*le_base,1e-3,1)) && CloseEnough(LOC(n,2),2*le_base,1e-3,1) %prevent y move
				%we can leave the 12*le+base, since itll never be reached
				nfbcy = nfbcy+1;
				fbcy = [fbcy n];
			end
			if CloseEnough(LOC(n,1),7*le_base,1e-3,1) %prevent x move
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			end
		end		
	elseif CasetoRun==219 || CasetoRun==224 || CasetoRun==227
		for n=1:size(LOC,1)
			if (CloseEnough(LOC(n,1),2*le_base,1e-3,1) || CloseEnough(LOC(n,1),12*le_base,1e-3,1)) && CloseEnough(LOC(n,2),2*le_base,1e-3,1) %prevent y move
				nfbcy = nfbcy+1;
				fbcy = [fbcy n];
			end
			if CloseEnough(LOC(n,1),7*le_base,1e-3,1) && CloseEnough(LOC(n,2),3*le_base,1e-3,1) %prevent x move
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			end
		end		
	elseif CasetoRun==217
		for n=1:size(LOC,1)
			%{
			if CloseEnough(LOC(n,1),2*le_base,1e-3,1) && (CloseEnough(LOC(n,2),2*le_base,1e-3,1) || CloseEnough(LOC(n,2),5*le_base,1e-3,1))
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			end
			%}
		end		
	elseif CasetoRun==229
		for n=1:size(LOC,1)
			if CloseEnough(LOC(n,2),2*le_base,1e-3,1) %locks the bottom at x and y directions
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
				nfbcy=nfbcy+1;
				fbcy = [fbcy n];
			end
		end		
	elseif CasetoRun==230
		%Edit point start: define nodes with fixed boundaries (pin)
		NodeyPosition_pin=-1*le_base; %to deactivate, put it out of bound
		NodexPosition_pin=-1*le_base; %to deactivate, put it out of bound
		
		NodexPosition_roller=-1*le_base; %to deactivate, put it out of bound
		NodeyPosition_roller=-1*le_base; %to deactivate, put it out of bound
		
		
		fprintf('%s',['before NodeyPosition_pin loadvariable' char(10)]);
		NodeyPosition_pin_loaded=loadvariable('NodeyPosition_pin');
		%fprintf('%s',['after NodeyPosition_pin loadvariable' char(10)]);
		fprintf('%s',['NodeyPosition_pin_loaded.found=' int2txt(NodeyPosition_pin_loaded.found) char(10)]);
		fprintf('%s',['NodeyPosition_pin_loaded.valuetext=' NodeyPosition_pin_loaded.valuetext char(10)]);
		if NodeyPosition_pin_loaded.found
			NodeyPosition_pin=str2float(NodeyPosition_pin_loaded.valuetext);
		end
		fprintf('%s',['NodeyPosition_pin=' float2scitxt(5,NodeyPosition_pin) char(10)]);
		
		fprintf('%s',['before NodexPosition_pin loadvariable' char(10)]);
		NodexPosition_pin_loaded=loadvariable('NodexPosition_pin');
		%fprintf('%s',['after NodexPosition_pin loadvariable' char(10)]);
		fprintf('%s',['NodexPosition_pin_loaded.found=' int2txt(NodexPosition_pin_loaded.found) char(10)]);
		fprintf('%s',['NodexPosition_pin_loaded.valuetext=' NodexPosition_pin_loaded.valuetext char(10)]);
		if NodexPosition_pin_loaded.found
			NodexPosition_pin=str2float(NodexPosition_pin_loaded.valuetext);
		end
		fprintf('%s',['NodexPosition_pin=' float2scitxt(5,NodexPosition_pin) char(10)]);
		
		fprintf('%s',['before NodexPosition_roller loadvariable' char(10)]);
		NodexPosition_roller_loaded=loadvariable('NodexPosition_roller');
		%fprintf('%s',['after NodexPosition_roller loadvariable' char(10)]);
		fprintf('%s',['NodexPosition_roller_loaded.found=' int2txt(NodexPosition_roller_loaded.found) char(10)]);
		fprintf('%s',['NodexPosition_roller_loaded.valuetext=' NodexPosition_roller_loaded.valuetext char(10)]);
		if NodexPosition_roller_loaded.found
			NodexPosition_roller=str2float(NodexPosition_roller_loaded.valuetext);
		end
		fprintf('%s',['NodexPosition_roller=' float2scitxt(5,NodexPosition_roller) char(10)]);
		
		fprintf('%s',['before NodeyPosition_roller loadvariable' char(10)]);
		NodeyPosition_roller_loaded=loadvariable('NodeyPosition_roller');
		%fprintf('%s',['after NodeyPosition_roller loadvariable' char(10)]);
		fprintf('%s',['NodeyPosition_roller_loaded.found=' int2txt(NodeyPosition_roller_loaded.found) char(10)]);
		fprintf('%s',['NodeyPosition_roller_loaded.valuetext=' NodeyPosition_roller_loaded.valuetext char(10)]);
		if NodeyPosition_roller_loaded.found
			NodeyPosition_roller=str2float(NodeyPosition_roller_loaded.valuetext);
		end
		fprintf('%s',['NodeyPosition_roller=' float2scitxt(5,NodeyPosition_roller) char(10)]);
		
		
		fprintf('%s',['before NodeyPosition_pin_rel loadvariable' char(10)]);
		NodeyPosition_pin_rel_loaded=loadvariable('NodeyPosition_pin_rel');
		%fprintf('%s',['after NodeyPosition_pin_rel loadvariable' char(10)]);
		fprintf('%s',['NodeyPosition_pin_rel_loaded.found=' int2txt(NodeyPosition_pin_rel_loaded.found) char(10)]);
		fprintf('%s',['NodeyPosition_pin_rel_loaded.valuetext=' NodeyPosition_pin_rel_loaded.valuetext char(10)]);
		NodeyPosition_pin_rel=zeros(1,1);
		if NodeyPosition_pin_rel_loaded.found
			NodeyPosition_pin_rel=str2float(NodeyPosition_pin_rel_loaded.valuetext);
			NodeyPosition_pin=NodeyPosition_pin_rel*le_base;
		end
		fprintf('%s',['NodeyPosition_pin_rel=' float2scitxt(5,NodeyPosition_pin_rel) char(10)]);
		
		fprintf('%s',['before NodexPosition_pin_rel loadvariable' char(10)]);
		NodexPosition_pin_rel_loaded=loadvariable('NodexPosition_pin_rel');
		%fprintf('%s',['after NodexPosition_pin_rel loadvariable' char(10)]);
		fprintf('%s',['NodexPosition_pin_rel_loaded.found=' int2txt(NodexPosition_pin_rel_loaded.found) char(10)]);
		fprintf('%s',['NodexPosition_pin_rel_loaded.valuetext=' NodexPosition_pin_rel_loaded.valuetext char(10)]);
		NodexPosition_pin_rel=zeros(1,1);
		if NodexPosition_pin_rel_loaded.found
			NodexPosition_pin_rel=str2float(NodexPosition_pin_rel_loaded.valuetext);
			NodexPosition_pin=NodexPosition_pin_rel*le_base;
		end
		fprintf('%s',['NodexPosition_pin_rel=' float2scitxt(5,NodexPosition_pin_rel) char(10)]);
		
		fprintf('%s',['before NodexPosition_roller_rel loadvariable' char(10)]);
		NodexPosition_roller_rel_loaded=loadvariable('NodexPosition_roller_rel');
		%fprintf('%s',['after NodexPosition_roller_rel loadvariable' char(10)]);
		fprintf('%s',['NodexPosition_roller_rel_loaded.found=' int2txt(NodexPosition_roller_rel_loaded.found) char(10)]);
		fprintf('%s',['NodexPosition_roller_rel_loaded.valuetext=' NodexPosition_roller_rel_loaded.valuetext char(10)]);
		NodexPosition_roller_rel=zeros(1,1);
		if NodexPosition_roller_rel_loaded.found
			NodexPosition_roller_rel=str2float(NodexPosition_roller_rel_loaded.valuetext);
			NodexPosition_roller=NodexPosition_roller_rel*le_base;
		end
		fprintf('%s',['NodexPosition_roller_rel=' float2scitxt(5,NodexPosition_roller_rel) char(10)]);
		
		fprintf('%s',['before NodeyPosition_roller_rel loadvariable' char(10)]);
		NodeyPosition_roller_rel_loaded=loadvariable('NodeyPosition_roller_rel');
		%fprintf('%s',['after NodeyPosition_roller_rel loadvariable' char(10)]);
		fprintf('%s',['NodeyPosition_roller_rel_loaded.found=' int2txt(NodeyPosition_roller_rel_loaded.found) char(10)]);
		fprintf('%s',['NodeyPosition_roller_rel_loaded.valuetext=' NodeyPosition_roller_rel_loaded.valuetext char(10)]);
		NodeyPosition_roller_rel=zeros(1,1);
		if NodeyPosition_roller_rel_loaded.found
			NodeyPosition_roller_rel=str2float(NodeyPosition_roller_rel_loaded.valuetext);
			NodeyPosition_roller=NodeyPosition_roller_rel*le_base;
		end
		fprintf('%s',['NodeyPosition_roller_rel=' float2scitxt(5,NodeyPosition_roller_rel) char(10)]);
		
		
		%Edit point end
		for n=1:size(LOC,1)
			if CloseEnough(LOC(n,2),NodeyPosition_pin,1e-3,1) || CloseEnough(LOC(n,1),NodexPosition_pin,1e-3,1) %locks in x and y directions
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
				nfbcy=nfbcy+1;
				fbcy = [fbcy n];
			elseif CloseEnough(LOC(n,2),NodeyPosition_roller,1e-3,1) %locks in y direction
				nfbcy=nfbcy+1;
				fbcy = [fbcy n];
			elseif CloseEnough(LOC(n,1),NodexPosition_roller,1e-3,1) %locks in x direction
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			end
		end		
	elseif CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207
		for n=1:size(LOC,1)
			%{
			if CloseEnough(LOC(n,1),2*le_base,1e-3,1) %pulls up
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			elseif CloseEnough(LOC(n,1),6*le_base,1e-3,1) %pulls up
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			end
			%}
		end		
	elseif CasetoRun==228
		for n=1:nodeCount
			if ((LOC(n,2)<=19*le_base+1e-3 & LOC(n,2)>=19*le_base-1e-3)) && ((LOC(n,1)<=4*le_base+1e-3 & LOC(n,1)>=4*le_base-1e-3))
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
			if ((LOC(n,2)<=2*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=7*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
				%nope, we pull top and bottom
			end
		end
	elseif CasetoRun==171
		for n=1:size(LOC,1)
			if CloseEnough(LOC(i,1),6*le_base,1e-3,1) %pulls up
				if LOC(i,2)>3*le_base+0.5*le(2)
					nfbcx=nfbcx+1;
					fbcx = [fbcx n];
				elseif LOC(i,2)<3*le_base-0.5*le(2) %pulls down
					nfbcx=nfbcx+1;
					fbcx = [fbcx n];
				end
			end
		end		
	elseif CasetoRun==166
		for n=1:size(LOC,1)
			if CloseEnough(LOC(i,2),2.5*le_base,1e-3,1) && CloseEnough(LOC(i,1),5.8*le_base,1e-3,1)
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			elseif CloseEnough(LOC(i,2),3.5*le_base,1e-3,1) && CloseEnough(LOC(i,1),5.8*le_base,1e-3,1)
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			end
		end		
	elseif CasetoRun==124
		%124 lock
		for n=1:size(LOC,1)
			if CloseEnough(LOC(n,2),2*le_base,1e-3,1)
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			elseif CloseEnough(LOC(n,2),7*le_base,1e-3,1)
				nfbcx=nfbcx+1;
				fbcx = [fbcx n];
			end
		end		
	elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135
		for n=1:size(LOC,1)
			if CloseEnough(LOC(n,1),10*le_base,1e-3,1)
				if CloseEnough(LOC(n,2),2*le_base,1e-3,1)
					nfbcx=nfbcx+1;
					fbcx = [fbcx n];
				elseif CloseEnough(LOC(n,2),4.25*le_base,1e-3,1)
					nfbcx=nfbcx+1;
					fbcx = [fbcx n];
				end
			end
		end
	elseif CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==154 || CasetoRun==161 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174
	elseif CasetoRun==175 || CasetoRun==194 || CasetoRun==180
		%for n=1:nodeCount
		%	if CloseEnough(LOC(n,1),7*le_base,1e-3,1)
		%		nfbcx = nfbcx+1;
		%		fbcx = [fbcx n];
		%	end
		%end
	elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147
		for n=1:nodeCount
			if CloseEnough(LOC(n,1),5*le_base,1e-3,1)
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
		end
	elseif CasetoRun==150 || CasetoRun==152 || CasetoRun==153
		for n=1:nodeCount
			if CloseEnough(LOC(n,1),7*le_base,1e-3,1)
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
			if CloseEnough(LOC(n,2),7*le_base,1e-3,1)
				nfbcy = nfbcy+1;
				fbcy = [fbcy n];
			end
		end	
	elseif CasetoRun==145
		%all defined in predxvel
	elseif CasetoRun==112
		for n=1:nodeCount
			if ((LOC(n,2)<=16*le_base+1e-3 & LOC(n,2)>=12*le_base-1e-3)) && ((LOC(n,1)<=2*le_base+1e-3 & LOC(n,1)>=2*le_base-1e-3))
				nfbcy = nfbcy+1;
				fbcy = [fbcy n];
				nfbcx = nfbcx+1;
				fbcx = [fbcx n];
			end
		end
	elseif CasetoRun==69
		for n=1:nodeCount
			if ((LOC(n,2)<=8*le_base+1e-3 & LOC(n,2)>=4*le_base-1e-3)) && ((LOC(n,1)<=13*le_base+1e-3 & LOC(n,1)>=13*le_base-1e-3))
				nfbcy = nfbcy+1;
				fbcy = [fbcy n];
			end
		end
	elseif CasetoRun==65 || CasetoRun==70
		for n=1:nodeCount
			if ((LOC(n,2)<=5*le_base+1e-3 & LOC(n,2)>=2*le_base-1e-3)) && ((LOC(n,1)<=8*le_base+1e-3 & LOC(n,1)>=8*le_base-1e-3))
				ynodedamped=[ynodedamped n];
			end
		end
	elseif CasetoRun==67
		for n=1:nodeCount
			if ((LOC(n,2)>=2*le_base-1e-3) && (LOC(n,2)<=2*le_base+1e-3)) && ((LOC(n,1)>=8*le_base-1e-3) && (LOC(n,1)<=8*le_base+1e-3))
				ynodedamped=[ynodedamped n];
			end
		end
	end
	troubleshotparticles=[];
	
	xdirletter=cell(1,1);
	ydirletter=cell(1,1);
	zdirletter=cell(1,1);
	xydirletter=cell(1,1);
	yzdirletter=cell(1,1);
	xzdirletter=cell(1,1);
	
	xdirletter{1,1}='';
	ydirletter{1,1}='';
	zdirletter{1,1}='';
	xydirletter{1,1}='';
	yzdirletter{1,1}='';
	xzdirletter{1,1}='';
	
	thetacrackrtl=[];
	
	support_center_x=[];
	support_center_y=[];
	support_radius=[];
	
	yparticledamped=[];
	ignoremomentum=[];
	Rdisplayedparticles=[];
	
	%start rotational protocol for 159
	rotate.angle_deg=zeros(1,1); %in degrees
	rotate.angle=zeros(1,1); %in rad
	rotate.center=zeros(1,2); %rotation axis
	rotate.R=zeros(2,2);
	
	%end rotational protocol for 159
	
	x_center=0;
	y_center=0;
	
	%{
	x_crack.center=zeros(100,2,100);
	x_crack.top=zeros(100,2,100);
	x_crack.bot=zeros(100,2,100);
	x_crack.npaths=0;
	x_crack.nparticles=zeros(1,100);
	%}
	
	energy.kinetic.value=zeros(1,1);
	energy.strain.value=zeros(1,1);
	energy.strain.ddt=zeros(1,1); %ddt: dstrain/dt
	energy.work.value=zeros(1,1);
	energy.work.ddt=zeros(1,1);
	
	x_crack.center=zeros(200,2,200); %icrackparticle,dimension,icrackpath
	x_crack.top=zeros(200,2,200);
	x_crack.bot=zeros(200,2,200);
	x_crack.npaths=0;
	x_crack.spacing=zeros(1,1); %crack particle spacing
	x_crack.cohesivepath=zeros(1,200); %0=noncohesve, 1=cohesive
	x_crack.cohesivepoint=zeros(200,200); %icrackparticle,icrackpath
	x_crack.nparticles=zeros(1,200);
	x_crack.propcounter=zeros(200,2); %ipath, which tip; this is for counting how many times it's been propagating, for calculating analysis order
	x_crack.gauss.locs=zeros(200,2,200,2); %igausspoint, dimension, ipath, which tip
	x_crack.gauss.weights=zeros(200,200,2); %igausspoint, ipath, which tip
	x_crack.gauss.lastlinedeltax=zeros(1,2);%deltax of last line of the crack, for calculating the trajectory, from second last to last (last minus second last), one set only, reusable
	x_crack.gauss.npoints=zeros(1,1);
	x_crack.tempaccel.tagged=zeros(200,200); %icrackparticle,icrackpath
	x_crack.tempaccel.dmax=zeros(1,1);
	x_crack.deltatemp=zeros(200,200); %temperature increase of crack point %icrackparticle, icrackpath
	
	%TDL definition of boxcalc parameters
	x_crack.boxcalc.active=zeros(200,2); %ipath, which tip.
	x_crack.boxcalc.lastlinedeltax=zeros(1,2); %1, dimension; for the very list line that involves the designated tip; recyclable
	x_crack.boxcalc.locs=zeros(4,2,200,2); %which corner point, dimension, ipath, which tip
	%x_crack.boxcalc.TheFieldSplit=zeros(4,4,2,200); %io_natural, which corner point, which tip, ipath;
	x_crack.boxcalc.length=zeros(1,1); %defined the same for all
	x_crack.boxcalc.width=zeros(1,1); %defined the same for all
	x_crack.boxcalc.trajectory=zeros(200,2); %ipath, which tip. 
	x_crack.boxcalc.tiploc=zeros(1,2); %dimension, location of crack tip, reusable
	x_crack.boxcalc.u_global=zeros(4,2); %which corner point, dimension; displacements in global coordinate
	x_crack.boxcalc.u_local=zeros(4,2); %which corner point, dimension; displacements in local (box) coordinate
	x_crack.boxcalc.zeromass=zeros(200,2,4); %ipath, which tip, which corner. zero-mass marker for corners, to help merging
	
	x_crack.terminatedprop=zeros(200,2); %ipath, which tip, determines if propagation is terminated
	x_crack.openedgetip=zeros(200,2); %ipath, which tip, determines whether the terminated end is outside an open edge
	x_crack.tipcrackratio=zeros(200,2); %ratio between crack force and resistance (max principal s_tip_max over elasticstrength) 
	x_crack.acctipcrackratio=zeros(200,2); %which path, which tip %accummulated tip crack ratio from several timesteps between data dump %for calculating propagation ranking crack force
	x_crack.mEfactor=zeros(200,2);
	x_crack.Efactor=zeros(200,2);
	x_crack.mass=zeros(200,2);
	x_crack.force.top=zeros(200,2,200); %icrackparticle,dimension,icrackpath
	x_crack.force.bot=zeros(200,2,200); %icrackparticle,dimension,icrackpath
	x_crack.bridge.base.deltax=zeros(200,2,200); %icrackparticle, dimension, icrackpath (deltax vector)
	x_crack.bridge.base.absdeltax=zeros(200,200); %icrackparticle, icrackpath (deltax magnitude)
	x_crack.bridge.base.absdeltaxmax=zeros(200,200); %icrackparticle, icrackpath (historical maximum displacement)
	x_crack.bridge.adjusted.deltax=zeros(200,2,200); %icrackparticle, dimension, icrackpath (deltax vector corrected)
	x_crack.bridge.adjusted.absdeltax=zeros(200,200); %icrackparticle, icrackpath (deltax magnitude)
	x_crack.bridge.adjusted.absdeltaxmax=zeros(200,200); %icrackparticle, icrackpath (historical maximum displacement)
	x_crack.bridge.adjusted.absdeltaxmaxi=zeros(200,200); %icrackparticle, icrackpath (historical maximum inelastic displacement)
	x_crack.bridge.kbase1=zeros(1,1); %(base stiffness globally)
	x_crack.bridge.kbase2=zeros(200,200); %icrackparticle, icrackpath (base stiffness for specific crack particle)
	x_crack.bridge.yieldforce1=zeros(1,1); %global
	x_crack.bridge.yieldforce2=zeros(200,200); %icrackparticle, icrackpath (maximum force at yield (not traction, must be calibrated from traction), for specific crack particle
	x_crack.bridge.absforce=zeros(200,200); %icrackparticle, icrackpath (magnitude of cohesive force)
	x_crack.bridge.completeratio=zeros(200,200); %icrackparticle, icrackpath (ratio between absdeltax and maximum distance till snap)
	x_crack.bridge.normal.top=zeros(200,2,200); %icrackparticle, dimension, icrackpath (direction of normal surface for top surface)
	x_crack.bridge.normal.bot=zeros(200,2,200); %icrackparticle, dimension, icrackpath (direction of normal surface for bottom surface)
	x_crack.bridge.deltai1=zeros(1,1); % a single universal value
	x_crack.bridge.deltai2=zeros(200,200); %icrackparticle, icrackpath (unique for each 
	x_crack.bridge.deltae=zeros(1,1); % elastic delta, only used as intermediary for calculating stiffness
	x_crack.bridge.deltae2=zeros(200,200); %icrackparticle, icrackpath (unique for each 
	x_crack.bridge.isactive=zeros(200,200); %icrackparticle, icrackpath (indicates whether cohesive force is active);
	x_crack.bridge.firsttimeactive=zeros(200,200); %icrackparticle, icrackpath (indicates first time activation to calculate first time displacement base);
	x_crack.bridge.absfirsttimedeltax=zeros(200,200); %icrackparticle, icrackpath (magnitude of deltax for adjustment during first time activation);
	x_crack.bridge.firsttimedeltax=zeros(200,2,200); %icrackparticle, dimension, icrackpath (deltax for adjustment during first time activation);
	x_crack.bridge.tt_first.value=zeros(1,1); %first tt when cohesion starts
	x_crack.bridge.tt_first.savetoken=zeros(1,1); %determines whether to save or not
	x_crack.bridge.tt_last.value=zeros(1,1); %first tt when cohesion is no more
	x_crack.bridge.tt_last.savetoken=zeros(1,1);
	x_crack.bridge.allsevered=zeros(1,1); %1=all bridging zones are completely severed
	x_crack.bridge.pathcompletemonitor.values=zeros(200,1);
	x_crack.bridge.pathcompletemonitor.size=zeros(1,1);
	x_crack.bridge.pathcompletemonitor.check=zeros(1,1);
	x_crack.bridge.storedanddissed.value=zeros(1,1); %the amount of energy that is stored and dissipated by all the cohesion, essentially int(fdx) summed for all points.
	x_crack.bridge.storedanddissed.d=zeros(1,1); %the increment of that described above for every timestep
	x_crack.bridge.dissipated1=zeros(1,1);
	x_crack.bridge.dissipated2=zeros(1,1);
	x_crack.bridge.absforcebefore=zeros(200,200);
	x_crack.bridge.adjusted.absdeltaxbefore=zeros(200,200);
	x_crack.bridge.mostsevered=zeros(1,1); %1=most bridging zone (immediate viscinity of crack tip) severed
	x_crack.bridge.failuresurface=zeros(200,200); %icrackparticle, icrackpath
	x_crack.bridge.fractureenergy=zeros(200,200); %icrackparticle, icrackpath
	x_crack.bridge.strength=zeros(200,200); %icrackparticle, icrackpath
	x_crack.bridge.effectivespacing=zeros(200,200); %icrackparticle, icrackpath
	x_crack.bridge.nodalenergy=zeros(200,200); %icrackparticle, icrackpath
	%x_crack.bridge.surfacewithfmax=zeros(1,1); %temporarily stores which surface has the max x at plasticity
	x_crack.sequence.tipreg=zeros(200,2); %which path, which tip
	x_crack.sequence.merge=zeros(200,2); %which path, which tip
	x_crack.tiprename=zeros(1,2*200);
	
	x_crack.gauss.npoints=0;
	s_tip_dump=zeros(200,3);
	coder.varsize('s_tip_dump');
	s_tip_dump=zeros(2,3);
	s_tip_K1_dump=zeros(200,3);
	coder.varsize('s_tip_K1_dump');
	s_tip_K1_dump=zeros(2,3);
	r_propdirweighted_dump=zeros(200,2);
	coder.varsize('r_propdirweighted_dump');
	r_propdirweighted_dump=zeros(0,2);
	d_tip_dump=zeros(200,8);
	coder.varsize('d_tip_dump');
	d_tip_dump=zeros(0,8);
	d_LOC_tip_dump=zeros(200,8);
	coder.varsize('d_LOC_tip_dump');
	d_LOC_tip_dump=zeros(0,8);
	
	x_tip_dump=zeros(200,2);
	coder.varsize('x_tip_dump');
	x_tip_dump=zeros(2,2);

	s_gauss_dump=zeros(5000,3);
	coder.varsize('s_gauss_dump');
	s_gauss_dump=zeros(2,3);

	x_gauss_dump=zeros(5000,2);
	coder.varsize('x_gauss_dump');
	x_gauss_dump=zeros(2,2);

	%coder.varsize('x_crack.center',[200 2 200]);
	%coder.varsize('x_crack.top',[200 2 200]);
	%coder.varsize('x_crack.bot',[200 2 200]);
	%coder.varsize('x_crack.nparticles',[1 200]);
	
	%[] definitions
	
	E_sp=[];
	exploding_sp=[];
	layer=[];
	x_sp=[];
	matmodel=[];
	orientationoffset=[];
	plotignore=[];
	p_sp=[];
	weakeningfactor_sp=[];
	k_sp=[];
	kdot_sp=[];
	uncrackable_sp=[];
	donut_pushed_sp=[];
	LWStatus=[];
	EWStatus=[];
	deltarideal_sp=[];
	r1_sp=[];
	r2_sp=[];
	v_ssp_0=[];
	pforce_sp_base=[];
	
	Efactor_sp=zeros(1,4*niCount);
	coder.varsize('Efactor_sp');
	s_si=zeros(niCount,3,200);
	coder.varsize('s_si');
	s_si=zeros(niCount,3,2);
	u_si=zeros(niCount,2,200);
	coder.varsize('u_si');
	u_si=zeros(niCount,2,2);
	v_si=zeros(niCount,2,200);
	coder.varsize('v_si');
	v_si=zeros(niCount,2,2);
	
	s_si_comb=zeros(niCount,3);
	s_si_K1=zeros(niCount,3);
	u_si_comb=zeros(niCount,2);
	m_si_comb=zeros(1,niCount);
	
	
	
	rampedyforceparticle1=[];
	rampedyforceparticle2=[];
	pforcemax=0;
	
	ncforce_cracktop=[];
	ncforce_crackbot=[];
	ParticleswithPredYVel=[];
	ParticlePredYVel=[];
	
	tractionededge=[];
	tractionedcorner=[];
	x_defaultcracktip=[];
	lp=zeros(1,2);
	
	normaledge=[];
	normalcorner=cell(1,1);
	normalcorner{1}=0;
	
	F_rollerX=[];
	coder.varsize('F_rollerX');
	F_rollerY=[];
	coder.varsize('F_rollerY');
	scaledtime=zeros(1,1);
	MPMtimemultbase=zeros(1,1); %time multiplier of MPM simulation, to match that of FDS
	
	%TDL define tueway for gerhard's tension with cracks
	theway=3; 
	
	
	
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
		if CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
			woodcentral_x=3*le_base-5;
			woodcentral_y=2*le_base+40/12*10;
		elseif CasetoRun==52
			woodcentral_x=3*le_base+48.6600;
			woodcentral_y=2*le_base+80-34.5920;
		elseif CasetoRun==54
			woodcentral_x=3*le_base+47.09408825978351;
			woodcentral_y=2*le_base+41.43213988343047;
		end
		%% Particle generation
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		pforce_sp=[];
		r1_sp=[];
		r2_sp=[];
		r_adjustor=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];
		A_sp=[]; %to stop coder whining
		nPar1=0;
		nPar2=0;
		
		x_start=3*le_base;
		x_end=7*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if y_trial<2*le_base
					continue;
				elseif y_trial<10*le_base
					if x_trial<3*le_base
						continue;
					elseif x_trial>7*le_base
						continue;
					end
				elseif ((y_trial<11.5*le_base && (CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17)) ...
						|| (y_trial<12*le_base && (CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39))) %related to steel head height
					if ~(x_trial>3*le_base || (x_trial>2*le_base && (CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45)))
						continue;
					elseif ~(x_trial<7*le_base || (x_trial<8*le_base && (CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45)))
						continue;
					end
				else
					continue;
				end
				sp=sp+1;
				if x_trial>=x_start && x_trial<=x_end && y_trial>=y_start && y_trial<=y_end
					x_number=round((x_trial-x_start-lp(1)/2)/lp(1)+1);
					y_number=round((y_trial-y_start-lp(2)/2)/lp(2)+1);
					layer=MatrixInsertion(layer,x_number,y_number,sp);
					%layer(x_number,y_number)=sp;
				end
				%if sp>spCount
				%    disp('spCount wrong!');
				%    pause;
				%end
				xdirletter{sp}=[];
				ydirletter{sp}=[];
				zdirletter{sp}=[];
				xydirletter{sp}=[];
				yzdirletter{sp}=[];
				xzdirletter{sp}=[];
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				%x_sp(sp,1:2)=[x_trial y_trial];
				if y_trial<10*le_base
					matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
					%matmodel(sp)=1; % wood schmidt
					p_sp=MatrixInsertion(p_sp,sp,1,psp1);% Density
					%p_sp(sp,1)             = psp1;                % Density
					xdirletter=CellInsertion(xdirletter,sp,'r'); 
					ydirletter=CellInsertion(ydirletter,sp,'t'); 
					zdirletter=CellInsertion(zdirletter,sp,'l'); 
					xydirletter=CellInsertion(xydirletter,sp,'rt'); 
					yzdirletter=CellInsertion(yzdirletter,sp,'tl'); 
					xzdirletter=CellInsertion(xzdirletter,sp,'rl'); 
				elseif ((y_trial<11.5*le_base && (CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17)) ...
						|| (y_trial<12*le_base && (CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39))) %related to steel head height
					matmodel=VectorInsertion(matmodel,sp,2) %steel
					%matmodel(sp)=2; %steel
					p_sp=MatrixInsertion(p_sp,sp,1,psp2); %Density
					%p_sp(sp,1)             = psp2;                % Density
				end
				if matmodel(sp)==1 || matmodel(sp)==3
					plotignore=VectorInsertion(plotignore,sp,0);
				elseif matmodel(sp)==2
					plotignore=VectorInsertion(plotignore,sp,1);
				end
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				if CasetoRun==1
					orientationoffset=VectorInsertion(orientationoffset,sp,0); %counterclockwise in xy plane
				elseif CasetoRun==2
					orientationoffset=VectorInsertion(orientationoffset,sp,pi/2); %counterclockwise in xy plane
				elseif CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
					deltax=x_trial-woodcentral_x;
					deltay=y_trial-woodcentral_y;
					orientationoffset=VectorInsertion(orientationoffset,sp,reliableatan(deltax,deltay));
					%orientationoffset(sp)=reliableatan(deltax,deltay);
					%if x_trial<woodcentral_x && x_trial>woodcentral_x-le(1) && y_trial>40 && y_trial<40+le(2)
					%    1;
					%end
				end
				if y_trial<10*le_base & y_trial>(10*le_base-lp(1))
					sp_predvelnum=sp_predvelnum+1;
					displacementmonitoredparticles=VectorInsertion(displacementmonitoredparticles,sp_predvelnum,sp);
				end
				%if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
				%    troubleshotparticles=[troubleshotparticles sp];
				%end
			end
		end
		
	elseif CasetoRun==21
		woodcentral_x=3*le_base-5;
		woodcentral_y=2*le_base+40/12*10+le(2);        

		%% Particle generation
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];
		
		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
	  
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if y_trial<2*le_base-le(2)
					continue;
				elseif y_trial<2*le_base
					if x_trial<2*le_base
						continue;
					elseif x_trial>8*le_base
						continue;
					end
				elseif y_trial<2*le_base+le(2)
					continue;
				elseif y_trial<10*le_base+le(2)
					if x_trial<3*le_base
						continue;
					elseif x_trial>7*le_base
						continue;
					end
				elseif y_trial<10*le_base+2*le(2)
					continue;
				elseif y_trial<10*le_base+2*le(2)+le_base
					if x_trial<2*le_base
						continue;
					elseif x_trial>8*le_base
						continue;
					end
				else
					continue;
				end
				sp=sp+1;
				%if sp>spCount
				%    disp('spCount wrong!');
				%    pause;
				%end
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial>2*le_base+le(2)/2 && y_trial<10*le_base+le(2)+le(2)/2
					matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
					p_sp=MatrixInsertion(p_sp,sp,1,psp1); %Density
					xdirletter=CellInsertion(xdirletter,sp,'r');
					ydirletter=CellInsertion(ydirletter,sp,'t');
					zdirletter=CellInsertion(zdirletter,sp,'l');
					xydirletter=CellInsertion(xydirletter,sp,'rt');
					yzdirletter=CellInsertion(yzdirletter,sp,'tl');
					xzdirletter=CellInsertion(xzdirletter,sp,'rl');
				else
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					p_sp=MatrixInsertion(p_sp,sp,1, psp2); % Density
				end
				if matmodel(sp)==1 || matmodel(sp)==3
					plotignore=VectorInsertion(plotignore,sp,0);
				elseif matmodel(sp)==2
					plotignore=VectorInsertion(plotignore,sp,1);
				end
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				if CasetoRun==1
					orientationoffset=VectorInsertion(orientationoffset,sp,0); %counterclockwise in xy plane
				elseif CasetoRun==2
					orientationoffset=VectorInsertion(orientationoffset,sp,pi/2); %counterclockwise in xy plane
				elseif CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
					deltax=x_trial-woodcentral_x;
					deltay=y_trial-woodcentral_y;
					orientationoffset=VectorInsertion(orientationoffset,sp,reliableatan(deltax,deltay));
					%if x_trial<woodcentral_x && x_trial>woodcentral_x-le(1) && y_trial>40 && y_trial<40+le(2)
					%    1;
					%end
				end
				if y_trial<10*le_base+le(2) & y_trial>(10*le_base+le(2)-lp(1))
					sp_predvelnum=sp_predvelnum+1;
					displacementmonitoredparticles=VectorInsertion(displacementmonitoredparticles,sp_predvelnum,sp);
				end
				%if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
				%    troubleshotparticles=[troubleshotparticles sp];
				%end
			end
		end
		
		
		
	
	elseif CasetoRun==4
		%% Particle generation
		particle_per_cell       = 4;
		%spCount                 = 10*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		%x_sp                    = zeros(spCount,1);
		%d_sp                    = zeros(spCount,2);
		%E_acc                   = zeros(spCount,1);
		%epsilonshrinkdot_sp     = zeros(spCount,1);
		%pforce_sp               = zeros(spCount,2);

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			if y_trial<20
				continue;
			elseif y_trial>190
				continue;
			end
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<20
					continue;
				end
				if y_trial<70
					if x_trial>120
						continue;
					end
				elseif y_trial<190
					if x_trial>70
						continue;
					end
				end
				sp=sp+1;
				%if sp>spCount
				%    disp('spCount wrong!');
				%    pause;
				%end
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,1);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0); %counterclockwise in xy plane
				if y_trial<70
					xdirletter=CellInsertion(xdirletter,sp,'l');
					ydirletter=CellInsertion(ydirletter,sp,'r');
					zdirletter=CellInsertion(zdirletter,sp,'t');
					xydirletter=CellInsertion(xydirletter,sp,'lr');
					yzdirletter=CellInsertion(yzdirletter,sp,'rt');
					xzdirletter=CellInsertion(xzdirletter,sp,'lt');
				elseif y_trial<190
					xdirletter=CellInsertion(xdirletter,sp,'r');
					ydirletter=CellInsertion(ydirletter,sp,'l');
					zdirletter=CellInsertion(zdirletter,sp,'t');
					xydirletter=CellInsertion(xydirletter,sp,'rl');
					yzdirletter=CellInsertion(yzdirletter,sp,'lt');
					xzdirletter=CellInsertion(xzdirletter,sp,'rt');
				end
				plotignore=VectorInsertion(plotignore,sp,0);
				if x_trial>20 & x_trial<70 & y_trial<70 & y_trial>(70-lp(2))
					sp_predvelnum=sp_predvelnum+1;
					displacementmonitoredparticles=VectorInsertion(displacementmonitoredparticles,sp_predvelnum,sp);
				end
				p_sp=MatrixInsertion(p_sp,sp,1, psp1); % Density
			end
		end
	elseif CasetoRun==5 || CasetoRun==6
		%% Particle generation
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=21*le_base;
		y_start=4*le_base;
		y_end=8*le_base;
		
		if CasetoRun==5
			support_center_x=VectorInsertion(support_center_x,1,3.5*le_base);
			support_center_y=VectorInsertion(support_center_y,1,1.5*le_base);
			support_radius=VectorInsertion(support_radius,1,1.5*le_base);
	 
			support_center_x=VectorInsertion(support_center_x,2,19.5*le_base);
			support_center_y=VectorInsertion(support_center_y,2,1.5*le_base);
			support_radius=VectorInsertion(support_radius,2,1.5*le_base);
	 
			support_center_x=VectorInsertion(support_center_x,3,11.5*le_base);
			support_center_y=VectorInsertion(support_center_y,3,10.5*le_base);
			support_radius=VectorInsertion(support_radius,3,1.5*le_base);
		elseif CasetoRun==6
			support_center_x=VectorInsertion(support_center_x,1,3.5*le_base);
			support_center_y=VectorInsertion(support_center_y,1,2.5*le_base);
			support_radius=VectorInsertion(support_radius,1,1.5*le_base);
	 
			support_center_x=VectorInsertion(support_center_x,2,19.5*le_base);
			support_center_y=VectorInsertion(support_center_y,2,2.5*le_base);
			support_radius=VectorInsertion(support_radius,2,1.5*le_base);
	 
			support_center_x=VectorInsertion(support_center_x,3,11.5*le_base);
			support_center_y=VectorInsertion(support_center_y,3,9.5*le_base);
			support_radius=VectorInsertion(support_radius,3,1.5*le_base);
		end
		woodcentral_x=11.5*le_base;
		woodcentral_y=-4*le_base;
			
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if CasetoRun==5
					if y_trial<le_base
						continue;
					elseif y_trial<4*le_base
						if ((x_trial-support_center_x(1))^2+(y_trial-support_center_y(1))^2)<(support_radius(1))^2
							% dont continue
						elseif ((x_trial-support_center_x(2))^2+(y_trial-support_center_y(2))^2)<(support_radius(2))^2
							% dont continue
						else
							continue;
						end

					elseif y_trial<6*le_base
						if x_trial<2*le_base
							continue;
						elseif x_trial>21*le_base
							continue;
						elseif x_trial>11*le_base && x_trial<12*le_base
							continue;
						%else
							%dont continue
						end                
					elseif y_trial<8*le_base
						if x_trial<2*le_base
							continue;
						elseif x_trial>21*le_base
							continue;
						%else
							%dont continue
						end
					elseif y_trial<9*le_base+support_radius(3)
						if ((x_trial-support_center_x(3))^2+(y_trial-support_center_y(3))^2)<(support_radius(3))^2
							%dont continue
						else
							continue;
						end
					elseif y_trial<12.5*le_base
						if ((x_trial-support_center_x(3))^2)<(support_radius(3))^2
							%dont continue
						else
							continue;
						end
					else
						continue;
					end
				elseif CasetoRun==6
					if y_trial<2*le_base
						continue;
					elseif y_trial<4*le_base
						if ((x_trial-support_center_x(1))^2+(y_trial-support_center_y(1))^2)<(support_radius(1))^2
							% dont continue
						elseif ((x_trial-support_center_x(2))^2+(y_trial-support_center_y(2))^2)<(support_radius(2))^2
							% dont continue
						else
							continue;
						end

					elseif y_trial<6*le_base
						if x_trial<2*le_base
							continue;
						elseif x_trial>21*le_base
							continue;
						elseif x_trial>11*le_base && x_trial<12*le_base
							continue;
						%else
							%dont continue
						end                
					elseif y_trial<8*le_base
						if x_trial<2*le_base
							continue;
						elseif x_trial>21*le_base
							continue;
						%else
							%dont continue
						end
					elseif y_trial<8*le_base+support_radius(3)
						if ((x_trial-support_center_x(3))^2+(y_trial-support_center_y(3))^2)<(support_radius(3))^2
							%dont continue
						else
							continue;
						end
					elseif y_trial<12.5*le_base
						if ((x_trial-support_center_x(3))^2)<(support_radius(3))^2
							%dont continue
						else
							continue;
						end
					else
						continue;
					end
				end
				sp=sp+1;
				%if (x_trial>6*le_base && x_trial<6*le_base+lp(1)) && (y_trial>6*le_base && y_trial<6*le_base+lp(1))
				%    Rdisplayedparticles=[Rdisplayedparticles sp];
				%end
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial>8*le_base
					ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,1);
				else
					ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,0);
				end
				if y_trial<4*le_base || y_trial>8*le_base
					matmodel=VectorInsertion(matmodel,sp,2);
					p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				else
					matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
					p_sp=MatrixInsertion(p_sp,sp,1, psp1); % Density
					xdirletter=CellInsertion(xdirletter,sp,'l');
					ydirletter=CellInsertion(ydirletter,sp,'r');
					zdirletter=CellInsertion(zdirletter,sp,'t');
					xydirletter=CellInsertion(xydirletter,sp,'lr');
					yzdirletter=CellInsertion(yzdirletter,sp,'rt');
					xzdirletter=CellInsertion(xzdirletter,sp,'lt');
				end
				if matmodel(sp)==1 || matmodel(sp)==3
					plotignore=VectorInsertion(plotignore,sp,0);
				elseif matmodel(sp)==2
					plotignore=VectorInsertion(plotignore,sp,1);
				end
				orientationoffset=VectorInsertion(orientationoffset,sp,(x_trial-((21-2)/2+2)*le_base)/((21-2)*le_base)*2*(pi/3));
				deltax=x_trial-woodcentral_x;
				deltay=y_trial-woodcentral_y;
				orientationoffset=VectorInsertion(orientationoffset,sp,reliableatan(deltax,deltay)-pi/2);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				if x_trial>11*le_base && x_trial<12*le_base && y_trial>6*le_base && y_trial<7*le_base
					sp_predvelnum=sp_predvelnum+1;
					displacementmonitoredparticles=VectorInsertion(displacementmonitoredparticles,sp_predvelnum,sp);
				end
				if CasetoRun==5
					if y_trial<1*le_base+lp(2) && y_trial>1*le_base && ((x_trial>2*le_base && x_trial<5*le_base) || (x_trial>18*le_base && x_trial<21*le_base))
						yparticledamped=VectorInsertion(yparticledamped,length(yparticledamped)+1,sp);
					end
				elseif CasetoRun==6
					if y_trial<2*le_base+lp(2) && y_trial>2*le_base && ((x_trial>2*le_base && x_trial<5*le_base) || (x_trial>18*le_base && x_trial<21*le_base))
						yparticledamped=VectorInsertion(yparticledamped,length(yparticledamped)+1,sp);
					end
				end
			end
		end
	elseif CasetoRun==7
		%% Particle generation
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=3*le_base;
		x_end=7*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if y_trial<2*le_base
					continue;
				elseif y_trial<10*le_base
					if x_trial<3*le_base
						continue;
					elseif x_trial >7*le_base
						continue;
					end
				elseif y_trial<14*le_base
					if x_trial<2*le_base
						continue;
					elseif x_trial>8*le_base
						continue;
					end
				else
					continue;
				end
				sp=sp+1;
				ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,0);
				if x_trial>=x_start && x_trial<=x_end && y_trial>=y_start && y_trial<=y_end
					x_number=round((x_trial-x_start-lp(1)/2)/lp(1)+1);
					y_number=round((y_trial-y_start-lp(2)/2)/lp(2)+1);
					layer=MatrixInsertion(layer,x_number,y_number,sp);
				end
				%if sp>spCount
				%    disp('spCount wrong!');
				%    pause;
				%end
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<10*le_base
					matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
					p_sp=MatrixInsertion(p_sp,sp,1, psp1); % Density
					xdirletter=CellInsertion(xdirletter,sp,'r');
					ydirletter=CellInsertion(ydirletter,sp,'t');
					zdirletter=CellInsertion(zdirletter,sp,'l');
					xydirletter=CellInsertion(xydirletter,sp,'rt');
					yzdirletter=CellInsertion(yzdirletter,sp,'tl');
					xzdirletter=CellInsertion(xzdirletter,sp,'rl');
				elseif y_trial<14*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,1);
					p_sp=MatrixInsertion(p_sp,sp,1, psp2); % Density
				end
				if matmodel(sp)==1 || matmodel(sp)==3
					plotignore=VectorInsertion(plotignore,sp,0);
				elseif matmodel(sp)==2
					plotignore=VectorInsertion(plotignore,sp,1);
				end
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0); %counterclockwise in xy plane
				if y_trial<14*le_base & y_trial>(14*le_base-lp(1))
					sp_predvelnum=sp_predvelnum+1;
					displacementmonitoredparticles=VectorInsertion(displacementmonitoredparticles,sp_predvelnum,sp);
				end
				if y_trial<2*le_base+lp(2) && y_trial>2*le_base && x_trial>3*le_base && x_trial<7*le_base
					yparticledamped=VectorInsertion(yparticledamped,length(yparticledamped)+1,sp);
				end
				%if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
				%    troubleshotparticles=[troubleshotparticles sp];
				%end
			end
		end
	elseif CasetoRun==8 || CasetoRun==9
		%% Particle generation
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		%lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		%lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=21*le_base;
		y_start=4*le_base;
		y_end=8*le_base;
		
		if CasetoRun==8
			support_center_x=VectorInsertion(support_center_x,1,3.5*le_base);
			support_center_y=VectorInsertion(support_center_y,1,1.5*le_base);
			support_radius=VectorInsertion(support_radius,1,1.5*le_base);

			support_center_x=VectorInsertion(support_center_x,2,19.5*le_base);
			support_center_y=VectorInsertion(support_center_y,2,1.5*le_base);
			support_radius=VectorInsertion(support_radius,2,1.5*le_base);

			support_center_x=VectorInsertion(support_center_x,3,11.5*le_base);
			support_center_y=VectorInsertion(support_center_y,3,10.5*le_base);
			support_radius=VectorInsertion(support_radius,3,1.5*le_base);
		elseif CasetoRun==9
			support_center_x=VectorInsertion(support_center_x,1,3.5*le_base);
			support_center_y=VectorInsertion(support_center_y,1,2.5*le_base);
			support_radius=VectorInsertion(support_radius,1,1.5*le_base);

			support_center_x=VectorInsertion(support_center_x,2,19.5*le_base);
			support_center_y=VectorInsertion(support_center_y,2,2.5*le_base);
			support_radius=VectorInsertion(support_radius,2,1.5*le_base);

			support_center_x=VectorInsertion(support_center_x,3,11.5*le_base);
			support_center_y=VectorInsertion(support_center_y,3,9.5*le_base);
			support_radius=VectorInsertion(support_radius,3,1.5*le_base);
		end
		
		for i=1:length(le_x)
			lp_trial_x=le_x(i)/sqrt(particle_per_cell);
			for j=1:length(le_y)
				lp_trial_y=le_y(j)/sqrt(particle_per_cell);
				for k=1:sqrt(particle_per_cell)
					x_trial=sum(le_x(1:i-1))+0.5*lp_trial_x+(k-1)*lp_trial_x;
					for l=1:sqrt(particle_per_cell)
						y_trial=sum(le_y(1:j-1))+0.5*lp_trial_y+(l-1)*lp_trial_y;
						if CasetoRun==8
							if y_trial<le_base
								continue;
							elseif y_trial<4*le_base
								if ((x_trial-support_center_x(1))^2+(y_trial-support_center_y(1))^2)<(support_radius(1))^2
									% dont continue
								elseif ((x_trial-support_center_x(2))^2+(y_trial-support_center_y(2))^2)<(support_radius(2))^2
									% dont continue
								else
									continue;
								end

							elseif y_trial<6*le_base
								if x_trial<2*le_base
									continue;
								elseif x_trial>21*le_base
									continue;
								elseif (x_trial-11.5*le_base)^2 < notchwidth^2
									continue;
								%else
									%dont continue
								end                
							elseif y_trial<8*le_base
								if x_trial<2*le_base
									continue;
								elseif x_trial>21*le_base
									continue;
								%else
									%dont continue
								end
							elseif y_trial<9*le_base+support_radius(3)
								if ((x_trial-support_center_x(3))^2+(y_trial-support_center_y(3))^2)<(support_radius(3))^2
									%dont continue
								else
									continue;
								end
							elseif y_trial<12*le_base
								if ((x_trial-support_center_x(3))^2)<(support_radius(3))^2
									%dont continue
								else
									continue;
								end
							else
								continue;
							end
						elseif CasetoRun==9
							if y_trial<2*le_base
								continue;
							elseif y_trial<4*le_base
								if ((x_trial-support_center_x(1))^2+(y_trial-support_center_y(1))^2)<(support_radius(1))^2
									% dont continue
								elseif ((x_trial-support_center_x(2))^2+(y_trial-support_center_y(2))^2)<(support_radius(2))^2
									% dont continue
								else
									continue;
								end

							elseif y_trial<6*le_base
								if x_trial<2*le_base
									continue;
								elseif x_trial>21*le_base
									continue;
								elseif (x_trial-11.5*le_base)^2 < notchwidth^2
									continue;
								%else
									%dont continue
								end                
							elseif y_trial<8*le_base
								if x_trial<2*le_base
									continue;
								elseif x_trial>21*le_base
									continue;
								%else
									%dont continue
								end
							elseif y_trial<8*le_base+support_radius(3)
								if ((x_trial-support_center_x(3))^2+(y_trial-support_center_y(3))^2)<(support_radius(3))^2
									%dont continue
								else
									continue;
								end
							elseif y_trial<12*le_base
								if ((x_trial-support_center_x(3))^2)<(support_radius(3))^2
									%dont continue
								else
									continue;
								end
							else
								continue;
							end
						end
						sp=sp+1;
						xdirletter=CellInsertion(xdirletter,sp,[]);
						ydirletter=CellInsertion(ydirletter,sp,[]);
						zdirletter=CellInsertion(zdirletter,sp,[]);
						xydirletter=CellInsertion(xydirletter,sp,[]);
						yzdirletter=CellInsertion(yzdirletter,sp,[]);
						xzdirletter=CellInsertion(xzdirletter,sp,[]);
						x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
						x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
						lp=MatrixInsertion(lp,sp,1,lp_trial_x);
						lp=MatrixInsertion(lp,sp,2,lp_trial_y);
						if y_trial<4*le_base || y_trial>8*le_base
							matmodel=VectorInsertion(matmodel,sp,2);
							p_sp=MatrixInsertion(p_sp,sp,1,psp2);
						else
							matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
							p_sp=MatrixInsertion(p_sp,sp,1, psp1); % Density
							xdirletter=CellInsertion(xdirletter,sp,'l');
							ydirletter=CellInsertion(ydirletter,sp,'r');
							zdirletter=CellInsertion(zdirletter,sp,'t');
							xydirletter=CellInsertion(xydirletter,sp,'lr');
							yzdirletter=CellInsertion(yzdirletter,sp,'rt');
							xzdirletter=CellInsertion(xzdirletter,sp,'lt');
						end
						if matmodel(sp)==1 || matmodel(sp)==3
							plotignore=VectorInsertion(plotignore,sp,0);
						elseif matmodel(sp)==2
							plotignore=VectorInsertion(plotignore,sp,1);
						end
						orientationoffset=VectorInsertion(orientationoffset,sp,0);
						weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
						k_sp=VectorInsertion(k_sp,sp,1);
						kdot_sp=VectorInsertion(kdot_sp,sp,0);
						if x_trial>11*le_base && x_trial<12*le_base && y_trial>6*le_base && y_trial<7*le_base
							sp_predvelnum=sp_predvelnum+1;
							displacementmonitoredparticles=VectorInsertion(displacementmonitoredparticles,sp_predvelnum,sp);
						end
					end
				end
			end
		end
	elseif CasetoRun==10
		%% Particle generation
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=3*le_base;
		x_end=7*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if y_trial<2*le_base
					continue;
				elseif y_trial<10*le_base
					if x_trial<3*le_base
						continue;
					elseif x_trial >7*le_base
						continue;
					end
				elseif y_trial<11*le_base
					if x_trial<3*le_base
						continue;
					elseif x_trial>7*le_base
						continue;
					end
				else
					continue;
				end
				sp=sp+1;
				if x_trial>=x_start && x_trial<=x_end && y_trial>=y_start && y_trial<=y_end
					x_number=round((x_trial-x_start-lp(1)/2)/lp(1)+1);
					y_number=round((y_trial-y_start-lp(2)/2)/lp(2)+1);
					layer=MatrixInsertion(layer,x_number,y_number,sp);
				end
				if y_trial>10*le_base
					ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,1);
				else
					ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,0);
				end
				%if sp>spCount
				%    disp('spCount wrong!');
				%    pause;
				%end
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<10*le_base
					matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
					p_sp=MatrixInsertion(p_sp,sp,1, psp1); % Density
					xdirletter=CellInsertion(xdirletter,sp,'t');
					ydirletter=CellInsertion(ydirletter,sp,'r');
					zdirletter=CellInsertion(zdirletter,sp,'l');
					xydirletter=CellInsertion(xydirletter,sp,'tr');
					yzdirletter=CellInsertion(yzdirletter,sp,'rl');
					xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				elseif y_trial<14*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					p_sp=MatrixInsertion(p_sp,sp,1, psp2); % Density
				end
				if y_trial<2*le_base+lp(2) && y_trial>2*le_base && ((x_trial>3*le_base && x_trial<7*le_base))
					yparticledamped=VectorInsertion(yparticledamped,length(yparticledamped)+1,sp);
				end

				if matmodel(sp)==1 || matmodel(sp)==3
					plotignore=VectorInsertion(plotignore,sp,0);
				elseif matmodel(sp)==2
					plotignore=VectorInsertion(plotignore,sp,1);
				end
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0); %counterclockwise in xy plane
				if y_trial<10*le_base & y_trial>(10*le_base-lp(1))
					sp_predvelnum=sp_predvelnum+1;
					displacementmonitoredparticles=VectorInsertion(displacementmonitoredparticles,sp_predvelnum,sp);
				end
				%if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
				%    troubleshotparticles=[troubleshotparticles sp];
				%end
			end
		end
	elseif CasetoRun==11
		knot_x=4.5*le_base;
		knot_y=10*le_base;
		knot_r=0.5*le_base;
		knot_xaffect=2*le_base;
		knot_yaffect=3*le_base;
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=7*le_base;
		y_start=2*le_base;
		y_end=19*le_base;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if y_trial<2*le_base
					continue;
				elseif y_trial<18*le_base
					if x_trial<2*le_base
						continue;
					elseif x_trial >7*le_base
						continue;
					end
				elseif y_trial<19*le_base %related to steel head height
					if x_trial<2*le_base
						continue;
					elseif x_trial>7*le_base
						continue;
					end
				else
					continue;
				end
				knot_deltaxtocenter=x_trial-knot_x;
				knot_deltaytocenter=y_trial-knot_y;
				if (knot_deltaxtocenter^2+knot_deltaytocenter^2)<knot_r^2
					continue;
				end
				sp=sp+1;
				if x_trial>=x_start && x_trial<=x_end && y_trial>=y_start && y_trial<=y_end
					x_number=round((x_trial-x_start-lp(1)/2)/lp(1)+1);
					y_number=round((y_trial-y_start-lp(2)/2)/lp(2)+1);
					layer=MatrixInsertion(layer,x_number,y_number,sp);
				end
				if y_trial>18*le_base
					ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,1);
				else
					ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,0);
				end
				%if sp>spCount
				%    disp('spCount wrong!');
				%    pause;
				%end
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<18*le_base
					matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
					p_sp=MatrixInsertion(p_sp,sp,1, psp1); % Density
					xdirletter=CellInsertion(xdirletter,sp,'t');
					ydirletter=CellInsertion(ydirletter,sp,'l');
					zdirletter=CellInsertion(zdirletter,sp,'r');
					xydirletter=CellInsertion(xydirletter,sp,'tl');
					yzdirletter=CellInsertion(yzdirletter,sp,'lr');
					xzdirletter=CellInsertion(xzdirletter,sp,'tr');
				elseif y_trial<19*le_base %related to steel head height
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					p_sp=MatrixInsertion(p_sp,sp,1, psp2); % Density
				end
				if matmodel(sp)==1 || matmodel(sp)==3
					plotignore=VectorInsertion(plotignore,sp,0);
				elseif matmodel(sp)==2
					plotignore=VectorInsertion(plotignore,sp,1);
				end
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				xside=0;
				yside=0;
				if x_trial>knot_x-knot_xaffect && x_trial<knot_x+knot_xaffect
					if x_trial<knot_x
						xside=1;
					else
						xside=2;
					end
				end
				if y_trial>knot_y-knot_yaffect && y_trial<knot_y+knot_yaffect
					if y_trial<knot_y
						yside=1;
					else
						yside=2;
					end
				end
				
				if xside==1
					knot_x_trial_relative=x_trial-(knot_x-knot_xaffect);
				elseif xside==2
					knot_x_trial_relative=(knot_x+knot_xaffect)-x_trial;
				end
				if yside==1
					knot_y_trial_relative=y_trial-(knot_y-knot_yaffect);
				elseif yside==2
					knot_y_trial_relative=(knot_y+knot_yaffect)-y_trial;
				end
				L0=knot_xaffect;
				L1=knot_xaffect-knot_x;
				A=2*L1/L0-1;
				h=knot_yaffect;
				if xside==1 && yside==1 || xside==2 && yside==2
					orientationoffset=VectorInsertion(orientationoffset,sp,-atan(-0.5*knot_x_trial_relative^2*(1-A)/L0*(0.5*pi/h)*sin(pi*knot_y_trial_relative/h)));
				elseif xside==1 && yside==2 || xside==2 && yside==1
					orientationoffset=VectorInsertion(orientationoffset,sp,atan(-0.5*knot_x_trial_relative^2*(1-A)/L0*(0.5*pi/h)*sin(pi*knot_y_trial_relative/h)));
				end                    
				if y_trial<10*le_base & y_trial>(10*le_base-lp(1))
					sp_predvelnum=sp_predvelnum+1;
					displacementmonitoredparticles=VectorInsertion(displacementmonitoredparticles,sp_predvelnum,sp);
				end
				%if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
				%    troubleshotparticles=[troubleshotparticles sp];
				%end
				%if y_trial<2*le_base+lp(2) && y_trial>2*le_base && (x_trial>2*le_base && x_trial<7*le_base)
				%    yparticledamped=[yparticledamped sp];
				%end
			end
		end
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		if CasetoRun==12
			knot_x=5*le_base;
		elseif CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
			knot_x=2*le_base+(1/4*90);
		end
		knot_y=7*le_base;
		knot_r=0.5*le_base;
		knot_xaffect=2*le_base;
		knot_yaffect=3*le_base;
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=8*le_base;
		y_start=2*le_base;
		y_end=19.5*le_base;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if y_trial<2*le_base
					continue;
				elseif y_trial<18*le_base
					if x_trial<2*le_base
						continue;
					elseif x_trial >8*le_base
						continue;
					end
				elseif y_trial<19.5*le_base %related to steel head height
					if x_trial<2*le_base
						continue;
					elseif x_trial>8*le_base
						continue;
					end
				else
					continue;
				end
				knot_deltaxtocenter=x_trial-knot_x;
				knot_deltaytocenter=y_trial-knot_y;
				if (knot_deltaxtocenter^2+knot_deltaytocenter^2)<knot_r^2
					thisisknot=1;
				else
					thisisknot=0;
				end
				sp=sp+1;
				if x_trial>=x_start && x_trial<=x_end && y_trial>=y_start && y_trial<=y_end
					x_number=round((x_trial-x_start-lp(1)/2)/lp(1)+1);
					y_number=round((y_trial-y_start-lp(2)/2)/lp(2)+1);
					layer=MatrixInsertion(layer,x_number,y_number,sp);
				end
				if y_trial>18*le_base
					ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,1);
				else
					ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,0);
				end
				%if sp>spCount
				%    disp('spCount wrong!');
				%    pause;
				%end
				xdirletter{sp}=[];
				ydirletter{sp}=[];
				zdirletter{sp}=[];
				xydirletter{sp}=[];
				yzdirletter{sp}=[];
				xzdirletter{sp}=[];
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<18*le_base
					matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
					p_sp=MatrixInsertion(p_sp,sp,1, psp1); % Density
					xdirletter{sp}='t';
					ydirletter{sp}='l';
					zdirletter{sp}='r';
					xydirletter{sp}='tl';
					yzdirletter{sp}='lr';
					xzdirletter{sp}='tr';
				elseif y_trial<19.5*le_base %related to steel head height
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					p_sp=MatrixInsertion(p_sp,sp,1, psp2); % Density
				end
				if matmodel(sp)==1 || matmodel(sp)==3
					plotignore=VectorInsertion(plotignore,sp,0);
				elseif matmodel(sp)==2
					plotignore=VectorInsertion(plotignore,sp,1);
				end
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				if thisisknot
					if CasetoRun==12
						weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0.7);
						if x_trial>75 && x_trial<75+lp(1) && y_trial>112.5-lp(2) && y_trial<112.5
							weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0.95);
						elseif x_trial>67.5 && x_trial<67.5+lp(1) && y_trial>105-lp(2) && y_trial<105
							weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0.95);
						end
					elseif CasetoRun==16
						weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0.7);
						if x_trial>52.5 && x_trial<52.5+lp(1) && y_trial>112.5-lp(2) && y_trial<112.5
							weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0.95);
						elseif x_trial>45 && x_trial<45+lp(1) && y_trial>105-lp(2) && y_trial<105
							weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0.95);
						end
					elseif CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
						weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0.7);
					end
					xdirletter=CellInsertion(xdirletter,sp,'r');
					ydirletter=CellInsertion(ydirletter,sp,'t');
					zdirletter=CellInsertion(zdirletter,sp,'l');
					xydirletter=CellInsertion(xydirletter,sp,'rt');
					yzdirletter=CellInsertion(yzdirletter,sp,'tl');
					xzdirletter=CellInsertion(xzdirletter,sp,'rl');
					orientationoffset=VectorInsertion(orientationoffset,sp,reliableatan(knot_deltaxtocenter,knot_deltaytocenter));
				else
					xside=0;
					yside=0;
					if x_trial>knot_x-knot_xaffect && x_trial<knot_x+knot_xaffect
						if x_trial<knot_x
							xside=1;
						else
							xside=2;
						end
					end
					if y_trial>knot_y-knot_yaffect && y_trial<knot_y+knot_yaffect
						if y_trial<knot_y
							yside=1;
						else
							yside=2;
						end
					end

					if xside==1
						knot_x_trial_relative=x_trial-(knot_x-knot_xaffect);
					elseif xside==2
						knot_x_trial_relative=(knot_x+knot_xaffect)-x_trial;
					end
					if yside==1
						knot_y_trial_relative=y_trial-(knot_y-knot_yaffect);
					elseif yside==2
						knot_y_trial_relative=(knot_y+knot_yaffect)-y_trial;
					end
					L0=knot_xaffect;
					L1=knot_xaffect-knot_r;
					A=2*L1/L0-1;
					h=knot_yaffect;
					%if xside==1 && yside==1 || xside==2 && yside==2
					%    orientationoffset(sp)=-atan(-0.5*knot_x_trial_relative^2*(1-A)/L0*(0.5*pi/h)*sin(pi*knot_y_trial_relative/h));
					%elseif xside==1 && yside==2 || xside==2 && yside==1
					%    orientationoffset(sp)=atan(-0.5*knot_x_trial_relative^2*(1-A)/L0*(0.5*pi/h)*sin(pi*knot_y_trial_relative/h));
					%end                    
					if y_trial<18*le_base & y_trial>(18*le_base-lp(1))
						sp_predvelnum=sp_predvelnum+1;
						displacementmonitoredparticles=VectorInsertion(displacementmonitoredparticles,sp_predvelnum,sp);
					end
					if xside>0 && yside>0
						knot_deltax=x_trial-knot_x;
						knot_deltay=y_trial-knot_y;
						if knot_deltax>0 && knot_deltay>0
							1;
						end
						%dxdy=1/(-1/(-sign(x_trial-knot_x)*((pi*sin((knot_deltay*pi)/h)*((knot_deltax-L0) - knot_r + ((knot_deltax-L0)^2*((L0 - 2*knot_r)/L0 - 1))/(2*L0) - ((knot_deltax-L0)*(L0 - 2*knot_r))/L0))/(2*h))));
						dxdy=(sign(knot_deltax)*((pi*sin((knot_deltay*pi)/h)*((abs(knot_deltax)-L0) - knot_r + ((abs(knot_deltax)-L0)^2*((L0 - 2*knot_r)/L0 - 1))/(2*L0) - ((abs(knot_deltax)-L0)*(L0 - 2*knot_r))/L0))/(2*h)));
						dydx=1/dxdy;
						tantheta=-1/dydx;
						%knot_deltax=knot_deltax-L0;
						%orientationoffset(sp)=-atan((pi*sin((knot_deltay*pi)/h)*(knot_deltax - knot_r + (knot_deltax^2*((L0 - 2*knot_r)/L0 - 1))/(2*L0) - (knot_deltax*(L0 - 2*knot_r))/L0))/(2*h));
						%orientationoffset(sp)=atan(-sign(x_trial-knot_x)*((pi*sin((knot_deltay*pi)/h)*((knot_deltax-L0) - knot_r + ((knot_deltax-L0)^2*((L0 - 2*knot_r)/L0 - 1))/(2*L0) - ((knot_deltax-L0)*(L0 - 2*knot_r))/L0))/(2*h)));
						orientationoffset=VectorInsertion(orientationoffset,sp,atan(tantheta));                    
					end
					%if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
					%    troubleshotparticles=[troubleshotparticles sp];
					%end
					if y_trial<2*le_base+lp(2) && y_trial>2*le_base && (x_trial>2*le_base && x_trial<8*le_base)
						yparticledamped=VectorInsertion(yparticledamped,length(yparticledamped)+1,sp);
					end
				end
			end
		end
			
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		knot_x=[];
		knot_y=[];
		knot_rx=[];
		knot_ry=[];
		knot_theta=[];
		knot_xaffect=[];
		knot_yaffect=[];
		knot_x=[];
		knot_y=[];
		knot_r=[];
		knot_rx=[];
		knot_ry=[];
		knot_theta=[];
		knot_xaffect=[];
		knot_yaffect=[];
		
		if CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
			knot_x=VectorInsertion(knot_x,1,72+2*le_base);
			knot_y=VectorInsertion(knot_y,1,10*le_base-20);
			knot_rx=VectorInsertion(knot_rx,1,7.625);
			knot_ry=VectorInsertion(knot_ry,1,7.625);
			knot_theta=VectorInsertion(knot_theta,1,0);
			knot_xaffect=VectorInsertion(knot_xaffect,1,2.5*knot_rx(1));
			knot_yaffect=VectorInsertion(knot_yaffect,1,5*knot_rx(1));
			knot_x=VectorInsertion(knot_x,2,28.8+2*le_base);
			knot_y=VectorInsertion(knot_y,2,10*le_base+20);
			knot_rx=VectorInsertion(knot_rx,2,14);
			knot_ry=VectorInsertion(knot_ry,2,8.5);
			knot_theta=VectorInsertion(knot_theta,2,atan(-1/5.5));
			knot_xaffect=VectorInsertion(knot_xaffect,2,[]);
			knot_yaffect=VectorInsertion(knot_yaffect,2,[]);
		else
			knot_x=VectorInsertion(knot_x,1,72+2*le_base);
			knot_y=VectorInsertion(knot_y,1,10*le_base-20);
			knot_r=VectorInsertion(knot_r,1,7.625);
			knot_xaffect=VectorInsertion(knot_xaffect,1,2.5*knot_r(1));
			knot_yaffect=VectorInsertion(knot_yaffect,1,5*knot_r(1));
			knot_x=VectorInsertion(knot_x,2,28.8+2*le_base);
			knot_y=VectorInsertion(knot_y,2,10*le_base+20);
			knot_r=VectorInsertion(knot_r,2,10.875);
			knot_xaffect=VectorInsertion(knot_xaffect,2,2.5*knot_r(2));
			knot_yaffect=VectorInsertion(knot_yaffect,2,5*knot_r(2));
		end
		if CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
			Xobservedrelative=[0 5 10 15 20 25 30 35 40 45 50 55];
			Yobservedrelative=[140 110 105 100 95 90 85 80 75 70 50];
			Xbigknotobserved=28.5;
			Ybigknotobserved=93;
			Xshift=knot_x(2)-Xbigknotobserved;
			Yshift=knot_y(2)-Ybigknotobserved;
			Xlist=Xobservedrelative+Xshift;
			Ylist=Yobservedrelative+Yshift;
			oneovertanthetalist=[1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99;
				1e99    -8  -6  -3  -2.5    -2  -1.5    -2  -2.8    -3.1    -6  1e99;
				1e99    -10 -4.5    -2.5    -1  -1/12   -1/1.5  -1.25   -1.25   -2  -6  1e99;
				1e99    -19 -9.5    -1.5    -1/5.5  1/4 1/2.5   1/2 1/1.3   -3  -13 1e99;
				1e99    1e99    -8  -3  -4  5   1/4 3.5 1/1.5   3.5 1e99    1e99;
				1e99	7   1/2 1   1/2 1/4 -1/2.5  -1  -8  1e99    12	1e99;
				1e99	7	5.2	2	1/2	1/6	1/17.5	-1/10	-1/2	-1	-4.5    1e99;
				1e99	9	7	4.5	1.8	1/2	1/1.8	1/3	1.5	-7	-15 1e99;
				1e99    8   8   4.2 1.5 1/1.5   1/1.3   1.1 2   3   10  1e99;
				1e99    8   4   2.5 1.7 1.2 1.4 1.4 2.5 4   15  1e99;
				1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99];

			for i=1:size(oneovertanthetalist,1)
				for j=1:size(oneovertanthetalist,2)
					tanthetalist=MatrixInsertion(tanthetalist,i,j,1/oneovertanthetalist(i,j));
					thetalist=MatrixInsertion(thetalist,i,j,atan(tanthetalist(i,j)));
				end
			end
		end
		%{
		knot_x(1)=3.5*le_base;
		knot_y(1)=(10.5+0.25)*le_base;
		knot_r(1)=0*le_base;
		knot_xaffect(1)=0*le_base;
		knot_yaffect(1)=0*le_base;
		%}
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		if CasetoRun==15
			x_start=2*le_base;
			x_end=7*le_base;
			y_start=5*le_base;
			y_end=16*le_base;
		else
			x_start=2*le_base;
			x_end=7*le_base;
			y_start=2*le_base;
			y_end=19*le_base;
		end
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if CasetoRun==15
					if y_trial<5*le_base
						continue;
					elseif y_trial<15*le_base
						if x_trial<2*le_base
							continue;
						elseif x_trial >7*le_base
							continue;
						end
					elseif y_trial<16*le_base %related to steel head height
						if x_trial<2*le_base
							continue;
						elseif x_trial>7*le_base
							continue;
						end
					else
						continue;
					end
				else
					if y_trial<2*le_base
						continue;
					elseif y_trial<18*le_base
						if x_trial<2*le_base
							continue;
						elseif x_trial >7*le_base
							continue;
						end
					elseif y_trial<19*le_base %related to steel head height
						if x_trial<2*le_base
							continue;
						elseif x_trial>7*le_base
							continue;
						end
					else
						continue;
					end
				end
				continuesignal=0;
				for knotnum=1:length(knot_x)
					if CasetoRun==25 || CasetoRun==32 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
						if ((x_trial-knot_x(knotnum))*cos(knot_theta(knotnum))+(y_trial-knot_y(knotnum))*sin(knot_theta(knotnum)))^2/knot_rx(knotnum)^2+((x_trial-knot_x(knotnum))*sin(knot_theta(knotnum))-(y_trial-knot_y(knotnum))*cos(knot_theta(knotnum)))^2/knot_ry(knotnum)^2<1
							continuesignal=1;
						end
					elseif CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61
					else 
						knot_deltax=x_trial-knot_x(knotnum);
						knot_deltay=y_trial-knot_y(knotnum);
						if (knot_deltax^2+knot_deltay^2)<knot_r(knotnum)^2
							continuesignal=1;
						end
					end
				end
				if continuesignal==1
					continue;
				end
				sp=sp+1;
				if x_trial>=x_start && x_trial<=x_end && y_trial>=y_start && y_trial<=y_end
					x_number=round((x_trial-x_start-lp(1)/2)/lp(1)+1);
					y_number=round((y_trial-y_start-lp(2)/2)/lp(2)+1);
					layer=MatrixInsertion(layer,x_number,y_number,sp);
				end
				if CasetoRun==15
					if y_trial>15*le_base
						ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,1);
					else
						ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,0);
					end
				else
					if y_trial>18*le_base
						ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,1);
					else
						ignoremomentum=MatrixInsertion(ignoremomentum,sp,1,0);
					end
				end
				%if sp>spCount
				%    disp('spCount wrong!');
				%    pause;
				%end
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if CasetoRun==15
					if y_trial<15*le_base
						matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
						p_sp=MatrixInsertion(p_sp,sp,1, psp1); % Density
						xdirletter=CellInsertion(xdirletter,sp,'t');
						ydirletter=CellInsertion(ydirletter,sp,'l');
						zdirletter=CellInsertion(zdirletter,sp,'r');
						xydirletter=CellInsertion(xydirletter,sp,'tl');
						yzdirletter=CellInsertion(yzdirletter,sp,'lr');
						xzdirletter=CellInsertion(xzdirletter,sp,'tr');
					elseif y_trial<16*le_base %related to steel head height
						matmodel=VectorInsertion(matmodel,sp,2); %steel
						p_sp=MatrixInsertion(p_sp,sp,1, psp2); % Density
					end
				elseif CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
					if y_trial<18*le_base
						if CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63
							itsasquishyball=0;
							for knotnum=1:length(knot_x)
								if ((x_trial-knot_x(knotnum))*cos(knot_theta(knotnum))+(y_trial-knot_y(knotnum))*sin(knot_theta(knotnum)))^2/knot_rx(knotnum)^2+((x_trial-knot_x(knotnum))*sin(knot_theta(knotnum))-(y_trial-knot_y(knotnum))*cos(knot_theta(knotnum)))^2/knot_ry(knotnum)^2<1
									itsasquishyball=1;
								end
							end
							if itsasquishyball
								matmodel=VectorInsertion(matmodel,sp,3);
								p_sp=MatrixInsertion(p_sp,sp,1,psp1);
							else
								matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
								p_sp=MatrixInsertion(p_sp,sp,1, psp1); % Density
								xdirletter=CellInsertion(xdirletter,sp,'l');
								ydirletter=CellInsertion(ydirletter,sp,'t');
								zdirletter=CellInsertion(zdirletter,sp,'r');
								xydirletter=CellInsertion(xydirletter,sp,'lt');
								yzdirletter=CellInsertion(yzdirletter,sp,'tr');
								xzdirletter=CellInsertion(xzdirletter,sp,'lr');
							end
						else
							matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
							p_sp=MatrixInsertion(p_sp,sp,1, psp1); % Density
							xdirletter=CellInsertion(xdirletter,sp,'l');
							ydirletter=CellInsertion(ydirletter,sp,'t');
							zdirletter=CellInsertion(zdirletter,sp,'r');
							xydirletter=CellInsertion(xydirletter,sp,'lt');
							yzdirletter=CellInsertion(yzdirletter,sp,'tr');
							xzdirletter=CellInsertion(xzdirletter,sp,'lr');
						end
					elseif y_trial<19*le_base %related to steel head height
						matmodel=VectorInsertion(matmodel,sp,2); %steel
						p_sp=MatrixInsertion(p_sp,sp,1, psp2); % Density
					end
				else
					if y_trial<18*le_base
						if CasetoRun==57 || CasetoRun==58 || CasetoRun==61
							itsasquishyball=0;
							for knotnum=1:length(knot_x)
								if ((x_trial-knot_x(knotnum))*cos(knot_theta(knotnum))+(y_trial-knot_y(knotnum))*sin(knot_theta(knotnum)))^2/knot_rx(knotnum)^2+((x_trial-knot_x(knotnum))*sin(knot_theta(knotnum))-(y_trial-knot_y(knotnum))*cos(knot_theta(knotnum)))^2/knot_ry(knotnum)^2<1
									itsasquishyball=1;
								end
							end
							if itsasquishyball
								matmodel=VectorInsertion(matmodel,sp,3);
								p_sp=MatrixInsertion(p_sp,sp,1,psp1);
							else
								matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
								p_sp=MatrixInsertion(p_sp,sp,1, psp1); % Density
								xdirletter=CellInsertion(xdirletter,sp,'t');
								ydirletter=CellInsertion(ydirletter,sp,'l');
								zdirletter=CellInsertion(zdirletter,sp,'r');
								xydirletter=CellInsertion(xydirletter,sp,'tl');
								yzdirletter=CellInsertion(yzdirletter,sp,'lr');
								xzdirletter=CellInsertion(xzdirletter,sp,'tr');
							end
						else
							matmodel=VectorInsertion(matmodel,sp,1); % wood schmidt
							p_sp=MatrixInsertion(p_sp,sp,1, psp1); % Density
							xdirletter=CellInsertion(xdirletter,sp,'t');
							ydirletter=CellInsertion(ydirletter,sp,'l');
							zdirletter=CellInsertion(zdirletter,sp,'r');
							xydirletter=CellInsertion(xydirletter,sp,'tl');
							yzdirletter=CellInsertion(yzdirletter,sp,'lr');
							xzdirletter=CellInsertion(xzdirletter,sp,'tr');
						end
					elseif y_trial<19*le_base %related to steel head height
						matmodel=VectorInsertion(matmodel,sp,2); %steel
						p_sp=MatrixInsertion(p_sp,sp,1, psp2); % Density
					end
				end
				if matmodel(sp)==1 || matmodel(sp)==3
					plotignore=VectorInsertion(plotignore,sp,0);
				elseif matmodel(sp)==2
					plotignore=VectorInsertion(plotignore,sp,1);
				end
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				if CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61
					orientationoffset=VectorInsertion(orientationoffset,sp,0);
					for knotnum=1:1
						if abs(x_trial-knot_x(knotnum))<=knot_xaffect(knotnum) && abs(y_trial-knot_y(knotnum))<=knot_yaffect(knotnum)
							knot_deltax=x_trial-knot_x(knotnum);
							knot_deltay=y_trial-knot_y(knotnum);
							L0=knot_xaffect(knotnum);
							L1=knot_xaffect(knotnum)-knot_x(knotnum);
							h=knot_yaffect(knotnum);
							if CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
								dxdy=(sign(knot_deltax)*((pi*sin((knot_deltay*pi)/h)*((abs(knot_deltax)-L0) - knot_rx(knotnum) + ((abs(knot_deltax)-L0)^2*((L0 - 2*knot_rx(knotnum))/L0 - 1))/(2*L0) - ((abs(knot_deltax)-L0)*(L0 - 2*knot_rx(knotnum)))/L0))/(2*h)));
							else
								dxdy=(sign(knot_deltax)*((pi*sin((knot_deltay*pi)/h)*((abs(knot_deltax)-L0) - knot_r(knotnum) + ((abs(knot_deltax)-L0)^2*((L0 - 2*knot_r(knotnum))/L0 - 1))/(2*L0) - ((abs(knot_deltax)-L0)*(L0 - 2*knot_r(knotnum)))/L0))/(2*h)));
							end
							orientationoffset=VectorInsertion(orientationoffset,sp,atan(-dxdy));
						end
					end
					if x_trial>min(Xlist) && x_trial<max(Xlist) && y_trial>min(Ylist) && y_trial<max(Ylist)
						orientationoffset=VectorInsertion(orientationoffset,sp,interp2(Xlist,Ylist,thetalist,x_trial,y_trial));
					end
					
					if y_trial<18*le_base & y_trial>(18*le_base-lp(1))
						sp_predvelnum=sp_predvelnum+1;
						displacementmonitoredparticles=VectorInsertion(displacementmonitoredparticles,sp_predvelnum,sp);
					end
					%if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
					%    troubleshotparticles=[troubleshotparticles sp];
					%end
				elseif CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37
					if plotignore(sp)
						orientationoffset=VectorInsertion(orientationoffset,sp,0);
					elseif matmodel(sp)==3
						orientationoffset=VectorInsertion(orientationoffset,sp,0);
					elseif y_trial<=13*le_base && y_trial>=7*le_base
						%orientationoffset(sp)=gerhardangles(2*le_base,7*le_base,x_trial,y_trial);
						%orientationoffset(sp)=gerhardanglesellipseonly(x_trial,y_trial,knot_x,knot_y,knot_rx,knot_ry,knot_theta);
						orientationoffset=VectorInsertion(orientationoffset,sp,gerhardanglescombined(2*le_base,7*le_base,x_trial,y_trial,knot_x,knot_y,knot_rx,knot_ry,knot_theta,CasetoRun,1));
						if orientationoffset(sp)<0 || orientationoffset(sp)>pi
							fprintf('%s',['angle inccorect' char(10)]);
							pause
							1;
						end
					else
						orientationoffset=VectorInsertion(orientationoffset,sp,pi/2);
					end
				else
					dxdy=0;
					for knotnum=1:length(knot_x)
						if abs(x_trial-knot_x(knotnum))<=knot_xaffect(knotnum) && abs(y_trial-knot_y(knotnum))<=knot_yaffect(knotnum)
							knot_deltax=x_trial-knot_x(knotnum);
							knot_deltay=y_trial-knot_y(knotnum);
							L0=knot_xaffect(knotnum);
							L1=knot_xaffect(knotnum)-knot_x(knotnum);
							h=knot_yaffect(knotnum);
							dxdy=dxdy+(sign(knot_deltax)*((pi*sin((knot_deltay*pi)/h)*((abs(knot_deltax)-L0) - knot_r(knotnum) + ((abs(knot_deltax)-L0)^2*((L0 - 2*knot_r(knotnum))/L0 - 1))/(2*L0) - ((abs(knot_deltax)-L0)*(L0 - 2*knot_r(knotnum)))/L0))/(2*h)));
						end
					end
					orientationoffset=VectorInsertion(orientationoffset,sp,atan(-dxdy));
					%if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
					%    troubleshotparticles=[troubleshotparticles sp];
					%end
				end
				if y_trial<18*le_base & y_trial>(18*le_base-lp(1))
					sp_predvelnum=sp_predvelnum+1;
					displacementmonitoredparticles=VectorInsertion(displacementmonitoredparticles,sp_predvelnum,sp);
				end
				if CasetoRun==15
					if y_trial<5*le_base+lp(2) && y_trial>5*le_base && (x_trial>2*le_base && x_trial<7*le_base)
						yparticledamped=VectorInsertion(yparticledamped,length(yparticledamped)+1,sp);
					end
				else
					if y_trial<2*le_base+lp(2) && y_trial>2*le_base && (x_trial>2*le_base && x_trial<7*le_base)
						yparticledamped=VectorInsertion(yparticledamped,length(yparticledamped)+1,sp);
					end
				end
			end
		end
	elseif CasetoRun==64
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=8*le_base;
		y_start=2*le_base;
		y_end=9*le_base;
		x_crack.npaths=1;
		x_crack.nparticles(1)=6;

		x_crack.center(1,1,1)=20;
		x_crack.center(1,2,1)=55;
		x_crack.center(2,1,1)=22;
		x_crack.center(2,2,1)=55;
		x_crack.center(3,1,1)=32;
		x_crack.center(3,2,1)=55;
		x_crack.center(4,1,1)=42;
		x_crack.center(4,2,1)=55;
		x_crack.center(5,1,1)=51;
		x_crack.center(5,2,1)=55;
		x_crack.center(6,1,1)=52;
		x_crack.center(6,2,1)=55;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
				
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_start+le_base
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				elseif x_trial<x_end
					if y_trial<y_start+2*le_base
						continue;
					elseif y_trial>y_end-2*le_base
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,2); %elastic (can be steel rubber or whatever)
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				
				if x_trial>7*le_base+lp(1);
					yparticledamped=VectorInsertion(yparticledamped,length(yparticledamped)+1,sp);
				end

				
			end
		end
	elseif CasetoRun==66
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=13*le_base;
		y_start=2*le_base;
		y_end=9*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1)=6;
		
		x_crack.center(1,1,1)=20;
		x_crack.center(1,2,1)=55;
		x_crack.center(2,1,1)=22;
		x_crack.center(2,2,1)=55;
		x_crack.center(3,1,1)=32;
		x_crack.center(3,2,1)=55;
		x_crack.center(4,1,1)=42;
		x_crack.center(4,2,1)=55;
		x_crack.center(5,1,1)=51;
		x_crack.center(5,2,1)=55;
		x_crack.center(6,1,1)=52;
		x_crack.center(6,2,1)=55;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_start+le_base
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				elseif x_trial<x_end
					if y_trial<y_start+2*le_base
						continue;
					elseif y_trial>y_end-2*le_base
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,2); %elastic (can be steel rubber or whatever)
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				
				%if x_trial>12*le_base+lp(1);
				%	yparticledamped=[yparticledamped sp];
				%end
			end
		end
	elseif CasetoRun==69
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=13*le_base;
		y_start=4*le_base;
		y_end=8*le_base;
		%{
		x_crackcenter(1,1)=20;
		x_crackcenter(1,2)=55;
		x_crackcenter(2,1)=22;
		x_crackcenter(2,2)=55;
		x_crackcenter(3,1)=32;
		x_crackcenter(3,2)=55;
		x_crackcenter(4,1)=42;
		x_crackcenter(4,2)=55;
		x_crackcenter(5,1)=51;
		x_crackcenter(5,2)=55;
		x_crackcenter(6,1)=52;
		x_crackcenter(6,2)=55;
		%}
		
		x_crack.npaths=1;
		x_crack.nparticles(1)=2;
		
		x_crack.center(1,1,1)=2*le_base;
		x_crack.center(1,2,1)=6*le_base;
		x_crack.center(2,1,1)=5*le_base;
		x_crack.center(2,2,1)=6*le_base;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
				
		pforcemax=10;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,2); %elastic (can be steel rubber or whatever)
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				if x_trial<x_start+lp(1) && y_trial<y_start+lp(2)
					rampedyforceparticle1=VectorInsertion(rampedyforceparticle1,length(rampedyforceparticle1)+1,sp);
				elseif x_trial<x_start+lp(1) && y_trial>y_end-lp(2)
					rampedyforceparticle2=VectorInsertion(rampedyforceparticle2,length(rampedyforceparticle2)+1,sp);
				end
				
				%if x_trial>12*le_base+lp(1);
				%	yparticledamped=[yparticledamped sp];
				%end
				
			end
		end
	elseif CasetoRun==68
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1)=3;
		
		x_crack.center(1,1,1)=60;
		x_crack.center(1,2,1)=55;
		x_crack.center(2,1,1)=60;
		x_crack.center(2,2,1)=41;
		x_crack.center(3,1,1)=60;
		x_crack.center(3,2,1)=40;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,2); %elastic (can be steel rubber or whatever)
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end

	elseif CasetoRun==71
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1)=3;
		
		x_crack.center(1,1,1)=60;
		x_crack.center(1,2,1)=55;
		x_crack.center(2,1,1)=60;
		x_crack.center(2,2,1)=50;
		x_crack.center(3,1,1)=60;
		x_crack.center(3,2,1)=49.5;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,2); %elastic (can be steel rubber or whatever)
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end
	elseif CasetoRun==72
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=23*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		x_notch_start=12*le_base;
		x_notch_end=13*le_base;
		y_notch_tip=8*le_base;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_notch_start
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				elseif x_trial<x_notch_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_notch_tip
						continue;
					end
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				
				ydirletter=CellInsertion(ydirletter,sp,[]);
				xdirletter=CellInsertion(xdirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,2); %elastic (can be steel rubber or whatever)
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end
	elseif CasetoRun==73
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=23*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		x_notch_start=12*le_base;
		x_notch_end=13*le_base;
		y_notch_tip=8*le_base;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_notch_start
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				elseif x_trial<x_notch_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_notch_tip
						continue;
					end
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end
	elseif CasetoRun==74
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1)=3;
		
		x_crack.center(1,1,1)=60;
		x_crack.center(1,2,1)=55;
		x_crack.center(2,1,1)=60;
		x_crack.center(2,2,1)=46;
		x_crack.center(3,1,1)=60;
		x_crack.center(3,2,1)=41;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end
	elseif CasetoRun==78 || CasetoRun==81 || CasetoRun==82
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1)=3;
		
		x_crack.center(1,1,1)=60;
		x_crack.center(1,2,1)=55;
		x_crack.center(2,1,1)=60;
		x_crack.center(2,2,1)=46;
		x_crack.center(3,1,1)=60;
		x_crack.center(3,2,1)=41;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				else
					matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
					orientationoffset=VectorInsertion(orientationoffset,sp,0);
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end
	elseif CasetoRun==83
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=2;
		x_crack.nparticles(1)=3;
		x_crack.nparticles(2)=3;
		
		x_crack.center(1,1,1)=40;
		x_crack.center(1,2,1)=55;
		x_crack.center(2,1,1)=40;
		x_crack.center(2,2,1)=46;
		x_crack.center(3,1,1)=40;
		x_crack.center(3,2,1)=41;
		
		x_crack.center(1,1,2)=80;
		x_crack.center(1,2,2)=55;
		x_crack.center(2,1,2)=80;
		x_crack.center(2,2,2)=46;
		x_crack.center(3,1,2)=80;
		x_crack.center(3,2,2)=41;
		
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				else
					matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
					orientationoffset=VectorInsertion(orientationoffset,sp,0);
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end
	elseif CasetoRun==84
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=2;
		x_crack.nparticles(1:2)=4;
		
		x_crack.center(1,1,1)=60;
		x_crack.center(1,2,1)=62.5;
		x_crack.center(2,1,1)=60;
		x_crack.center(2,2,1)=40;
		x_crack.center(3,1,1)=60;
		x_crack.center(3,2,1)=20;
		x_crack.center(4,1,1)=60;
		x_crack.center(4,2,1)=2.5;
		
		x_crack.center(1,1,2)=2.5;
		x_crack.center(1,2,2)=30;
		x_crack.center(2,1,2)=50;
		x_crack.center(2,2,2)=30;
		x_crack.center(3,1,2)=70;
		x_crack.center(3,2,2)=30;
		x_crack.center(4,1,2)=122.5;
		x_crack.center(4,2,2)=30;

		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				%if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				%else
				%	matmodel(sp)=1; %wood_schmidt7
				%	orientationoffset(sp)=0;
				%end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				%epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
			end
		end
	elseif CasetoRun==88 || CasetoRun==98 || CasetoRun==96
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=2;
		x_crack.nparticles(1)=0;
		x_crack.nparticles(2)=0;
		%sizes are all messed up, correct before use please
		if CasetoRun==88
			x_crack.center(:,2,1)=transpose(57.5:-pi:40);
			x_crack.nparticles(1)=length(x_crack.venter(:,2,1));
			x_crack.center(1:x_crack.nparticles(1),1,1)=80;
		
			x_crack.center(:,:,2)=x_crack.center(:,:,1);
			x_crack.center(:,1,2)=40;
			x_crack.nparticles(1)=length(x_crack.center(:,2,2));
		elseif CasetoRun==98
			x_crack.center(:,2,1)=transpose(57.5:-pi:35);
			x_crack.nparticles(1)=length(x_crack.center(:,2,1));
			x_crack.center(1:x_crack.nparticles(1),1,1)=80;
			
			x_crack.center(:,2,2)=transpose(57.5:-pi:40);
			x_crack.center(:,1,2)=40;
			x_crack.nparticles(1)=length(x_crack.center(:,2,2));
		elseif CasetoRun==96
			x_crack.center(:,2,1)=transpose(57.5:-pi:35);
			branchingpoint=size(x_crack.center(:,:,1),1);
			x_crack.center(branchingpoint,2,1)=35;
			x_crack.center(:,1,1)=60;
			movingindex=0;
			for y_crack_trial=x_crack.center(branchingpoint,2,1)-pi:-pi:20
				movingindex=movingindex+1;
				x_crack.center(branchingpoint+movingindex,2,1)=y_crack_trial;
				x_crack.center(branchingpoint+movingindex,1,1)=60+pi/2*movingindex;
			end
			x_crack.nparticles(1)=size(x_crack.center,1);
			x_crack.nparticles(2)=x_crack.nparticles(1)-branchingpoint+1;
			x_crack.center(:,:,2)=x_crack.center(branchingpoint:size(x_crackcenter{1},1),:,1);
			x_crack.center(:,1,2)=60-(x_crackcenter(:,1,2)-60);
		end
		%{
		x_crackcenter{1}(1,1)=80;
		x_crackcenter{1}(1,2)=55;
		x_crackcenter{1}(2,1)=80;
		x_crackcenter{1}(2,2)=46;
		x_crackcenter{1}(3,1)=80;
		x_crackcenter{1}(3,2)=41;

		x_crackcenter{2}(1,1)=40;
		x_crackcenter{2}(1,2)=55;
		x_crackcenter{2}(2,1)=40;
		x_crackcenter{2}(2,2)=46;
		x_crackcenter{2}(3,1)=40;
		x_crackcenter{2}(3,2)=41;
		%}
		x_cracktop=x_crackcenter;
		x_crackbot=x_crackcenter;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				else
					if CasetoRun==98
						matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
						orientationoffset=VectorInsertion(orientationoffset,sp,0);
					else
						matmodel=VectorInsertion(matmodel,sp,2); %steel
						orientationoffset=VectorInsertion(orientationoffset,sp,NaN); %steel-steel for now
					end
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end
	elseif CasetoRun==100 || CasetoRun==101 || CasetoRun==105
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1:1)=3;
		
		x_crack.center(1,1,1)=60;
		x_crack.center(1,2,1)=55;
		x_crack.center(2,1,1)=60;
		x_crack.center(2,2,1)=46;
		x_crack.center(3,1,1)=60;
		x_crack.center(3,2,1)=41;

		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				else
					matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
					orientationoffset=VectorInsertion(orientationoffset,sp,0);
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end	
	elseif CasetoRun==109
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1:1)=3;
		
		x_crack.center(1,1,1)=60;
		x_crack.center(1,2,1)=55;
		x_crack.center(2,1,1)=60;
		x_crack.center(2,2,1)=46;
		x_crack.center(3,1,1)=60;
		x_crack.center(3,2,1)=41;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		x_cracktop=x_crackcenter;
		x_crackbot=x_crackcenter;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'r');
				ydirletter=CellInsertion(ydirletter,sp,'t');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'rt');
				yzdirletter=CellInsertion(yzdirletter,sp,'tl');
				xzdirletter=CellInsertion(xzdirletter,sp,'rl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				else
					matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
					orientationoffset=VectorInsertion(orientationoffset,sp,pi/2);
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end	
	elseif CasetoRun==102
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=3;
		x_crack.nparticles(1:3)=3;
		
		x_crack.center(1,1,1)=40;
		x_crack.center(1,2,1)=55;
		x_crack.center(2,1,1)=40;
		x_crack.center(2,2,1)=46;
		x_crack.center(3,1,1)=40;
		x_crack.center(3,2,1)=41;
		
		x_crack.center(1,1,2)=60;
		x_crack.center(1,2,2)=55;
		x_crack.center(2,1,2)=60;
		x_crack.center(2,2,2)=46;
		x_crack.center(3,1,2)=60;
		x_crack.center(3,2,2)=41;
		
		x_crack.center(1,1,3)=70;
		x_crack.center(1,2,3)=55;
		x_crack.center(2,1,3)=70;
		x_crack.center(2,2,3)=46;
		x_crack.center(3,1,3)=70;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				else
					matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
					orientationoffset=VectorInsertion(orientationoffset,sp,0);
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end	
	elseif CasetoRun==106
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crackcenter{1}(:,2)=transpose(57.5:-pi:35);
		x_crackcenter{1}(:,1)=80;

		x_crackcenter{2}(:,2)=transpose(57.5:-pi:40);
		x_crackcenter{2}(:,1)=40;
		
		x_cracktop=x_crackcenter;
		x_crackbot=x_crackcenter;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				else
					matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
					orientationoffset=VectorInsertion(orientationoffset,sp,0);
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end	
	elseif CasetoRun==107
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crackcenter{1}(:,2)=transpose(57.5:-pi:40);
		x_crackcenter{1}(:,1)=80;

		x_crackcenter{2}(:,2)=transpose(57.5:-pi:40);
		x_crackcenter{2}(:,1)=40;
		
		x_cracktop=x_crackcenter;
		x_crackbot=x_crackcenter;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				else
					matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
					orientationoffset=VectorInsertion(orientationoffset,sp,0);
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end	
	elseif CasetoRun==103
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1:1)=2;
		
		x_crack.center(1,1,1)=60;
		x_crack.center(1,2,1)=41;
		x_crack.center(2,1,1)=60;
		x_crack.center(2,2,1)=36;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				else
					matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
					orientationoffset=VectorInsertion(orientationoffset,sp,0);
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end	
	elseif CasetoRun==104 || CasetoRun==114
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1:1)=2;
		
		x_crack.center(1,1,1)=1;
		x_crack.center(1,2,1)=1;
		x_crack.center(2,1,1)=1;
		x_crack.center(2,2,1)=2;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;

		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				else
					matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
					orientationoffset=VectorInsertion(orientationoffset,sp,0);
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end	
	elseif CasetoRun==108 || CasetoRun==110
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.center(1,1,1)=1;
		x_crack.center(1,2,1)=1;
		x_crack.center(2,1,1)=1;
		x_crack.center(2,2,1)=2;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		weakeningfactorcounter=0;
		weakeningfactorlist=[0.00288151222434182 0.00766816007402974 0.00819039114023511 0.00206492725892124 0.00550087229560278 0.00886610423295293 0.00271950803658363 0.00443702800163524 0.00941825156270763 0.00894423010348648 0.00571706432219782 0.00452053528811982 0.00167950736922723 0.00658014158621619 0.00846529684305844 0.00872439936759172 0.00846977684943388 0.00415260028628463 0.00502644146389766 0.00484150020418957 0.00187037971504438 0.00985947663837137 0.00289289872951303 0.000362044440089581 0.00303547310853137 0.00887375733748427 0.00192453208682581 0.00964888027067501 0.00791975845733582 0.00154541079076149 0.00529942189752767 0.00933693229143841 0.00978590745016202 0.00130750919289898 0.00686437069493387 0.00714991523231083 0.00103735466840257 0.00858819451675231 0.0079271329202272 0.00541936047566576 0.00652560397777236 0.00562448490332467 0.00330743732616964 0.00313379933617871 0.00709201739693978 0.00299051922312481 0.00932478809593775 0.00748362337780803 0.00531391396137042 0.0016958372338974 0.00517668132633026 0.00247342262797549 0.00699004862424677 0.00902714773653955 0.00944425392442729 0.00610135553603108 0.00182221157448127 0.000606461848265278 0.0019302177937423 0.00965688752409669 0.00346658832860904 0.00706319537603954 0.00963911544608514 0.00336156933121046 0.0099069389540077 0.00674555349925084 0.00338014016027076 0.00243160971239059 0.00919480902754352 0.00875235227644536 0.00999743954283944 0.00255743988087225 0.00803813897931835 0.00279163058646554 0.00402384241996415 0.00347113995562023 0.00447186258577744 0.00718688421503438 3.01039226423994E-06 0.0050185688529129 0.000711319832713989 0.00180146420933763 0.00651523374606015 0.00210395840673967 0.00525048438044075 0.00048255185000101 0.00306716274538377 0.00188922913948279 0.00968808365423962 0.00752112575444415 0.00341613831273792 0.00309143545727035 0.0033406072131505 0.00021153188192593 0.00133175354519212 0.00871365100470319 0.00672474092194059 0.000673813327952691 0.00764332327817865 0.00329429518638246 0.00270424341584231 0.00941066602601188 0.00286175394485562 0.00521835858259539 0.00469851201649738 0.00877488596244973 0.00905124423794886 0.00503536836177755 0.0097766299530509 0.00413010208800381 0.00531853354924132 0.00736649928139957 0.00931143033300578 0.000616355263154424 0.00233193456956093 0.00247148996314264 0.000671375154289947 0.00385162013296107 0.00545482773350906 0.00359362966897553 0.00243661178553081 0.00817887378453148 0.000299151843915149 0.00898913157279223 0.00921857812156791 0.00711994953969055 0.00660048033836392 0.008599383303583 0.00279165860375161 0.00736841621438943 0.00998526708330981 0.0015826881720091 0.00628321513135645 0.00120051164320441 0.00967202738175216 0.005817414523798 0.00494438807082617 0.00437688013412547 0.00597462802208307 0.0064215168162815 0.00415520487631298 0.00528947537216599 0.00951926264586612 0.0022295267628736 0.000113061800611495 0.00662590908224851 0.00748900887229356 0.00521380434083576 0.00787829770455287 0.00132112758696115 0.00499031109142165 0.00832729030759734];

		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				else
					matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
					orientationoffset=VectorInsertion(orientationoffset,sp,0);
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				if y_trial>10*le_base-lp(2);
					weakeningfactorcounter=weakeningfactorcounter+1;
					weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,weakeningfactorlist(weakeningfactorcounter));
				else
					weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				end
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end
	elseif CasetoRun==111 || CasetoRun==113
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=3.5*le_base;
		x_mid=8.5*le_base;
		x_end=16*le_base;
		y_start=4*le_base;
		y_mid1=9*le_base;
		y_mid2=11*le_base;
		y_end=16*le_base;
		steelcirclecenter=[6 7;
							6 13]*le_base;
		steelcircleradius=[1;1]*le_base;
		ncircle=size(steelcirclecenter,2);
		
		x_crackcenter{1}=[7 10;
					11 10]*le_base;
		
		x_cracktop=x_crackcenter;
		x_crackbot=x_crackcenter;
		
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_mid
					if y_trial<y_start
						continue;
					elseif y_trial<y_mid1
					elseif y_trial<y_mid2
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				insidecircle=0;
				for icircle=1:ncircle
					if sqrt((x_trial-steelcirclecenter(icircle,1))^2+(y_trial-steelcirclecenter(icircle,2))^2)<steelcircleradius(icircle);
						insidecircle=1;
						break;
					end
				end
				if insidecircle
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
					plotignore=VectorInsertion(plotignore,sp,1);
				else
					matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
					orientationoffset=VectorInsertion(orientationoffset,sp,0);
					plotignore=VectorInsertion(plotignore,sp,0);
				end
				if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
					ParticleswithPredYVel=VectorInsertion(ParticleswithPredYVel,1,sp);
				end
				if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
					ParticleswithPredYVel=VectorInsertion(ParticleswithPredYVel,2,sp);
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
			end
		end
	elseif CasetoRun==115
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=5*le_base;
		y_start=2*le_base;
		y_end=5*le_base;
		
		x_crackcenter{1}=[0.5 3.5;
					3.5-pi*1e-5 3.5]*le_base;
		x_defaultcracktip=[3.5 3.5]*le_base;
		
		x_cracktop=x_crackcenter;
		x_crackbot=x_crackcenter;
		
		elasticstrength=5; %MPa
		
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,2); %steel
				orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				plotignore=VectorInsertion(plotignore,sp,0);
				
				if x_trial>5*le_base-lp(1)
					if y_trial>5*le_base-lp(2)
						tractionedcorner=VectorInsertion(tractionedcorner,length(tractionedcorner)+1,sp);
						normalcorner{length(tractionedcorner)}=[1 0;
																0 1];
					elseif y_trial<2*le_base+lp(2)
						tractionedcorner=VectorInsertion(tractionedcorner,length(tractionedcorner)+1,sp);
						normalcorner{length(tractionedcorner)}=[1 0;
																0 -1];
					else
						tractionededge=VectorInsertion(tractionededge,length(tractionededge)+1,sp);
						normaledge=VectorInsertion(normaledge,length(tractionededge),1,1);
						normaledge=VectorInsertion(normaledge,length(tractionededge),2,0);
						
					end
				elseif y_trial>5*le_base-lp(2)
					tractionededge=VectorInsertion(tractionededge,length(tractionededge)+1,sp);
					normaledge=MatrixInsertion(normaledge,length(tractionededge),1,0);
					normaledge=MatrixInsertion(normaledge,length(tractionededge),2,1);
				elseif y_trial<2*le_base+lp(2)
					tractionededge=VectorInsertion(tractionededge,length(tractionededge)+1,sp);
					normaledge=MatrixInsertion(normaledge,length(tractionededge),1,0);
					normaledge=MatrixInsertion(normaledge,length(tractionededge),2,-1);
				end
				
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
				%	ParticleswithPredYVel(1)=sp;
				%end
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
				%	ParticleswithPredYVel(2)=sp;
				%end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
			end
		end
	elseif CasetoRun==116 || CasetoRun==119 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==117
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=4*le_base;
		y_start=2*le_base;
		y_end=4*le_base;
		
		if CasetoRun==117
			x_crackcenter{1}=[0.5 3;
						3-pi*1e-5 3-pi*1e-5;
				3-pi*1e-5+2.5 3]*le_base;
		elseif CasetoRun==122
			rotationangle=30/180*pi;
			rotationcenter=[2 3]*le_base;
			rotationmatrix=[cos(rotationangle) -sin(rotationangle);
							sin(rotationangle) cos(rotationangle)];
			
			x_crackcenter{1}=[0.5 3; %x1 y1
						3-pi*1e-5 3]*le_base; %x2 y2
			for icrackparticle=1:size(x_crackcenter{1},1)
				x_crackcenter{1}(icrackparticle,:)=transpose(rotationmatrix*transpose(x_crackcenter{1}(icrackparticle,:)-rotationcenter))+rotationcenter;
			end
		else
			x_crackcenter{1}=[0.5 3;
						3-pi*1e-5 3]*le_base;
		end
		x_defaultcracktip=[3 3]*le_base;
		
		x_cracktop=x_crackcenter;
		x_crackbot=x_crackcenter;
		
		elasticstrength=5; %MPa
		
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,2); %steel
				orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				plotignore=VectorInsertion(plotignore,sp,0);
				
				if x_trial>4*le_base-lp(1)
					if y_trial>4*le_base-lp(2)
						tractionedcorner=VectorInsertion(tractionedcorner,length(tractionedcorner)+1,sp);
						normalcorner{length(tractionedcorner)}=[1 0;
																0 1];
					elseif y_trial<2*le_base+lp(2)
						tractionedcorner=VectorInsertion(tractionedcorner,length(tractionedcorner)+1,sp);
						normalcorner{length(tractionedcorner)}=[1 0;
																0 -1];
					else
						tractionededge=VectorInsertion(tractionededge,length(tractionededge)+1,sp);
						normaledge=MatrixInsertion(normaledge,length(tractionededge),1,1);
						normaledge=MatrixInsertion(normaledge,length(tractionededge),2,0);
					end
				elseif y_trial>4*le_base-lp(2)
					tractionededge=VectorInsertion(tractionededge,length(tractionededge)+1,sp);
					normaledge=MatrixInsertion(normaledge,length(tractionededge),1,0);
					normaledge=MatrixInsertion(normaledge,length(tractionededge),2,1);
				elseif y_trial<2*le_base+lp(2)
					tractionededge=VectorInsertion(tractionededge,length(tractionededge)+1,sp);
					normaledge=MatrixInsertion(normaledge,length(tractionededge),1,0);
					normaledge=MatrixInsertion(normaledge,length(tractionededge),2,-1);
				end
				
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
				%	ParticleswithPredYVel(1)=sp;
				%end
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
				%	ParticleswithPredYVel(2)=sp;
				%end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
			end
		end
		spCount=sp;
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);
	elseif CasetoRun==137
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		x_crack.npaths=1;
		x_crack.nparticles(1)=2;
		
		x_start=2*le_base;
		x_end=4*le_base;
		y_start=2*le_base;
		y_end=4*le_base;
		
		x_crack.center(1,1,1)=0.5*le_base;
		x_crack.center(1,2,1)=3*le_base;
		x_crack.center(2,1,1)=(3-(pi*1e-5))*le_base;
		x_crack.center(2,2,1)=3*le_base;
		
		for i=1:2
			for j=1:2
				x_crack.top(i,j,1)=x_crack.center(i,j,1);
				x_crack.bot(i,j,1)=x_crack.center(i,j,1);
			end
		end
		x_defaultcracktip=[3 3]*le_base;
		
		
		elasticstrength=5; %MPa
		
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,2); %steel
				orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				plotignore=VectorInsertion(plotignore,sp,0);
				
				if x_trial>4*le_base-lp(1)
					if y_trial>4*le_base-lp(2)
						tractionedcorner=VectorInsertion(tractionedcorner,length(tractionedcorner)+1,sp);
						normalcorner{length(tractionedcorner)}=[1 0;
																0 1];
					elseif y_trial<2*le_base+lp(2)
						tractionedcorner=VectorInsertion(tractionedcorner,length(tractionedcorner)+1,sp);
						normalcorner{length(tractionedcorner)}=[1 0;
																0 -1];
					else
						tractionededge=VectorInsertion(tractionededge,length(tractionededge)+1,sp);
						normaledge=MatrixInsertion(normaledge,length(tractionededge),1,1);
						normaledge=MatrixInsertion(normaledge,length(tractionededge),2,0);
					end
				elseif y_trial>4*le_base-lp(2)
					tractionededge=VectorInsertion(tractionededge,length(tractionededge)+1,sp);
					normaledge=MatrixInsertion(normaledge,length(tractionededge),1,0);
					normaledge=MatrixInsertion(normaledge,length(tractionededge),2,1);
				elseif y_trial<2*le_base+lp(2)
					tractionededge=VectorInsertion(tractionededge,length(tractionededge)+1,sp);
					normaledge=MatrixInsertion(normaledge,length(tractionededge),1,0);
					normaledge=MatrixInsertion(normaledge,length(tractionededge),2,-1);
				end
				
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
				%	ParticleswithPredYVel(1)=sp;
				%end
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
				%	ParticleswithPredYVel(2)=sp;
				%end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
			end
		end
		spCount=sp;
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);
	elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==192
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=4*le_base;
		y_start=2*le_base;
		y_end=4*le_base;
		
		x_crack_unused=cell(1,10);
		%x_crackcenter=coder.nullcopy(x_crack_unused);
		x_crack.npaths=10;
		x_crack.nparticles(1:10)=2;
		%x_crack.center=zeros(2,2,10);
		%x_crack.top=zeros(2,2,10);
		%x_crack.bot=zeros(2,2,10);
		
		x_crack_temp=([0.33 0.371;0.4843 0.5235]+[2 2;2 2])*le_base;
		x_crack.center(1,1,1)=x_crack_temp(1,1);
		x_crack.center(1,2,1)=x_crack_temp(1,2);
		x_crack.center(2,1,1)=x_crack_temp(2,1);
		x_crack.center(2,2,1)=x_crack_temp(2,2);
		x_crack_temp=([0.2706 0.8233; 0.4120 0.9933]+[2 2;2 2])*le_base;
		x_crack.center(1,1,2)=x_crack_temp(1,1);
		x_crack.center(1,2,2)=x_crack_temp(1,2);
		x_crack.center(2,1,2)=x_crack_temp(2,1);
		x_crack.center(2,2,2)=x_crack_temp(2,2);
		x_crack_temp=([0.3115 1.5362; 0.4883 1.7130]+[2 2;2 2])*le_base;
		x_crack.center(1,1,3)=x_crack_temp(1,1);
		x_crack.center(1,2,3)=x_crack_temp(1,2);
		x_crack.center(2,1,3)=x_crack_temp(2,1);
		x_crack.center(2,2,3)=x_crack_temp(2,2);
		x_crack_temp=([0.9106 0.4681; 1.0908 0.3494]+[2 2;2 2])*le_base;
		x_crack.center(1,1,4)=x_crack_temp(1,1);
		x_crack.center(1,2,4)=x_crack_temp(1,2);
		x_crack.center(2,1,4)=x_crack_temp(2,1);
		x_crack.center(2,2,4)=x_crack_temp(2,2);
		x_crack_temp=([0.8329 0.9064; 1.0876 0.9599]+[2 2;2 2])*le_base;
		x_crack.center(1,1,5)=x_crack_temp(1,1);
		x_crack.center(1,2,5)=x_crack_temp(1,2);
		x_crack.center(2,1,5)=x_crack_temp(2,1);
		x_crack.center(2,2,5)=x_crack_temp(2,2);
		x_crack_temp=([0.7134 1.3365; 0.6068 1.5130]+[2 2;2 2])*le_base;
		x_crack.center(1,1,6)=x_crack_temp(1,1);
		x_crack.center(1,2,6)=x_crack_temp(1,2);
		x_crack.center(2,1,6)=x_crack_temp(2,1);
		x_crack.center(2,2,6)=x_crack_temp(2,2);
		x_crack_temp=([1.4393 0.3678; 1.6253 0.4967]+[2 2;2 2])*le_base;
		x_crack.center(1,1,7)=x_crack_temp(1,1);
		x_crack.center(1,2,7)=x_crack_temp(1,2);
		x_crack.center(2,1,7)=x_crack_temp(2,1);
		x_crack.center(2,2,7)=x_crack_temp(2,2);
		x_crack_temp=([1.5926 0.8224; 1.4581 0.9953]+[2 2;2 2])*le_base;
		x_crack.center(1,1,8)=x_crack_temp(1,1);
		x_crack.center(1,2,8)=x_crack_temp(1,2);
		x_crack.center(2,1,8)=x_crack_temp(2,1);
		x_crack.center(2,2,8)=x_crack_temp(2,2);
		x_crack_temp=([1.6752 1.2320; 1.5203 1.4134]+[2 2;2 2])*le_base;
		x_crack.center(1,1,9)=x_crack_temp(1,1);
		x_crack.center(1,2,9)=x_crack_temp(1,2);
		x_crack.center(2,1,9)=x_crack_temp(2,1);
		x_crack.center(2,2,9)=x_crack_temp(2,2);
		x_crack_temp=([1.1323 1.5215; 1.3586 1.6957]+[2 2;2 2])*le_base;
		x_crack.center(1,1,10)=x_crack_temp(1,1);
		x_crack.center(1,2,10)=x_crack_temp(1,2);
		x_crack.center(2,1,10)=x_crack_temp(2,1);
		x_crack.center(2,2,10)=x_crack_temp(2,2);
		
		%{
		if CasetoRun==117
			x_crackcenter{1}=[0.5 3;
						3-pi*1e-5 3-pi*1e-5;
				3-pi*1e-5+2.5 3]*le_base;
		end
		x_defaultcracktip=[3 3]*le_base;
		%}
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		x_crack.spacing=le(1)/2;
		elasticstrength=25;
		x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
		x_crack.bridge.kbase2(:,:)=1e99;
		x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
		x_crack.bridge.deltai1=0.002*le_base;
		x_crack.bridge.deltae=0.1*x_crack.bridge.deltai1;
		x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
		x_crack.cohesivepath(1)=1;
		x_crack.cohesivepath(2)=1;
		x_crack.cohesivepath(3)=1;
		x_crack.cohesivepath(4)=1;
		x_crack.cohesivepath(5)=1;
		x_crack.cohesivepath(6)=1;
		x_crack.cohesivepath(7)=1;
		x_crack.cohesivepath(8)=1;
		x_crack.cohesivepath(9)=1;
		x_crack.cohesivepath(10)=1;
		
		x_crack.cohesivepoint(1,1)=1;
		x_crack.cohesivepoint(2,1)=1;
		x_crack.cohesivepoint(1,2)=1;
		x_crack.cohesivepoint(2,2)=1;
		x_crack.cohesivepoint(1,3)=1;
		x_crack.cohesivepoint(2,3)=1;
		x_crack.cohesivepoint(1,4)=1;
		x_crack.cohesivepoint(2,4)=1;
		x_crack.cohesivepoint(1,5)=1;
		x_crack.cohesivepoint(2,5)=1;
		x_crack.cohesivepoint(1,6)=1;
		x_crack.cohesivepoint(2,6)=1;
		x_crack.cohesivepoint(1,7)=1;
		x_crack.cohesivepoint(2,7)=1;
		x_crack.cohesivepoint(1,8)=1;
		x_crack.cohesivepoint(2,8)=1;
		x_crack.cohesivepoint(1,9)=1;
		x_crack.cohesivepoint(2,9)=1;
		x_crack.cohesivepoint(1,10)=1;
		x_crack.cohesivepoint(2,10)=1; %(iparticle,ipath)
		
		x_crack.bridge.pathcompletemonitor.values(1)=1;
		x_crack.bridge.pathcompletemonitor.values(2)=2;
		x_crack.bridge.pathcompletemonitor.values(3)=3;
		x_crack.bridge.pathcompletemonitor.values(4)=4;
		x_crack.bridge.pathcompletemonitor.values(5)=5;
		x_crack.bridge.pathcompletemonitor.values(6)=6;
		x_crack.bridge.pathcompletemonitor.values(7)=7;
		x_crack.bridge.pathcompletemonitor.values(8)=8;
		x_crack.bridge.pathcompletemonitor.values(9)=9;
		x_crack.bridge.pathcompletemonitor.values(10)=10;
		x_crack.bridge.pathcompletemonitor.size=10;


		%x_crack.top=x_crack.center;
		%x_crack.bot=x_crack.center;
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				
				if x_trial>4*le_base-lp(1)
					if y_trial>4*le_base-lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						normalcorner_counter=normalcorner_counter+1;
					elseif y_trial<2*le_base+lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						normalcorner_counter=normalcorner_counter+1;
					else
						tractionededge_counter=tractionededge_counter+1;
						normaledge_counter=normaledge_counter+1;
					end
				elseif y_trial>4*le_base-lp(2)
					tractionededge_counter=tractionededge_counter+1;
					normaledge_counter=normaledge_counter+1;
				elseif y_trial<2*le_base+lp(2)
					tractionededge_counter=tractionededge_counter+1;
					normaledge_counter=normaledge_counter+1;
				end
				
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
				%	ParticleswithPredYVel(1)=sp;
				%end
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
				%	ParticleswithPredYVel(2)=sp;
				%end
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);

		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		alphahp=zeros(spCount,7);
		uncrackable_sp=zeros(1,spCount);

		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				matmodel(sp)=4; %crackable elastic
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
				if x_trial>4*le_base-lp(1)
					if y_trial>4*le_base-lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						tractionedcorner(tractionedcorner_counter)=sp;
						normalcorner_counter=normalcorner_counter+1;
						normalcorner{normalcorner_counter}=[1 0;
																0 1];
					elseif y_trial<2*le_base+lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						tractionedcorner(tractionedcorner_counter)=sp;
						normalcorner_counter=normalcorner_counter+1;
						normalcorner{normalcorner_counter}=[1 0;
																0 -1];
					else
						tractionededge_counter=tractionededge_counter+1;
						tractionededge(tractionededge_counter)=sp;
						normaledge_counter=normaledge_counter+1;
						normaledge(normaledge_counter,1)=1;
						normaledge(normaledge_counter,2)=0;
					end
				elseif y_trial>4*le_base-lp(2)
					tractionededge_counter=tractionededge_counter+1;
					tractionededge(tractionededge_counter)=sp;
					normaledge_counter=normaledge_counter+1;
					normaledge(normaledge_counter,1)=0;
					normaledge(normaledge_counter,2)=1;
				elseif y_trial<2*le_base+lp(2)
					tractionededge_counter=tractionededge_counter+1;
					tractionededge(tractionededge_counter)=sp;
					normaledge_counter=normaledge_counter+1;
					normaledge(normaledge_counter,1)=0;
					normaledge(normaledge_counter,2)=-1;
				end
				
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
				%	ParticleswithPredYVel(1)=sp;
				%end
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
				%	ParticleswithPredYVel(2)=sp;
				%end
			end
		end
		1;
	elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130
		particle_per_cell=4;
		
		%below is for knot geometry calculations
		%TDL CasetoRun==228 is plugged in from particlesfor228from55or56or57fdkjsalfhdsjkal.m
		knot_x=zeros(1,2);
		knot_y=zeros(1,2);
		knot_rx=zeros(1,2);
		knot_ry=zeros(1,2);
		knot_theta=zeros(1,2);
		knot_xaffect=zeros(1,1);
		knot_yaffect=zeros(1,1);
		Xobservedrelative=zeros(1,12);
		Yobservedrelative=zeros(1,11);
		Xbigknotobserved=zeros(1,1);
		Ybigknotobserved=zeros(1,1);
		Xshift=zeros(1,1);
		Yshift=zeros(1,1);
		Xlist=zeros(size(Xobservedrelative));
		Ylist=zeros(size(Yobservedrelative));
		oneovertanthetalist=zeros(11,12);
		tanthetalist=zeros(size(oneovertanthetalist));
		thetalist=zeros(size(oneovertanthetalist));
		
		
		if CasetoRun==228
			knot_x(1)=72+2*le_base;
			knot_y(1)=10*le_base-20;
			knot_rx(1)=7.625;
			knot_ry(1)=7.625;
			knot_theta(1)=0;
			knot_xaffect(1)=2.5*knot_rx(1);
			knot_yaffect(1)=5*knot_rx(1);
			knot_x(2)=28.8+2*le_base;
			knot_y(2)=10*le_base+20;
			knot_rx(2)=14;
			knot_ry(2)=8.5;
			knot_theta(2)=atan(-1/5.5);
			Xobservedrelative=[0 5 10 15 20 25 30 35 40 45 50 55];
			Yobservedrelative=[50 70 75 80 85 90 95 100 105 110 140];
			Xbigknotobserved=28.5;
			Ybigknotobserved=93;
			Xshift=knot_x(2)-Xbigknotobserved;
			Yshift=knot_y(2)-Ybigknotobserved;
			Xlist=Xobservedrelative+Xshift;
			Ylist=Yobservedrelative+Yshift;
			oneovertanthetalist=[1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99;
				1e99    8   4   2.5 1.7 1.2 1.4 1.4 2.5 4   15  1e99;
				1e99    8   8   4.2 1.5 1/1.5   1/1.3   1.1 2   3   10  1e99;
				1e99	9	7	4.5	1.8	1/2	1/1.8	1/3	1.5	-7	-15 1e99;
				1e99	7	5.2	2	1/2	1/6	1/17.5	-1/10	-1/2	-1	-4.5    1e99;
				1e99	7   1/2 1   1/2 1/4 -1/2.5  -1  -8  1e99    12	1e99;
				1e99    1e99    -8  -3  -4  5   1/4 3.5 1/1.5   3.5 1e99    1e99;
				1e99    -19 -9.5    -1.5    -1/5.5  1/4 1/2.5   1/2 1/1.3   -3  -13 1e99;
				1e99    -10 -4.5    -2.5    -1  -1/12   -1/1.5  -1.25   -1.25   -2  -6  1e99;
				1e99    -8  -6  -3  -2.5    -2  -1.5    -2  -2.8    -3.1    -6  1e99;
				1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99    1e99];
			for i=1:size(oneovertanthetalist,1)
				for j=1:size(oneovertanthetalist,2)
					tanthetalist(i,j)=1/oneovertanthetalist(i,j);
					thetalist(i,j)=atan(tanthetalist(i,j));
				end
			end
		end
		
		if CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227
			%TDL switch particle_per_cell for 219 here!
			particle_per_cell=4;
		end
		%spCount=5*4*particle_per_cell;
		%spCount=5*4*particle_per_cell-((30-7*2)*2);
		lp(1)=le(1)/sqrt(particle_per_cell); %size of particle in X direction
		lp(2)=lp(1); %size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		%declarations below to quit coder from whining;
		x_center=zeros(1,1);
		y_center=zeros(1,1);
		r_cylinder=zeros(1,1);
		
		if CasetoRun==205 || CasetoRun==210 || CasetoRun==207
			x_center=6*le_base;
			y_center=7*le_base;
			r_cylinder=3*le_base;
		end
		
		x_start=2*le_base;
		if CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==132 || CasetoRun==130
			x_end=6*le_base;
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==220
			x_end=5*le_base;
		elseif CasetoRun==229
			x_end=3*le_base;
		elseif CasetoRun==228
			x_end=7*le_base;
		elseif CasetoRun==225
			x_end=3*le_base;
		elseif CasetoRun==205 || CasetoRun==210 || CasetoRun==207
			x_start=x_center-r_cylinder; %yes, the x_start definition outside the elseif barrage is overridden;
			x_end=x_center+r_cylinder;
		elseif CasetoRun==223 || CasetoRun==226
			x_end=7*le_base;
		elseif CasetoRun==204 || CasetoRun==208 || CasetoRun==219 || CasetoRun==224 || CasetoRun==206 || CasetoRun==209 || CasetoRun==227
			x_end=12*le_base;
		elseif CasetoRun==202 
			x_end=6*le_base;
		elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==201
			x_end=4*le_base;
		elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			x_end=10*le_base;
		elseif CasetoRun==134 || CasetoRun==136
			x_end=7.5*le_base;
		end
		y_start=2*le_base;
		if CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			y_end=4*le_base;
		elseif CasetoRun==224
			y_end=3*le_base;
		elseif CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==219 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==206 || CasetoRun==209
			y_end=4*le_base;
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==220
			y_end=5*le_base;
		elseif CasetoRun==217
			%TDL y_start and y_end for 217
			y_start=2*le_base;
			y_end=5*le_base;
		elseif CasetoRun==229
			y_end=8*le_base;
		elseif CasetoRun==228
			y_end=19*le_base;
		elseif CasetoRun==225
			y_end=3*le_base;
		elseif CasetoRun==205 || CasetoRun==210 || CasetoRun==207
			y_start=y_center-r_cylinder; %yes, the y_start definition outside the elseif barrage is overridden;
			y_end=y_center+r_cylinder;
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130
			y_end=4.25*le_base;
		end
		
		if CasetoRun==123
			x_crack_unused=cell(1,2);
			%x_crackcenter=coder.nullcopy(x_crack_unused);
			x_crack.npaths=2;
			x_crack.nparticles(1:2)=2;
			%x_crack.center=zeros(2,2,10);
			%x_crack.top=zeros(2,2,10);
			%x_crack.bot=zeros(2,2,10);
			
			x_crack_temp=[6 3;4.5 3]*le_base+[2 0;0 0]*le(1)+[pi pi;pi pi]/50;
			x_crack.center(1,1,1)=x_crack_temp(1,1);
			x_crack.center(1,2,1)=x_crack_temp(1,2);
			x_crack.center(2,1,1)=x_crack_temp(2,1);
			x_crack.center(2,2,1)=x_crack_temp(2,2);
			
			x_crack_temp=[3+0.5*cos(pi/3) 3+0.5*sin(pi/3);3-0.5*cos(pi/3) 3-0.5*sin(pi/3)]*le_base;
			x_crack.center(1,1,2)=x_crack_temp(1,1);
			x_crack.center(1,2,2)=x_crack_temp(1,2);
			x_crack.center(2,1,2)=x_crack_temp(2,1);
			x_crack.center(2,2,2)=x_crack_temp(2,2);
		elseif CasetoRun==166
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			
			%start of for testing only
			
			x_crack.npaths=2;
			x_crack.nparticles(2)=5;
			x_crack.center(1:5,1:2,2)=[ ...
			+4.853930069693719e+000	+2.972240882749910e+000
			+4.950000017129133e+000	+2.999999994755408e+000
			+5.050000014504054e+000	+2.999999998547479e+000
			+5.149948599642003e+000	+3.003205858301732e+000
			+5.249897195596345e+000	+3.006411718110133e+000 ...
			];
			
			%end of for testing only
		elseif CasetoRun==169
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
		elseif CasetoRun==201
			%fracture parameters initiation for 200
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			
			x_crack.spacing=le(1);
			elasticstrength=1;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base; %[D]TDL delete later %no, need this for fallback
			%x_crack.bridge.deltai1=999*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.size=1;
		elseif CasetoRun==222 || CasetoRun==225
			%just adding the bogus crack here
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)-0.01;
			x_crack.center(1,2,1)=le(2)-0.01;
			x_crack.center(2,1,1)=le(1)-0.011;
			x_crack.center(2,2,1)=le(2)-0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			
			%TDL adjusting initial crack energy problem
			
			%first initial crack in the middle below, both tips are active
			%{
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1:2,1:2,2)=[ ...
			3.5 3
			3.5 4 ...
			]*le_base; %x y;x y
			
			%second initial crack on the edge below, one tip is terminated, the other is alive
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.5
			5.5 3.5 ...
			]*le_base;
			x_crack.terminatedprop(3,1)=1;
			%}
			%below is some global definitions:
			
			x_crack.spacing=1.25*le(1)/2;
			
			for ipath=1:x_crack.npaths
			for itip=1:2
				if x_crack.terminatedprop(ipath,itip)==0
					x_crack.boxcalc.active(ipath,itip)=1;
				else
					x_crack.boxcalc.active(ipath,itip)=0;
				end
			end
			end
			x_crack.spacing=le(1);
			
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			%x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
		elseif CasetoRun==214 || CasetoRun==221 || CasetoRun==220
			%just adding the bogus crack here
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			
			%TDL adjusting initial crack energy problem
			
			%first initial crack in the middle below, both tips are active
			%{
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1:2,1:2,2)=[ ...
			3.5 3
			3.5 4 ...
			]*le_base; %x y;x y
			
			%second initial crack on the edge below, one tip is terminated, the other is alive
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.5
			5.5 3.5 ...
			]*le_base;
			x_crack.terminatedprop(3,1)=1;
			%}
			%below is some global definitions:
			
			x_crack.npaths=2;
			x_crack.nparticles(2)=3;
			x_crack.center(1:3,1:2,2)=[ ...
			5.5 3.5
			5.0 3.5
			4.5 3.5 ...
			]*le_base; %x y;x y
			x_crack.spacing=1.25*le(1)/2;
			x_crack.terminatedprop(2,2)=1;
			
			for ipath=1:x_crack.npaths
			for itip=1:2
				if x_crack.terminatedprop(ipath,itip)==0
					x_crack.boxcalc.active(ipath,itip)=1;
				else
					x_crack.boxcalc.active(ipath,itip)=0;
				end
			end
			end
			x_crack.spacing=le(1);
			
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			%x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(3,2)=1;
			%x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
		elseif CasetoRun==217 || CasetoRun==229 || CasetoRun==228
			%just adding the bogus crack here
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			
			for ipath=1:x_crack.npaths
			for itip=1:2
				if x_crack.terminatedprop(ipath,itip)==0
					x_crack.boxcalc.active(ipath,itip)=1;
				else
					x_crack.boxcalc.active(ipath,itip)=0;
				end
			end
			end
			
			x_crack.spacing=1.25*le(1)/2;
			
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			%x_crack.cohesivepath(3)=1;
			%x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
		elseif CasetoRun==218
			%just adding the bogus crack here
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			
			%TDL adjusting initial crack energy problem
			
			%first initial crack in the middle below, both tips are active
			
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1:2,1:2,2)=[ ...
			3.25 3
			3.75 4 ...
			]*le_base; %x y;x y
			
			%second initial crack on the edge below, one tip is terminated, the other is alive
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.5
			5.5 3.5 ...
			]*le_base;
			x_crack.terminatedprop(3,1)=1;
			
			
			for ipath=1:x_crack.npaths
			for itip=1:2
				if x_crack.terminatedprop(ipath,itip)==0
					x_crack.boxcalc.active(ipath,itip)=1;
				else
					x_crack.boxcalc.active(ipath,itip)=0;
				end
			end
			end
			x_crack.spacing=1.25*le(1)/2;
			
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			%x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(3,2)=1;
			%x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
		elseif CasetoRun==216
			%just adding the bogus crack here
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			
			%TDL adjusting initial crack energy problem
			
			%first initial crack in the middle below, both tips are active
			
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1:2,1:2,2)=[ ...
			3.475 3
			3.525 4 ...
			]*le_base; %x y;x y
			
			%second initial crack on the edge below, one tip is terminated, the other is alive
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.5
			5.5 3.5 ...
			]*le_base;
			x_crack.terminatedprop(3,1)=1;
			
			
			for ipath=1:x_crack.npaths
			for itip=1:2
				if x_crack.terminatedprop(ipath,itip)==0
					x_crack.boxcalc.active(ipath,itip)=1;
				else
					x_crack.boxcalc.active(ipath,itip)=0;
				end
			end
			end
			x_crack.spacing=1.25*le(1)/2;
			
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			%x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(3,2)=1;
			%x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
		elseif CasetoRun==213 || CasetoRun==215
			%just adding the bogus crack here
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			
			%TDL adjusting initial crack energy problem
			
			%first initial crack in the middle below, both tips are active
			
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1:2,1:2,2)=[ ...
			3.5 3
			3.5 4 ...
			]*le_base; %x y;x y
			
			%second initial crack on the edge below, one tip is terminated, the other is alive
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.5
			5.5 3.5 ...
			]*le_base;
			x_crack.terminatedprop(3,1)=1;
			
			
			for ipath=1:x_crack.npaths
			for itip=1:2
				if x_crack.terminatedprop(ipath,itip)==0
					x_crack.boxcalc.active(ipath,itip)=1;
				else
					x_crack.boxcalc.active(ipath,itip)=0;
				end
			end
			end
			x_crack.spacing=1.25*le(1)/2;
			
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			%x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(3,2)=1;
			%x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
		elseif CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227
			%just adding the bogus crack here
			%TDL crack definition for 219
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			
			%{
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1,1,2)=4.5*le_base;
			x_crack.center(1,2,2)=5*le_base;
			x_crack.center(2,1,2)=4.5*le_base;
			x_crack.center(2,2,2)=3.5*le_base;
			x_crack.terminatedprop(2,1)=0;
			x_crack.terminatedprop(2,2)=1;
			%}
			
			%now adding the new predefined crack paths
			%{
			x_crack.npaths=9;
			x_crack.nparticles(2)=5;
			x_crack.nparticles(3)=5;
			x_crack.nparticles(4)=5;
			x_crack.nparticles(5)=5;
			x_crack.nparticles(6)=5;
			x_crack.nparticles(7)=5;
			x_crack.nparticles(8)=5;
			x_crack.nparticles(9)=5;
			
			x_crack.terminatedprop(2,:)=[1	0];
			x_crack.terminatedprop(3,:)=[1	0];
			x_crack.terminatedprop(4,:)=[1	0];
			x_crack.terminatedprop(5,:)=[1	0];
			x_crack.terminatedprop(6,:)=[0	1];
			x_crack.terminatedprop(7,:)=[0	1];
			x_crack.terminatedprop(8,:)=[0	1];
			x_crack.terminatedprop(9,:)=[0	1];
			
			
			x_crack.center(1:5,:,2)=[ ... 
				497.325887	483.3477064;
				488.0023928	461.1126079;
				478.6363426	438.8800685;
				469.3395359	416.6356408;
				460.0176084	394.4197291];

			x_crack.center(1:5,:,3)=[ ... 
				702.674113	483.3477064;
				711.9976072	461.1126079;
				721.3636574	438.8800684;
				730.6604641	416.6356408;
				739.9823916	394.4197291];
				
			x_crack.center(1:5,:,4)=[ ... 
				383.3477064	597.325887;
				361.1126079	588.0023928;
				338.8800684	578.6363426;
				316.6356408	569.3395359;
				294.4197291	560.0176084];
				
			x_crack.center(1:5,:,5)=[ ... 
				816.6522936	597.325887;
				838.8873921	588.0023928;
				861.1199316	578.6363426;
				883.3643592	569.3395359;
				905.5802709	560.0176084];
				
			x_crack.center(1:5,:,6)=[ ... 
				294.4197291	839.9823916;
				316.6356408	830.6604641;
				338.8800684	821.3636574;
				361.1126079	811.9976072;
				383.3477064	802.674113];
				
			x_crack.center(1:5,:,7)=[ ... 
				905.5802709	839.9823916;
				883.3643592	830.6604641;
				861.1199316	821.3636574;
				838.8873921	811.9976072;
				816.6522936	802.674113];
				
			x_crack.center(1:5,:,8)=[ ... 
				460.0176084	1005.580271;
				469.3395359	983.3643592;
				478.6363426	961.1199316;
				488.0023928	938.8873921;
				497.325887	916.6522936];
				
			x_crack.center(1:5,:,9)=[ ... 
				739.9823916	1005.580271;
				730.6604641	983.3643592;
				721.3636574	961.1199316;
				711.9976072	938.8873921;
				702.674113	916.6522936];
			%}
			
			
			
			for ipath=1:x_crack.npaths
			for itip=1:2
				if x_crack.terminatedprop(ipath,itip)==0
					x_crack.boxcalc.active(ipath,itip)=1;
				else
					x_crack.boxcalc.active(ipath,itip)=0;
				end
			end
			end
			x_crack.spacing=1.25*le(1)/2;
		elseif CasetoRun==205 || CasetoRun==207
			%just adding the bogus crack here
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
		elseif CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209
			%fracture parameters initiation for 200
			x_crack.npaths=3;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			%x_crack.terminatedprop(2,1)=1;
			
			x_crack.nparticles(2)=2;
			x_crack.center(1,1,2)=3.5*le_base; %tip in the middle
			x_crack.center(1,2,2)=4*le_base+1.5*le(2);
			x_crack.center(2,1,2)=3.5*le_base; %tip outside
			x_crack.center(2,2,2)=3*le_base;
			
			x_crack.nparticles(3)=2;
			x_crack.center(1,1,3)=4.5*le_base; %tip in the middle
			x_crack.center(1,2,3)=4*le_base+1.5*le(2);
			x_crack.center(2,1,3)=4.5*le_base; %tip outside
			x_crack.center(2,2,3)=3*le_base;
			
			%TDL x_crack switcher here!
			x_crack.center(1,1,2)=2*le(1)+0.01;
			x_crack.center(1,2,2)=le(2)+0.01;
			x_crack.center(2,1,2)=2*le(1)+0.011;
			x_crack.center(2,2,2)=le(2)+0.011;
			
			%x_crack.center(1,1,3)=3*le(1)+0.01;
			%x_crack.center(1,2,3)=le(2)+0.01;
			%x_crack.center(2,1,3)=3*le(1)+0.011;
			%x_crack.center(2,2,3)=le(2)+0.011;
			
			x_crack.terminatedprop(2,1)=1;
			x_crack.terminatedprop(2,2)=1; %you need this always
			%x_crack.terminatedprop(3,1)=1;
			x_crack.terminatedprop(3,2)=1; %you need this always
			
			x_crack.spacing=le(1);
			elasticstrength=1;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base; %[D]TDL delete later %no, need this for fallback
			%x_crack.bridge.deltai1=999*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(2,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.size=1;
		elseif CasetoRun==203
			%fracture parameters initiation for 200
			x_crack.npaths=3;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.terminatedprop(2,1)=1;
			x_crack.nparticles(2)=2;
			x_crack.nparticles(3)=2;
			x_crack.center(1,1,2)=3*le_base-0.5*le(1); %tip in the middle
			x_crack.center(1,2,2)=2.75*le_base;
			x_crack.center(2,1,2)=1*le_base; %replacement for opposite direction or bottom left
			x_crack.center(2,2,2)=2.75*le_base;
			
			x_crack.center(1,1,3)=3*le_base-0.5*le(1); %tip in the middle
			x_crack.center(1,2,3)=(5-0.75)*le_base;
			x_crack.center(2,1,3)=1*le_base; %replacement for opposite direction or bottom left
			x_crack.center(2,2,3)=(5-0.75)*le_base;
			
			x_crack.spacing=le(1);
			
			elasticstrength=1;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base; %[D]TDL delete later %no, need this for fallback
			%x_crack.bridge.deltai1=999*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
			x_crack.cohesivepoint(2,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.size=1;
		elseif CasetoRun==211
			%fracture parameters initiation for 200
			%TDL experimenting with initial cracks for 211
			x_crack.npaths=2;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.terminatedprop(2,1)=1;
			x_crack.nparticles(2)=2;
			x_crack.center(1,1,2)=3*le_base-0.5*le(1); %tip in the middle
			x_crack.center(1,2,2)=3.5*le_base;
			x_crack.center(2,1,2)=1*le_base; %replacement for opposite direction or bottom left
			x_crack.center(2,2,2)=2*le_base;
			
			%{
			x_crack.center(1:2,1,2)=x_crack.center(1:2,1,2)-0.375*le(1); %tip in the middle
			x_crack.center(2,2,2)=x_crack.center(1,2,2);
		
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1,:,3)=[587.5 500];
			x_crack.center(2,:,3)=[587.5 900];
			%x_crack.center(1,:,3)=[650 500];
			%x_crack.center(2,:,3)=[650 900];
			%x_crack.center(1,:,3)=[687.5 500];
			%x_crack.center(2,:,3)=[687.5 900];
			x_crack.terminatedprop(3,1)=1;
			x_crack.terminatedprop(3,2)=1;
			%}
			
			x_crack.spacing=le(1);
			
			elasticstrength=1;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base; %[D]TDL delete later %no, need this for fallback
			%x_crack.bridge.deltai1=999*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
			x_crack.cohesivepoint(2,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.size=1;
			
			for ipath=1:x_crack.npaths
			for itip=1:2
				if x_crack.terminatedprop(ipath,itip)==0
					x_crack.boxcalc.active(ipath,itip)=1;
				else
					x_crack.boxcalc.active(ipath,itip)=0;
				end
			end
			end
		elseif CasetoRun==200
			%fracture parameters initiation for 200
			x_crack.npaths=2;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.terminatedprop(2,1)=1;
			x_crack.nparticles(2)=2;
			x_crack.center(1,1,2)=3*le_base-0.5*le(1); %tip in the middle
			x_crack.center(1,1,2)=3*le_base-0.15*le(1); %replacement for opposite direction or bottom left
			
			x_crack.center(1,2,2)=3.25*le_base;
			x_crack.center(2,1,2)=5*le_base; %tip outside
			x_crack.center(2,1,2)=1*le_base; %replacement for opposite direction or bottom left
			
			x_crack.center(2,2,2)=3.25*le_base;
			x_crack.center(2,2,2)=1.25*le_base; %replacement for bottom left
			
			x_crack.spacing=le(1);
			elasticstrength=1;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base; %[D]TDL delete later %no, need this for fallback
			%x_crack.bridge.deltai1=999*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepath(3)=1;
			x_crack.cohesivepath(2)=1;%delete this after, for experiment of no cohesion only
			x_crack.cohesivepath(3)=1;%delete this after, for experiment of no cohesion only
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.size=1;
		elseif CasetoRun==199 
			x_crack.npaths=2;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.nparticles(2)=2;
			x_crack.center(1,1,2)=3*le_base;
			x_crack.center(1,2,2)=3.25*le_base;
			x_crack.center(2,1,2)=5*le_base;
			x_crack.center(2,2,2)=3.25*le_base;
			elasticstrength=2;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.size=1;
			%[D]TDL fix parameters above, screwed up
		elseif CasetoRun==179 
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
		elseif CasetoRun==177 || CasetoRun==178
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1,1,2)=le(1)+0.01+0.001;
			x_crack.center(1,2,2)=le(2)+0.01;
			x_crack.center(2,1,2)=le(1)+0.011+0.001;
			x_crack.center(2,2,2)=le(2)+0.011;
			x_crack.terminatedprop(2,1)=1;
			x_crack.terminatedprop(2,2)=1;
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.5
			5.5 3.5 ...
			];
			x_crack.terminatedprop(3,1)=1;
			x_crack.terminatedprop(3,2)=0;
		elseif CasetoRun==182 || CasetoRun==189
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;

			x_crack.npaths=2;
			midarc.alpha.deltay=zeros(1,1); %line angle at middle
			midarc.alpha.deltax=zeros(1,1); %line angle at middle
			midarc.thetai=zeros(1,1); %arc angle at middle
			midarc.Ai=zeros(1,1); %arc amplitude
			midarc.xci=zeros(1,1); %x position of x center, calculated
			midarc.thetaend=zeros(1,1); %arc angle end, which is less than zero
			midarc.thetastart=zeros(1,1); %arc angle start, which is zero
			midarc.npoints=zeros(1,1); %number of points for the crack
			midarc.s=zeros(1,1); %side of specimen
			midarc.ytop=zeros(1,1); %top tip of the middle crack relative to bottom left corner of the specimen
			midarc.ybot=zeros(1,1); %bot tip of the middle crack relative to bottom left corner of the specimen
			midarc.generate.thetatrial=zeros(1,1);
			midarc.generate.xtrial=zeros(1,1);
			midarc.generate.ytrial=zeros(1,1);
			midarc.generate.A=zeros(1,1); %arc amplitude for generation
			midarc.generate.xc=zeros(1,1); %center of arc relative to bottom left corner of the specimen
			midarc.generate.yc=zeros(1,1); %center of arc relative to bottom left corner of the specimen
			
			midarc.npoints=11;
			midarc.ytop=(4-2)*le_base;
			midarc.ybot=(3-2)*le_base;
			midarc.s=3*le_base;
			midarc.alpha.deltay=(4-3)*le_base;
			midarc.alpha.deltax=(3.75-3.25)*le_base;
			midarc.thetai=reliableatan(midarc.alpha.deltay,-midarc.alpha.deltax); %yes it is flipped. it is noted that reliableatan takes (deltax,deltay) as input. it was flipped for the reason of theta=one over minus alpha
			midarc.Ai=abs(1/sin(midarc.thetai)*(midarc.s/2-midarc.ytop));
			midarc.xci=midarc.s/2-midarc.Ai*cos(midarc.thetai);
			midarc.thetaend=asin(1/midarc.Ai*(midarc.ybot-midarc.ytop));
			midarc.thetastart=0;
			midarc.generate.A=midarc.Ai;
			midarc.generate.yc=midarc.ytop;
			midarc.generate.xc=midarc.xci;
			for ipoint=1:midarc.npoints
				midarc.generate.thetatrial=midarc.thetastart+(midarc.thetaend-midarc.thetastart)/(midarc.npoints-1)*(ipoint-1);
				midarc.generate.xtrial=midarc.generate.xc+midarc.generate.A*cos(midarc.generate.thetatrial);
				midarc.generate.ytrial=midarc.generate.yc+midarc.generate.A*sin(midarc.generate.thetatrial);
				x_crack.center(ipoint,1,x_crack.npaths)=midarc.generate.xtrial+2*le_base;
				x_crack.center(ipoint,2,x_crack.npaths)=midarc.generate.ytrial+2*le_base;
			end
			
			disp('x_crack.center(1:5,1,2)=')
			disp(x_crack.center(1:5,1,2))
			disp('x_crack.center(1:5,2,2)=')
			disp(x_crack.center(1:5,2,2))

			x_crack.nparticles(2)=midarc.npoints;
			
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.5
			5.5 3.5 ...
			];
			
			x_crack.terminatedprop(3,1)=1;
			x_crack.spacing=le(1)/2;
			x_crack.bridge.kbase1=1e99;
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.kbase2(:,:)=1e99;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.002;
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(x_crack.nparticles(2),2)=1;
			x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.values(2)=3;
			x_crack.bridge.pathcompletemonitor.size=2;

		elseif CasetoRun==183
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
		elseif CasetoRun==185
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.npaths=2;
			x_crack.nparticles(2)=9;
			x_crack.center(1:x_crack.nparticles(x_crack.npaths),1:2,x_crack.npaths)=[ ...
			3.5 3.5
			3.75 3.5
			4 3.5
			4.25 3.5
			4.5 3.5
			4.75 3.5
			5.0 3.5
			5.26 3.5
			5.51 3.5 ...
			]; %x y;x y
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(3,2)=1;
			x_crack.cohesivepoint(4,2)=1;
			x_crack.cohesivepoint(5,2)=1;
			x_crack.cohesivepoint(6,2)=1;
			x_crack.cohesivepoint(7,2)=0;
			x_crack.cohesivepoint(8,2)=0;
			x_crack.cohesivepoint(9,2)=0;
			x_crack.spacing=0.25;
			x_crack.bridge.kbase1=1e99;
			x_crack.bridge.yieldforce1=E*0.000002;
			for ipath=1:x_crack.npaths
				if x_crack.cohesivepath(ipath)==1
					for iparticle=1:x_crack.nparticles(ipath)
						if x_crack.cohesivepoint(iparticle,ipath)==1
							%x_crack.force.top(iparticle,1,ipath)=10;
							%x_crack.force.bot(iparticle,1,ipath)=-10;
							x_crack.bridge.kbase2(:,:)=1e99;
							x_crack.bridge.yieldforce2(:,:)=E*0.000002;
						end
					end
				end
			end
			x_crack.bridge.deltai1=0.00002;
			x_crack.terminatedprop(2,1)=0;
			x_crack.terminatedprop(2,2)=0;
		elseif CasetoRun==193
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			elasticstrength=25;
			x_crack.npaths=2;
			x_crack.spacing=le(1)/2;
			x_crack.npaths=2;
			x_crack.nparticles(2)=17;
			x_crack.center(1:x_crack.nparticles(x_crack.npaths),1:2,x_crack.npaths)=[ ...
			1.49 3.5
			1.74 3.5
			2.0 3.5
			2.25 3.5
			2.5 3.5
			2.75 3.5
			3 3.5
			3.25 3.5
			3.5 3.5
			3.75 3.5
			4 3.5
			4.25 3.5
			4.5 3.5
			4.75 3.5
			5.0 3.5
			5.26 3.5
			5.51 3.5 ...
			]*le_base; %x y;x y
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepoint(1,2)=0;
			x_crack.cohesivepoint(2,2)=0;
			x_crack.cohesivepoint(3,2)=0;
			x_crack.cohesivepoint(4,2)=1;
			x_crack.cohesivepoint(5,2)=1;
			x_crack.cohesivepoint(6,2)=1;
			x_crack.cohesivepoint(7,2)=1;
			x_crack.cohesivepoint(8,2)=1;
			x_crack.cohesivepoint(9,2)=1;
			x_crack.cohesivepoint(10,2)=1;
			x_crack.cohesivepoint(11,2)=1;
			x_crack.cohesivepoint(12,2)=1;
			x_crack.cohesivepoint(13,2)=1;
			x_crack.cohesivepoint(14,2)=1;
			x_crack.cohesivepoint(15,2)=0;
			x_crack.cohesivepoint(16,2)=0;
			x_crack.cohesivepoint(17,2)=0;
			x_crack.bridge.deltai1=0.2*le_base;
			x_crack.bridge.deltae=1*x_crack.bridge.deltai1;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=1e99;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.terminatedprop(2,1)=0;
			x_crack.terminatedprop(2,2)=0;
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.size=1;
		elseif CasetoRun==186
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			elasticstrength=25;
			x_crack.npaths=2;
			x_crack.cohesivepath(2)=1;
			x_crack.spacing=le(1)/2;
			for iparticle=1:99999
				x_crack_trial=(4.25*le_base+(iparticle-1)*x_crack.spacing);
				if x_crack_trial>5*le_base+le(1)
					x_crack.nparticles(x_crack.npaths)=iparticle-1;
					break;
				end
				x_crack.center(iparticle,:,x_crack.npaths)=[x_crack_trial 3.5*le_base];
				%if iparticle>1 && x_crack_trial<=5
				%	x_crack.cohesivepoint(iparticle,x_crack.npaths)=1;
				%end
			end
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			%x_crack.bridge.kbase1=1e99;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			
			x_crack.terminatedprop(2,1)=0;
			x_crack.terminatedprop(2,2)=0;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.size=1;
		elseif CasetoRun==184
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.npaths=2;
			x_crack.nparticles(2)=17;
			x_crack.center(1:x_crack.nparticles(x_crack.npaths),1:2,x_crack.npaths)=[ ...
			1.49 3.5
			1.74 3.5
			2.0 3.5
			2.25 3.5
			2.5 3.5
			2.75 3.5
			3 3.5
			3.25 3.5
			3.5 3.5
			3.75 3.5
			4 3.5
			4.25 3.5
			4.5 3.5
			4.75 3.5
			5.0 3.5
			5.26 3.5
			5.51 3.5 ...
			]; %x y;x y
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepoint(1,2)=0;
			x_crack.cohesivepoint(2,2)=0;
			x_crack.cohesivepoint(3,2)=0;
			x_crack.cohesivepoint(4,2)=1;
			x_crack.cohesivepoint(5,2)=1;
			x_crack.cohesivepoint(6,2)=1;
			x_crack.cohesivepoint(7,2)=1;
			x_crack.cohesivepoint(8,2)=1;
			x_crack.cohesivepoint(9,2)=1;
			x_crack.cohesivepoint(10,2)=1;
			x_crack.cohesivepoint(11,2)=1;
			x_crack.cohesivepoint(12,2)=1;
			x_crack.cohesivepoint(13,2)=1;
			x_crack.cohesivepoint(14,2)=1;
			x_crack.cohesivepoint(15,2)=0;
			x_crack.cohesivepoint(16,2)=0;
			x_crack.cohesivepoint(17,2)=0;
			x_crack.bridge.kbase1=E/100;
			x_crack.bridge.yieldforce1=E*0.002;
			for ipath=1:x_crack.npaths
				if x_crack.cohesivepath(ipath)==1
					for iparticle=1:x_crack.nparticles(ipath)
						if x_crack.cohesivepoint(iparticle,ipath)==1
							%x_crack.force.top(iparticle,1,ipath)=10;
							%x_crack.force.bot(iparticle,1,ipath)=-10;
							x_crack.bridge.kbase2(iparticle,ipath)=E/100;
							x_crack.bridge.yieldforce2(iparticle,ipath)=E*0.002;
						end
					end
				end
			end
			x_crack.bridge.deltai1=0.4;
			x_crack.terminatedprop(2,1)=1;
			x_crack.terminatedprop(2,2)=1;
		elseif CasetoRun==197
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1:2,1:2,2)=[ ...
			3.475 3
			3.525 4 ...
			]*le_base; %x y;x y
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.5
			5.5 3.5 ...
			]*le_base;
			x_crack.terminatedprop(3,1)=1;
			x_crack.spacing=le(1)/2;
			%x_crack.bridge.kbase1=1e99;
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.values(2)=3;
			x_crack.bridge.pathcompletemonitor.size=2;
			x_crack.tiprename(6)=1;
			x_crack.tiprename(3)=2;
			x_crack.tiprename(4)=3;
		elseif CasetoRun==196
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1:2,1:2,2)=[ ...
			3.25 3
			3.75 4 ...
			]*le_base; %x y;x y
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.5
			5.5 3.5 ...
			]*le_base;
			x_crack.terminatedprop(3,1)=1;
			x_crack.spacing=le(1)/2;
			%x_crack.bridge.kbase1=1e99;
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.values(2)=3;
			x_crack.bridge.pathcompletemonitor.size=2;
		elseif CasetoRun==198
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1:2,1:2,2)=[ ...
			3.5 3
			3.5 4 ...
			]*le_base; %x y;x y
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.65
			5.5 3.65 ...
			]*le_base;
			x_crack.terminatedprop(3,1)=1;
			x_crack.spacing=le(1)/2;
			%x_crack.bridge.kbase1=1e99;
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.values(2)=3;
			x_crack.bridge.pathcompletemonitor.size=2;
		elseif CasetoRun==212
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1:2,1:2,2)=[ ...
			3.5 3
			3.5 4 ...
			]*le_base; %x y;x y
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.5
			5.5 3.5 ...
			]*le_base;
			x_crack.terminatedprop(3,1)=1;
			x_crack.spacing=le(1)/2;
			%x_crack.bridge.kbase1=1e99;
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.values(2)=3;
			x_crack.bridge.pathcompletemonitor.size=2;
			x_crack.tiprename(6)=1;
			x_crack.tiprename(3)=2;
			x_crack.tiprename(4)=3;
			for ipath=1:x_crack.npaths
			for itip=1:2
				if x_crack.terminatedprop(ipath,itip)==0
					x_crack.boxcalc.active(ipath,itip)=1;
				else
					x_crack.boxcalc.active(ipath,itip)=0;
				end
			end
			end
		elseif CasetoRun==191 || CasetoRun==195
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1:2,1:2,2)=[ ...
			3.5 3
			3.5 4 ...
			]*le_base; %x y;x y
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.5
			5.5 3.5 ...
			]*le_base;
			x_crack.terminatedprop(3,1)=1;
			x_crack.spacing=le(1)/2;
			%x_crack.bridge.kbase1=1e99;
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.0018*le_base;
			x_crack.bridge.deltae=0.0002*le_base;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.values(2)=3;
			x_crack.bridge.pathcompletemonitor.size=2;
			x_crack.tiprename(6)=1;
			x_crack.tiprename(3)=2;
			x_crack.tiprename(4)=3;
		elseif CasetoRun==168 || CasetoRun==181 || CasetoRun==188
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.npaths=2;
			x_crack.nparticles(2)=2;
			x_crack.center(1:2,1:2,2)=[ ...
			3.25 3
			3.75 4 ...
			]; %x y;x y
			x_crack.npaths=3;
			x_crack.nparticles(3)=2;
			x_crack.center(1:2,1:2,3)=[ ...
			4.5 3.5
			5.5 3.5 ...
			];
			x_crack.terminatedprop(3,1)=1;
			x_crack.spacing=le(1)/2;
			x_crack.bridge.kbase1=1e99;
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.kbase2(:,:)=1e99;
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.002;
			x_crack.cohesivepath(2)=1;
			x_crack.cohesivepath(3)=1;
			x_crack.cohesivepoint(1,2)=1;
			x_crack.cohesivepoint(2,2)=1;
			x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			x_crack.bridge.pathcompletemonitor.values(2)=3;
			x_crack.bridge.pathcompletemonitor.size=2;
		elseif CasetoRun==187
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.spacing=le(1)/2;
			
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane/2;
			
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane/2;
			x_crack.bridge.deltai1=0.002*le_base;
			x_crack.bridge.deltae=0.1*x_crack.bridge.deltai1;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			%x_crack.bridge.kbase1=1e99;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.pathcompletemonitor.size=1;
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			%start of for testing only
			%{
			x_crack.npaths=2;
			x_crack.nparticles(2)=7;
			x_crack.center(1:7,1:2,2)=[ ...
			+4.596752447366979e+000	+3.041619701808984e+000
			+4.696290712550657e+000	+3.051218335265043e+000
			+4.795909705886739e+000	+3.059939259714092e+000
			+4.895901988371145e+000	+3.061184153532690e+000
			+4.975000206978596e+000	+3.000000142189686e+000
			+5.025000185699557e+000	+2.999999910819500e+000
			+5.075000059195514e+000	+2.999999704432420e+000 ...
			];
			x_crack.terminatedprop(2,1)=1;
			x_crack.terminatedprop(2,2)=1;
			%}
			%end of for testing only
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==190
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			x_crack.spacing=le(1)/2;
			
			elasticstrength=25;
			x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
			
			x_crack.bridge.yieldforce2(:,:)=elasticstrength*x_crack.spacing*t0_plane;
			x_crack.bridge.deltai1=0.002*le_base;
			x_crack.bridge.deltae=0.1*x_crack.bridge.deltai1;
			x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
			%x_crack.bridge.kbase1=1e99;
			x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
			x_crack.bridge.pathcompletemonitor.size=1;
			x_crack.bridge.pathcompletemonitor.values(1)=2;
			%start of for testing only
			%{
			x_crack.npaths=2;
			x_crack.nparticles(2)=7;
			x_crack.center(1:7,1:2,2)=[ ...
			+4.596752447366979e+000	+3.041619701808984e+000
			+4.696290712550657e+000	+3.051218335265043e+000
			+4.795909705886739e+000	+3.059939259714092e+000
			+4.895901988371145e+000	+3.061184153532690e+000
			+4.975000206978596e+000	+3.000000142189686e+000
			+5.025000185699557e+000	+2.999999910819500e+000
			+5.075000059195514e+000	+2.999999704432420e+000 ...
			];
			x_crack.terminatedprop(2,1)=1;
			x_crack.terminatedprop(2,2)=1;
			%}
			%end of for testing only
		elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
			%start of for testing only
			%{
			x_crack.npaths=2;
			x_crack.nparticles(2)=7;
			x_crack.center(1:7,1:2,2)=[ ...
			+4.596752447366979e+000	+3.041619701808984e+000
			+4.696290712550657e+000	+3.051218335265043e+000
			+4.795909705886739e+000	+3.059939259714092e+000
			+4.895901988371145e+000	+3.061184153532690e+000
			+4.975000206978596e+000	+3.000000142189686e+000
			+5.025000185699557e+000	+2.999999910819500e+000
			+5.075000059195514e+000	+2.999999704432420e+000 ...
			];
			x_crack.terminatedprop(2,1)=1;
			x_crack.terminatedprop(2,2)=1;
			%}
			%end of for testing only
		elseif CasetoRun==165
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=4.9;
			x_crack.center(1,2,1)=3;
			x_crack.center(2,1,1)=5.1;
			x_crack.center(2,2,1)=3;
			%x_crack.terminatedprop(1,1)=1;
			%x_crack.terminatedprop(1,2)=1;
			%start of for testing only
			x_crack.npaths=2;
			x_crack.nparticles(2)=22;
			x_crack.center(1:22,1:2,2)=[ ...
				+3.091765351281428e+000	+3.022806922837118e+000
				+3.185843691102719e+000	+3.007989220718556e+000
				+3.280977884646035e+000	+3.003541389201554e+000
				+3.376195649669847e+000	+3.001575602330670e+000
				+3.471429631288700e+000	+3.000701515846796e+000
				+3.566666812176795e+000	+3.000309518596676e+000
				+3.661904675242100e+000	+3.000135578982751e+000
				+3.757142679368846e+000	+3.000059419167263e+000
				+3.852380722826116e+000	+3.000026428069705e+000
				+3.947618807704730e+000	+3.000011979863817e+000
				+4.042856908329258e+000	+3.000005392529500e+000
				+4.138094987221649e+000	+3.000003264944478e+000
				+4.233333045219497e+000	+3.000001493655222e+000
				+4.328571099602669e+000	+3.000000882780074e+000
				+4.423809154429415e+000	+3.000000394093565e+000
				+4.519047214425030e+000	+2.999999786064010e+000
				+4.614285281001976e+000	+2.999999901102053e+000
				+4.709523365084847e+000	+3.000000081099648e+000
				+4.804761470287792e+000	+3.000000424946622e+000
				+4.899999560750276e+000	+3.000000000002859e+000
				+5.099999730741565e+000	+3.000000000001138e+000
				+5.299999999999999e+000	+3.000000000000000e+000 ...
				];
			x_crack.terminatedprop(2,1)=0;
			x_crack.terminatedprop(2,2)=0;
			%end of for testing only
		elseif CasetoRun==151
			x_crack_unused=cell(1,2);
			%x_crackcenter=coder.nullcopy(x_crack_unused);
			x_crack.npaths=2;
			x_crack.nparticles(1:2)=2;
			%x_crack.center=zeros(2,2,10);
			%x_crack.top=zeros(2,2,10);
			%x_crack.bot=zeros(2,2,10);
			
			x_crack_temp=[6 3;4.5 3]*le_base+[2 0;0 0]*le(1)+[pi pi;pi pi]/50;
			x_crack.center(1,1,1)=x_crack_temp(1,1);
			x_crack.center(1,2,1)=x_crack_temp(1,2);
			x_crack.center(2,1,1)=x_crack_temp(2,1);
			x_crack.center(2,2,1)=x_crack_temp(2,2);
			
			x_crack_temp=[3+0.5*cos(pi/2) 3+0.5*sin(pi/2);3-0.5*cos(pi/2) 3-0.5*sin(pi/2)]*le_base;
			x_crack.center(1,1,2)=x_crack_temp(1,1);
			x_crack.center(1,2,2)=x_crack_temp(1,2);
			x_crack.center(2,1,2)=x_crack_temp(2,1);
			x_crack.center(2,2,2)=x_crack_temp(2,2);
		elseif CasetoRun==125 || CasetoRun==126
			x_crack_unused=cell(1,2);
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			
			x_crack_temp=[6 3;4.5 3]*le_base+[2 0;0 0]*le(1)+[pi pi;pi pi]/50;
			x_crack.center(1,1,1)=x_crack_temp(1,1);
			x_crack.center(1,2,1)=x_crack_temp(1,2);
			x_crack.center(2,1,1)=x_crack_temp(2,1);
			x_crack.center(2,2,1)=x_crack_temp(2,2);
		elseif CasetoRun==127
			x_crack_unused=cell(1,2);
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			
			x_crack_temp=[6 3;4.5 3]*le_base+[2 0;0 0]*le(1)+[pi 0;pi 0]/50;
			x_crack.center(1,1,1)=x_crack_temp(1,1);
			x_crack.center(1,2,1)=x_crack_temp(1,2);
			x_crack.center(2,1,1)=x_crack_temp(2,1);
			x_crack.center(2,2,1)=x_crack_temp(2,2);
		elseif CasetoRun==128
			x_crack_unused=cell(1,2);
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			
			x_crack_temp=[6 3;4.5 3]*le_base+[2 0;0 0]*le(1)+[1 0;1 0]*le_base/4-[pi 0;pi 0]/50;
			x_crack.center(1,1,1)=x_crack_temp(1,1);
			x_crack.center(1,2,1)=x_crack_temp(1,2);
			x_crack.center(2,1,1)=x_crack_temp(2,1);
			x_crack.center(2,2,1)=x_crack_temp(2,2);
		elseif CasetoRun==129 || CasetoRun==132
			x_crack_unused=cell(1,2);
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			
			x_crack_temp=[6 3;4.5 3]*le_base+[2 0;0 0]*le(1)+[pi 0;pi 0]/50+[0 1;0 1]*le_base/8;
			x_crack.center(1,1,1)=x_crack_temp(1,1);
			x_crack.center(1,2,1)=x_crack_temp(1,2);
			x_crack.center(2,1,1)=x_crack_temp(2,1);
			x_crack.center(2,2,1)=x_crack_temp(2,2);
		elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			x_crack_unused=cell(1,2);
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			
			x_crack_temp=[10 3;4.5 3]*le_base+[2 0;0 0]*le(1)+[pi 0;pi 0]/50+[0 1;0 1]*le_base/8;
			x_crack.center(1,1,1)=x_crack_temp(1,1);
			x_crack.center(1,2,1)=x_crack_temp(1,2);
			x_crack.center(2,1,1)=x_crack_temp(2,1);
			x_crack.center(2,2,1)=x_crack_temp(2,2);
		elseif CasetoRun==130
			x_crack_unused=cell(1,2);
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			
			x_crack_temp=[6 3;4.5 3]*le_base+[2 0;0 0]*le(1)+[1 0;1 0]*le_base/4-[pi 0;pi 0]/50+[0 1;0 1]*le_base/8;
			x_crack.center(1,1,1)=x_crack_temp(1,1);
			x_crack.center(1,2,1)=x_crack_temp(1,2);
			x_crack.center(2,1,1)=x_crack_temp(2,1);
			x_crack.center(2,2,1)=x_crack_temp(2,2);
		end
		%{
		if CasetoRun==117
			x_crackcenter{1}=[0.5 3;
						3-pi*1e-5 3-pi*1e-5;
				3-pi*1e-5+2.5 3]*le_base;
		end
		x_defaultcracktip=[3 3]*le_base;
		%}
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
				
		%x_crack.top=x_crack.center;
		%x_crack.bot=x_crack.center;
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				if CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166
					if x_trial>5*le_base
						if y_trial>3*le_base-le(1)
							if y_trial<3*le_base+le(1)
								continue;
							end
						end
					end
				elseif CasetoRun==169
					if x_trial>4.5*le_base || x_trial<2.5*le_base
						if y_trial>3.5*le_base-le(1)
							if y_trial<3.5*le_base+le(1)
								continue;
							end
						end
					end
				elseif CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==206 || CasetoRun==209 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220
				elseif CasetoRun==205 || CasetoRun==210 || CasetoRun==207
					delta_x_trial=[x_trial-x_center y_trial-y_center];
					r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
					if r_trial>r_cylinder
						continue;
					end
				elseif CasetoRun==201
					if (x_trial<3*le_base-le(1) && y_trial<3.5*le_base+le(2) && y_trial>3.5*le_base-2*le(2)) || (x_trial<3*le_base && y_trial<3.5*le_base && y_trial>3.5*le_base-le(2))
						continue;
					end
				elseif CasetoRun==179 
					if y_trial>3*le_base && y_trial<4*le_base && (x_trial<2.5*le_base || x_trial>3.5*le_base)
						continue;
					end
				elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==187 || CasetoRun==217
					%the application of notch #1
					if x_trial>4.5*le_base
						if y_trial>3.5*le_base-le(1)
							if y_trial<3.5*le_base+le(1)
								continue;
							end
						end
					end
				elseif CasetoRun==228
					if theway==2 || theway==3
						itsasquishyball=0;
						for knotnum=1:length(knot_x)
							if ((x_trial-knot_x(knotnum))*cos(knot_theta(knotnum))+(y_trial-knot_y(knotnum))*sin(knot_theta(knotnum)))^2/knot_rx(knotnum)^2+((x_trial-knot_x(knotnum))*sin(knot_theta(knotnum))-(y_trial-knot_y(knotnum))*cos(knot_theta(knotnum)))^2/knot_ry(knotnum)^2<1
								itsasquishyball=1;
							end
						end
						if itsasquishyball
							continue;
						end
					else%if theway==1
						itsasquishyball=0;
						for knotnum=1:length(knot_x)
							if ((x_trial-knot_x(knotnum))*cos(knot_theta(knotnum))+(y_trial-knot_y(knotnum))*sin(knot_theta(knotnum)))^2/knot_rx(knotnum)^2+((x_trial-knot_x(knotnum))*sin(knot_theta(knotnum))-(y_trial-knot_y(knotnum))*cos(knot_theta(knotnum)))^2/knot_ry(knotnum)^2<1
								itsasquishyball=1;
							end
						end
						if itsasquishyball
							continue;
						end
					end
				elseif CasetoRun==190
					if x_trial>4.5*le_base || x_trial<2.5*le_base
						if y_trial>3.5*le_base-le(1)
							if y_trial<3.5*le_base+le(1)
								continue;
							end
						end
					end
				elseif CasetoRun==165
					if x_trial>5*le_base
						if y_trial>3*le_base-1.5*le(1)
							if y_trial<3*le_base+1.5*le(1)
								continue;
							end
						end
					end
				end
				
				sp=sp+1;
				
				if x_trial>4*le_base-lp(1)
					if y_trial>4*le_base-lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						normalcorner_counter=normalcorner_counter+1;
					elseif y_trial<2*le_base+lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						normalcorner_counter=normalcorner_counter+1;
					else
						tractionededge_counter=tractionededge_counter+1;
						normaledge_counter=normaledge_counter+1;
					end
				elseif y_trial>4*le_base-lp(2)
					tractionededge_counter=tractionededge_counter+1;
					normaledge_counter=normaledge_counter+1;
				elseif y_trial<2*le_base+lp(2)
					tractionededge_counter=tractionededge_counter+1;
					normaledge_counter=normaledge_counter+1;
				end
				
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
				%	ParticleswithPredYVel(1)=sp;
				%end
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
				%	ParticleswithPredYVel(2)=sp;
				%end
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);
		
		matmodel=zeros(1,spCount);
		uncrackable_sp=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		alphahp=zeros(spCount,7);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);
		depth_sp=zeros(1,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		
		%TDL particle deletion starts here
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell)
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell)
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				if CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166
					if x_trial>5*le_base
						if y_trial>3*le_base-le(1)
							if y_trial<3*le_base+le(1)
								continue;
							end
						end
					end
				elseif CasetoRun==169
					if x_trial>4.5*le_base || x_trial<2.5*le_base
						if y_trial>3.5*le_base-le(1)
							if y_trial<3.5*le_base+le(1)
								continue;
							end
						end
					end
				elseif CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==206 || CasetoRun==209 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220
				elseif CasetoRun==205 || CasetoRun==210 || CasetoRun==207
					delta_x_trial=[x_trial-x_center y_trial-y_center];
					r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
					if r_trial>r_cylinder
						continue;
					end
				elseif CasetoRun==201
					if (x_trial<3*le_base-le(1) && y_trial<3.5*le_base+le(2) && y_trial>3.5*le_base-2*le(2)) || (x_trial<3*le_base && y_trial<3.5*le_base && y_trial>3.5*le_base-le(2))
						continue;
					end
				elseif CasetoRun==179 
					if y_trial>3*le_base && y_trial<4*le_base && (x_trial<2.5*le_base || x_trial>3.5*le_base)
						continue;
					end
				elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==187 || CasetoRun==217
					%the application of notch #2
					if x_trial>4.5*le_base
						if y_trial>3.5*le_base-le(1)
							if y_trial<3.5*le_base+le(1)
								continue;
							end
						end
					end
				elseif CasetoRun==228
					if theway==2 || theway==3
						itsasquishyball=0;
						for knotnum=1:length(knot_x)
							if ((x_trial-knot_x(knotnum))*cos(knot_theta(knotnum))+(y_trial-knot_y(knotnum))*sin(knot_theta(knotnum)))^2/knot_rx(knotnum)^2+((x_trial-knot_x(knotnum))*sin(knot_theta(knotnum))-(y_trial-knot_y(knotnum))*cos(knot_theta(knotnum)))^2/knot_ry(knotnum)^2<1
								itsasquishyball=1;
							end
						end
						if itsasquishyball
							continue;
						end
					else%if theway==1
						itsasquishyball=0;
						for knotnum=1:length(knot_x)
							if ((x_trial-knot_x(knotnum))*cos(knot_theta(knotnum))+(y_trial-knot_y(knotnum))*sin(knot_theta(knotnum)))^2/knot_rx(knotnum)^2+((x_trial-knot_x(knotnum))*sin(knot_theta(knotnum))-(y_trial-knot_y(knotnum))*cos(knot_theta(knotnum)))^2/knot_ry(knotnum)^2<1
								itsasquishyball=1;
							end
						end
						if itsasquishyball
							continue;
						end
					end
				elseif CasetoRun==190
					if x_trial>4.5*le_base || x_trial<2.5*le_base
						if y_trial>3.5*le_base-le(1)
							if y_trial<3.5*le_base+le(1)
								continue;
							end
						end
					end
				elseif CasetoRun==165
					if x_trial>5*le_base
						if y_trial>3*le_base-1.5*le(1)
							if y_trial<3*le_base+1.5*le(1)
								continue;
							end
						end
					end
				end
				
				sp=sp+1;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				%TDL shrinkage definition here!
				%epsilonshrinkdot_sp(sp)=-0.125*(y_trial-2*le_base)/(4*le_base-2*le_base);
				if CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==201
					xdirletter{sp}='l';
					ydirletter{sp}='t';
					zdirletter{sp}='r';
					xydirletter{sp}='tl';
					yzdirletter{sp}='rt';
					xzdirletter{sp}='lr';
				elseif CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227
					%TDL xdirletter adjustment for 219
					directionset=2; %direction=1: weak directions; direction=2: strong direction for x
					thetacrackrtl(sp)=NaN;
					if directionset==1
						xdirletter{sp}='t';
						ydirletter{sp}='r';
						zdirletter{sp}='l';
						xydirletter{sp}='tr';
						yzdirletter{sp}='rl';
						xzdirletter{sp}='tl';
					else%if directionset==2
						xdirletter{sp}='l';
						ydirletter{sp}='r';
						zdirletter{sp}='t';
						xydirletter{sp}='lr';
						yzdirletter{sp}='rt';
						xzdirletter{sp}='tl';
					end
				elseif CasetoRun==206 || CasetoRun==209
					xdirletter{sp}='r';
					ydirletter{sp}='t';
					zdirletter{sp}='l';
					xydirletter{sp}='rt';
					yzdirletter{sp}='tl';
					xzdirletter{sp}='rl';
				elseif CasetoRun==210
					%TDL thetacrackrtl NaN claim
					thetacrackrtl(sp)=NaN;
					xdirletter{sp}='t';
					ydirletter{sp}='r';
					zdirletter{sp}='l';
					xydirletter{sp}='rt';
					yzdirletter{sp}='rl';
					xzdirletter{sp}='tl';
				elseif CasetoRun==221
					%{
					xdirletter{sp}='r';
					ydirletter{sp}='t';
					zdirletter{sp}='l';
					xydirletter{sp}='rt';
					yzdirletter{sp}='tl';
					xzdirletter{sp}='rl';
					%}
					xdirletter{sp}='t';
					ydirletter{sp}='r';
					zdirletter{sp}='l';
					xydirletter{sp}='rt';
					yzdirletter{sp}='rl';
					xzdirletter{sp}='tl';
				elseif CasetoRun==217 || CasetoRun==229
					thetacrackrtl(sp)=NaN;
					xdirletter{sp}='r';
					ydirletter{sp}='t';
					zdirletter{sp}='l';
					xydirletter{sp}='rt';
					yzdirletter{sp}='tl';
					xzdirletter{sp}='rl';
				elseif CasetoRun==205 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207
				%TDL xdirletter adjustment here
					thetacrackrtl(sp)=NaN;
					%{
					xdirletter{sp}='r';
					ydirletter{sp}='t';
					zdirletter{sp}='l';
					xydirletter{sp}='rt';
					yzdirletter{sp}='tl';
					xzdirletter{sp}='rl';
					%}
					xdirletter{sp}='t';
					ydirletter{sp}='r';
					zdirletter{sp}='l';
					xydirletter{sp}='rt';
					yzdirletter{sp}='rl';
					xzdirletter{sp}='tl';
				elseif CasetoRun==228
					thetacrackrtl(sp)=NaN;
					if theway==2 || theway==3
						xdirletter{sp}='l';
						ydirletter{sp}='t';
						zdirletter{sp}='r';
						xydirletter{sp}='lt';
						yzdirletter{sp}='tr';
						xzdirletter{sp}='lr';
					else%if theway==1
						xdirletter{sp}='t';
						ydirletter{sp}='l';
						zdirletter{sp}='r';
						xydirletter{sp}='tl';
						yzdirletter{sp}='lr';
						xzdirletter{sp}='tr';
					end
				elseif CasetoRun==212
					xdirletter{sp}='t';
					ydirletter{sp}='r';
					zdirletter{sp}='l';
					xydirletter{sp}='tr';
					yzdirletter{sp}='rl';
					xzdirletter{sp}='tl';
				end
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				matmodel(sp)=4; %crackable elastic
				if CasetoRun==176
					matmodel(sp)=1;
				end
				orientationoffset(sp)=NaN;
				%TDL matmodel switch here
				if CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==201
					matmodel(sp)=1;
					orientationoffset(sp)=0;
				elseif CasetoRun==217 || CasetoRun==229
					%TDL matmodel switch for 217
					%matmodel=1 for wood
					%matmodel=2 for elastic
					matmodel(sp)=1;
					orientationoffset(sp)=0;
				elseif CasetoRun==228
					%TDL orientationoffset for 228
					matmodel(sp)=1;
					orientationoffset(sp)=0;
					if theway==1
						for knotnum=1:1
							if abs(x_trial-knot_x(knotnum))<=knot_xaffect(knotnum) && abs(y_trial-knot_y(knotnum))<=knot_yaffect(knotnum)
								knot_deltax=x_trial-knot_x(knotnum);
								knot_deltay=y_trial-knot_y(knotnum);
								L0=knot_xaffect(knotnum);
								L1=knot_xaffect(knotnum)-knot_x(knotnum);
								h=knot_yaffect(knotnum);
								dxdy=(sign(knot_deltax)*((pi*sin((knot_deltay*pi)/h)*((abs(knot_deltax)-L0) - knot_rx(knotnum) + ((abs(knot_deltax)-L0)^2*((L0 - 2*knot_rx(knotnum))/L0 - 1))/(2*L0) - ((abs(knot_deltax)-L0)*(L0 - 2*knot_rx(knotnum)))/L0))/(2*h)));
								orientationoffset(sp)=atan(-dxdy);
							end
						end
						if x_trial>min(Xlist) && x_trial<max(Xlist) && y_trial>min(Ylist) && y_trial<max(Ylist)
							orientationoffset(sp)=interp2(Xlist,Ylist,thetalist,x_trial,y_trial);
						end
						
						%if ((x_trial>60 & x_trial<(60+lp(1))) & (y_trial<50 & x_trial>(50-lp(2)))) | ((x_trial<90 & x_trial>(90-lp(1))) & (y_trial<50 & x_trial>(50-lp(2))))
						%    troubleshotparticles=[troubleshotparticles sp];
						%end
					else%if theway==2 || theway==3
						if plotignore(sp)
							orientationoffset=VectorInsertion(orientationoffset,sp,0);
						elseif matmodel(sp)==3
							orientationoffset=VectorInsertion(orientationoffset,sp,0);
						elseif y_trial<=13*le_base && y_trial>=7*le_base
							%orientationoffset(sp)=gerhardangles(2*le_base,7*le_base,x_trial,y_trial);
							%orientationoffset(sp)=gerhardanglesellipseonly(x_trial,y_trial,knot_x,knot_y,knot_rx,knot_ry,knot_theta);
							orientationoffset=VectorInsertion(orientationoffset,sp,gerhardanglescombined(2*le_base,7*le_base,x_trial,y_trial,knot_x,knot_y,knot_rx,knot_ry,knot_theta,theway,2));
							if orientationoffset(sp)<0 || orientationoffset(sp)>pi
								fprintf('%s',['angle inccorect' char(10)]);
								pause
								1;
							end
						else
							orientationoffset=VectorInsertion(orientationoffset,sp,pi/2);
						end
					end
				elseif CasetoRun==227
					matmodel(sp)=2;
					orientationoffset(sp)=0;
				elseif CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226
					%TDL matmodel switch for 219
					%matmodel=1 for wood
					%matmodel=2 for elastic
					matmodel(sp)=1;
					orientationoffset(sp)=0;
				elseif CasetoRun==208
					matmodel(sp)=2;
					orientationoffset(sp)=0;
				elseif CasetoRun==206
					matmodel(sp)=1;
					orientationoffset(sp)=pi/2;
				elseif CasetoRun==209
					matmodel(sp)=2;
					orientationoffset(sp)=pi/2;
				elseif CasetoRun==205 || CasetoRun==210 
					%TDL matmodel switch for 210
					%TDL orientationoffset adjust
					%TDL matmodel switch for shrinklog
					matmodel(sp)=1;
					orientationoffset(sp)=reliableatan(delta_x_trial(1),delta_x_trial(2))+pi/2;
					%orientationoffset(sp)=pi/2;
					%orientationoffset(sp)=0;
				elseif CasetoRun==213 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220
					matmodel(sp)=1;
					orientationoffset(sp)=0;
				elseif CasetoRun==212 
					matmodel(sp)=1;
					orientationoffset(sp)=0;
				elseif CasetoRun==207
					matmodel(sp)=4;
					uncrackable_sp(sp)=1;
					orientationoffset(sp)=0;
				end
				plotignore(sp)=0;
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				if CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207
					%TDL weakening switcher here!
					%{
					if x_trial<4*le_base+le(1) && x_trial > 4*le_base-le(1) && y_trial>4*le_base-le(2)
						weakeningfactor_sp(sp)=0.5;
					end
					%}
					%TDL k_sp switcher here!
					%k_sp(sp)=0.5;
				end
				if CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==190 || CasetoRun==187 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220
					%TDL nocrack top bottom switcher
					if y_trial<2.375*le_base
						uncrackable_sp(sp)=1;
						weakeningfactor_sp(sp)=-9999;
					elseif y_trial>4.625*le_base
						uncrackable_sp(sp)=1;
						weakeningfactor_sp(sp)=-9999;
					end
				elseif CasetoRun==229
					weakeningfactor_sp(sp)=0;
				elseif CasetoRun==228
					if y_trial>y_end-5*le_base || y_trial<y_start+5*le_base
						weakeningfactor_sp(sp)=-999;
					end
				end
				
				if x_trial>4*le_base-lp(1)
					if y_trial>4*le_base-lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						tractionedcorner(tractionedcorner_counter)=sp;
						normalcorner_counter=normalcorner_counter+1;
						normalcorner{normalcorner_counter}=[1 0;
																0 1];
					elseif y_trial<2*le_base+lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						tractionedcorner(tractionedcorner_counter)=sp;
						normalcorner_counter=normalcorner_counter+1;
						normalcorner{normalcorner_counter}=[1 0;
																0 -1];
					else
						tractionededge_counter=tractionededge_counter+1;
						tractionededge(tractionededge_counter)=sp;
						normaledge_counter=normaledge_counter+1;
						normaledge(normaledge_counter,1)=1;
						normaledge(normaledge_counter,2)=0;
					end
				elseif y_trial>4*le_base-lp(2)
					tractionededge_counter=tractionededge_counter+1;
					tractionededge(tractionededge_counter)=sp;
					normaledge_counter=normaledge_counter+1;
					normaledge(normaledge_counter,1)=0;
					normaledge(normaledge_counter,2)=1;
				elseif y_trial<2*le_base+lp(2)
					tractionededge_counter=tractionededge_counter+1;
					tractionededge(tractionededge_counter)=sp;
					normaledge_counter=normaledge_counter+1;
					normaledge(normaledge_counter,1)=0;
					normaledge(normaledge_counter,2)=-1;
				end
				
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
				%	ParticleswithPredYVel(1)=sp;
				%end
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
				%	ParticleswithPredYVel(2)=sp;
				%end
			end
		end
	elseif CasetoRun==230
		particle_per_cell=4;
		
		%below is for knot geometry calculations
		knot_x=zeros(1,2);
		knot_y=zeros(1,2);
		knot_rx=zeros(1,2);
		knot_ry=zeros(1,2);
		knot_theta=zeros(1,2);
		knot_xaffect=zeros(1,1);
		knot_yaffect=zeros(1,1);
		Xobservedrelative=zeros(1,12);
		Yobservedrelative=zeros(1,11);
		Xbigknotobserved=zeros(1,1);
		Ybigknotobserved=zeros(1,1);
		Xshift=zeros(1,1);
		Yshift=zeros(1,1);
		Xlist=zeros(size(Xobservedrelative));
		Ylist=zeros(size(Yobservedrelative));
		oneovertanthetalist=zeros(11,12);
		tanthetalist=zeros(size(oneovertanthetalist));
		thetalist=zeros(size(oneovertanthetalist));
		
		lp(1)=le(1)/sqrt(particle_per_cell); %size of particle in X direction
		lp(2)=lp(1); %size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		%declarations below to quit coder from whining;
		x_center=zeros(1,1);
		y_center=zeros(1,1);
		r_cylinder=zeros(1,1);
		
		x_start=2*le_base;
		%Edit point start: define start of MPM particles in x direction
		x_start=1*le_base;
		x_end=4*le_base;
		
		fprintf('%s',['before x_start loadvariable' char(10)]);
		x_start_loaded=loadvariable('x_start');
		%fprintf('%s',['after x_start loadvariable' char(10)]);
		fprintf('%s',['x_start_loaded.found=' int2txt(x_start_loaded.found) char(10)]);
		fprintf('%s',['x_start_loaded.valuetext=' x_start_loaded.valuetext char(10)]);
		if x_start_loaded.found
			x_start=str2float(x_start_loaded.valuetext);
		end
		fprintf('%s',['x_start=' float2scitxt(5,x_start) char(10)]);
		
		fprintf('%s',['before x_start_rel loadvariable' char(10)]);
		x_start_rel_loaded=loadvariable('x_start_rel');
		%fprintf('%s',['after x_start_rel loadvariable' char(10)]);
		fprintf('%s',['x_start_rel_loaded.found=' int2txt(x_start_rel_loaded.found) char(10)]);
		fprintf('%s',['x_start_rel_loaded.valuetext=' x_start_rel_loaded.valuetext char(10)]);
		x_start_rel=zeros(1,1);
		if x_start_rel_loaded.found
			x_start_rel=str2float(x_start_rel_loaded.valuetext);
			x_start=x_start_rel*le_base;
		end
		fprintf('%s',['x_start_rel=' float2scitxt(5,x_start_rel) char(10)]);
			
		fprintf('%s',['before x_end loadvariable' char(10)]);
		x_end_loaded=loadvariable('x_end');
		%fprintf('%s',['after x_end loadvariable' char(10)]);
		fprintf('%s',['x_end_loaded.found=' int2txt(x_end_loaded.found) char(10)]);
		fprintf('%s',['x_end_loaded.valuetext=' x_end_loaded.valuetext char(10)]);
		if x_end_loaded.found
			x_end=str2float(x_end_loaded.valuetext);
		end
		fprintf('%s',['x_end=' float2scitxt(5,x_end) char(10)]);
		
		fprintf('%s',['before x_end_rel loadvariable' char(10)]);
		x_end_rel_loaded=loadvariable('x_end_rel');
		%fprintf('%s',['after x_end_rel loadvariable' char(10)]);
		fprintf('%s',['x_end_rel_loaded.found=' int2txt(x_end_rel_loaded.found) char(10)]);
		fprintf('%s',['x_end_rel_loaded.valuetext=' x_end_rel_loaded.valuetext char(10)]);
		x_end_rel=zeros(1,1);
		if x_end_rel_loaded.found
			x_end_rel=str2float(x_end_rel_loaded.valuetext);
			x_end=x_end_rel*le_base;
		end
		fprintf('%s',['x_end_rel=' float2scitxt(5,x_end_rel) char(10)]);
		
		%Edit point end
		
		y_start=2*le_base;
		%Edit point start: define start of MPM particles in y direction
		y_start=1*le_base;
		y_end=3*le_base;
		
		fprintf('%s',['before y_start loadvariable' char(10)]);
		y_start_loaded=loadvariable('y_start');
		%fprintf('%s',['after y_start loadvariable' char(10)]);
		fprintf('%s',['y_start_loaded.found=' int2txt(y_start_loaded.found) char(10)]);
		fprintf('%s',['y_start_loaded.valuetext=' y_start_loaded.valuetext char(10)]);
		if y_start_loaded.found
			y_start=str2float(y_start_loaded.valuetext);
		end
		fprintf('%s',['y_start=' float2scitxt(5,y_start) char(10)]);
			
		fprintf('%s',['before y_start_rel loadvariable' char(10)]);
		y_start_rel_loaded=loadvariable('y_start_rel');
		%fprintf('%s',['after y_start_rel loadvariable' char(10)]);
		fprintf('%s',['y_start_rel_loaded.found=' int2txt(y_start_rel_loaded.found) char(10)]);
		fprintf('%s',['y_start_rel_loaded.valuetext=' y_start_rel_loaded.valuetext char(10)]);
		y_start_rel=zeros(1,1);
		if y_start_rel_loaded.found
			y_start_rel=str2float(y_start_rel_loaded.valuetext);
			y_start=y_start_rel*le_base;
		end
		fprintf('%s',['y_start_rel=' float2scitxt(5,y_start_rel) char(10)]);
			
		fprintf('%s',['before y_end loadvariable' char(10)]);
		y_end_loaded=loadvariable('y_end');
		%fprintf('%s',['after y_end loadvariable' char(10)]);
		fprintf('%s',['y_end_loaded.found=' int2txt(y_end_loaded.found) char(10)]);
		fprintf('%s',['y_end_loaded.valuetext=' y_end_loaded.valuetext char(10)]);
		if y_end_loaded.found
			y_end=str2float(y_end_loaded.valuetext);
		end
		fprintf('%s',['y_end=' float2scitxt(5,y_end) char(10)]);
			
		fprintf('%s',['before y_end_rel loadvariable' char(10)]);
		y_end_rel_loaded=loadvariable('y_end_rel');
		%fprintf('%s',['after y_end_rel loadvariable' char(10)]);
		fprintf('%s',['y_end_rel_loaded.found=' int2txt(y_end_rel_loaded.found) char(10)]);
		fprintf('%s',['y_end_rel_loaded.valuetext=' y_end_rel_loaded.valuetext char(10)]);
		y_end_rel=zeros(1,1);
		if y_end_rel_loaded.found
			y_end_rel=str2float(y_end_rel_loaded.valuetext);
			y_end=y_end_rel*le_base;
		end
		fprintf('%s',['y_end_rel=' float2scitxt(5,y_end_rel) char(10)]);
		
		%Edit point end
		
		
		crackinitdebug=0;
		crackinitdebug_loaded=loadvariable('crackinitdebug');
		if crackinitdebug_loaded.found
			crackinitdebug=str2long(crackinitdebug_loaded.valuetext);
		end
		
		n_crackpaths=0;
		n_crackpaths_loaded=loadvariable('n_crackpaths');
		if n_crackpaths_loaded.found
			n_crackpaths=str2long(n_crackpaths_loaded.valuetext);
		end
		if crackinitdebug
			printfloat(1,n_crackpaths,'n_crackpaths');
		end
		
		if n_crackpaths==0
			%just adding the bogus crack here
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack.center(1,1,1)=le(1)+0.01;
			x_crack.center(1,2,1)=le(2)+0.01;
			x_crack.center(2,1,1)=le(1)+0.011;
			x_crack.center(2,2,1)=le(2)+0.011;
			x_crack.terminatedprop(1,1)=1;
			x_crack.terminatedprop(1,2)=1;
		else
			x_crack.npaths=n_crackpaths;
			for ipath=1:x_crack.npaths
				for itip=1:2
					tip_terminate=0;
					tip_terminate_loaded=loadvariable(['tip_terminate(' int2txt(ipath) ',' int2txt(itip) ')']);
					if tip_terminate_loaded.found
						tip_terminate=str2long(tip_terminate_loaded.valuetext);
					end
					x_crack.terminatedprop(ipath,itip)=tip_terminate;
					if crackinitdebug
						printfloat(1,tip_terminate,['tip_terminate(' int2txt(ipath) ',' int2txt(itip) ')']);
						printfloat(1,x_crack.terminatedprop(ipath,itip),['x_crack.terminatedprop(' int2txt(ipath) ',' int2txt(itip) ')']);
					end
				end
				
				cohesivepath=1;
				cohesivepath_loaded=loadvariable(['cohesivepath(' int2txt(ipath) ')']);
				if cohesivepath_loaded.found
					cohesivepath=str2long(cohesivepath_loaded.valuetext);
				end
				x_crack.cohesivepath(ipath)=cohesivepath;
				if crackinitdebug
					printfloat(1,cohesivepath,['cohesivepath(' int2txt(ipath) ')']);
					printfloat(1,x_crack.cohesivepath(ipath),['x_crack.nparticles(' int2txt(ipath) ')']);
				end
				
				
				n_crackparticles=0;
				n_crackparticles_loaded=loadvariable(['n_crackparticles(' int2txt(ipath) ')']);
				if n_crackparticles_loaded.found
					n_crackparticles=str2long(n_crackparticles_loaded.valuetext);
				end
				x_crack.nparticles(ipath)=n_crackparticles;
				if crackinitdebug
					printfloat(1,n_crackparticles,['n_crackparticles(' int2txt(ipath) ')']);
					printfloat(1,x_crack.nparticles(ipath),['x_crack.nparticles(' int2txt(ipath) ')']);
				end
				
				for iparticle=1:x_crack.nparticles(ipath)
					for idim=1:2
						x_crackparticle=0;
						x_crackparticle_loaded=loadvariable(['x_crackparticle(' int2txt(iparticle) ',' int2txt(idim) ',' int2txt(ipath) ')']);
						if x_crackparticle_loaded.found
							x_crackparticle=str2float(x_crackparticle_loaded.valuetext);
						end
						x_crack.center(iparticle,idim,ipath)=x_crackparticle;
						if crackinitdebug
							printfloat(1,x_crackparticle,['x_crackparticle(' int2txt(iparticle) ',' int2txt(idim) ',' int2txt(ipath) ')']);
							printfloat(1,x_crack.center(iparticle,idim,ipath),['x_crack.center(' int2txt(iparticle) ',' int2txt(idim) ',' int2txt(ipath) ')']);
						end
					end
				end
			end
		end
		for ipath=1:x_crack.npaths
		for itip=1:2
			if x_crack.terminatedprop(ipath,itip)==0
				x_crack.boxcalc.active(ipath,itip)=1;
			else
				x_crack.boxcalc.active(ipath,itip)=0;
			end
		end
		end
		
		x_crack.spacing=1.25*le(1)/2;
		
		elasticstrength=25;
		elasticstrength_loaded=loadvariable('elasticstrength');
		if elasticstrength_loaded.found
			elasticstrength=str2float(elasticstrength_loaded.valuetext);
		end
		debugprint9=0;
		debugprint9_loaded=loadvariable('debugprint9');
		if debugprint9_loaded.found
			debugprint9=str2float(debugprint9_loaded.valuetext);
		end
		if debugprint9
			printfloat(1,elasticstrength,'in 24689, elasticstrength');
		end
		
		deltae=0;
		deltae_loaded=loadvariable('deltae');
		if deltae_loaded.found
			deltae=str2float(deltae_loaded.valuetext);
		end
		if crackinitdebug
			printfloat(1,deltae,'deltae');
		end
		
		deltai=0;
		deltai_loaded=loadvariable('deltai');
		if deltai_loaded.found
			deltai=str2float(deltai_loaded.valuetext);
		end
		if crackinitdebug
			printfloat(1,deltai,'deltai');
		end
		
		cohesivepeakfactor=1;
		cohesivepeakfactor_loaded=loadvariable('cohesivepeakfactor');
		if cohesivepeakfactor_loaded.found
			if CompareTexts(cohesivepeakfactor_loaded.type,'long')
				cohesivepeakfactor=str2long(cohesivepeakfactor_loaded.valuetext);
			else
				cohesivepeakfactor=str2float(cohesivepeakfactor_loaded.valuetext);
			end
		end
		if crackinitdebug
			printfloat(1,cohesivepeakfactor,'cohesivepeakfactor');
		end
		
		x_crack.bridge.yieldforce1=cohesivepeakfactor*elasticstrength*x_crack.spacing*t0_plane;
		%printfloat(1,cohesivepeakfactor,'cohesivepeakfactor')
		%printfloat(1,elasticstrength,'elasticstrength')
		%printfloat(1,x_crack.spacing,'x_crack.spacing')
		%printfloat(1,t0_plane,'t0_plane')
		x_crack.bridge.deltai1=deltai;
		x_crack.bridge.deltae=deltae;
		x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
		x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
		x_crack.bridge.yieldforce2(:,:)=cohesivepeakfactor*elasticstrength*x_crack.spacing*t0_plane;
		x_crack.cohesivepath(2)=1;
		%x_crack.cohesivepath(3)=1;
		%x_crack.cohesivepoint(1,3)=1; %(iparticle,ipath)
		%{
		x_defaultcracktip=[3 3]*le_base;
		%}
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
				
		%x_crack.top=x_crack.center;
		%x_crack.bot=x_crack.center;
		
		debugprint7=0;
		fprintf('%s',['before debugprint7 loadvariable' char(10)]);
		debugprint7_loaded=loadvariable('debugprint7');
		%fprintf('%s',['after debugprint7 loadvariable' char(10)]);
		fprintf('%s',['debugprint7_loaded.found=' int2txt(debugprint7_loaded.found) char(10)]);
		fprintf('%s',['debugprint7_loaded.valuetext=' debugprint7_loaded.valuetext char(10)]);
		if debugprint7_loaded.found
			debugprint7=str2long(debugprint7_loaded.valuetext);
		end
		fprintf('%s',['debugprint7=' float2scitxt(5,debugprint7) char(10)]);
		
		debugprint8=0;
		fprintf('%s',['before debugprint8 loadvariable' char(10)]);
		debugprint8_loaded=loadvariable('debugprint8');
		%fprintf('%s',['after debugprint8 loadvariable' char(10)]);
		fprintf('%s',['debugprint8_loaded.found=' int2txt(debugprint8_loaded.found) char(10)]);
		fprintf('%s',['debugprint8_loaded.valuetext=' debugprint8_loaded.valuetext char(10)]);
		if debugprint8_loaded.found
			debugprint8=str2long(debugprint8_loaded.valuetext);
		end
		fprintf('%s',['debugprint8=' float2scitxt(5,debugprint8) char(10)]);
		
		n_eraseboxes=0;
		fprintf('%s',['before n_eraseboxes loadvariable' char(10)]);
		n_eraseboxes_loaded=loadvariable('n_eraseboxes');
		%fprintf('%s',['after n_eraseboxes loadvariable' char(10)]);
		fprintf('%s',['n_eraseboxes_loaded.found=' int2txt(n_eraseboxes_loaded.found) char(10)]);
		fprintf('%s',['n_eraseboxes_loaded.valuetext=' n_eraseboxes_loaded.valuetext char(10)]);
		if n_eraseboxes_loaded.found
			n_eraseboxes=str2long(n_eraseboxes_loaded.valuetext);
		end
		fprintf('%s',['n_eraseboxes=' float2scitxt(5,n_eraseboxes) char(10)]);
		
		stringmaxlength=128; %has to match with other stringmaxlength definitions
		
		cohesivepath=0;
		cohesivepath_loaded.found=0;
		cohesivepath_loaded.valuetext=char(zeros(1,stringmaxlength));
		coder.varsize('cohesivepath_loaded.valuetext');
		cohesivepath_loaded.type=char(zeros(1,stringmaxlength));
		coder.varsize('cohesivepath_loaded.type');
		
		x_erase_start=0;
		x_erase_start_loaded.found=0;
		x_erase_start_loaded.valuetext=char(zeros(1,stringmaxlength));
		coder.varsize('x_erase_start_loaded.valuetext');
		x_erase_start_loaded.type=char(zeros(1,stringmaxlength));
		coder.varsize('x_erase_start_loaded.type');
		
		x_erase_end=0;
		x_erase_end_loaded.found=0;
		x_erase_end_loaded.valuetext=char(zeros(1,stringmaxlength));
		coder.varsize('x_erase_end_loaded.valuetext');
		x_erase_end_loaded.type=char(zeros(1,stringmaxlength));
		coder.varsize('x_erase_end_loaded.type');
		
		y_erase_start=0;
		y_erase_start_loaded.found=0;
		y_erase_start_loaded.valuetext=char(zeros(1,stringmaxlength));
		coder.varsize('y_erase_start_loaded.valuetext');
		y_erase_start_loaded.type=char(zeros(1,stringmaxlength));
		coder.varsize('y_erase_start_loaded.type');
		
		y_erase_end=0;
		y_erase_end_loaded.found=0;
		y_erase_end_loaded.valuetext=char(zeros(1,stringmaxlength));
		coder.varsize('y_erase_end_loaded.valuetext');
		y_erase_end_loaded.type=char(zeros(1,stringmaxlength));
		coder.varsize('y_erase_end_loaded.type');
		
		tip_terminate=0;
		tip_terminate_loaded.found=0;
		tip_terminate_loaded.valuetext=char(zeros(1,stringmaxlength));
		coder.varsize('tip_terminate_loaded.valuetext');
		tip_terminate_loaded.type=char(zeros(1,stringmaxlength));
		coder.varsize('tip_terminate_loaded.type');
		
		n_crackparticles=0;
		n_crackparticles_loaded.found=0;
		n_crackparticles_loaded.valuetext=char(zeros(1,stringmaxlength));
		coder.varsize('n_crackparticles_loaded.valuetext');
		n_crackparticles_loaded.type=char(zeros(1,stringmaxlength));
		coder.varsize('n_crackparticles_loaded.type');
		
		x_crackparticle=0;
		x_crackparticle_loaded.found=0;
		x_crackparticle_loaded.valuetext=char(zeros(1,stringmaxlength));
		coder.varsize('x_crackparticle_loaded.valuetext');
		x_crackparticle_loaded.type=char(zeros(1,stringmaxlength));
		coder.varsize('x_crackparticle_loaded.type');
		
		
		
		elasticstrength=25; %MPa
		
		continuesignal=0;
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				%MARK this is where particle trimming begins
				
				continuesignal=0;
				for i_erasebox=1:n_eraseboxes
					x_erase_start=0;
					%fprintf('%s',['before x_erase_start_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					x_erase_start_loaded=loadvariable(['x_erase_start(' int2txt(i_erasebox) ')']);
					%fprintf('%s',['after x_erase_start_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					%fprintf('%s',['x_erase_start_loaded.found=' int2txt(x_erase_start_loaded.found) char(10)]);
					%fprintf('%s',['x_erase_start_loaded.valuetext=' x_erase_start_loaded.valuetext char(10)]);
					if x_erase_start_loaded.found
						x_erase_start=str2float(x_erase_start_loaded.valuetext);
					end
					%fprintf('%s',['x_erase_start=' float2scitxt(5,x_erase_start) char(10)]);
					
					x_erase_end=0;
					%fprintf('%s',['before x_erase_end_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					x_erase_end_loaded=loadvariable(['x_erase_end(' int2txt(i_erasebox) ')']);
					%fprintf('%s',['after x_erase_end_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					%fprintf('%s',['x_erase_end_loaded.found=' int2txt(x_erase_end_loaded.found) char(10)]);
					%fprintf('%s',['x_erase_end_loaded.valuetext=' x_erase_end_loaded.valuetext char(10)]);
					if x_erase_end_loaded.found
						x_erase_end=str2float(x_erase_end_loaded.valuetext);
					end
					%fprintf('%s',['x_erase_end=' float2scitxt(5,x_erase_end) char(10)]);
					
					y_erase_start=0;
					%fprintf('%s',['before y_erase_start_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					y_erase_start_loaded=loadvariable(['y_erase_start(' int2txt(i_erasebox) ')']);
					%fprintf('%s',['after y_erase_start_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					%fprintf('%s',['y_erase_start_loaded.found=' int2txt(y_erase_start_loaded.found) char(10)]);
					%fprintf('%s',['y_erase_start_loaded.valuetext=' y_erase_start_loaded.valuetext char(10)]);
					if y_erase_start_loaded.found
						y_erase_start=str2float(y_erase_start_loaded.valuetext);
					end
					%fprintf('%s',['y_erase_start=' float2scitxt(5,y_erase_start) char(10)]);
					
					y_erase_end=0;
					%fprintf('%s',['before y_erase_end_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					y_erase_end_loaded=loadvariable(['y_erase_end(' int2txt(i_erasebox) ')']);
					%fprintf('%s',['after y_erase_end_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					%fprintf('%s',['y_erase_end_loaded.found=' int2txt(y_erase_end_loaded.found) char(10)]);
					%fprintf('%s',['y_erase_end_loaded.valuetext=' y_erase_end_loaded.valuetext char(10)]);
					if y_erase_end_loaded.found
						y_erase_end=str2float(y_erase_end_loaded.valuetext);
					end
					%fprintf('%s',['y_erase_end=' float2scitxt(5,y_erase_end) char(10)]);
					
					if debugprint8
						printfloat(1,i_erasebox,'in debugprint8, i_erasebox');
						debugprint8=0;
						fprintf('%s',['before debugprint8 loadvariable' char(10)]);
						debugprint8_loaded=loadvariable('debugprint8');
						%fprintf('%s',['after debugprint8 loadvariable' char(10)]);
						fprintf('%s',['debugprint8_loaded.found=' int2txt(debugprint8_loaded.found) char(10)]);
						fprintf('%s',['debugprint8_loaded.valuetext=' debugprint8_loaded.valuetext char(10)]);
						if debugprint8_loaded.found
							debugprint8=str2long(debugprint8_loaded.valuetext);
						end
						fprintf('%s',['debugprint8=' float2scitxt(5,debugprint8) char(10)]);
					end
					
					if (x_trial-x_erase_start)*(x_trial-x_erase_end)<0
						if (y_trial-y_erase_start)*(y_trial-y_erase_end)<0
							continuesignal=1;
							continue;
							if debugprint8
								printtext(1,'particle skipped from current box!')
							end
						end
					end
				end
				
				if debugprint7
					printfloat(0,x_trial,'in debugprint7, x_trial');
					printfloat(0,y_trial,'in debugprint7, y_trial');
					printfloat(1,sp,'in debugprint7, sp');
					debugprint7=0;
					fprintf('%s',['before debugprint7 loadvariable' char(10)]);
					debugprint7_loaded=loadvariable('debugprint7');
					%fprintf('%s',['after debugprint7 loadvariable' char(10)]);
					fprintf('%s',['debugprint7_loaded.found=' int2txt(debugprint7_loaded.found) char(10)]);
					fprintf('%s',['debugprint7_loaded.valuetext=' debugprint7_loaded.valuetext char(10)]);
					if debugprint7_loaded.found
						debugprint7=str2long(debugprint7_loaded.valuetext);
					end
					fprintf('%s',['debugprint7=' float2scitxt(5,debugprint7) char(10)]);
				end
				
				if continuesignal
					if debugprint7
						printtext(1,'particle skipped from current particle placement!')
					end
					continue;
				end
				%if x_trial>5*le_base
					%if y_trial>3*le_base-le(1)
						%if y_trial<3*le_base+le(1)
							%continue;
						%end
					%end
				%end
				%MARK this is where particle trimming ends
				
				sp=sp+1;
			end
		end
		
		
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);
		
		matmodel=zeros(1,spCount);
		uncrackable_sp=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		alphahp=zeros(spCount,7);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);
		depth_sp=zeros(1,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		
		%TDL particle deletion starts here
		
		%TDL matmodel switch here
		%TDL matmodel switch for 230
		matmodelnum=4;
		
		%fprintf('%s',['before matmodelnum loadvariable' char(10)]);
		matmodelnum_loaded=loadvariable('matmodelnum');
		%fprintf('%s',['after matmodelnum loadvariable' char(10)]);
		%fprintf('%s',['matmodelnum_loaded.found=' int2txt(matmodelnum_loaded.found) char(10)]);
		%fprintf('%s',['matmodelnum_loaded.valuetext=' matmodelnum_loaded.valuetext char(10)]);
		if matmodelnum_loaded.found
			matmodelnum=str2long(matmodelnum_loaded.valuetext);
		end
		%fprintf('%s',['matmodelnum=' float2scitxt(5,matmodelnum) char(10)]);
		
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell)
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell)
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				
				continuesignal=0;
				for i_erasebox=1:n_eraseboxes
					x_erase_start=0;
					%fprintf('%s',['before x_erase_start_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					x_erase_start_loaded=loadvariable(['x_erase_start(' int2txt(i_erasebox) ')']);
					%fprintf('%s',['after x_erase_start_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					%fprintf('%s',['x_erase_start_loaded.found=' int2txt(x_erase_start_loaded.found) char(10)]);
					%fprintf('%s',['x_erase_start_loaded.valuetext=' x_erase_start_loaded.valuetext char(10)]);
					if x_erase_start_loaded.found
						x_erase_start=str2float(x_erase_start_loaded.valuetext);
					end
					%fprintf('%s',['x_erase_start=' float2scitxt(5,x_erase_start) char(10)]);
					
					x_erase_end=0;
					%fprintf('%s',['before x_erase_end_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					x_erase_end_loaded=loadvariable(['x_erase_end(' int2txt(i_erasebox) ')']);
					%fprintf('%s',['after x_erase_end_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					%fprintf('%s',['x_erase_end_loaded.found=' int2txt(x_erase_end_loaded.found) char(10)]);
					%fprintf('%s',['x_erase_end_loaded.valuetext=' x_erase_end_loaded.valuetext char(10)]);
					if x_erase_end_loaded.found
						x_erase_end=str2float(x_erase_end_loaded.valuetext);
					end
					%fprintf('%s',['x_erase_end=' float2scitxt(5,x_erase_end) char(10)]);
					
					y_erase_start=0;
					%fprintf('%s',['before y_erase_start_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					y_erase_start_loaded=loadvariable(['y_erase_start(' int2txt(i_erasebox) ')']);
					%fprintf('%s',['after y_erase_start_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					%fprintf('%s',['y_erase_start_loaded.found=' int2txt(y_erase_start_loaded.found) char(10)]);
					%fprintf('%s',['y_erase_start_loaded.valuetext=' y_erase_start_loaded.valuetext char(10)]);
					if y_erase_start_loaded.found
						y_erase_start=str2float(y_erase_start_loaded.valuetext);
					end
					%fprintf('%s',['y_erase_start=' float2scitxt(5,y_erase_start) char(10)]);
					
					y_erase_end=0;
					%fprintf('%s',['before y_erase_end_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					y_erase_end_loaded=loadvariable(['y_erase_end(' int2txt(i_erasebox) ')']);
					%fprintf('%s',['after y_erase_end_' int2txt(i_erasebox) ' loadvariable' char(10)]);
					%fprintf('%s',['y_erase_end_loaded.found=' int2txt(y_erase_end_loaded.found) char(10)]);
					%fprintf('%s',['y_erase_end_loaded.valuetext=' y_erase_end_loaded.valuetext char(10)]);
					if y_erase_end_loaded.found
						y_erase_end=str2float(y_erase_end_loaded.valuetext);
					end
					%fprintf('%s',['y_erase_end=' float2scitxt(5,y_erase_end) char(10)]);
					
					if (x_trial-x_erase_start)*(x_trial-x_erase_end)<0
						if (y_trial-y_erase_start)*(y_trial-y_erase_end)<0
							continuesignal=1;
							continue;
						end
					end
				end
				
				if continuesignal
					continue;
				end
				
				%MARK this is where particle trimming begins (has to be identical with the one before)
				%if x_trial>5*le_base
					%if y_trial>3*le_base-le(1)
						%if y_trial<3*le_base+le(1)
							%continue;
						%end
					%end
				%end
				%MARK this is where particle trimming ends (has to be identical with the one before)
				
				sp=sp+1;
				%TDL shrinkage definition here!
				%epsilonshrinkdot_sp(sp)=-0.125*(y_trial-2*le_base)/(4*le_base-2*le_base);
				thetacrackrtl(sp)=NaN;
				
				%below's only relevant for wood material model
				xdirletter{sp}='r';
				ydirletter{sp}='t';
				zdirletter{sp}='l';
				xydirletter{sp}='rt';
				yzdirletter{sp}='tl';
				xzdirletter{sp}='rl';
				
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				
				
				orientationoffset(sp)=NaN;
				
				matmodel(sp)=matmodelnum;
				plotignore(sp)=0;
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				%TDL weakening switcher here!
				%{
				if x_trial<4*le_base+le(1) && x_trial > 4*le_base-le(1) && y_trial>4*le_base-le(2)
					weakeningfactor_sp(sp)=0.5;
				end
				%}
				%TDL k_sp switcher here!
				%k_sp(sp)=0.5;
				
				
			end
		end
	elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=3*le_base;
		x_end=12*le_base;
		y_start=2*le_base;
		y_end=5*le_base;
		
		if CasetoRun==144
			x_crack.npaths=1;
			x_crack.nparticles(1)=13;
			
			x_crack_temp=[7.5 0.5;
							7.5 1;
							7.5 1.5;
							7.5 2;
							7.5 2.5;
							7.5 3;
							7.5 3.5;
							7.5 4;
							7.5 4.5;
							7.5 5;
							7.5 5.5;
							7.5 6;
							7.5 6.5]*le_base;
							
			ipath=1;
			for iparticle=1:x_crack.nparticles(ipath);
				for dim=1:2
					x_crack.center(iparticle,dim,ipath)=x_crack_temp(iparticle,dim);
				end
			end
		elseif CasetoRun==148
			x_crack.npaths=1;
			x_crack.nparticles(1)=13;
			
			x_crack_temp=[7.125 0.5;
							7.125 1;
							7.125 1.5;
							7.125 2;
							7.125 2.5;
							7.125 3;
							7.125 3.5;
							7.125 4;
							7.125 4.5;
							7.125 5;
							7.125 5.5;
							7.125 6;
							7.125 6.5]*le_base;
							
			ipath=1;
			for iparticle=1:x_crack.nparticles(ipath);
				for dim=1:2
					x_crack.center(iparticle,dim,ipath)=x_crack_temp(iparticle,dim);
				end
			end
		elseif CasetoRun==146
			x_crack.npaths=1;
			x_crack.nparticles(1)=13;
			
			x_crack_temp=[5.5 0.5;
							5.5 1;
							5.5 1.5;
							5.5 2;
							5.5 2.5;
							5.5 3;
							5.5 3.5;
							5.5 4;
							5.5 4.5;
							5.5 5;
							5.5 5.5;
							5.5 6;
							5.5 6.5]*le_base;
		
			ipath=1;
			for iparticle=1:x_crack.nparticles(ipath);
				for dim=1:2
					x_crack.center(iparticle,dim,ipath)=x_crack_temp(iparticle,dim);
				end
			end
		elseif CasetoRun==149
			x_crack.npaths=1;
			x_crack.nparticles(1)=2;
			x_crack_temp=[5.5 0.5;
							5.5 1]*le_base;
		
			ipath=1;
			for iparticle=1:x_crack.nparticles(ipath);
				for dim=1:2
					x_crack.center(iparticle,dim,ipath)=x_crack_temp(iparticle,dim);
				end
			end
		elseif CasetoRun==147
		
			x_crack.npaths=1;
			x_crack.nparticles(1)=13;
			
			x_crack_temp=[9.5 0.5;
							9.5 1;
							9.5 1.5;
							9.5 2;
							9.5 2.5;
							9.5 3;
							9.5 3.5;
							9.5 4;
							9.5 4.5;
							9.5 5;
							9.5 5.5;
							9.5 6;
							9.5 6.5]*le_base;
		
			ipath=1;
			for iparticle=1:x_crack.nparticles(ipath);
				for dim=1:2
					x_crack.center(iparticle,dim,ipath)=x_crack_temp(iparticle,dim);
				end
			end
		elseif CasetoRun==145
			x_crack.npaths=2;
			x_crack.nparticles(1)=13;
			x_crack.nparticles(2)=13;
			
			ipath=1;
			x_crack_temp=[6.5 0.5;
							6.5 1;
							6.5 1.5;
							6.5 2;
							6.5 2.5;
							6.5 3;
							6.5 3.5;
							6.5 4;
							6.5 4.5;
							6.5 5;
							6.5 5.5;
							6.5 6;
							6.5 6.5]*le_base;
			for iparticle=1:x_crack.nparticles(ipath);
				for dim=1:2
					x_crack.center(iparticle,dim,ipath)=x_crack_temp(iparticle,dim);
				end
			end
			
			ipath=2;
			x_crack_temp=[7.5 0.5;
							7.5 1;
							7.5 1.5;
							7.5 2;
							7.5 2.5;
							7.5 3;
							7.5 3.5;
							7.5 4;
							7.5 4.5;
							7.5 5;
							7.5 5.5;
							7.5 6;
							7.5 6.5]*le_base;
			for iparticle=1:x_crack.nparticles(ipath);
				for dim=1:2
					x_crack.center(iparticle,dim,ipath)=x_crack_temp(iparticle,dim);
				end
			end
		end
		
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);

		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		alphahp=zeros(spCount,7);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				matmodel(sp)=4; %crackable elastic
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
			end
		end
		1;
	elseif CasetoRun==153
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_center=7*le_base;
		y_center=7*le_base;
		r_donut_internal=1*le_base;
		r_donut_external=1.5*le_base;
		r_donut_uncrackable=1.5*le_base;
		
		x_crack.npaths=8;
		r_crack_internal=5.5*le_base;
		r_crack_external=6*le_base;
		
		for ipath=1:x_crack.npaths
			x_crack.nparticles(ipath)=9;
			theta=2*pi*(0.5+ipath)/x_crack.npaths;
			for iparticle=1:x_crack.nparticles(ipath)
				r_crack=r_crack_internal+(r_crack_external-r_crack_internal)/(x_crack.nparticles(ipath)-1)*(iparticle-1);
				x_crack.center(iparticle,1,ipath)=x_center+r_crack*cos(theta);
				x_crack.center(iparticle,2,ipath)=y_center+r_crack*sin(theta);
			end
		end
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				sp=sp+1;
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);

		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		r_adjustor=zeros(1,spCount);
		alphahp=zeros(spCount,7);
		uncrackable_sp=zeros(1,spCount);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				matmodel(sp)=4; %crackable elastic
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				
				uncrackable_sp(sp)=0;
				if r_trial<r_donut_uncrackable
					uncrackable_sp(sp)=1;
					r_adjustor(sp)=1*le_base-r_trial;
				end
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
			end
		end
		1;
	elseif CasetoRun==154 || CasetoRun==161
		%vortex initiate
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		center=4;
		x_center=center;
		y_center=center;
		resolution=refinementfactor;
		% Ring distribution
		nPar1                   = 45* resolution;
		nPar2                   = 4 * resolution;
		spCount                 = nPar1*nPar2;
		x_sp                    = zeros(spCount,2);
		A_sp                    = zeros(spCount,1);
		r1_sp                   = zeros(spCount,2);
		r2_sp                   = zeros(spCount,2);
		v_ssp_0=zeros(spCount,2);
		pforce_sp=zeros(spCount,2);
		% Ring distribution
		for i = 1:nPar1
			ttemp=(i-0.5)*2*pi/nPar1;
			for j = 1:nPar2
				rtemp=0.75+(j-0.5)*0.5/nPar2;
				x_sp((i-1)*nPar2+j,:)=[center+rtemp*cos(ttemp) center+rtemp*sin(ttemp)];
				A_sp((i-1)*nPar2+j)=0.5/nPar2*2*pi/nPar1*rtemp;
				r1_sp((i-1)*nPar2+j,:)=1*pi/nPar1*rtemp*[sin(ttemp) -cos(ttemp)];
				r2_sp((i-1)*nPar2+j,:)=0.25/nPar2*[cos(ttemp) sin(ttemp)];
			end
		end
		x_spo=x_sp;
		for sp=1:spCount
			R_sp                = sqrt((x_spo(sp,1)-center)^2 + (x_spo(sp,2)-center)^2);
			theta               = atan2((x_spo(sp,2)-center),(x_spo(sp,1)-center));
			Constant            = 1 - 32 * (R_sp-1)^2 + 256 * (R_sp-1)^4;
			alpha               = A * sin(C*pi*t_time) * Constant;
			alfap               = A^2 * C * pi * Constant;
			v_ssp_0(sp,1)         = alfap * (-sin(alpha)*(x_spo(sp,1)-center) - cos(alpha)*(x_spo(sp,2)-center));
			v_ssp_0(sp,2)         = alfap * (cos(alpha)*(x_spo(sp,1)-center) - sin(alpha)*(x_spo(sp,2)-center));
		end
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		
		x_crack.npaths=1;
		r_crack_internal=7.5*le_base;
		r_crack_external=8*le_base;
		%{
		for ipath=1:x_crack.npaths
			x_crack.nparticles(ipath)=9;
			theta=2*pi*(0.5+ipath)/x_crack.npaths;
			for iparticle=1:x_crack.nparticles(ipath)
				r_crack=r_crack_internal+(r_crack_external-r_crack_internal)/(x_crack.nparticles(ipath)-1)*(iparticle-1);
				x_crack.center(iparticle,1,ipath)=x_center+r_crack*cos(theta);
				x_crack.center(iparticle,2,ipath)=y_center+r_crack*sin(theta);
			end
		end
		%}
		x_crack.nparticles(1)=2;
		x_crack.center(1,1,1)=0.1;
		x_crack.center(1,2,1)=0.1;
		x_crack.center(2,1,1)=0.1;
		x_crack.center(2,2,1)=0.11;

		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		elasticstrength=25; %MPa
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		
		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		r_adjustor=zeros(1,spCount);
		alphahp=zeros(spCount,7);
		uncrackable_sp=zeros(1,spCount);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		
		for isp=1:spCount
			thetacrackrtl(isp)=NaN;
			xdirletter{isp}='t';
			ydirletter{isp}='r';
			zdirletter{isp}='l';
			xydirletter{isp}='tr';
			yzdirletter{isp}='rl';
			xzdirletter{isp}='tl';
			%matmodel(isp)=4; %crackable elastic
			matmodel(isp)=6; %hyperelastic
			orientationoffset(isp)=NaN;
			plotignore(isp)=0;
			
			uncrackable_sp(isp)=0;
			
			p_sp=MatrixInsertion(p_sp,isp,1,psp);
			weakeningfactor_sp(isp)=0;
		end
		sp=spCount;
		1;
	elseif CasetoRun==150 || CasetoRun==152
		
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_center=7*le_base;
		y_center=7*le_base;
		r_donut_internal=1*le_base;
		r_donut_external=3*le_base;
		r_donut_uncrackable=2*le_base;
		
		x_crack.npaths=8;
		r_crack_internal=2.5*le_base;
		r_crack_external=r_donut_external+le(1)/2;
		r_crack_far=6*le_base;
		
		for ipath=1:x_crack.npaths
			x_crack.nparticles(ipath)=3;
			theta=2*pi*(0.5+ipath)/x_crack.npaths;
			for iparticle=1:x_crack.nparticles(ipath)
				r_crack=r_crack_internal+(r_crack_external-r_crack_internal)/(x_crack.nparticles(ipath)-1)*(iparticle-1);
				x_crack.center(iparticle,1,ipath)=x_center+r_crack*cos(theta);
				x_crack.center(iparticle,2,ipath)=y_center+r_crack*sin(theta);
			end
			x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
			r_crack=r_crack_far;
			x_crack.center(x_crack.nparticles(ipath),1,ipath)=x_center+r_crack*cos(theta);
			x_crack.center(x_crack.nparticles(ipath),2,ipath)=y_center+r_crack*sin(theta);
			
			x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
			r_crack=r_crack_far+0.1*le_base;
			x_crack.center(x_crack.nparticles(ipath),1,ipath)=x_center+r_crack*cos(theta);
			x_crack.center(x_crack.nparticles(ipath),2,ipath)=y_center+r_crack*sin(theta);
		end
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				sp=sp+1;
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);

		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		r_adjustor=zeros(1,spCount);
		alphahp=zeros(spCount,7);
		uncrackable_sp=zeros(1,spCount);
		deltarideal_sp=zeros(1,spCount);
		deltaractual_sp=zeros(1,spCount);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				matmodel(sp)=4; %crackable elastic
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				
				uncrackable_sp(sp)=0;
				if r_trial<r_donut_uncrackable
					uncrackable_sp(sp)=1;
					r_adjustor(sp)=1*le_base-r_trial;
				end
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
			end
		end
		1;
	elseif CasetoRun==158
		
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_center=7*le_base;
		y_center=7*le_base;
		r_donut_internal=1*le_base;
		r_donut_external=3*le_base;
		r_donut_innermid=1.5*le_base;
		r_donut_outtermid=2*le_base;
		r_donut_uncrackable=2*le_base;
		
		x_crack.npaths=8;
		%r_crack_internal=2.5*le_base;
		r_crack_internal=2*le_base;
		r_crack_external=r_donut_external-le(1)/2;
		r_crack_far=6*le_base;
		
		for ipath=1:x_crack.npaths
			%x_crack.nparticles(ipath)=3;
			x_crack.nparticles(ipath)=1;
			theta=2*pi*(0.5+ipath)/x_crack.npaths;
			for iparticle=1:x_crack.nparticles(ipath)
				%r_crack=r_crack_internal+(r_crack_external-r_crack_internal)/(x_crack.nparticles(ipath)-1)*(iparticle-1);
				r_crack=r_crack_internal;
				x_crack.center(iparticle,1,ipath)=x_center+r_crack*cos(theta);
				x_crack.center(iparticle,2,ipath)=y_center+r_crack*sin(theta);
			end
			x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
			r_crack=r_crack_far;
			x_crack.center(x_crack.nparticles(ipath),1,ipath)=x_center+r_crack*cos(theta);
			x_crack.center(x_crack.nparticles(ipath),2,ipath)=y_center+r_crack*sin(theta);
			
			x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
			r_crack=r_crack_far+0.1*le_base;
			x_crack.center(x_crack.nparticles(ipath),1,ipath)=x_center+r_crack*cos(theta);
			x_crack.center(x_crack.nparticles(ipath),2,ipath)=y_center+r_crack*sin(theta);
		end
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				sp=sp+1;
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);

		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		pforce_sp_base=zeros(spCount,2);
		r_adjustor=zeros(1,spCount);
		alphahp=zeros(spCount,7);
		uncrackable_sp=zeros(1,spCount);
		deltarideal_sp=zeros(1,spCount);
		deltaractual_sp=zeros(1,spCount);
		E_sp=zeros(1,spCount);
		exploding_sp=zeros(1,spCount);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		
		stretchmultiplier=2.1; %how much does the donut stretch
		r0_donut=(r_donut_internal+r_donut_uncrackable)/2;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				theta_trial=reliableatan(delta_x_trial(1),delta_x_trial(2));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				matmodel(sp)=7; %Elastic E_sp
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				
				uncrackable_sp(sp)=0;
				if r_trial<r_donut_uncrackable
					uncrackable_sp(sp)=1;
					r_adjustor(sp)=1*le_base-r_trial;
					pforce_sp_base(sp,1)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*cos(theta_trial);
					pforce_sp_base(sp,2)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*sin(theta_trial);
				end
				%the E_sp definition overrides the global E definition for matmodel=7
				%make sure E global is the highest E_sp value for curan condition calculation
				if r_trial>r_donut_outtermid 
					E_sp(sp)=E;
					p_sp(sp)=psp2;
				elseif r_trial>r_donut_innermid
					E_sp(sp)=E/10;
					p_sp(sp)=psp2;
				else
					E_sp(sp)=E;
					p_sp(sp)=psp2*10;
				end
				
				weakeningfactor_sp(sp)=0;
				
			end
		end
		1;
	elseif CasetoRun==180
		
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_center=7*le_base;
		y_center=7*le_base;
		r_donut_internal=1*le_base;
		r_donut_external=3*le_base;
		r_donut_uncrackable=2*le_base;
		
		x_crack.npaths=8;
		r_crack_internal=2*le_base;
		r_crack_external=r_donut_external-lp(1);
		r_crack_far=6*le_base;
		
		for ipath=1:x_crack.npaths
			%x_crack.nparticles(ipath)=3;
			x_crack.nparticles(ipath)=8;
			theta=2*pi*(0.5+ipath)/x_crack.npaths;
			for iparticle=1:x_crack.nparticles(ipath)
				r_crack=r_crack_internal+(r_crack_external-r_crack_internal)/(x_crack.nparticles(ipath)-1)*(iparticle-1);
				x_crack.center(iparticle,1,ipath)=x_center+r_crack*cos(theta);
				x_crack.center(iparticle,2,ipath)=y_center+r_crack*sin(theta);
			end
			x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
			r_crack=r_donut_external+3*le(1);
			x_crack.center(x_crack.nparticles(ipath),1,ipath)=x_center+r_crack*cos(theta);
			x_crack.center(x_crack.nparticles(ipath),2,ipath)=y_center+r_crack*sin(theta);
			x_crack.terminatedprop(ipath,1)=1;
			x_crack.terminatedprop(ipath,2)=0;
		end
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				sp=sp+1;
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);

		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		pforce_sp_base=zeros(spCount,2);
		r_adjustor=zeros(1,spCount);
		alphahp=zeros(spCount,7);
		uncrackable_sp=zeros(1,spCount);
		deltarideal_sp=zeros(1,spCount);
		deltaractual_sp=zeros(1,spCount);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		stretchmultiplier=2.1; %to stop coder whining
		stretchmultiplier=1.9; %how much does the donut stretch
		r0_donut=(r_donut_internal+r_donut_uncrackable)/2;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				theta_trial=reliableatan(delta_x_trial(1),delta_x_trial(2));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				%matmodel switch
				%matmodel(sp)=6; %hyperelastic
				matmodel(sp)=4; %crackable elastic
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				
				uncrackable_sp(sp)=0;
				if r_trial<r_donut_uncrackable
					uncrackable_sp(sp)=1;
					r_adjustor(sp)=1*le_base-r_trial;
					pforce_sp_base(sp,1)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*cos(theta_trial);
					pforce_sp_base(sp,2)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*sin(theta_trial);
				end
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
			end
		end
		if CasetoRun==159 || CasetoRun==162
			for isp=1:spCount
				x_sp(isp,:)=transpose(rotate.R*(transpose(x_sp(isp,:)-rotate.center)))+rotate.center;
				pforce_sp_base(isp,:)=transpose(rotate.R*(transpose(pforce_sp_base(isp,:))));
			end
		end
		1;
	elseif CasetoRun==194
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_center=7*le_base;
		y_center=7*le_base;
		r_donut_internal=1*le_base;
		r_donut_external=3*le_base;
		r_donut_uncrackable=2*le_base;
		
		x_crack.npaths=8;
		r_crack_internal=2.5*le_base;
		%r_crack_internal=2*le_base;
		r_crack_external=r_donut_external-lp(1);
		r_crack_far=6*le_base;
		
		elasticstrength=25; %MPa
		x_crack.spacing=le(1)/2;
		x_crack.bridge.yieldforce1=elasticstrength*x_crack.spacing*t0_plane;
		x_crack.bridge.yieldforce2(:,:)=x_crack.bridge.yieldforce1;
		x_crack.bridge.deltai1=0.002*le_base;
		x_crack.bridge.deltae=0.1*x_crack.bridge.deltai1;
		x_crack.bridge.kbase1=x_crack.bridge.yieldforce1/x_crack.bridge.deltae;
		x_crack.bridge.kbase2(:,:)=x_crack.bridge.kbase1;
		
		x_crack.bridge.pathcompletemonitor.size=x_crack.npaths;
		
		for ipath=1:x_crack.npaths
			%x_crack.nparticles(ipath)=3;
			x_crack.nparticles(ipath)=8;
			x_crack.cohesivepath(ipath)=1;
			x_crack.cohesivepoint(1,ipath)=1;
			x_crack.bridge.pathcompletemonitor.values(ipath)=ipath;
			theta=2*pi*(0.5+ipath)/x_crack.npaths;
			for iparticle=1:x_crack.nparticles(ipath)
				r_crack=r_crack_internal+(r_crack_external-r_crack_internal)/(x_crack.nparticles(ipath)-1)*(iparticle-1);
				x_crack.center(iparticle,1,ipath)=x_center+r_crack*cos(theta);
				x_crack.center(iparticle,2,ipath)=y_center+r_crack*sin(theta);
			end
			x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
			r_crack=r_donut_external+3*le(1);
			x_crack.center(x_crack.nparticles(ipath),1,ipath)=x_center+r_crack*cos(theta);
			x_crack.center(x_crack.nparticles(ipath),2,ipath)=y_center+r_crack*sin(theta);
			x_crack.terminatedprop(ipath,1)=1;
			x_crack.terminatedprop(ipath,2)=0;
		end
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				sp=sp+1;
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);

		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		pforce_sp_base=zeros(spCount,2);
		r_adjustor=zeros(1,spCount);
		alphahp=zeros(spCount,7);
		uncrackable_sp=zeros(1,spCount);
		deltarideal_sp=zeros(1,spCount);
		deltaractual_sp=zeros(1,spCount);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		stretchmultiplier=2.1; %to stop coder whining
		stretchmultiplier=1.9; %how much does the donut stretch
		r0_donut=(r_donut_internal+r_donut_uncrackable)/2;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				theta_trial=reliableatan(delta_x_trial(1),delta_x_trial(2));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				%matmodel switch
				%matmodel(sp)=6; %hyperelastic
				matmodel(sp)=4; %crackable elastic
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				
				uncrackable_sp(sp)=0;
				if r_trial<r_donut_uncrackable
					uncrackable_sp(sp)=1;
					r_adjustor(sp)=1*le_base-r_trial;
					pforce_sp_base(sp,1)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*cos(theta_trial);
					pforce_sp_base(sp,2)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*sin(theta_trial);
				end
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
			end
		end
		if CasetoRun==159 || CasetoRun==162
			for isp=1:spCount
				x_sp(isp,:)=transpose(rotate.R*(transpose(x_sp(isp,:)-rotate.center)))+rotate.center;
				pforce_sp_base(isp,:)=transpose(rotate.R*(transpose(pforce_sp_base(isp,:))));
			end
		end
		1;
	elseif CasetoRun==175
		
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_center=7*le_base;
		y_center=7*le_base;
		r_donut_internal=1*le_base;
		r_donut_external=3*le_base;
		r_donut_uncrackable=2*le_base;
		
		x_crack.npaths=8;
		r_crack_internal=2.5*le_base;
		%r_crack_internal=2*le_base;
		r_crack_external=r_donut_external-lp(1);
		r_crack_far=6*le_base;
		
		for ipath=1:x_crack.npaths
			%x_crack.nparticles(ipath)=3;
			x_crack.nparticles(ipath)=8;
			theta=2*pi*(0.5+ipath)/x_crack.npaths;
			for iparticle=1:x_crack.nparticles(ipath)
				r_crack=r_crack_internal+(r_crack_external-r_crack_internal)/(x_crack.nparticles(ipath)-1)*(iparticle-1);
				x_crack.center(iparticle,1,ipath)=x_center+r_crack*cos(theta);
				x_crack.center(iparticle,2,ipath)=y_center+r_crack*sin(theta);
			end
			x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
			r_crack=r_donut_external+3*le(1);
			x_crack.center(x_crack.nparticles(ipath),1,ipath)=x_center+r_crack*cos(theta);
			x_crack.center(x_crack.nparticles(ipath),2,ipath)=y_center+r_crack*sin(theta);
			x_crack.terminatedprop(ipath,1)=1;
			x_crack.terminatedprop(ipath,2)=0;
		end
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				sp=sp+1;
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);

		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		pforce_sp_base=zeros(spCount,2);
		r_adjustor=zeros(1,spCount);
		alphahp=zeros(spCount,7);
		uncrackable_sp=zeros(1,spCount);
		deltarideal_sp=zeros(1,spCount);
		deltaractual_sp=zeros(1,spCount);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		stretchmultiplier=2.1; %to stop coder whining
		stretchmultiplier=1.9; %how much does the donut stretch
		r0_donut=(r_donut_internal+r_donut_uncrackable)/2;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				theta_trial=reliableatan(delta_x_trial(1),delta_x_trial(2));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				%matmodel switch
				%matmodel(sp)=6; %hyperelastic
				matmodel(sp)=4; %crackable elastic
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				
				uncrackable_sp(sp)=0;
				if r_trial<r_donut_uncrackable
					uncrackable_sp(sp)=1;
					r_adjustor(sp)=1*le_base-r_trial;
					pforce_sp_base(sp,1)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*cos(theta_trial);
					pforce_sp_base(sp,2)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*sin(theta_trial);
				end
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
			end
		end
		if CasetoRun==159 || CasetoRun==162
			for isp=1:spCount
				x_sp(isp,:)=transpose(rotate.R*(transpose(x_sp(isp,:)-rotate.center)))+rotate.center;
				pforce_sp_base(isp,:)=transpose(rotate.R*(transpose(pforce_sp_base(isp,:))));
			end
		end
		1;
	elseif CasetoRun==160
		
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_center=7*le_base;
		y_center=7*le_base;
		r_donut_internal=1*le_base;
		r_donut_external=3*le_base;
		r_donut_uncrackable=2*le_base;
		r_donut_uncrackable=2*le_base;
		
		x_crack.npaths=8;
		%r_crack_internal=2.5*le_base;
		r_crack_internal=2*le_base; %to stop coder whining
		r_crack_internal=2*le_base;
		r_crack_external=r_donut_external+2*le(1);
		r_crack_far=6*le_base;
		
		for ipath=1:x_crack.npaths
			%x_crack.nparticles(ipath)=3;
			x_crack.nparticles(ipath)=8;
			theta=2*pi*(0.5+ipath)/x_crack.npaths;
			for iparticle=1:x_crack.nparticles(ipath)
				r_crack=r_crack_internal+(r_crack_external-r_crack_internal)/(x_crack.nparticles(ipath)-1)*(iparticle-1);
				x_crack.center(iparticle,1,ipath)=x_center+r_crack*cos(theta);
				x_crack.center(iparticle,2,ipath)=y_center+r_crack*sin(theta);
			end
			x_crack.terminatedprop(ipath,1)=1;
			x_crack.terminatedprop(ipath,2)=1;
		end
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				sp=sp+1;
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);

		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		pforce_sp_base=zeros(spCount,2);
		r_adjustor=zeros(1,spCount);
		alphahp=zeros(spCount,7);
		uncrackable_sp=zeros(1,spCount);
		deltarideal_sp=zeros(1,spCount);
		deltaractual_sp=zeros(1,spCount);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		stretchmultiplier=2.1; %to stop coder whining
		stretchmultiplier=1.9; %how much does the donut stretch
		r0_donut=(r_donut_internal+r_donut_uncrackable)/2;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				theta_trial=reliableatan(delta_x_trial(1),delta_x_trial(2));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				%matmodel switch
				%matmodel(sp)=6; %hyperelastic
				matmodel(sp)=4; %crackable elastic
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				
				uncrackable_sp(sp)=0;
				if r_trial<r_donut_uncrackable
					uncrackable_sp(sp)=1;
					r_adjustor(sp)=1*le_base-r_trial;
					pforce_sp_base(sp,1)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*cos(theta_trial);
					pforce_sp_base(sp,2)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*sin(theta_trial);
				end
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
			end
		end
		if CasetoRun==159 || CasetoRun==162
			for isp=1:spCount
				x_sp(isp,:)=transpose(rotate.R*(transpose(x_sp(isp,:)-rotate.center)))+rotate.center;
				pforce_sp_base(isp,:)=transpose(rotate.R*(transpose(pforce_sp_base(isp,:))));
			end
		end
		1;
	elseif CasetoRun==155 || CasetoRun==157 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162
		
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_center=7*le_base;
		y_center=7*le_base;
		r_donut_internal=1*le_base;
		r_donut_external=3*le_base;
		r_donut_uncrackable=2*le_base;
		if CasetoRun==156 || CasetoRun==159 || CasetoRun==162
			r_donut_uncrackable=1.5*le_base;
		elseif CasetoRun==155 || CasetoRun==157
			r_donut_uncrackable=2*le_base;
		end
		
		x_crack.npaths=8;
		%r_crack_internal=2.5*le_base;
		r_crack_internal=2*le_base; %to stop coder whining
		if CasetoRun==155 || CasetoRun==157
			r_crack_internal=2*le_base;
		elseif CasetoRun==156 || CasetoRun==159 || CasetoRun==162
			r_crack_internal=2.75*le_base;
		end
		r_crack_external=r_donut_external-le(1)/2;
		r_crack_far=6*le_base;
		
		for ipath=1:x_crack.npaths
			%x_crack.nparticles(ipath)=3;
			x_crack.nparticles(ipath)=1;
			theta=2*pi*(0.5+ipath)/x_crack.npaths;
			for iparticle=1:x_crack.nparticles(ipath)
				%r_crack=r_crack_internal+(r_crack_external-r_crack_internal)/(x_crack.nparticles(ipath)-1)*(iparticle-1);
				r_crack=r_crack_internal;
				x_crack.center(iparticle,1,ipath)=x_center+r_crack*cos(theta);
				x_crack.center(iparticle,2,ipath)=y_center+r_crack*sin(theta);
			end
			x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
			r_crack=r_crack_far;
			x_crack.center(x_crack.nparticles(ipath),1,ipath)=x_center+r_crack*cos(theta);
			x_crack.center(x_crack.nparticles(ipath),2,ipath)=y_center+r_crack*sin(theta);
			
			x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
			r_crack=r_crack_far+0.1*le_base;
			x_crack.center(x_crack.nparticles(ipath),1,ipath)=x_center+r_crack*cos(theta);
			x_crack.center(x_crack.nparticles(ipath),2,ipath)=y_center+r_crack*sin(theta);
		end
		
		if CasetoRun==159 || CasetoRun==162
			rotate.angle_deg=15;
			rotate.angle=rotate.angle_deg/180*pi;
			rotate.center=[x_center y_center];
			rotate.R=[cos(rotate.angle) -sin(rotate.angle);sin(rotate.angle) cos(rotate.angle)];
			for ipath=1:x_crack.npaths
				for iparticle=1:x_crack.nparticles(ipath)
					x_crack.center(iparticle,:,ipath)=transpose(rotate.R*(transpose(x_crack.center(iparticle,:,ipath)-rotate.center)))+rotate.center;
				end
			end
		end
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				sp=sp+1;
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);

		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		pforce_sp_base=zeros(spCount,2);
		r_adjustor=zeros(1,spCount);
		alphahp=zeros(spCount,7);
		uncrackable_sp=zeros(1,spCount);
		deltarideal_sp=zeros(1,spCount);
		deltaractual_sp=zeros(1,spCount);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		stretchmultiplier=2.1; %to stop coder whining
		if CasetoRun==157
			%stretch adjust
			stretchmultiplier=1.95; %how much does the donut stretch
		elseif CasetoRun==155 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162
			stretchmultiplier=2.1;
		end
		r0_donut=(r_donut_internal+r_donut_uncrackable)/2;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				theta_trial=reliableatan(delta_x_trial(1),delta_x_trial(2));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				if CasetoRun==156 || CasetoRun==159 || CasetoRun==162
					matmodel(sp)=4; %crackable elastic
				elseif CasetoRun==155 || CasetoRun==157
					%matmodel switch
					%matmodel(sp)=6; %hyperelastic
					matmodel(sp)=4; %crackable elastic
				end
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				
				uncrackable_sp(sp)=0;
				if r_trial<r_donut_uncrackable
					uncrackable_sp(sp)=1;
					r_adjustor(sp)=1*le_base-r_trial;
					pforce_sp_base(sp,1)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*cos(theta_trial);
					pforce_sp_base(sp,2)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*sin(theta_trial);
				end
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
			end
		end
		if CasetoRun==159 || CasetoRun==162
			for isp=1:spCount
				x_sp(isp,:)=transpose(rotate.R*(transpose(x_sp(isp,:)-rotate.center)))+rotate.center;
				pforce_sp_base(isp,:)=transpose(rotate.R*(transpose(pforce_sp_base(isp,:))));
			end
		end
		1;
	elseif CasetoRun==172 || CasetoRun==174
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_center=7*le_base;
		y_center=7*le_base;
		r_donut_internal=1*le_base;
		r_donut_external=3*le_base;
		r_donut_uncrackable=0*le_base;
		r_donut_push=1.5*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1)=2;
		x_crack.terminatedprop(1,1)=1; %crack is terminated, no further propagation
		x_crack.terminatedprop(1,2)=1; %crack is terminated, no further propagation
		x_crack.center(1,1,1)=x_center+10e-5;
		x_crack.center(1,2,1)=y_center+10e-5;
		x_crack.center(2,1,1)=x_center+11e-5;
		x_crack.center(2,2,1)=y_center+11e-5;
		
		
		%additional for troubleshooting
		%{
		x_crack.center(1,1,1)=x_center+r_donut_internal-le(1);
		x_crack.center(1,2,1)=y_center;
		x_crack.center(2,1,1)=x_center+r_donut_internal+le(1);
		x_crack.center(2,2,2)=y_center;
		x_crack.terminatedprop(1,1)=0;
		x_crack.terminatedprop(1,2)=0;
		%}
		
		
		rotate.angle_deg=0;
		rotate.angle=rotate.angle_deg/180*pi;
		rotate.center=[x_center y_center];
		rotate.R=[cos(rotate.angle) -sin(rotate.angle);sin(rotate.angle) cos(rotate.angle)];
		for ipath=1:x_crack.npaths
			for iparticle=1:x_crack.nparticles(ipath)
				x_crack.center(iparticle,:,ipath)=transpose(rotate.R*(transpose(x_crack.center(iparticle,:,ipath)-rotate.center)))+rotate.center;
			end
		end
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				sp=sp+1;
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);
		
		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		Efactor_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		pforce_sp_base=zeros(spCount,2);
		r_adjustor=zeros(1,spCount);
		alphahp=zeros(spCount,7);
		uncrackable_sp=zeros(1,spCount);
		donut_pushed_sp=zeros(1,spCount);
		deltarideal_sp=zeros(1,spCount);
		deltaractual_sp=zeros(1,spCount);
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);
		
		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		stretchmultiplier=2.1; %to stop coder whining
		stretchmultiplier=2.1;
		r0_donut=(r_donut_internal+r_donut_uncrackable)/2;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				theta_trial=reliableatan(delta_x_trial(1),delta_x_trial(2));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				matmodel(sp)=4; %crackable elastic
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				relativeangle_rad=reliableatan(delta_x_trial(1),delta_x_trial(2));
				relativeangle_deg=relativeangle_rad/pi*180;
				if relativeangle_deg>30 && relativeangle_deg<45
					Efactor_sp(sp)=0.9;
				else
					Efactor_sp(sp)=1;
				end
				
				uncrackable_sp(sp)=0;
				if r_trial<r_donut_uncrackable
					uncrackable_sp(sp)=1;
				end
				
				donut_pushed_sp(sp)=0;
				if r_trial<r_donut_push
					donut_pushed_sp(sp)=1;
					r_adjustor(sp)=1*le_base-r_trial;
					pforce_sp_base(sp,1)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*cos(theta_trial);
					pforce_sp_base(sp,2)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*sin(theta_trial);
				end
				
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
			end
		end
		
		for isp=1:spCount
			x_sp(isp,:)=transpose(rotate.R*(transpose(x_sp(isp,:)-rotate.center)))+rotate.center;
			pforce_sp_base(isp,:)=transpose(rotate.R*(transpose(pforce_sp_base(isp,:))));
		end
		1;
	elseif CasetoRun==164
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_center=7*le_base;
		y_center=7*le_base;
		r_donut_internal=1*le_base;
		r_donut_external=3*le_base;
		r_donut_uncrackable=0*le_base;
		r_donut_push=1.5*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1)=2;
		x_crack.terminatedprop(1,1)=1; %crack is terminated, no further propagation
		x_crack.terminatedprop(1,2)=1; %crack is terminated, no further propagation
		x_crack.center(1,1,1)=x_center+10e-5;
		x_crack.center(1,2,1)=y_center+10e-5;
		x_crack.center(2,1,1)=x_center+11e-5;
		x_crack.center(2,2,1)=y_center+11e-5;
		rotate.angle_deg=0;
		rotate.angle=rotate.angle_deg/180*pi;
		rotate.center=[x_center y_center];
		rotate.R=[cos(rotate.angle) -sin(rotate.angle);sin(rotate.angle) cos(rotate.angle)];
		for ipath=1:x_crack.npaths
			for iparticle=1:x_crack.nparticles(ipath)
				x_crack.center(iparticle,:,ipath)=transpose(rotate.R*(transpose(x_crack.center(iparticle,:,ipath)-rotate.center)))+rotate.center;
			end
		end
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				sp=sp+1;
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);
		
		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		pforce_sp_base=zeros(spCount,2);
		r_adjustor=zeros(1,spCount);
		alphahp=zeros(spCount,7);
		uncrackable_sp=zeros(1,spCount);
		donut_pushed_sp=zeros(1,spCount);
		deltarideal_sp=zeros(1,spCount);
		deltaractual_sp=zeros(1,spCount);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);
		
		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		stretchmultiplier=2.1; %to stop coder whining
		stretchmultiplier=2.1;
		r0_donut=(r_donut_internal+r_donut_uncrackable)/2;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				delta_x_trial=[x_trial-x_center y_trial-y_center];
				r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
				theta_trial=reliableatan(delta_x_trial(1),delta_x_trial(2));
				if r_trial<r_donut_internal
					continue;
				elseif r_trial>r_donut_external
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				matmodel(sp)=4; %crackable elastic
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				
				uncrackable_sp(sp)=0;
				if r_trial<r_donut_uncrackable
					uncrackable_sp(sp)=1;
				end
				
				donut_pushed_sp(sp)=0;
				if r_trial<r_donut_push
					donut_pushed_sp(sp)=1;
					r_adjustor(sp)=1*le_base-r_trial;
					pforce_sp_base(sp,1)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*cos(theta_trial);
					pforce_sp_base(sp,2)=log(stretchmultiplier)*E*lp(1)*lp(2)*t0_plane/r0_donut*sin(theta_trial);
				end
				
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
			end
		end
		
		for isp=1:spCount
			x_sp(isp,:)=transpose(rotate.R*(transpose(x_sp(isp,:)-rotate.center)))+rotate.center;
			pforce_sp_base(isp,:)=transpose(rotate.R*(transpose(pforce_sp_base(isp,:))));
		end
		1;
	elseif CasetoRun==138
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=4*le_base;
		y_start=2*le_base;
		y_end=4*le_base;
		
		x_crack_unused=cell(1,2);
		x_crack.npaths=1;
		x_crack.nparticles(1)=2;
		
		x_crack_temp=[0.5 3;
						3-pi*1e-5 3]*le_base;
		x_crack.center(1,1,1)=x_crack_temp(1,1);
		x_crack.center(1,2,1)=x_crack_temp(1,2);
		x_crack.center(2,1,1)=x_crack_temp(2,1);
		x_crack.center(2,2,1)=x_crack_temp(2,2);
		
		%{
		if CasetoRun==117
			x_crackcenter{1}=[0.5 3;
						3-pi*1e-5 3-pi*1e-5;
				3-pi*1e-5+2.5 3]*le_base;
		end
		x_defaultcracktip=[3 3]*le_base;
		%}
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
				
		%x_crack.top=x_crack.center;
		%x_crack.bot=x_crack.center;
		
		elasticstrength=25; %MPa
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				
				if x_trial>4*le_base-lp(1)
					if y_trial>4*le_base-lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						normalcorner_counter=normalcorner_counter+1;
					elseif y_trial<2*le_base+lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						normalcorner_counter=normalcorner_counter+1;
					else
						tractionededge_counter=tractionededge_counter+1;
						normaledge_counter=normaledge_counter+1;
					end
				elseif y_trial>4*le_base-lp(2)
					tractionededge_counter=tractionededge_counter+1;
					normaledge_counter=normaledge_counter+1;
				elseif y_trial<2*le_base+lp(2)
					tractionededge_counter=tractionededge_counter+1;
					normaledge_counter=normaledge_counter+1;
				end
				
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
				%	ParticleswithPredYVel(1)=sp;
				%end
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
				%	ParticleswithPredYVel(2)=sp;
				%end
			end
		end
		spCount=sp;
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);
		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		alphahp=zeros(spCount,7);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		for icell=1:normalcorner_counter
			normalcorner{icell}=zeros(2,2);
		end
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				matmodel(sp)=4; %crackable elastic
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
				if x_trial>4*le_base-lp(1)
					if y_trial>4*le_base-lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						tractionedcorner(tractionedcorner_counter)=sp;
						normalcorner_counter=normalcorner_counter+1;
						normalcorner{normalcorner_counter}=[1 0;
																0 1];
					elseif y_trial<2*le_base+lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						tractionedcorner(tractionedcorner_counter)=sp;
						normalcorner_counter=normalcorner_counter+1;
						normalcorner{normalcorner_counter}=[1 0;
																0 -1];
					else
						tractionededge_counter=tractionededge_counter+1;
						tractionededge(tractionededge_counter)=sp;
						normaledge_counter=normaledge_counter+1;
						normaledge(normaledge_counter,1)=1;
						normaledge(normaledge_counter,2)=0;
					end
				elseif y_trial>4*le_base-lp(2)
					tractionededge_counter=tractionededge_counter+1;
					tractionededge(tractionededge_counter)=sp;
					normaledge_counter=normaledge_counter+1;
					normaledge(normaledge_counter,1)=0;
					normaledge(normaledge_counter,2)=1;
				elseif y_trial<2*le_base+lp(2)
					tractionededge_counter=tractionededge_counter+1;
					tractionededge(tractionededge_counter)=sp;
					normaledge_counter=normaledge_counter+1;
					normaledge(normaledge_counter,1)=0;
					normaledge(normaledge_counter,2)=-1;
				end
				
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
				%	ParticleswithPredYVel(1)=sp;
				%end
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
				%	ParticleswithPredYVel(2)=sp;
				%end
			end
		end
		1;
	elseif CasetoRun==124
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		tractionedcorner_counter=0; %size reference
		normalcorner_counter=0; %size reference
		tractionededge_counter=0; %size reference
		normaledge_counter=0; %size reference
		
		pforce_sp_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_end=8*le_base;
		x_start=x_end-7.85;
		y_start=4.5*le_base-6.47/2;
		y_end=4.5*le_base+6.47/2;
		
		x_crack_unused=cell(1,2);
		%x_crackcenter=coder.nullcopy(x_crack_unused);
		x_crack.npaths=1;
		x_crack.nparticles(1)=2;
		%x_crack.center=zeros(2,2,10);
		%x_crack.top=zeros(2,2,10);
		%x_crack.bot=zeros(2,2,10);
		initialcracklength=1.61025641025641;
		
		x_crack.center(1,1,1)=(8+1)*le_base;
		x_crack.center(1,2,1)=4.5*le_base;
		x_crack.center(2,1,1)=8*le_base-initialcracklength;
		x_crack.center(2,2,1)=4.5*le_base;
		
		%{
		if CasetoRun==117
			x_crackcenter{1}=[0.5 3;
						3-pi*1e-5 3-pi*1e-5;
				3-pi*1e-5+2.5 3]*le_base;
		end
		x_defaultcracktip=[3 3]*le_base;
		%}
		
		for i=1:size(x_crack.center,1)
			for j=1:size(x_crack.center,2)
				for k=1:size(x_crack.center,3)
					x_crack.top(i,j,k)=x_crack.center(i,j,k);
					x_crack.bot(i,j,k)=x_crack.center(i,j,k);
				end
			end
		end
		
		%x_crack.top=x_crack.center;
		%x_crack.bot=x_crack.center;
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				
				if x_trial>4*le_base-lp(1)
					if y_trial>4*le_base-lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						normalcorner_counter=normalcorner_counter+1;
					elseif y_trial<2*le_base+lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						normalcorner_counter=normalcorner_counter+1;
					else
						tractionededge_counter=tractionededge_counter+1;
						normaledge_counter=normaledge_counter+1;
					end
				elseif y_trial>4*le_base-lp(2)
					tractionededge_counter=tractionededge_counter+1;
					normaledge_counter=normaledge_counter+1;
				elseif y_trial<2*le_base+lp(2)
					tractionededge_counter=tractionededge_counter+1;
					normaledge_counter=normaledge_counter+1;
				end
				
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
				%	ParticleswithPredYVel(1)=sp;
				%end
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
				%	ParticleswithPredYVel(2)=sp;
				%end
			end
		end
		spCount=sp;
		LWStatus=zeros(1,spCount);
		EWStatus=zeros(1,spCount);
		
		thetacrackrtl=zeros(1,spCount);
		xdirletter_unused=cell(1,spCount);
		ydirletter_unused=cell(1,spCount);
		zdirletter_unused=cell(1,spCount);
		xydirletter_unused=cell(1,spCount);
		yzdirletter_unused=cell(1,spCount);
		xzdirletter_unused=cell(1,spCount);
		
		xdirletter=coder.nullcopy(xdirletter_unused);
		ydirletter=coder.nullcopy(ydirletter_unused);
		zdirletter=coder.nullcopy(zdirletter_unused);
		xydirletter=coder.nullcopy(xydirletter_unused);
		yzdirletter=coder.nullcopy(yzdirletter_unused);
		xzdirletter=coder.nullcopy(xzdirletter_unused);
		
		x_sp=zeros(spCount,2);
		r1_sp=zeros(spCount,2);
		r2_sp=zeros(spCount,2);
		matmodel=zeros(1,spCount);
		orientationoffset=zeros(1,spCount);
		plotignore=zeros(1,spCount);
		tractionedcorner=zeros(1,spCount);
		p_sp=zeros(spCount,1); %it's a vertical vector
		weakeningfactor_sp=zeros(1,spCount);
		k_sp=zeros(1,spCount);
		k_sp=ones(1,spCount);
		kdot_sp=zeros(1,spCount);
		pforce_sp=zeros(spCount,2);
		alphahp=zeros(spCount,7);
		
		epsilonshrinkdot_sp=zeros(1,spCount);
		temp_sp=zeros(1,spCount);
		tempdot_sp=zeros(1,spCount);
		epsilonshrinkdotx_sp=zeros(1,spCount);
		epsilonshrinkdoty_sp=zeros(1,spCount);
		epsilonshrinkdotmat_sp=zeros(2,2,spCount);

		tractionedcorner=zeros(1,tractionedcorner_counter);
		normalcorner=cell(1,normalcorner_counter);
		tractionededge=zeros(1,tractionededge_counter);
		normaledge=zeros(normaledge_counter,2);
		
		
		tractionedcorner_counter=0;
		normalcorner_counter=0;
		tractionededge_counter=0;
		normaledge_counter=0;
		
		sp=0;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl(sp)=NaN;
				xdirletter{sp}='t';
				ydirletter{sp}='r';
				zdirletter{sp}='l';
				xydirletter{sp}='tr';
				yzdirletter{sp}='rl';
				xzdirletter{sp}='tl';
				x_sp(sp,1)=x_trial;
				x_sp(sp,2)=y_trial;
				LWStatus(sp)=LWRequest(x_trial,y_trial,x_start,y_start,x_end,y_end); %tempmarker3
				if LWStatus(sp)==0
					matmodel(sp)=5; %crackable elastic
					EWStatus(sp)=1;
				else
					matmodel(sp)=4;
					EWStatus(sp)=0;
				end
				orientationoffset(sp)=NaN;
				plotignore(sp)=0;
				
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				weakeningfactor_sp(sp)=0;
				
				if x_trial>4*le_base-lp(1)
					if y_trial>4*le_base-lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						tractionedcorner(tractionedcorner_counter)=sp;
						normalcorner_counter=normalcorner_counter+1;
						normalcorner{normalcorner_counter}=[1 0;
																0 1];
					elseif y_trial<2*le_base+lp(2)
						tractionedcorner_counter=tractionedcorner_counter+1;
						tractionedcorner(tractionedcorner_counter)=sp;
						normalcorner_counter=normalcorner_counter+1;
						normalcorner{normalcorner_counter}=[1 0;
																0 -1];
					else
						tractionededge_counter=tractionededge_counter+1;
						tractionededge(tractionededge_counter)=sp;
						normaledge_counter=normaledge_counter+1;
						normaledge(normaledge_counter,1)=1;
						normaledge(normaledge_counter,2)=0;
					end
				elseif y_trial>4*le_base-lp(2)
					tractionededge_counter=tractionededge_counter+1;
					tractionededge(tractionededge_counter)=sp;
					normaledge_counter=normaledge_counter+1;
					normaledge(normaledge_counter,1)=0;
					normaledge(normaledge_counter,1)=1;
				elseif y_trial<2*le_base+lp(2)
					tractionededge_counter=tractionededge_counter+1;
					tractionededge(tractionededge_counter)=sp;
					normaledge_counter=normaledge_counter+1;
					normaledge(normaledge_counter,1)=0;
					normaledge(normaledge_counter,2)=-1;
				end
				
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial>13*le_base && y_trial<13*le_base+lp(2);
				%	ParticleswithPredYVel(1)=sp;
				%end
				%if x_trial<6*le_base && x_trial>(6*le_base-lp(1)) && y_trial<7*le_base && y_trial>7*le_base-lp(2);
				%	ParticleswithPredYVel(2)=sp;
				%end
			end
		end
		%{
		close all;
		scatter([x_sp(1,1);x_sp(:,1)],[x_sp(1,2);x_sp(:,2)],1,[1.5 EWStatus],'filled');
		hold on
		plot([x_crack.center(1,1,1) x_crack.center(2,1,1)],[x_crack.center(1,2,1) x_crack.center(2,2,1)],'LineWidth',2,'Color','Black');
		daspect([1 1 1]);
		axis([le_base,9*le_base,le_base,8*le_base]);
		set(gca,'xtick',[0:le_base:10*le_base]);
		set(gca,'ytick',[0:le_base:9*le_base]);
		pause
		hold off
		%}
		1;
	elseif CasetoRun==112
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction
		
		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=12*le_base;
		y_start=13*le_base;
		y_end=15*le_base;
		
		x_crackcenter{1}=[0.5 0.25;
					0.5 0.75]*le_base;
		
		x_cracktop=x_crackcenter;
		x_crackbot=x_crackcenter;
		iParticleswithPredYVel=0;
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
			end
		end
		spCount=sp;
		pforce_sp=zeros(spCount,2);
		sp=0;
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial<y_end
					else
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				
				if x_trial>11*le_base && x_trial<11*le_base+lp(1) && y_trial>14*le_base && y_trial<14*le_base+lp(2)
					iParticleswithPredYVel=iParticleswithPredYVel+1;
					ParticleswithPredYVel=VectorInsertion(ParticleswithPredYVel,iParticleswithPredYVel,sp);
				end
				
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,2); %steel
				orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				pforce_sp=MatrixInsertion(pforce_sp,sp,1,0);
				pforce_sp=MatrixInsertion(pforce_sp,sp,2,0);
			end
		end
	elseif CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		if CasetoRun==94
			x_end=8*le_base;
		else
			x_end=7*le_base;
		end
		y_start=2*le_base;
		y_end=7*le_base;
		
		movingindex=0;
		if CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90
			crackparticlespacing=pi/10; %relative to le_base
		elseif CasetoRun==89
			crackparticlespacing=1; %relative to le_base
		end
		if CasetoRun==86 || CasetoRun==87 || CasetoRun==89 || CasetoRun==90 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99
			crackparticleend=9.5;
		elseif CasetoRun==91
			crackparticleend=8.5;
		end
		for movingcoordinate=0.5:crackparticlespacing:crackparticleend
			movingindex=movingindex+1;
			
			x_crackcenter{1}(movingindex,1)=movingcoordinate*le_base;
			if CasetoRun==86
				x_crackcenter{1}(movingindex,2)=(4+7/8)*le_base;
			elseif CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==89
				x_crackcenter{1}(movingindex,2)=(4+1/2)*le_base;
			elseif CasetoRun==97
				x_crackcenter{1}(movingindex,2)=(4)*le_base;
			elseif CasetoRun==99
				x_crackcenter{1}(movingindex,2)=(4+1/8)*le_base;		
			elseif CasetoRun==90
				x_crackcenter{1}(movingindex,2)=(6+1/8)*le_base;
			else
				fprintf('%s',['CasetoRun Error! 1904101734' char(10)]);
				pause;
				1;
			end
			
			if CasetoRun==86
				x_crackcenter{2}(movingindex,1)=(4+7/8)*le_base;
			elseif CasetoRun==87 || CasetoRun==95
				x_crackcenter{2}(movingindex,1)=(4+1/2)*le_base;
			elseif CasetoRun==97
				x_crackcenter{2}(movingindex,1)=(4)*le_base;
			elseif CasetoRun==99
				x_crackcenter{2}(movingindex,1)=(4+1/8)*le_base;
			elseif CasetoRun==91
				x_crackcenter{2}(movingindex,1)=(9+1/2)*le_base;
			elseif CasetoRun==92
				x_crackcenter{2}(movingindex,1)=(9+1/2)*le_base;
			elseif CasetoRun==94
				x_crackcenter{2}(movingindex,1)=(6.5)*le_base;
			elseif CasetoRun==93
				x_crackcenter{2}(movingindex,1)=(10+1/2)*le_base;
			elseif CasetoRun==90
				x_crackcenter{2}(movingindex,1)=(6+1/8)*le_base;
			elseif CasetoRun==89
			else
				fprintf('%s',['CasetoRun Error! 1904101735' char(10)]);
				pause;
				1;
			end
			
			if CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90
				x_crackcenter{2}(movingindex,2)=movingcoordinate*le_base;
			elseif CasetoRun==89
			else
				fprintf('%s',['CasetoRun Error! 1904101939' char(10)]);
				pause;
				1;
			end
		end
		
		x_cracktop=x_crackcenter;
		x_crackbot=x_crackcenter;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				%if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				%else
				%	matmodel(sp)=1; %wood_schmidt7
				%	orientationoffset(sp)=0;
				%end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				%epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
			end
		end
	elseif CasetoRun==85
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=1*le_base;
		x_end=3*le_base;
		y_start=1*le_base;
		y_end=3*le_base;
		
		x_crack.npaths=2;
		x_crack.nparticles(1:2)=2;
		
		x_crack.center(1,1,1)=0.5*le_base;
		x_crack.center(1,2,1)=15/8*le_base;
		x_crack.center(2,1,1)=3.5*le_base;
		x_crack.center(2,2,1)=15/8*le_base;
		
		x_crack.center(1,1,2)=15/8*le_base;
		x_crack.center(1,2,2)=3.5*le_base;
		x_crack.center(2,1,2)=15/8*le_base;
		x_crack.center(2,2,2)=0.5*le_base;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;

		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				%if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				%else
				%	matmodel(sp)=1; %wood_schmidt7
				%	orientationoffset(sp)=0;
				%end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				%epsilonshrinkdot_sp(sp,1)=-0.02*(y_trial-y_start)/(y_end-y_start);
			end
		end
	elseif CasetoRun==79 || CasetoRun==80
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1)=3;
		
		x_crack.center(1,1,1)=60+le_base/2;
		x_crack.center(1,2,1)=55;
		x_crack.center(2,1,1)=60+le_base/2;
		x_crack.center(2,2,1)=46;
		x_crack.center(3,1,1)=60+le_base/2;
		x_crack.center(3,2,1)=41;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				if y_trial<4*le_base
					matmodel=VectorInsertion(matmodel,sp,2); %steel
					orientationoffset=VectorInsertion(orientationoffset,sp,NaN);
				else
					matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
					orientationoffset=VectorInsertion(orientationoffset,sp,0);
				end
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02*(y_trial-y_start)/(y_end-y_start));
			end
		end
	elseif CasetoRun==77
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=10*le_base;
		
		x_crack.npaths=1;
		x_crack.center(:,2,1)=transpose([57.5:-1.25:2.5]);
		x_crack.center(:,1,1)=60;
		x_crack.nparticles(1)=size(x_crack.center,1);
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		ncforce_cracktop=zeros(x_crack.nparticles(1),2);
		ncforce_crackbot=zeros(x_crack.nparticles(1),2);
		%ncforce_cracktop(8:38,1)=100*(le(2)/4);
		%ncforce_crackbot=-ncforce_cracktop;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				thetacrackrtl=VectorInsertion(thetacrackrtl,sp,NaN);
				xdirletter=CellInsertion(xdirletter,sp,'t');
				ydirletter=CellInsertion(ydirletter,sp,'r');
				zdirletter=CellInsertion(zdirletter,sp,'l');
				xydirletter=CellInsertion(xydirletter,sp,'tr');
				yzdirletter=CellInsertion(yzdirletter,sp,'rl');
				xzdirletter=CellInsertion(xzdirletter,sp,'tl');
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,1); %wood_schmidt7
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				%{
				if y_trial<2*le_base+lp(2);
					yparticledamped=[yparticledamped sp];
				end
				%}
				%{
				if y_trial>4*le_base
					epsilonshrinkdotx_sp(sp,1)=-0.02;
					%epsilonshrinkdoty_sp(sp,1)=-0.01;
				else
					epsilonshrinkdotx_sp(sp,1)=0;
					%epsilonshrinkdoty_sp(sp,1)=0;
				end
				%}
				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,0);
			end
		end
	elseif CasetoRun==67
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=22*le_base;
		y_start=2*le_base;
		y_end=6*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1)=3;

		
		x_crack.center(1,1,1)=60.1;
		x_crack.center(1,2,1)=30.1;
		x_crack.center(2,1,1)=60.1;
		x_crack.center(2,2,1)=21.1;
		x_crack.center(3,1,1)=60.1;
		x_crack.center(3,2,1)=20.1;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_end
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1:2,[x_trial y_trial]);
				matmodel=VectorInsertion(matmodel,sp,2); %elastic (can be steel rubber or whatever)
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				
				if y_trial<2*le_base+lp(2);
					yparticledamped=VectorInsertion(yparticledamped,length(yparticledamped)+1,sp);
				end

				epsilonshrinkdot_sp=MatrixInsertion(epsilonshrinkdot_sp,sp,1,-0.02);
				
			end
		end
	elseif CasetoRun==65 || CasetoRun==70
		particle_per_cell       = 4;
		%spCount                 = 5*4*particle_per_cell;
		%spCount                 = 5*4*particle_per_cell-((30-7*2)*2);
		lp(1)                   = le(1)/sqrt(particle_per_cell);                                 % size of particle in X direction
		lp(2)                   = lp(1);                              % size of particle in Y direction

		pforce_sp=[];
		pforce_sp_sp=[];
		epsilonshrinkdot_sp=[];
		temp_sp=[];
		tempdot_sp=[];
		epsilonshrinkdotx_sp=[];
		epsilonshrinkdoty_sp=[];
		epsilonshrinkdotmat_sp=[];

		sp=0;
		sp_predvelnum=0;
		displacementmonitoredparticles=[];
		
		x_start=2*le_base;
		x_end=8*le_base;
		y_start=1*le_base;
		y_end=8*le_base;
		
		x_crack.npaths=1;
		x_crack.nparticles(1)=6;
		
		x_crack.center(1,1,1)=20;
		x_crack.center(1,2,1)=37;
		x_crack.center(2,1,1)=22;
		x_crack.center(2,2,1)=37;
		x_crack.center(3,1,1)=32;
		x_crack.center(3,2,1)=37;
		x_crack.center(4,1,1)=42;
		x_crack.center(4,2,1)=37;
		x_crack.center(5,1,1)=51;
		x_crack.center(5,2,1)=37;
		x_crack.center(6,1,1)=52;
		x_crack.center(6,2,1)=37;
		
		x_crack.top=x_crack.center;
		x_crack.bot=x_crack.center;
		
		for i=1:(NN(2)-1)*sqrt(particle_per_cell);
			y_trial=(lp(2)/2)+(i-1)*lp(2);
			for j=1:(NN(1)-1)*sqrt(particle_per_cell);
				x_trial=(lp(1)/2)+(j-1)*lp(1);
				%if x_trial>2*le_base && x_trial<8*le_base && y_trial>2*le_base && y_trial<6*le_base
				if x_trial<x_start
					continue;
				elseif x_trial<x_start+1*le_base
					if y_trial<y_start
						continue;
					elseif y_trial>y_end
						continue;
					end
				elseif x_trial<x_end
					if y_trial<y_start+1*le_base
						continue;
					elseif y_trial>y_end-3*le_base
						continue;
					end
				else
					continue;
				end
				
				sp=sp+1;
				
				xdirletter=CellInsertion(xdirletter,sp,[]);
				ydirletter=CellInsertion(ydirletter,sp,[]);
				zdirletter=CellInsertion(zdirletter,sp,[]);
				xydirletter=CellInsertion(xydirletter,sp,[]);
				yzdirletter=CellInsertion(yzdirletter,sp,[]);
				xzdirletter=CellInsertion(xzdirletter,sp,[]);
				x_sp=MatrixInsertion(x_sp,sp,1,x_trial);
				x_sp=MatrixInsertion(x_sp,sp,2,y_trial);
				matmodel=VectorInsertion(matmodel,sp,2); %elastic (can be steel rubber or whatever)
				p_sp=MatrixInsertion(p_sp,sp,1,psp2);
				plotignore=VectorInsertion(plotignore,sp,0);
				weakeningfactor_sp=VectorInsertion(weakeningfactor_sp,sp,0);
				k_sp=VectorInsertion(k_sp,sp,1);
				kdot_sp=VectorInsertion(kdot_sp,sp,0);
				orientationoffset=VectorInsertion(orientationoffset,sp,0);
				
				if x_trial>7*le_base+lp(1);
					yparticledamped=VectorInsertion(yparticledamped,length(yparticledamped)+1,sp);
				end
				
			end
		end
	end
	
	spCount=sp;

	d_sp                    = zeros(spCount,2);
	E_acc                   = zeros(spCount,1);
	%{
	if exist('epsilonshrinkdot_sp')
	else
		epsilonshrinkdot_sp     = zeros(spCount,1);
	end
	if exist('epsilonshrinkdotx_sp')
	else
		epsilonshrinkdotx_sp     = zeros(spCount,1);
	end
	if exist('epsilonshrinkdoty_sp')
	else
		epsilonshrinkdoty_sp     = zeros(spCount,1);
	end
	if exist('pforce_sp')
	else
		pforce_sp               = zeros(spCount,2);
	end
	%}
	
	%TDL spCount variable declarations here
	s_sp=zeros(spCount,3);
	b_sp=zeros(spCount,2);
	pforce_sp=zeros(spCount,2);
	e_t_global_big=zeros(spCount,6);
	e_pl_global_big=zeros(spCount,6);
	alphahp=zeros(spCount,7);
	shrinkplot.xshrinkage=zeros(1,spCount);
	shrinkplot.yshrinkage=zeros(1,spCount);
	shrinkplot.matrix=zeros(spCount,3);
	shrinkage_sp=zeros(2,2,spCount);
	shrinkage_local_before_sp=zeros(2,2,spCount);
	shrinkage_global_before_sp=zeros(2,2,spCount);
	shrinkage_local_new_sp=zeros(2,2,spCount);
	shrinkage_global_new_sp=zeros(2,2,spCount);
	shrinkage_global_sp_vectorized=zeros(spCount,3);
	shrinkagedot_global_sp=zeros(2,2,spCount);
	temp_sp_temp=zeros(1,spCount);
	tempdot_sp_temp=zeros(1,spCount);
	surroundtag_sp=zeros(1,spCount);
	time_fds=zeros(1,spCount);
	MPMtimemult_sp1=zeros(1,spCount); %calculation from around crack
	MPMtimemult_sp2=zeros(1,spCount); %calculation from acceleration due to at the edge
	MPMtimemult_sp=zeros(1,spCount); %taking the maximum from the two above
	straighttocooling=0;
	density_sp=zeros(1,spCount);
	epsilonshrinkmax_sp=zeros(spCount,2);
	F_loadcontrolled=zeros(1,1);
	t0=zeros(1,1); %see docs/dmtasetup.tex
	Ktangent_local=zeros(6,6,spCount);
	
	if straighttocooling
		for isp=1:spCount
			time_fds(isp)=1800;
		end
	end
	%TDL remaining strength adjustment here
	hightempremainingstrength=0.1;
	density0=500; %to stop coder whining
	temp0=20; %to stop coder whining
	
	%list of data repositories:
		%Simple11
		%Spruce210325
		%Spruce210405
		%Spruce210508
		%Spruce210517
		%Spruce210325 Spruce210405 Spruce210508
	%loading FDS data and literature shrinkage
	%if 0
		if CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==210
			%preallocating for FDS results
			repositoryname='Spruce210405';
			[size1,size2]=sizematrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSShrinkage.txt']);
			FDS.shrinkage=zeros(size1,size2);
			
			[size1,size2]=sizematrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSTemp.txt']);
			FDS.temp=zeros(size1,size2);
			
			[size1,size2]=sizematrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSTime.txt']);
			FDS.time=zeros(size1,size2);
			
			[size1,size2]=sizematrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSDepth.txt']);
			FDS.depth=zeros(size1,size2);
			
			[size1,size2]=sizematrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSConversion.txt']);
			FDS.conversion=zeros(size1,size2);
			
			[size1,size2]=sizematrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSDensity.txt']);
			FDS.density=zeros(size1,size2);
			
			FDS.s=zeros(1,1); %shrinkage ratio = 1-L/L0 or 1-V/V0
			FDS.firsttempplot=zeros(1,1); %switcher to indicate first temperature plot
			FDS.epsilonshrink=zeros(spCount,2);
			FDS.lratiocalc=zeros(1,1); %calculated from literature
			FDS.lratiomin=zeros(1,1); %minimum L ratio, put something really small but >0
			FDS.lratiomax=zeros(1,1); %maximum L ratio value (normally 1, but if swelling is allowed (not recommended, probably bad interpretation), then can put like really big or +infinite or something) 
			FDS.lratio=zeros(1,1); %taken to the next calculations
			FDS.sigma=zeros(1,1); %that multiplier factor before conversion squared
			
			[size1,size2]=sizematrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSConversion.txt']);
			FDS.k=zeros(size1,size2); %stiffness multiplier (1 as default, 0 at total flimsiness)
			
			FDS_scalc.a=zeros(1,1); %that factor for the T vs sigma 2nd order regression
			FDS_scalc.b=zeros(1,1); %that factor for the T vs sigma 2nd order regression
			FDS_scalc.c=zeros(1,1); %that factor for the T vs sigma 2nd order regression
			
			[size1,size2]=sizematrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSConversion.txt']);
			FDS_scalc.shrinkage=zeros(size1,size2); %shrinkage in log strain
			
			FDS.scalc=repmat(FDS_scalc,1,3);%1 for R, 2 for T, 3 for L
			FDS.firsttempplot=zeros(1,1);
			
			%assigning values
			FDS.shrinkage=loadmatrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSShrinkage.txt']);
			FDS.temp=loadmatrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSTemp.txt']);
			FDS.time=loadmatrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSTime.txt']);
			FDS.depth=loadmatrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSDepth.txt']);
			FDS.conversion=loadmatrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSConversion.txt']);
			FDS.density=loadmatrixfloat(['C:\\Users\\Tito\\Documents\\Run Data Repository 2\\' repositoryname '\\FDSDensity.txt']);
			density0=max(FDS.density(:,1));
			temp0=min(FDS.temp(:,1));
			if CasetoRun==226 || CasetoRun==227
				%calculation, see: /d/Users/Tito/Documents/Combined_2020-11-26/Equations/shrinkbasis01.wmf
				%data, see: Tito@Asus-X450J '/d/Users/Tito/Documents/Writing Up 4/210417-12.dwg'
				experimentalhomogeneousshrinkage=1; %only supports strong direction for now
				consideredface=2; %1: weak direction, 2: strong direction
				if consideredface==1
					epsilonshrinkxtop=(8.929-10)/10;
					epsilonshrinkxbot=(8.9735-10)/10;
				else%if consideredface==2
					epsilonshrinkxtop=(9.1374-10)/10;
					epsilonshrinkxbot=(8.8994-10)/10;
					if experimentalhomogeneousshrinkage==1
						epsilonshrinkxtop=(8.8994-10)/10;
						epsilonshrinkxbot=(8.8994-10)/10;
					elseif experimentalhomogeneousshrinkage==2
						epsilonshrinkxtop=(9.1374-10)/10;
						epsilonshrinkxbot=(8.8994-10)/10;
					end
					%epsilonshrinky=-(2-[1.135 1.990 1.845 1.890 1.245])/2; %function of y
				end
				
				%TDL proper shrinky switch here
				%epsilonshrinky=-(2-[1.2494 1.6976 1.4704 1.4414 1.1537])/2; %function of y
				if consideredface==1
					epsilonshrinky=-(2-[1.2919 1.2517 1.3700 1.2727 1.1718])/2; %function of y
				else%if consideredface==2
					epsilonshrinky=-(2-[1.1537 1.4414 1.4704 1.4414 1.1537])/2; %function of y
					if experimentalhomogeneousshrinkage==1
						epsilonshrinky=[0.25 0.25 0.25 0.25 0.25];
						epsilonshrinky=[1 1 1 1 1]*(1e-8);
					elseif experimentalhomogeneousshrinkage==2
						epsilonshrinky=-(2-[1.2919 1.2517 1.3700 1.2727 1.1718])/2*(1e-8); %function of y
					end
				end
				epsilonshrinkx=[epsilonshrinkxbot epsilonshrinkxtop];
				
				x_epsilonshrinky=linspace(20,120,5);
				y_epsilonshrinkx=linspace(20,40,2);
				%calculating integral epsilonshrinky*dx and kx below:
				nintpoints=101;
				x_in1=linspace(20,120,nintpoints);
				y_out1=arbitrarybasis(x_epsilonshrinky,epsilonshrinky,x_in1);
				L=100;
				kx=L/trapz(x_in1,y_out1);
				
				
				%calculating integral epsilonshrinkx*dy and ky below:
				x_in2=linspace(20,40,nintpoints);
				y_out2=arbitrarybasis(y_epsilonshrinkx,epsilonshrinkx,x_in2);
				h=20;
				ky=h/trapz(x_in2,y_out2);
				for isp=1:spCount
					epsilonshrinkmax_sp(isp,:)=[kx ky]*arbitrarybasis(x_epsilonshrinky,epsilonshrinky,x_sp(isp,1))*arbitrarybasis(y_epsilonshrinkx,epsilonshrinkx,x_sp(isp,2));
				end
				%converting to log strain below
				for isp=1:spCount
					for idim=1:2
						epsilonshrinkmax_sp(isp,idim)=log(1+epsilonshrinkmax_sp(isp,idim));
					end
				end
				
				
				regularproportion=1;
				%flippedproportion=0.1;
				flippedproportion=0;
				%regularproportion=0.6;
				%flippedproportion=0.4;
				depthmax=20; %mm, predefined, specimen-specific, ok?
				FDS_temp_new=zeros(size(FDS.temp));
				FDS_density_new=zeros(size(FDS.density));
				FDS_deltatemp=FDS.temp-temp0;
				FDS_deltadensity=FDS.density-density0;
				%find where the depths end
				idepthmax=1; %to prevent coder whining
				for i=1:length(FDS.depth)
					if FDS.depth(i)>depthmax+1e-6
						idepthmax=i-1;
						break;
					end
				end
				for i=1:idepthmax
					%assumptions:
						%FDS.density is spaced equally spatially.
					i2=idepthmax+1-i;
					%works for partition of unity, have to think in terms of deltas otherwise
					%FDS_temp_new(i,:)=regularproportion*FDS.temp(i,:)+flippedproportion*FDS.temp(i2,:);
					%FDS_density(i,:)=regularproportion*FDS.density(i,:)+flippedproportion*FDS.density(i2,:);
					
					%works with delta stuff, no partition of unity is necessary for regularproportion or flippedproportion
					FDS_temp_new(i,:)=temp0+regularproportion*FDS_deltatemp(i,:)+flippedproportion*FDS_deltatemp(i2,:);
					FDS_density_new(i,:)=density0+regularproportion*FDS_deltadensity(i,:)+flippedproportion*FDS_deltadensity(i2,:);
				end
				FDS.temp=FDS_temp_new;
				FDS.density=FDS_density_new;
			end
			
			FDS.lratiomin=0.001;
			FDS.lratiomax=1;
			%source of calculation data and method:
			%https://www.sciencedirect.com/science/article/pii/S0016236101001697
			FDS.scalc(1).a=-2.62e-6;
			FDS.scalc(1).b=0.00395;
			FDS.scalc(1).c=-1;
			FDS.scalc(2).a=4.55e-6;
			FDS.scalc(2).b=-0.00856;
			FDS.scalc(2).c=4.4;
			FDS.scalc(3).a=-5.86e-6;
			FDS.scalc(3).b=0.0108;
			FDS.scalc(3).c=-4.7;
			%"D:\Users\Tito\Documents\Combined_2020-11-26\aleksi's run data\shrinkfromliterature01.wmf"
			for idir=1:3 %1=R, 2=T, 3=L
				for i=1:size(FDS.conversion,1)
					for j=1:size(FDS.conversion,2)
						FDS.sigma=FDS.scalc(idir).a*(FDS.temp(i,j)+273.15)^2+FDS.scalc(idir).b*(FDS.temp(i,j)+273.15)+FDS.scalc(idir).c;
						FDS.s=FDS.sigma*FDS.conversion(i,j)^2;
						FDS.lratiocalc=1-FDS.s;
						FDS.lratio=min(FDS.lratiomax,max(FDS.lratiomin,FDS.lratiocalc));
						FDS.scalc(idir).shrinkage(i,j)=log(FDS.lratio);
					end
				end
			end
			for i=1:size(FDS.k,1)
				for j=1:size(FDS.k,2)
					FDS.k(i,j)=max([hightempremainingstrength 1-(FDS.temp(i,j)-20)/(300-20)]);
				end
			end
		elseif CasetoRun==-210
			%preallocating for FDS results
			[size1,size2]=sizematrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSShrinkage.txt');
			FDS.shrinkage=zeros(size1,size2);
			
			[size1,size2]=sizematrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSTemp.txt');
			FDS.temp=zeros(size1,size2);
			
			[size1,size2]=sizematrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSTime.txt');
			FDS.time=zeros(size1,size2);
			
			[size1,size2]=sizematrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSDepth.txt');
			FDS.depth=zeros(size1,size2);
			
			[size1,size2]=sizematrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSConversion.txt');
			FDS.conversion=zeros(size1,size2);
			
			[size1,size2]=sizematrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSDensity.txt');
			FDS.density=zeros(size1,size2);
			
			FDS.s=zeros(1,1); %shrinkage ratio = 1-L/L0 or 1-V/V0
			FDS.firsttempplot=zeros(1,1); %switcher to indicate first temperature plot
			FDS.epsilonshrink=zeros(spCount,2);
			FDS.lratiocalc=zeros(1,1); %calculated from literature
			FDS.lratiomin=zeros(1,1); %minimum L ratio, put something really small but >0
			FDS.lratiomax=zeros(1,1); %maximum L ratio value (normally 1, but if swelling is allowed (not recommended, probably bad interpretation), then can put like really big or +infinite or something) 
			FDS.lratio=zeros(1,1); %taken to the next calculations
			FDS.sigma=zeros(1,1); %that multiplier factor before conversion squared
			
			[size1,size2]=sizematrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSConversion.txt');
			FDS.k=zeros(size1,size2); %stiffness multiplier (1 as default, 0 at total flimsiness)
			
			FDS_scalc.a=zeros(1,1); %that factor for the T vs sigma 2nd order regression
			FDS_scalc.b=zeros(1,1); %that factor for the T vs sigma 2nd order regression
			FDS_scalc.c=zeros(1,1); %that factor for the T vs sigma 2nd order regression
			
			[size1,size2]=sizematrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSConversion.txt');
			FDS_scalc.shrinkage=zeros(size1,size2); %shrinkage in log strain
			
			FDS.scalc=repmat(FDS_scalc,1,3);%1 for R, 2 for T, 3 for L
			FDS.firsttempplot=zeros(1,1);
			
			%assigning values
			FDS.shrinkage=loadmatrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSShrinkage.txt');
			FDS.temp=loadmatrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSTemp.txt');
			FDS.time=loadmatrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSTime.txt');
			FDS.depth=loadmatrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSDepth.txt');
			FDS.conversion=loadmatrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSConversion.txt');
			FDS.density=loadmatrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\Simple11\\FDSDensity.txt');
			FDS.lratiomin=0.001;
			FDS.lratiomax=1;
			%source of calculation data and method:
			%https://www.sciencedirect.com/science/article/pii/S0016236101001697
			FDS.scalc(1).a=-2.62e-6;
			FDS.scalc(1).b=0.00395;
			FDS.scalc(1).c=-1;
			FDS.scalc(2).a=4.55e-6;
			FDS.scalc(2).b=-0.00856;
			FDS.scalc(2).c=4.4;
			FDS.scalc(3).a=-5.86e-6;
			FDS.scalc(3).b=0.0108;
			FDS.scalc(3).c=-4.7;
			%"D:\Users\Tito\Documents\Combined_2020-11-26\aleksi's run data\shrinkfromliterature01.wmf"
			for idir=1:3 %1=R, 2=T, 3=L
				for i=1:size(FDS.conversion,1)
					for j=1:size(FDS.conversion,2)
						FDS.sigma=FDS.scalc(idir).a*(FDS.temp(i,j)+273.15)^2+FDS.scalc(idir).b*(FDS.temp(i,j)+273.15)+FDS.scalc(idir).c;
						FDS.s=FDS.sigma*FDS.conversion(i,j)^2;
						FDS.lratiocalc=1-FDS.s;
						FDS.lratio=min(FDS.lratiomax,max(FDS.lratiomin,FDS.lratiocalc));
						FDS.scalc(idir).shrinkage(i,j)=log(FDS.lratio);
					end
				end
			end
			for i=1:size(FDS.k,1)
				for j=1:size(FDS.k,2)
					FDS.k(i,j)=max([0.1 1-(FDS.temp(i,j)-20)/(300-20)]);
				end
			end
		else
			%within this is just bogus declarations to stop coder from whining
			FDS.shrinkage=zeros(1,1);
			FDS.time=zeros(1,1);
			FDS.depth=zeros(1,1);
			FDS.temp=zeros(1,1);
			FDS.conversion=zeros(1,1);
			FDS.firsttempplot=zeros(1,1); %switcher to indicate first temperature plot
			FDS.epsilonshrink=zeros(1,2);
			
			FDS.s=zeros(1,1); %shrinkage ratio = 1-L/L0 or 1-V/V0
			FDS.lratiocalc=zeros(1,1); %calculated from literature
			FDS.lratiomin=zeros(1,1); %minimum L ratio, put something really small but >0
			FDS.lratiomax=zeros(1,1); %maximum L ratio value (normally 1, but if swelling is allowed (not recommended, probably bad interpretation), then can put like really big or +infinite or something) 
			FDS.lratio=zeros(1,1); %taken to the next calculations
			FDS.sigma=zeros(1,1); %that multiplier factor before conversion squared
			FDS.k=zeros(1,1);
			FDS_scalc.a=zeros(1,1); %that factor for the T vs sigma 2nd order regression
			FDS_scalc.b=zeros(1,1); %that factor for the T vs sigma 2nd order regression
			FDS_scalc.c=zeros(1,1); %that factor for the T vs sigma 2nd order regression
			FDS_scalc.shrinkage=zeros(1,1); %shrinkage in log strain
			FDS.scalc=repmat(FDS_scalc,1,2);%1 for R, 2 for T, 3 for L
		end
	%end
	%load('hfdjsklafhndjsklafhdjsklaf.mat');
	
	%{
	%switchable1
	if size(epsilonshrinkdot_sp,1)==0
		epsilonshrinkdot_sp=ResizeMatrix(epsilonshrinkdot_sp,spCount,1);
	end
	if size(epsilonshrinkdotx_sp,1)==0
		epsilonshrinkdotx_sp=zeros(spCount,1);
	end
	if size(epsilonshrinkdoty_sp,1)==0
		epsilonshrinkdoty_sp=zeros(spCount,1);
	end
	if size(pforce_sp,1)==0
		pforce_sp=zeros(spCount,2);
	end
	%evaltimes_accummulated  = zeros(spCount,1);
	%}
	%switchable1

	%{
	for i=1:6
		for j=1:30
			%if (j>7 & j<24) & (i==1|i==6)
			%    continue;
			%end
			sp=sp+1;
			if sp>spCount
				disp('spCount wrong!');
				pause;
			end
			x_sp(sp,1:2)= [4*le(1,1)+0.5*lp(1,1)+(j-1)*lp(1,1) 4*le(1,2)+0.5*lp(1,2)+(i-1)*lp(1,2)];
			if j==15
				sp_predvelnum=sp_predvelnum+1;
				displacementmonitoredparticles(sp_predvelnum)=sp;
			end
			xdirletter{sp}='l';
			ydirletter{sp}='r';
			zdirletter{sp}='t';
			xydirletter{sp}='lr';
			yzdirletter{sp}='rt';
			xzdirletter{sp}='lt';
		end
	end
	%}
	% x_sp: Vector, position of MPs
	% spCount: total number of MPs

	%DELTAt=k*DELTAt_critical


	%% Plot initial condition
	%{
	%switchable1
	if Debugging.Active==0
		if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==7 || CasetoRun==5 || CasetoRun==6
			initial_figure = Plot_Initial(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp);
		elseif CasetoRun==10
			initial_figure = Plot_Initial_sp(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp);
		elseif CasetoRun==8 || CasetoRun==9
			initial_figure = Plot_Initial_var(x_sp,LOC,LOCX,LOCY,orientationoffset,xdirletter,ydirletter,lp);
		elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==56 || CasetoRun==60 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
			initial_figure = Plot_Initial_linehighlighted(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp);
		elseif CasetoRun==61 || CasetoRun==62 || CasetoRun==63
			if runorjustplot==0
				initial_figure = Plot_Initial_squishy(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,matmodel);
			else
				initial_figure = Plot_Initial_squishy2(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,matmodel);
			end
		elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
			initial_figure = Plot_Initial_linehighlighted2(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp);
		elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
			initial_figure = Plot_Initial(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp);
		elseif CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
			initial_figure = Plot_Initial_crackmulti(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,x_crack,CasetoRun);
		elseif CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174
			initial_figure = Plot_Initial_crackmulti_r_sp(r1_sp,r2_sp,x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,x_crack,CasetoRun);
		end
	end
	%}
	%switchable1
	
	%% Particle variables
	dparticle               = lp(1)*lp(2);                          % area of particle domain
	x_spo                   = x_sp;                                 % initial position
	d_sp                    = zeros(spCount,2);                     % displacement
	s_sp                    = zeros(spCount,3);                     % Stress tensor
	ds_sp                   = zeros(spCount,3);                     % Stress increment
	if CasetoRun==154 || CasetoRun==161
		v_ssp=v_ssp_0;
	else
		v_ssp               = zeros(spCount,2);                     % velocty
	end
	e_sp                    = zeros(spCount,3);                     % Strain tensor
	de_sp                   = zeros(spCount,3);                     % Strain increment
	ptraction_sp            = zeros(spCount,2);                     % traction
	F_sp                    = cell(spCount,1);                      % Gradient deformation
	e_pl_sp                 = zeros(spCount,3);
	sigma_local_big         = zeros(spCount,6);
	sigma_global_big        = zeros(spCount,6);
	e_t_global_big          = zeros(spCount,6);
	e_pl_global_big         = zeros(spCount,6);
	alphahp                 = zeros(spCount,7);
	f_final_vect            = zeros(spCount,7);
	surfacewithfmax         = zeros(1,spCount);
	E_acc                   = zeros(1,spCount);
	evaltimes               = zeros(spCount,1);
	stackvars               = zeros(spCount+1,2);
	duration                = zeros(1,spCount);
	dudx_sp                 = zeros(spCount,4); %11, 12, 21, 22
	W_sp                    = zeros(spCount,1);
	thetacrack              = zeros(1,spCount);
	%thetacrackrtl           = zeros(1,spCount);
	sigmainf                = 0;
	G                       = 0;
	Ga                      = 0;
	Grelativeerror          = 0;
	sigmamaxprincmaxperfy   = 0; %max of all nodes
	e_t_schmidtglobalmatrixsimple=zeros(spCount,3);%strain approximation for small rotation
	e_t_schmidtswellsonly=zeros(spCount,3);%strain approximation for small rotation
	epsilonshrink_sp_vectorized=zeros(spCount,3);
	epsilonshrinkdot_sp_vectorized=zeros(spCount,3);
	
	coder.varsize('f_final_vect');
	coder.varsize('surfacewithfmax');
	coder.varsize('E_acc');
	
	%rexp: exponential asymtotic approach of loading
	rexp.rs=zeros(1,1);
	rexp.rsdot=zeros(1,1);
	rexp.A=zeros(1,1);
	rexp.ts=zeros(1,1);
	rexp.switched=zeros(1,1);
	
	%pushcol: spring-damper as function of average radial distance/velocity
	pushcol.spcounter=zeros(1,1);
	pushcol.initialcalculated=zeros(1,1);
	pushcol.deltax.initial=zeros(spCount,2);
	pushcol.deltax.current=zeros(spCount,2);
	pushcol.theta.initial=zeros(1,spCount);
	pushcol.theta.current=zeros(1,spCount);
	pushcol.absolute_r_sp.initial=zeros(1,spCount);
	pushcol.absolute_r_sp.current=zeros(1,spCount);
	pushcol.relative_r_sp.current=zeros(1,spCount);
	pushcol.relative_r_sp.curavg=zeros(1,1);
	pushcol.relative_r_sp.coltgt=zeros(1,1);
	pushcol.relative_r_sp.delta=zeros(1,1);
	pushcol.relative_r_sp.springforce=zeros(1,1);
	pushcol.v_r_sp.current=zeros(1,spCount);
	pushcol.v_r_sp.curavg=zeros(1,1);
	pushcol.v_r_sp.coltgt=zeros(1,1);
	pushcol.v_r_sp.delta=zeros(1,1);
	pushcol.v_r_sp.dampforce=zeros(1,1);	
	
	%anerror: case 154 (vortex) velocity field error calculation (numerical vs analytical)
	anerror.gridsize=zeros(1,1);
	anerror.t_deviation=zeros(1,1);
	anerror.v_ssp_an=zeros(spCount,2);
	anerror.v_err_absolute=zeros(spCount,2);
	anerror.v_srsserror=zeros(1,1);
	anerror.v_srssan=zeros(1,1);
	anerror.v_err_relative=zeros(1,1);
	anerror.u_sp=zeros(spCount,2);
	anerror.u_sp_an=zeros(spCount,2);
	anerror.u_err_absolute=zeros(spCount,2);
	anerror.u_err_relative=zeros(1,1);
	anerror.u_srsserror=zeros(1,1);
	anerror.u_srssan=zeros(1,1);
	
	
	if CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
		r1crack_sp = cell(1,1);
		r2crack_sp = cell(1,1);
		v_crack             = cell(x_crack.npaths);
		for i=1:length(x_crack) %this is supposed to be x_crackcenter.
			v_crack{i}      = zeros(x_crack.nparticles(i),2);
		end
	else
		v_crack             = zeros(size(x_crack)); %this is supposed to be x_crackcenter.
	end
	

	%% Initial condition
	% Gradient deformation
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==10 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		r1crack_sp = cell(1,1);
		r2crack_sp = cell(1,1);
		for sp_inloop = 1:spCount
			r1_sp(sp_inloop,:) = [lp(1,1)/2 0];
			r2_sp(sp_inloop,:) = [0 lp(1,2)/2];
			F_sp{sp_inloop} = [1 0; 0 1];
		end

		Fcrack_sp=cell(1,size(x_crack.center,1));
		for spcrack=1:size(x_crack.center,1)
			r1crack_sp{1}=MatrixInsertion(r1crack_sp{1},spcrack,1,lp(1,1)/2);
			r1crack_sp{1}=MatrixInsertion(r1crack_sp{1},spcrack,2,0);
			Fcrack_sp{spcrack}=[1 0; 0 1];
		end
	elseif CasetoRun==154 || CasetoRun==161
		for sp_inloop = 1:spCount
			F_sp{sp_inloop} = [1 0; 0 1];
		end
		
		length_x_crack=x_crack.npaths;
		r1crack_sp = cell(1,length_x_crack);
		r2crack_sp = cell(1,length_x_crack);
		
		Fcrack_sp=cell(1,length_x_crack);
		
		for icrackpath=1:length_x_crack
			Fcrack_sp{icrackpath}=cell(1,x_crack.nparticles(icrackpath));
			r1crack_sp{icrackpath}=zeros(x_crack.nparticles(icrackpath),2);
			r2crack_sp{icrackpath}=zeros(x_crack.nparticles(icrackpath),2);
		end
		
		for icrackpath=1:length_x_crack
			for spcrack=1:size(x_crack.nparticles(icrackpath),1)
				r1crack_sp{icrackpath}(spcrack,1) = lp(1,1)/2;
				r1crack_sp{icrackpath}(spcrack,2) = 0;
				r2crack_sp{icrackpath}(spcrack,1) = 0;
				r2crack_sp{icrackpath}(spcrack,2) = lp(1,2)/2;
				Fcrack_sp{icrackpath}{spcrack} = [1 0; 0 1];		
			end
		end
	elseif CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
		for sp_inloop = 1:spCount
			r1_sp(sp_inloop,:) = [lp(1,1)/2 0];
			r2_sp(sp_inloop,:) = [0 lp(1,2)/2];
			F_sp{sp_inloop} = [1 0; 0 1];
		end
		if CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174
			for isp=1:spCount
				r1_sp(isp,:)=transpose(rotate.R*(transpose(r1_sp(isp,:))));
				r2_sp(isp,:)=transpose(rotate.R*(transpose(r2_sp(isp,:))));
			end
		end
		length_x_crack=x_crack.npaths;
		r1crack_sp = cell(1,length_x_crack);
		r2crack_sp = cell(1,length_x_crack);
		
		Fcrack_sp=cell(1,length_x_crack);
		
		for icrackpath=1:length_x_crack
			Fcrack_sp{icrackpath}=cell(1,x_crack.nparticles(icrackpath));
			r1crack_sp{icrackpath}=zeros(x_crack.nparticles(icrackpath),2);
			r2crack_sp{icrackpath}=zeros(x_crack.nparticles(icrackpath),2);
		end
		
		for icrackpath=1:length_x_crack
			for spcrack=1:size(x_crack.nparticles(icrackpath),1)
				r1crack_sp{icrackpath}(spcrack,1) = lp(1,1)/2;
				r1crack_sp{icrackpath}(spcrack,2) = 0;
				r2crack_sp{icrackpath}(spcrack,1) = 0;
				r2crack_sp{icrackpath}(spcrack,2) = lp(1,2)/2;
				Fcrack_sp{icrackpath}{spcrack} = [1 0; 0 1];		
			end
		end
		
	elseif CasetoRun==8 || CasetoRun==9
		for sp_inloop = 1:spCount
			r1_sp(sp_inloop,:) = [lp(sp_inloop,1)/2 0];
			r2_sp(sp_inloop,:) = [0 lp(sp_inloop,2)/2];
			F_sp{sp_inloop} = [1 0; 0 1];
		end
	end
	r10_sp = r1_sp;
	r20_sp = r2_sp;
	%A_sp                    = zeros(spCount,1);
	t_sp                    = ones(spCount,1)*t0_plane;
	if CasetoRun==154 || CasetoRun==161
	else
		A_sp                    = 4.*abs(r1_sp(:,1).*r2_sp(:,2)-r1_sp(:,2).*r2_sp(:,1)); 
	end
	A_spo                   = A_sp;
	t_spo                   = t_sp;
	m_sp                    = p_sp.*A_sp.*t_sp;                           % mass
	
	% Traction
	%{
	for sp_inloop=1:spCount
		if x_sp(sp_inloop,1)>1.01
			ptraction_sp(sp_inloop,1) = 0;
		end
	end
	%}
	
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
		%dmax=-4*le_base;
		%{
		dmax=-0.2680*le_base;
		%dmax=-0.3*le_base;
		%t1=20*2;
		t1=4;
		t2=6;
		t3=10;
		t4=12;
		t5=16;
		%}
		%pforce_maxpres=-30;
		%pforce_max=pforce_maxpres*10/2;
	elseif CasetoRun==4
		dmax=-20;
		t1=10;
		
		pforce_maxpres=-30;
		pforce_max=pforce_maxpres*10/2;
	elseif CasetoRun==5 || CasetoRun==6
	elseif CasetoRun==7
	elseif CasetoRun==8 || CasetoRun==9
	elseif CasetoRun==10
	elseif CasetoRun==11
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
	elseif CasetoRun==158
		
	end
	

	%{
	while sp<spCount+0.0001
		for i=1:6
			for j=1:24
				if j==24
					sp_predvelnum=sp_predvelnum+1;
					particleswithpredeterminedvelocities(sp_predvelnum)=sp;
					predeterminedvelocityvalueref(sp_predvelnum,:)=[1 0]; 
					%ptraction_sp(sp_predvelnum,1)=1000000;
				end
				sp=sp+1;
			end
		end
	end
	%}
	%% start the algorithm
	% video
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
		videofps=60;                              % video output fps
		timescale=0.5;                      % video speed-up factor
	elseif CasetoRun==4
		videofps=60;                              % video output fps
		timescale=1;                      % video speed-up factor
	elseif CasetoRun==5 || CasetoRun==6
		videofps=60;                              % video output fps
		timescale=0.5;                      % video speed-up factor
	elseif CasetoRun==7
		videofps=60;                              % video output fps
		timescale=0.5;                      % video speed-up factor
	elseif CasetoRun==8 || CasetoRun==9
		videofps=60;                              % video output fps
		timescale=0.5;                      % video speed-up factor
	elseif CasetoRun==10
		videofps=60;                              % video output fps
		timescale=0.5;                      % video speed-up factor
	elseif CasetoRun==11
		videofps=60;                              % video output fps
		timescale=0.5;                      % video speed-up factor
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		videofps=60;                              % video output fps
		timescale=0.5;                      % video speed-up factor
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		videofps=60;                              % video output fps
		timescale=0.5;                      % video speed-up factor
	elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		videofps=60;                              % video output fps
		timescale=0.1;                      % video speed-up factor
	elseif CasetoRun==118 || CasetoRun==173
		videofps=60;                              % video output fps
		timescale=0.2/4/10;                      % video speed-up factor
		%timescale=0.2/1/10;
	elseif CasetoRun==182
		videofps=60;                              % video output fps
		timescale=dt*videofps; % 1:1 frame to timestep(dt)
		%timescale=dt*videofps*32; % 1:1 frame to timestep(dt)
	elseif CasetoRun==193
		videofps=60;                              % video output fps
		timescale=dt*videofps*64; % 1:1 frame to timestep(dt)
	elseif CasetoRun==187
		videofps=60;                              % video output fps
		timescale=dt*videofps; % 1:1 frame to timestep(dt)
		%timescale=dt*videofps*32; % 1:1 frame to timestep(dt)
	elseif CasetoRun==191 || CasetoRun==212 || CasetoRun==197
		videofps=60;                              % video output fps
		%timescale=dt*videofps; % 1:1 frame to timestep(dt)
		timescale=dt*videofps*32; % 1:1 frame to timestep(dt)
	elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==190 || CasetoRun==188 || CasetoRun==198 || CasetoRun==196 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
		videofps=60;                              % video output fps
		timescale=dt*videofps*4; % 1:1 frame to timestep(dt)
		%timescale=dt*videofps*32; % 1:1 frame to timestep(dt)
	elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169 || CasetoRun==165
		videofps=60;                              % video output fps
		timescale=dt*videofps; % 1:1 frame to timestep(dt)
		%timescale=dt*videofps*32; % 1:1 frame to timestep(dt)
	elseif CasetoRun==183
		videofps=60;                              % video output fps
		timescale=dt*videofps*10; % 1:1 frame to timestep(dt)
		%timescale=dt*videofps*32; % 1:1 frame to timestep(dt)
	elseif CasetoRun==201
		videofps=60;                              % video output fps
		timescale=dt*videofps; % 32x skip frame to timestep(dt)
	elseif CasetoRun==210
		videofps=60;                              % video output fps
		timescale=dt*videofps*round(32*refinementfactor/3);
		%timescale=dt*videofps;
	elseif CasetoRun==222 || CasetoRun==225
		videofps=60;                              % video output fps
		timescale=dt*videofps*round(32*refinementfactor/3);
	elseif CasetoRun==221
		%TDL video switcher here!
		videofps=60;                              % video output fps
		timescale=dt*videofps*round(4*refinementfactor/3); % 32x skip frame to timestep(dt)
		%TDL no save txt
		%timescale=dt*videofps*round(9999*refinementfactor/3); % 32x skip frame to timestep(dt)
		%timescale=dt*videofps;
	elseif CasetoRun==228
		videofps=60;                              % video output fps
		timescale=dt*videofps*round(32*refinementfactor/3); % 32x skip frame to timestep(dt)
	elseif CasetoRun==217
		%TDL video switcher here!
		videofps=60;                              % video output fps
		timescale=dt*videofps*round(16*refinementfactor/3*10/sqrt(massscalingfactor)*10); %
	elseif CasetoRun==230
		%TDL video switcher here!
		videofps=100;                              % video output fps
		timescale=1; %
	elseif CasetoRun==229
		%TDL video switcher here!
		videofps=60;                              % video output fps
		timescale=dt*videofps*round(16*refinementfactor/3*10/sqrt(massscalingfactor)*25); %
	elseif CasetoRun==205 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==214 || CasetoRun==220 || CasetoRun==207	
		%TDL video switcher here!
		videofps=60;                              % video output fps
		timescale=dt*videofps*round(16*refinementfactor/3); % 32x skip frame to timestep(dt)
		%TDL no save txt
		%timescale=dt*videofps*round(9999*refinementfactor/3); % 32x skip frame to timestep(dt)
		%timescale=dt*videofps;
	elseif CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227
		%TDL video switcher here!
		videofps=60;                              % video output fps
		timescale=dt*videofps*round(32*refinementfactor/3); % 32x skip frame to timestep(dt)
	elseif CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209
		%TDL video switcher here!
		videofps=60;                              % video output fps
		timescale=dt*videofps*round(32*refinementfactor/3); % 32x skip frame to timestep(dt)
	elseif CasetoRun==200 || CasetoRun==203 || CasetoRun==211  
		videofps=60;                              % video output fps
		timescale=dt*videofps*32*round(refinementfactor/2); % 32x skip frame to timestep(dt)
	elseif CasetoRun==179 || CasetoRun==199
		videofps=60;                              % video output fps
		timescale=dt*videofps*32; % 32x skip frame to timestep(dt)
	elseif CasetoRun==171 || CasetoRun==166
		videofps=60;                              % video output fps
		%timescale=dt*videofps; % 1:1 frame to timestep(dt)
		timescale=dt*videofps*128; % 1:1 frame to timestep(dt)
	
	elseif CasetoRun==127 || CasetoRun==125 || CasetoRun==126 || CasetoRun==129 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==134 || CasetoRun==138
		videofps=60;                              % video output fps
		timescale=0.2/4/10;                      % video speed-up factor
	elseif CasetoRun==139 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
		videofps=60;                              % video output fps
		timescale=0.2/4;                      % video speed-up factor
	elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==152 || CasetoRun==153 || CasetoRun==147 || CasetoRun==145
		videofps=60;                              % video output fps
		timescale=0.5;                      % video speed-up factor
		%timescale=dt*videofps; % 1:1 frame to timestep(dt)
	elseif CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174
		videofps=60;                              % video output fps
		timescale=0.1;                      % video speed-up factor
		%timescale=0.5;                      % video speed-up factor
		%timescale=dt*videofps; % 1:1 frame to timestep(dt)		
	elseif CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180
		videofps=60;                              % video output fps
		timescale=dt*videofps*1280;                      % video speed-up factor
		%timescale=dt*videofps; % 1:1 frame to timestep(dt)
	elseif CasetoRun==154
		videofps=60;                              % video output fps
		%timescale=resolution*dt*videofps; % 1:resolution frame to timestep(dt)
		timescale=dt*videofps; % 1:resolution frame to timestep(dt)
	elseif CasetoRun==161
		videofps=60;
		timescale=dt*videofps; % 1:resolution frame to timestep(dt)
	elseif CasetoRun==136
		videofps=60;                              % video output fps
		timescale=0.5/200;                      % video speed-up factor	
		timescale=dt*videofps; % 1:1 frame to timestep(dt)
	elseif CasetoRun==135
		videofps=60;                              % video output fps
		timescale=0.5;                      % video speed-up factor	
	elseif CasetoRun==128 || CasetoRun==130
		%1:1 frame to timestep(dt)
		videofps=60;                              % video output fps
		timescale=dt*videofps; % 1:1 frame to timestep(dt)
	elseif CasetoRun==124
		videofps=60;                              % video output fps
		%timescale=0.2/refinementfactor;                      % video speed-up factor
		timescale=0.2/5*40;                      % video speed-up factor
	elseif CasetoRun==137
		videofps=60;                              % video output fps
		timescale=0.2/4/10;                      % video speed-up factor	
	end
	timestep = videofps*ftime/timescale;     % number of frame to save
	%r=timestep/ftime;      % number of frame per second video ~200s
	autosavetimeinterval=2.5;
	autosaveruntimeinterval=60*10; %autosave run-time interval in secodns
	fprintf('%s',['Running ' mfilename '-' int2txt(CasetoRun) char(10)]);
	
	%{
	%switchable1
	if exist('refinemenfactorinput')
		disp(['refinementfactor=' int2txt(refinementfactor)]);
		uiload;
	elseif Debugging.Active==0
		uiload;
	else
		load(Debugging.FileName);
		disp([Debugging.FileName ' loaded']);
	end
	if runorjustplot==1
		ttstart=1;
		ttstart=input('new ttstart? (default is 1) ');
	elseif runorjustplot==2
		ttstart=tt;
	end
	justloadedyo=1;
	if CasetoRun==14
		sourcefilename=TimeStampedName;
	end

	TimeStampedNameNew=[mfilename '-' int2txt(CasetoRun) '_' casename];
	TimeStampedNameBasic=TimeStampedNameNew;
	if dtoverride
		TimeStampedNameNew=[TimeStampedNameNew '-ms=' float2txt(0,massscalingfactor)];
	end
	if CasetoRun==14
		TimeStampedNameNew=[TimeStampedNameNew '-cores=' int2txt(numberofcores)];
	elseif CasetoRun==19 || CasetoRun==21
		TimeStampedNameNew=[TimeStampedNameNew '-RF=' float2txt(0,ReductionFactor)];
	elseif CasetoRun==26 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117
		TimeStampedNameNew=[TimeStampedNameNew '-RefLvl=' int2txt(refinementfactor)];
	elseif CasetoRun==27
		currentgcp=gcp;
		TimeStampedNameNew=[TimeStampedNameNew '-cores=' int2txt(currentgcp.NumWorkers)];
	end
	if exist('refinemenfactorinput')
		try
			load([TimeStampedNameNew '-Master.mat']);
		catch
		end
	end
	if exist('tt')
		if exist('IsItDump')
			clear IsItDump;
		else
			if exist('refinemenfactorinput')
			else
				tt=input('New tt? (type tt for no change) ');
			end
			load([TimeStampedName '\\' int2txt(tt) '.mat']);
		end
		if CompareTexts(TimeStampedName,TimeStampedNameNew)==0;
			copyfile([TimeStampedName '-Master.mat'],[TimeStampedNameNew '-Master.mat']);
			mkdir(TimeStampedNameNew);
			if CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==17
				mkdir([TimeStampedNameNew '\\evaltimes']);
			end
			if CasetoRun==27
				mkdir([TimeStampedNameNew '\\scheduleotf']); %put up top
			end
			
			for i=1:tt
				try
					copyfile([TimeStampedName '\\' int2txt(i) '.mat'],TimeStampedNameNew);
				catch
					1;
				end
			end
		end

	else
	%}
	%switchable1
		tt=1;
		TLD=[];
		coder.varsize('TLD');
		ntt=0;
		
	%{
	%switchable1
		mkdir(TimeStampedNameNew)
		if CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==17
			mkdir([TimeStampedNameNew '\\evaltimes']);
		end
		if CasetoRun==27
			mkdir([TimeStampedNameNew '\\scheduleotf']);
		end
	end
	TimeStampedName=TimeStampedNameNew;
	%autosavetimemodprev=0;
	%}
	%switchable1
	%[
	%switchable1
	if CasetoRun==161
		TimeStampedName=['SimOutput\\Out-' VersionNum '-Case_' int2txt(CasetoRun) '-' casenamelist{CasetoRun} '-' int2txt(refinementfactor)];
	else
		TimeStampedName=['SimOutput\\Out-' VersionNum '-Case_' int2txt(CasetoRun) '-' casenamelist{CasetoRun}];
	end
	%]
	%switchable1	
	%[
	%switchable2
	%{
	%switchable3
	try
		%}
		%switchable3
		tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
		%{
		%switchable3
	catch
	end
	%}
	%switchable3
	
	if tt>1
		TLD=loadmatrixfloat([TimeStampedName '-Master-' 'TLD' '.txt']);
		ttstart=loadsinglelong([TimeStampedName '-Master-' 'ttstart' '.txt']);
		if 0
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(tt) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(tt) '.txt']);
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(tt) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(tt) '.txt']);
			A_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'A_sp' '-' int2txt(tt) '.txt']);
			t_sp=loadmatrixfloat([TimeStampedName '-Slave-' 't_sp' '-' int2txt(tt) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(tt) '.txt']);
			p_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'p_sp' '-' int2txt(tt) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(tt) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(tt) '.txt']);
			F_rollerX=loadmatrixfloat([TimeStampedName '-Slave-' 'F_rollerX' '-' int2txt(tt) '.txt']);
			F_rollerY=loadmatrixfloat([TimeStampedName '-Slave-' 'F_rollerY' '-' int2txt(tt) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(tt) '.txt']);
			e_pl_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'e_pl_sp' '-' int2txt(tt) '.txt']);
			sigma_global_big=loadmatrixfloat([TimeStampedName '-Slave-' 'sigma_global_big' '-' int2txt(tt) '.txt']);
			e_t_global_big=loadmatrixfloat([TimeStampedName '-Slave-' 'e_t_global_big' '-' int2txt(tt) '.txt']);
			e_pl_global_big=loadmatrixfloat([TimeStampedName '-Slave-' 'e_pl_global_big' '-' int2txt(tt) '.txt']);
			alphahp=loadmatrixfloat([TimeStampedName '-Slave-' 'alphahp' '-' int2txt(tt) '.txt']);
			f_final_vect=loadmatrixfloat([TimeStampedName '-Slave-' 'f_final_vect' '-' int2txt(tt) '.txt']);
			surfacewithfmax=loadmatrixfloat([TimeStampedName '-Slave-' 'surfacewithfmax' '-' int2txt(tt) '.txt']);
			sigma_local_big=loadmatrixfloat([TimeStampedName '-Slave-' 'sigma_local_big' '-' int2txt(tt) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(tt) '.txt']);
			evaltimes=loadmatrixfloat([TimeStampedName '-Slave-' 'evaltimes' '-' int2txt(tt) '.txt']);
			stackvars=loadmatrixfloat([TimeStampedName '-Slave-' 'stackvars' '-' int2txt(tt) '.txt']);
			duration=loadmatrixfloat([TimeStampedName '-Slave-' 'duration' '-' int2txt(tt) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(tt) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(tt) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(tt) '.txt']);
			dudx_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'dudx_sp' '-' int2txt(tt) '.txt']);
			W_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'W_sp' '-' int2txt(tt) '.txt']);
			thetacrackrtl=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrackrtl' '-' int2txt(tt) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(tt) '.txt']);
			pforce_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'pforce_sp' '-' int2txt(tt) '.txt']);
			sigmainf=loadsinglefloat([TimeStampedName '-Slave-' 'sigmainf' '-' int2txt(tt) '.txt']);
			G=loadsinglefloat([TimeStampedName '-Slave-' 'G' '-' int2txt(tt) '.txt']);
			Ga=loadsinglefloat([TimeStampedName '-Slave-' 'Ga' '-' int2txt(tt) '.txt']);
			Grelativeerror=loadsinglefloat([TimeStampedName '-Slave-' 'Grelativeerror' '-' int2txt(tt) '.txt']);
			ntforce_si=loadmatrixfloat([TimeStampedName '-Slave-' 'ntforce_si' '-' int2txt(tt) '.txt']);
		end
	end

	%]
	%switchable2
		%AccummulatedTocReductor=0; %looks like no use anymore
	%{
	%switchable1
	if exist('DispPump')==0
		DispPump=0;
	end
	if CasetoRun==14
		tic;
		elapsedtime=[];
		starttimestep=[];
		 endtimestep=[];
	end
	%}
	%switchable1



	%[
	%switchable1
	DispPump=0;
	t_time=0;
	rampfactor=0;
	rampfactordot=0;
	rampfactordoubledot=0;
	pforce_sp_save.saved=zeros(1,1);
	pforce_sp_save.values=zeros(spCount,2);
	n_iter=1;
	%]
	%switchable1
	%{
	%switchable2
	savesinglelong(ttstart,[TimeStampedName '-Master-' 'ttstart' '.txt']);
	%}
	%switchable2
	%the savemarker does not comply with CODER, deactivate for CODER runs!
	
	%TDL savemarker 1
	%how to savemarker: delete the %{ and %}, adjust ttop to the target time plus a small margin, change .name into something unique (just ciw and mash keyboard), go find the other TDL marker, delete the %{ and %}
	%{
	savemarker.size=50;
	savemarker.tbot=0;
	savemarker.ttop=0.6;
	savemarker.time=linspace(savemarker.tbot,savemarker.ttop,savemarker.size);
	savemarker.name='fhdkjsmhfdljshflas'; %put something random here for new runs
	savemarker.saved=zeros(1,savemarker.size);
	savemarker.loaded=zeros(1,1);
	%}
	
	
    while tt<=timestep
		
		1;
		1;
		1;
		1;
		1;
		%{
		simulationbreaksignal=1;
		simulationbreaksignal=1;
		simulationbreaksignal=1;
		%}
		if CasetoRun==5
			if tt==2399+1
				simulationbreaksignal=1;
			end
		end
		if simulationbreaksignal
			tt=tt+1;
			break
		end
		
		ft              = ftime/timestep*tt;
		%     ft=ftime;
		
		
		
		while t_time<ft+0.0000000001
			justloadedyo=0;
			
			PredXDisp=0;
			PredYDisp=0;
			PredXDisp2=0;
			PredYDisp2=0;

			PredXVel=0;
			PredXAcc=0;
			PredYVel=0;
			PredYAcc=0;
			PredXVel2=0;
			PredXAcc2=0;
			PredYVel2=0;
			PredYAcc2=0;
			ParticlePredYVel=0;
			sigmainf=0;
			
			%TDL here is where displacement control is controlled
			if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
				if mod(t_time,(loadtime+pausetime))<=loadtime
					PredYVel=(dispload*pi*sin((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime);
					PredYAcc=(dispload*pi^2*cos((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
				else
					PredYVel=0;
					PredYAcc=0;
				end            
				DispPump=DispPump+PredYVel*dt;
			elseif CasetoRun==54
				if mod(t_time,(loadtime+pausetime))<=loadtime
					PredYVel=dispload/loadtime;
					PredYAcc=0;
				else
					PredYVel=0;
					PredYAcc=0;
				end
				DispPump=DispPump+PredYVel*dt;
			elseif CasetoRun==4
				if t_time<=t1
					PredYVel=(dmax*pi*sin((pi*t_time)/t1))/(2*t1);
					PredYAcc=(dmax*pi^2*cos((pi*t_time)/t1))/(2*t1^2);
				else
					PredYVel=0;
					PredYAcc=0;
				end
				DispPump=DispPump+PredYVel*dt;
			elseif CasetoRun==5 || CasetoRun==6
				if mod(t_time,(loadtime+pausetime))<=loadtime
					PredYVel=(dispload*pi*sin((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime);
					PredYAcc=(dispload*pi^2*cos((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
				else
					PredYVel=0;
					PredYAcc=0;
				end            
				DispPump=DispPump+PredYVel*dt;
			elseif CasetoRun==7
				if mod(t_time,(loadtime+pausetime))<=loadtime
					PredYVel=(dispload*pi*sin((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime);
					PredYAcc=(dispload*pi^2*cos((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
				else
					PredYVel=0;
					PredYAcc=0;
				end            
				DispPump=DispPump+PredYVel*dt;
			elseif CasetoRun==8 || CasetoRun==9
				if mod(t_time,(loadtime+pausetime))<=loadtime
					PredYVel=(dispload*pi*sin((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime);
					PredYAcc=(dispload*pi^2*cos((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
				else
					PredYVel=0;
					PredYAcc=0;
				end            
				DispPump=DispPump+PredYVel*dt;
			elseif CasetoRun==10
				if mod(t_time,(loadtime+pausetime))<=loadtime
					PredYVel=(dispload*pi*sin((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime);
					PredYAcc=(dispload*pi^2*cos((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
				else
					PredYVel=0;
					PredYAcc=0;
				end            
				DispPump=DispPump+PredYVel*dt;
			elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
				if mod(t_time,(loadtime+pausetime))<=loadtime
					PredYVel=(dispload*pi*sin((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime);
					PredYAcc=(dispload*pi^2*cos((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
				else
					PredYVel=0;
					PredYAcc=0;
				end            
				DispPump=DispPump+PredYVel*dt;
			elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
				if mod(t_time,(loadtime+pausetime))<=loadtime
					PredYVel=(dispload*pi*sin((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime);
					PredYAcc=(dispload*pi^2*cos((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
				else
					PredYVel=0;
					PredYAcc=0;
				end            
				DispPump=DispPump+PredYVel*dt;
			elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==65 || CasetoRun==70
				if mod(t_time,(loadtime+pausetime))<=loadtime
					PredYVel=(dispload*pi*sin((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime);
					PredYVel2=-PredYVel;
					PredYAcc=(dispload*pi^2*cos((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
					PredYAcc2=-PredYAcc;
				else
					PredYVel=0;
					PredYAcc=0;
				end            
				DispPump=DispPump+PredYVel*dt;        
			elseif CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==110 || CasetoRun==96
				ncforce_cracktop=zeros(size(x_crack.center(:,:,1)));
				ncforce_crackbot=zeros(size(x_crack.center(:,:,1)));
			elseif CasetoRun==111 || CasetoRun==113
				ncforce_cracktop=zeros(size(x_crack.center(:,:,1)));
				ncforce_crackbot=zeros(size(x_crack.center(:,:,1)));
				if mod(t_time,(loadtime+pausetime))<=loadtime
					ParticlePredYVel=VectorInsertion(ParticlePredYVel,1,(dispload*pi*sin((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime));
				else
					ParticlePredYVel=VectorInsertion(ParticlePredYVel,1,0);
				end
				ParticlePredYVel=VectorInsertion(ParticlePredYVel,2,-ParticlePredYVel(1));
				PredYVel=ParticlePredYVel(1);
				PredYVel2=ParticlePredYVel(2);
			elseif CasetoRun==121
				if t_time<loadtime/2
					rampfactor=0.5-0.5*cos(pi/loadtime*t_time);
				else
					rampfactor=0.5+pi*(t_time-(loadtime/2))/(2*loadtime);
				end
				sigmainf=sigmainfmax*rampfactor;
				S=sigmainf;
				x_central=[2 3]*le_base;
				a=1*le_base;
				for nsi=1:length(tractionededge_si)
					si=tractionededge_si(nsi);
					x=LOC(si,1)-x_central(1);
					if x==0
						x=le_base*1e-5;
					end
					y=LOC(si,2)-x_central(2);
					sigmay=real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 + (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2;
					sigmax = - real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 - (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2 + S*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1);
					sigmaxy = imag(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2;
					sigma_inxysystem=[sigmax sigmaxy;sigmaxy sigmay];
					ntforce_si(si,:)=normaledge_si(nsi,:)*sigma_inxysystem*le(1)*t0_plane; %assuming le(1)=le(2)
				end
				for nsi=1:length(tractionedcorner_si)
					si=tractionedcorner_si(nsi);
					x=LOC(si,1)-x_central(1);
					if x==0
						x=le_base*1e-5;
					end
					y=LOC(si,2)-x_central(2);
					sigmay=real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 + (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2;
					sigmax = - real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 - (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2 + S*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1);
					sigmaxy = imag(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2;
					sigma_inxysystem=[sigmax sigmaxy;sigmaxy sigmay];
					ntforce_si(si,:)=(normalcorner_si{nsi}(1,:)*sigma_inxysystem+normalcorner_si{nsi}(2,:)*sigma_inxysystem)*0.5*le(1)*t0_plane; %assuming le(1)=le(2)
				end
			elseif CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==122 || CasetoRun==120 || CasetoRun==117 || CasetoRun==138
				pforce_sp=zeros(spCount,2);
				if CasetoRun==115
					if mod(t_time,(loadtime+pausetime))<=loadtime
						rampfactor=(0.5-0.5*cos(pi*mod(t_time,(loadtime+pausetime))));
					else
						rampfactor=1;
					end
				elseif CasetoRun==116 || CasetoRun==119 || CasetoRun==122 || CasetoRun==120 || CasetoRun==117
					if t_time<loadtime/2
						rampfactor=0.5-0.5*cos(pi/loadtime*t_time);
					else
						rampfactor=0.5+pi*(t_time-(loadtime/2))/(2*loadtime);
					end
				elseif CasetoRun==138
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
					end
				end
				sigmainf=sigmainfmax*rampfactor;
				S=sigmainf;
				if CasetoRun==115
					x_central=[2 3.5]*le_base;
					a=1.5*le_base;
				elseif CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==137
					x_central=[2 3]*le_base;
					a=1*le_base;
				end
				for nsp=1:length(tractionededge)
					sp=tractionededge(nsp);
					if CasetoRun==120
						x=x_spo(sp,1)-x_central(1);
						y=x_spo(sp,2)-x_central(2);
					else
						x=x_sp(sp,1)-x_central(1);
						y=x_sp(sp,2)-x_central(2);
					end
					sigmay=real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 + (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2;
					sigmax = - real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 - (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2 + S*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1);
					sigmaxy = imag(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2;
					sigma_inxysystem=[sigmax sigmaxy;sigmaxy sigmay];
					%pforce_sp_sp=normaledge(nsp,:)*sigma_inxysystem*lp(1)*t0_plane; %assuming lp(1)=lp(2)
					%pforce_sp=MatrixInsertion(pforce_sp,sp,1,pforce_sp_sp(1,1));
					%pforce_sp=MatrixInsertion(pforce_sp,sp,2,pforce_sp_sp(1,2));
					pforce_sp(sp,:)=normaledge(nsp,:)*sigma_inxysystem*lp(1)*t0_plane; %assuming lp(1)=lp(2)
				end
				for nsp=1:length(tractionedcorner)
					sp=tractionedcorner(nsp);
					if CasetoRun==120
						x=x_spo(sp,1)-x_central(1);
						y=x_spo(sp,2)-x_central(2);
					else
						x=x_sp(sp,1)-x_central(1);
						y=x_sp(sp,2)-x_central(2);
					end
					sigmay=real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 + (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2;
					sigmax = - real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 - (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2 + S*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1);
					sigmaxy = imag(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2;
					sigma_inxysystem=[sigmax sigmaxy;sigmaxy sigmay];
					%pforce_sp_sp=(normalcorner{nsp}(1,:)*sigma_inxysystem+normalcorner{nsp}(2,:)*sigma_inxysystem)*lp(1)*t0_plane; %assuming lp(1)=lp(2)
					%pforce_sp=MatrixInsertion(pforce_sp,sp,1,pforce_sp_sp(1,1));
					%pforce_sp=MatrixInsertion(pforce_sp,sp,2,pforce_sp_sp(1,2));
					pforce_sp(sp,:)=(normalcorner{nsp}(1,:)*sigma_inxysystem+normalcorner{nsp}(2,:)*sigma_inxysystem)*lp(1)*t0_plane; %assuming lp(1)=lp(2)
				end
				1;
				%implementing sigmainf to traction
				%K1=sigmainf;
				%{
				for nsp=1:length(tractionededge)
					sp=tractionededge(nsp);
					delta_x=x_sp(sp,:)-x_defaultcracktip;
					r=sqrt(dot(delta_x,delta_x));
					theta=reliableatan(delta_x(1),delta_x(2));
					sigmathetatheta=K1/sqrt(2*pi*r)*(3/4*cos(theta/2)+1/4*cos(3*theta/2));
					sigmartheta=K1/sqrt(2*pi*r)*(1/4*sin(theta/2)+1/4*sin(3*theta/2));
					sigmarr=K1/sqrt(2*pi*r)*(5/4*cos(theta/2)-1/4*cos(3*theta/2));
					sigma_inrthetasystem=[sigmarr sigmartheta;
										  sigmartheta sigmathetatheta];
					n1old=[cos(theta) sin(theta)];
					sigma_inxysystem=rotatetensorfromold(sigma_inrthetasystem,n1old);
					pforce_sp(sp,:)=normaledge(nsp,:)*sigma_inxysystem;
				end
				for nsp=1:length(tractionedcorner)
					sp=tractionedcorner(nsp);
					delta_x=x_sp(sp,:)-x_defaultcracktip;
					r=sqrt(dot(delta_x,delta_x));
					theta=reliableatan(delta_x(1),delta_x(2));
					sigmathetatheta=K1/sqrt(2*pi*r)*(3/4*cos(theta/2)+1/4*cos(3*theta/2));
					sigmartheta=K1/sqrt(2*pi*r)*(1/4*sin(theta/2)+1/4*sin(3*theta/2));
					sigmarr=K1/sqrt(2*pi*r)*(5/4*cos(theta/2)-1/4*cos(3*theta/2));
					sigma_inrthetasystem=[sigmarr sigmartheta;
										  sigmartheta sigmathetatheta];
					n1old=[cos(theta) sin(theta)];
					sigma_inxysystem=rotatetensorfromold(sigma_inrthetasystem,n1old);
					pforce_sp(sp,:)=normalcorner{nsp}(1,:)*sigma_inxysystem+normalcorner{nsp}(2,:)*sigma_inxysystem;
				end
				%}
			elseif CasetoRun==170
				%124 predvelvalue
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
					rampfactordoubledot=0;
				end
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
						
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==171
				if rexp.switched==0
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
						rampfactordoubledot=0;
					end
					if sigmamaxprincmaxperfy>0.00125
					%if sigmamaxprincmaxperfy>0.45 %between 0.5 and 0.475
						rexp.switched=1;
						rexp.rs=rampfactor;
						rexp.rsdot=rampfactordot;
						rexp.A=999*rampfactor;
						rexp.ts=t_time;
					end
				elseif rexp.switched==1
					rampfactor=rexp.rs+rexp.rsdot*(t_time-rexp.ts);
					rampfactordot=rexp.rsdot;
					rampfactordoubledot=0;
				end
					
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
						
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==178
				if rexp.switched==0
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
						rampfactordoubledot=0;
					end
					if sigmamaxprincmaxperfy>0.9
					%if sigmamaxprincmaxperfy>0.45 %between 0.5 and 0.475
						rexp.switched=1;
						rexp.rs=rampfactor;
						rexp.rsdot=rampfactordot;
						rexp.A=0.5*rampfactor;
						rexp.ts=t_time;
					end
				elseif rexp.switched==1
					rampfactor=rexp.rs+rexp.A*(1-exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts)));
					rampfactordot=rexp.rsdot*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
					rampfactordoubledot=-rexp.rsdot^2/rexp.A*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
				end
					
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel*1.5;
				PredXAcc=PredYAcc*1.5;
				PredXVel2=PredYVel2*1.5;
				PredXAcc2=PredYAcc2*1.5;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
						
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				
				nro=PredVelVect.nX; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredXVel)
						PredVelVect.XVel(iro)=PredXVel;
						PredVelVect.XAcc(iro)=PredXAcc;
						
					else
						PredVelVect.XVel(iro)=PredXVel2;
						PredVelVect.XAcc(iro)=PredXAcc2;
					end
				end
				
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==183
				N0 = Compute_Interpolator_CPDI_optimized_N0(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp,0,0);
				if t_time<=5*dt
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=0;
					rampfactordot=0;
					rampfactordoubledot=0;
				end
				PredYDisp=-dispload*rampfactor;
				PredYDisp2=-PredYDisp;
				PredXDisp=PredYDisp;
				PredXDisp2=PredYDisp2;
				
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YDisp(iro)=PredYDisp;
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
					else
						PredVelVect.YDisp(iro)=PredYDisp2;
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==183-999
				N0 = Compute_Interpolator_CPDI_optimized_N0(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp,0,0);
				if rexp.switched==0
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
						rampfactordoubledot=0;
					end
					if sigmamaxprincmaxperfy>0.9
					%if sigmamaxprincmaxperfy>0.45 %between 0.5 and 0.475
						rexp.switched=1;
						rexp.rs=rampfactor;
						rexp.rsdot=rampfactordot;
						rexp.A=0.5*rampfactor;
						rexp.ts=t_time;
					end
				elseif rexp.switched==1
					rampfactor=rexp.rs+rexp.A*(1-exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts)));
					rampfactordot=rexp.rsdot*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
					rampfactordoubledot=-rexp.rsdot^2/rexp.A*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
				end
				PredYDisp=-dispload*rampfactor;
				PredYDisp2=-PredYDisp;
				PredXDisp=PredYDisp;
				PredXDisp2=PredYDisp2;
				
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YDisp(iro)=PredYDisp;
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
					else
						PredVelVect.YDisp(iro)=PredYDisp2;
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==192
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
					rampfactordoubledot=0;
				end
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
						
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end

				nro=PredVelVect.nX; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredXVel)
						PredVelVect.XVel(iro)=PredXVel;
						PredVelVect.XAcc(iro)=PredXAcc;
						
					else
						PredVelVect.XVel(iro)=PredXVel2;
						PredVelVect.XAcc(iro)=PredXAcc2;
					end
				end

				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==193
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
					rampfactordoubledot=0;
				end
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
						
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;

			elseif CasetoRun==187
				if rexp.switched==0
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
						rampfactordoubledot=0;
					end
					if sigmamaxprincmaxperfy>0.9
					%if sigmamaxprincmaxperfy>0.45 %between 0.5 and 0.475
						rexp.switched=1;
						rexp.rs=rampfactor;
						rexp.rsdot=rampfactordot;
						rexp.A=9999*rampfactor;
						%rexp.A=0.004-rexp.rs;
						rexp.ts=t_time;
					end
				elseif rexp.switched==1
					rampfactor=rexp.rs+rexp.A*(1-exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts)));
					rampfactordot=rexp.rsdot*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
					rampfactordoubledot=-rexp.rsdot^2/rexp.A*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
				end
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
						
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;
			
			elseif CasetoRun==186
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
					rampfactordoubledot=0;
				end
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
						
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;

			elseif CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225
				%TDL definition of moving BC values
				if rexp.switched==0
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
						rampfactordoubledot=0;
					end
					if sigmamaxprincmaxperfy>0.9
					%if sigmamaxprincmaxperfy>0.45 %between 0.5 and 0.475
						rexp.switched=1;
						rexp.rs=rampfactor;
						rexp.rsdot=rampfactordot;
						rexp.A=99*rampfactor;
						rexp.ts=t_time;
					end
				elseif rexp.switched==1
					rampfactor=rexp.rs+rexp.A*(1-exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts)));
					rampfactordot=rexp.rsdot*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
					rampfactordoubledot=-rexp.rsdot^2/rexp.A*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
				end
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
						
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==230
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
					rampfactordoubledot=0;
				end
				PredYVel=dispload*rampfactordot;
				PredYAcc=dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				
				nro=PredVelVect.nX; %Number of Relevant nOdes
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredXVel)
						PredVelVect.XVel(iro)=PredXVel;
						PredVelVect.XAcc(iro)=PredXAcc;
						
					else
						PredVelVect.XVel(iro)=PredXVel2;
						PredVelVect.XAcc(iro)=PredXAcc2;
					end
				end
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
						
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel*dt;
			elseif CasetoRun==220
				if rexp.switched==0
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
						rampfactordoubledot=0;
					end
					if sigmamaxprincmaxperfy>0.9
					%if sigmamaxprincmaxperfy>0.45 %between 0.5 and 0.475
						rexp.switched=1;
						rexp.rs=rampfactor;
						rexp.rsdot=rampfactordot;
						rexp.A=99*rampfactor;
						rexp.ts=t_time;
					end
				elseif rexp.switched==1
					rampfactor=rexp.rs+rexp.A*(1-exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts)));
					rampfactordot=rexp.rsdot*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
					rampfactordoubledot=-rexp.rsdot^2/rexp.A*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
				end
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=2*PredYVel;
				PredXAcc=2*PredYAcc;
				PredXVel2=2*PredYVel2;
				PredXAcc2=2*PredYAcc2;
				
				
				nro=PredVelVect.nX; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredXVel)
						PredVelVect.XVel(iro)=PredXVel;
						PredVelVect.XAcc(iro)=PredXAcc;
						
					else
						PredVelVect.XVel(iro)=PredXVel2;
						PredVelVect.XAcc(iro)=PredXAcc2;
					end
				end
				
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
						
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==207
				%if rexp.switched==0
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
						rampfactordoubledot=0;
					end
				%{	
					if sigmamaxprincmaxperfy>0.9
					%if sigmamaxprincmaxperfy>0.45 %between 0.5 and 0.475
						rexp.switched=1;
						rexp.rs=rampfactor;
						rexp.rsdot=rampfactordot;
						rexp.A=0.5*rampfactor;
						rexp.ts=t_time;
					end
				elseif rexp.switched==1
					rampfactor=rexp.rs+rexp.A*(1-exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts)));
					rampfactordot=rexp.rsdot*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
					rampfactordoubledot=-rexp.rsdot^2/rexp.A*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
				end
				%}
				
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredXVel)
						PredVelVect.XVel(iro)=PredXVel;
						PredVelVect.XAcc(iro)=PredXAcc;
						
					else
						PredVelVect.XVel(iro)=PredXVel2;
						PredVelVect.XAcc(iro)=PredXAcc2;
					end
				end
				DispPump=DispPump+PredXVel2*dt;
			elseif CasetoRun==163 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==201 || CasetoRun==169
				if rexp.switched==0
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
						rampfactordoubledot=0;
					end
					if sigmamaxprincmaxperfy>0.9
					%if sigmamaxprincmaxperfy>0.45 %between 0.5 and 0.475
						rexp.switched=1;
						rexp.rs=rampfactor;
						rexp.rsdot=rampfactordot;
						rexp.A=0.5*rampfactor;
						rexp.ts=t_time;
					end
				elseif rexp.switched==1
					rampfactor=rexp.rs+rexp.A*(1-exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts)));
					rampfactordot=rexp.rsdot*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
					rampfactordoubledot=-rexp.rsdot^2/rexp.A*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
				end
					
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
						
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==166
				if rexp.switched==0
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
						rampfactordoubledot=0;
					end
					if sigmamaxprincmaxperfy>0.0125
					%if sigmamaxprincmaxperfy>0.45 %between 0.5 and 0.475
						rexp.switched=1;
						rexp.rs=rampfactor;
						rexp.rsdot=rampfactordot;
						rexp.A=999*rampfactor;
						rexp.ts=t_time;
					end
				elseif rexp.switched==1
					%{
					%exponential asymptotic
					rampfactor=rexp.rs+rexp.A*(1-exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts)));
					rampfactordot=rexp.rsdot*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
					rampfactordoubledot=-rexp.rsdot^2/rexp.A*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
					%}
					
					%linear
					rampfactor=rexp.rs+rexp.rsdot*(t_time-rexp.ts);
					rampfactordot=rexp.rsdot;
					rampfactordoubledot=0;
				end
					
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==173 || CasetoRun==192
				if rexp.switched==0
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
						rampfactordoubledot=0;
					end
					if sigmamaxprincmaxperfy>0.9
						rexp.switched=1;
						rexp.rs=rampfactor;
						rexp.rsdot=rampfactordot;
						rexp.A=3*rampfactor;
						rexp.ts=t_time;
					end
				elseif rexp.switched==1
					rampfactor=rexp.rs+rexp.A*(1-exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts)));
					rampfactordot=rexp.rsdot*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
					rampfactordoubledot=-rexp.rsdot^2/rexp.A*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
				end

				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==165
				%124 predvelvalue
				if rexp.switched==0
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
						rampfactordoubledot=0;
					end
					if sigmamaxprincmaxperfy>0.9
						rexp.switched=1;
						rexp.rs=rampfactor;
						rexp.rsdot=rampfactordot;
						rexp.A=0.5*rampfactor;
						rexp.ts=t_time;
					end
				elseif rexp.switched==1
					rampfactor=rexp.rs+rexp.A*(1-exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts)));
					rampfactordot=rexp.rsdot*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
					rampfactordoubledot=-rexp.rsdot^2/rexp.A*exp(-rexp.rsdot/rexp.A*(t_time-rexp.ts));
				end

				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==118 || CasetoRun==123 || CasetoRun==151 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==130 || CasetoRun==124 || CasetoRun==137
				%124 predvelvalue
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
					rampfactordoubledot=0;
				end
				PredYVel=-dispload*rampfactordot;
				PredYAcc=-dispload*rampfactordoubledot;
				PredYVel2=-PredYVel;
				PredYAcc2=-PredYAcc;
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				PredXVel2=PredYVel2;
				PredXAcc2=PredYAcc2;
				
				nro=PredVelVect.nY; %Number of Relevant nOdes
				
				
				for iro=1:nro %iro=RUNNING NUMBER (i) of Relevant nOdes
					if iro<=length(NodeswithPredYVel)
						PredVelVect.YVel(iro)=PredYVel;
						PredVelVect.YAcc(iro)=PredYAcc;
					else
						PredVelVect.YVel(iro)=PredYVel2;
						PredVelVect.YAcc(iro)=PredYAcc2;
					end
				end
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==140 || CasetoRun==141 || CasetoRun==142
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
				end
				PredYVel=-dispload*rampfactordot;
				%PredYVel2=-PredYVel; &only the bottom is pulled
				PredXVel=-4*0.15167634039640241135537956256614*dispload*rampfactordot;
				PredXVel2=-PredXVel; %
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
					rampfactordoubledot=0;
				end
				PredXVel=dispload*rampfactordot;
				PredXAcc=dispload*rampfactordoubledot;
				DispPump=DispPump+PredXVel*dt;
			elseif CasetoRun==155
				%{
				if t_time<4*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=0;
					rampfactordot=0;
					rampfactordoubledot=0;
				end
				%}
				if t_time<2*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				elseif t_time<3*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(2*endcostime)));
					rampfactordot=0;
					rampfactordoubledot=0;
				elseif t_time<5*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-endcostime)));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-endcostime)/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-endcostime)/(2*endcostime));
				else
					rampfactor=0;
					rampfactordot=0;
					rampfactordoubledot=0;
				end
				pforce_sp=pforce_sp_base*rampfactor;
				%pforce_sp=pforce_sp_base;
				PredXVel=dispload*rampfactordot;
				PredXAcc=dispload*rampfactordoubledot;
			elseif CasetoRun==158
				%changing ramp not used
			elseif CasetoRun==157
				%{
				if t_time<4*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=0;
					rampfactordot=0;
					rampfactordoubledot=0;
				end
				%}
				if t_time<2*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				elseif t_time<3*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(2*endcostime)));
					rampfactordot=0;
					rampfactordoubledot=0;
				elseif t_time<5*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-endcostime)));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-endcostime)/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-endcostime)/(2*endcostime));
				else
					rampfactor=0;
					rampfactordot=0;
					rampfactordoubledot=0;
				end
				pforce_sp=pforce_sp_base*rampfactor;
				%pforce_sp=pforce_sp_base;
				PredXVel=dispload*rampfactordot;
				PredXAcc=dispload*rampfactordoubledot;
			elseif CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==162
				if CasetoRun==160
					if t_time<2*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					elseif t_time<3*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(2*endcostime)));
						rampfactordot=0;
						rampfactordoubledot=0;
					elseif t_time<5*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-endcostime)));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-endcostime)/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-endcostime)/(2*endcostime));
					else
						rampfactor=0;
						rampfactordot=0;
						rampfactordoubledot=0;
					end
				elseif CasetoRun==194
					if t_time<2*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					elseif t_time<3*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(2*endcostime)));
						rampfactordot=0;
						rampfactordoubledot=0;
					elseif t_time<5*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-endcostime)));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-endcostime)/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-endcostime)/(2*endcostime));
					elseif t_time<6*endcostime
						rampfactor=0;
						rampfactordot=0;
						rampfactordoubledot=0;
					elseif t_time<8*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-2*endcostime)));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-2*endcostime)/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-2*endcostime)/(2*endcostime));
					elseif t_time<9*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(2*endcostime)));
						rampfactordot=0;
						rampfactordoubledot=0;
					elseif t_time<11*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-3*endcostime)));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-3*endcostime)/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-3*endcostime)/(2*endcostime));
					elseif t_time<12*endcostime
						rampfactor=0;
						rampfactordot=0;
						rampfactordoubledot=0;
					elseif t_time<14*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-4*endcostime)));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-4*endcostime)/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-4*endcostime)/(2*endcostime));
					elseif t_time<15*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(2*endcostime)));
						rampfactordot=0;
						rampfactordoubledot=0;
					elseif t_time<17*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-5*endcostime)));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-5*endcostime)/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-5*endcostime)/(2*endcostime));
					elseif t_time<18*endcostime
						rampfactor=0;
						rampfactordot=0;
						rampfactordoubledot=0;
					elseif t_time<20*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-6*endcostime)));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-6*endcostime)/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-6*endcostime)/(2*endcostime));
					elseif t_time<=21*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(2*endcostime)));
						rampfactordot=0;
						rampfactordoubledot=0;
					elseif t_time<23*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-7*endcostime)));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-7*endcostime)/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-7*endcostime)/(2*endcostime));
					else
						rampfactor=0;
						rampfactordot=0;
						rampfactordoubledot=0;
					end
				elseif CasetoRun==175 || CasetoRun==180
					if t_time<2*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					elseif t_time<3*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(2*endcostime)));
						rampfactordot=0;
						rampfactordoubledot=0;
					elseif t_time<5*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-endcostime)));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-endcostime)/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-endcostime)/(2*endcostime));
					elseif t_time<6*endcostime
						rampfactor=0;
						rampfactordot=0;
						rampfactordoubledot=0;
					elseif t_time<8*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-2*endcostime)));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-2*endcostime)/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-2*endcostime)/(2*endcostime));
					elseif t_time<9*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(2*endcostime)));
						rampfactordot=0;
						rampfactordoubledot=0;
					elseif t_time<11*endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-3*endcostime)));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-3*endcostime)/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-3*endcostime)/(2*endcostime));
					else
						rampfactor=0;
						rampfactordot=0;
						rampfactordoubledot=0;
					end
				elseif CasetoRun==162
					if t_time<endcostime
						rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
						rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
						rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
					else
						rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
						rampfactordot=endcosramp*pi/(2*endcostime);
						rampfactordoubledot=0;
					end
				end
				if pushcol.initialcalculated==0
					for isp=1:spCount
						if uncrackable_sp(isp)==1
							pushcol.deltax.current(isp,:)=x_spo(isp,:)-[x_center y_center];
							pushcol.absolute_r_sp.initial(isp)=sqrt(dot(pushcol.deltax.current(isp,:),pushcol.deltax.current(isp,:)));
							pushcol.theta.initial(isp)=reliableatan(pushcol.deltax.current(isp,1),pushcol.deltax.current(isp,2));
						end
					end
					pushcol.initialcalculated=1;
				end
				pushcol.spcounter=0;
				for isp=1:spCount
					if uncrackable_sp(isp)==1
						pushcol.deltax.current(isp,:)=x_sp(isp,:)-[x_center y_center];
						pushcol.theta.current(isp)=reliableatan(pushcol.deltax.current(isp,1),pushcol.deltax.current(isp,2));
						pushcol.absolute_r_sp.current(isp)=sqrt(dot(pushcol.deltax.current(isp,:),pushcol.deltax.current(isp,:)));
						pushcol.relative_r_sp.current(isp)=pushcol.absolute_r_sp.current(isp)-pushcol.absolute_r_sp.initial(isp);
						pushcol.relative_r_sp.curavg=pushcol.relative_r_sp.curavg+pushcol.relative_r_sp.current(isp);
						pushcol.v_r_sp.current(isp)=dot(v_ssp(isp,:),[cos(pushcol.theta.current(isp)) sin(pushcol.theta.current(isp))]);
						pushcol.v_r_sp.curavg=pushcol.v_r_sp.curavg+pushcol.v_r_sp.current(isp);
						pushcol.spcounter=pushcol.spcounter+1;
					end
				end
				k_spring=0.5*E*t0_plane;
				m_relevant=m_sp(1); %assuming all the particle masses are the same
				c_critical=2*sqrt(k_spring*m_relevant);
				c_applied1=0.5*c_critical;
				c_applied2=0.8*m_sp(1)/dt;
				c_applied=min(c_applied1,c_applied2);
				
				pushcol.relative_r_sp.curavg=pushcol.relative_r_sp.curavg/pushcol.spcounter;
				pushcol.relative_r_sp.coltgt=dispload*rampfactor; %from dispload;
				pushcol.relative_r_sp.delta=pushcol.relative_r_sp.curavg-pushcol.relative_r_sp.coltgt;
				pushcol.relative_r_sp.springforce=-pushcol.relative_r_sp.delta*k_spring;

				pushcol.v_r_sp.curavg=pushcol.v_r_sp.curavg/pushcol.spcounter;
				pushcol.v_r_sp.coltgt=dispload*rampfactordot; %from dispload;
				pushcol.v_r_sp.delta=pushcol.v_r_sp.curavg-pushcol.v_r_sp.coltgt;
				pushcol.v_r_sp.dampforce=-pushcol.v_r_sp.delta*c_applied;
				
				if pushcol.relative_r_sp.springforce+pushcol.v_r_sp.dampforce<0
					pushcol.relative_r_sp.springforce=0;
					pushcol.v_r_sp.dampforce=0;
				end
				
				%pforce_sp=pforce_sp_base*rampfactor;
				for isp=1:spCount
					if uncrackable_sp(isp)==1
						pforce_sp(isp,:)=[cos(pushcol.theta.initial(isp)) sin(pushcol.theta.initial(isp))]*(pushcol.relative_r_sp.springforce+pushcol.v_r_sp.dampforce);
					end
				end
				%pforce_sp=pforce_sp_base;
				PredXVel=dispload*rampfactordot;
				PredXAcc=dispload*rampfactordoubledot;
			elseif CasetoRun==164 || CasetoRun==172 || CasetoRun==174
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
					rampfactordoubledot=0;
				end
				if pushcol.initialcalculated==0
					for isp=1:spCount
						if donut_pushed_sp(isp)==1
							pushcol.deltax.current(isp,:)=x_spo(isp,:)-[x_center y_center];
							pushcol.absolute_r_sp.initial(isp)=sqrt(dot(pushcol.deltax.current(isp,:),pushcol.deltax.current(isp,:)));
							pushcol.theta.initial(isp)=reliableatan(pushcol.deltax.current(isp,1),pushcol.deltax.current(isp,2));
						end
					end
					pushcol.initialcalculated=1;
				end
				pushcol.spcounter=0;
				for isp=1:spCount
					if donut_pushed_sp(isp)==1
						pushcol.deltax.current(isp,:)=x_sp(isp,:)-[x_center y_center];
						pushcol.theta.current(isp)=reliableatan(pushcol.deltax.current(isp,1),pushcol.deltax.current(isp,2));
						pushcol.absolute_r_sp.current(isp)=sqrt(dot(pushcol.deltax.current(isp,:),pushcol.deltax.current(isp,:)));
						pushcol.relative_r_sp.current(isp)=pushcol.absolute_r_sp.current(isp)-pushcol.absolute_r_sp.initial(isp);
						pushcol.relative_r_sp.curavg=pushcol.relative_r_sp.curavg+pushcol.relative_r_sp.current(isp);
						pushcol.v_r_sp.current(isp)=dot(v_ssp(isp,:),[cos(pushcol.theta.current(isp)) sin(pushcol.theta.current(isp))]);
						pushcol.v_r_sp.curavg=pushcol.v_r_sp.curavg+pushcol.v_r_sp.current(isp);
						pushcol.spcounter=pushcol.spcounter+1;
					end
				end
				k_spring=0.5*E*t0_plane;
				m_relevant=m_sp(1); %assuming all the particle masses are the same
				c_critical=2*sqrt(k_spring*m_relevant);
				c_applied1=0.5*c_critical;
				c_applied2=0.8*m_sp(1)/dt;
				c_applied=min(c_applied1,c_applied2);
				
				pushcol.relative_r_sp.curavg=pushcol.relative_r_sp.curavg/pushcol.spcounter;
				pushcol.relative_r_sp.coltgt=dispload*rampfactor; %from dispload;
				pushcol.relative_r_sp.delta=pushcol.relative_r_sp.curavg-pushcol.relative_r_sp.coltgt;
				pushcol.relative_r_sp.springforce=-pushcol.relative_r_sp.delta*k_spring;
				pushcol.v_r_sp.curavg=pushcol.v_r_sp.curavg/pushcol.spcounter;
				pushcol.v_r_sp.coltgt=dispload*rampfactordot; %from dispload;
				pushcol.v_r_sp.delta=pushcol.v_r_sp.curavg-pushcol.v_r_sp.coltgt;
				pushcol.v_r_sp.dampforce=-pushcol.v_r_sp.delta*c_applied;
				
				%pforce_sp=pforce_sp_base*rampfactor;
				for isp=1:spCount
					if donut_pushed_sp(isp)==1
						pforce_sp(isp,:)=[cos(pushcol.theta.initial(isp)) sin(pushcol.theta.initial(isp))]*(pushcol.relative_r_sp.springforce+pushcol.v_r_sp.dampforce);
					end
				end
				%pforce_sp=pforce_sp_base;
				PredXVel=dispload*rampfactordot;
				PredXAcc=dispload*rampfactordoubledot;
			elseif CasetoRun==156 || CasetoRun==159
				%{
				if t_time<4*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=0;
					rampfactordot=0;
					rampfactordoubledot=0;
				end
				%}
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
					rampfactordoubledot=0;
				end
				%pforce_sp=pforce_sp_base;
				PredXVel=dispload*rampfactordot;
				PredXAcc=dispload*rampfactordoubledot;
			elseif CasetoRun==150
				%pforce_sp experiment
				pforce_sp=zeros(spCount,2);
				if t_time<4*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=0;
					rampfactordot=0;
					rampfactordoubledot=0;
				end
				r0=(0.8+rampfactor)*le_base;
				exprate=7/0.2;
				pforce_base=1.5*E*le_base^2*t0_plane/(4*(1.25*le_base))/(refinementfactor^2);
				k_spring=0.5*E*t0_plane;
				m_relevant=m_sp(1); %assuming all the particle masses are the same
				c_critical=2*sqrt(k_spring*m_relevant);
				c_applied1=0.5*c_critical;
                c_applied2=0.8*m_sp(1)/dt;
                c_applied=min(c_applied1,c_applied2);
                x_tgt=zeros(spCount,2);
                v_tgt=zeros(spCount,2);
                delta_x_wall=zeros(spCount,2);
                delta_v_wall=zeros(spCount,2);
				%thalflife=0.0001;
				%k=log(2)/thalflife;
				deltarideal_sp=zeros(1,spCount);
				for isp=1:spCount
					if uncrackable_sp(isp)>0.5
						delta_x0=[x_spo(isp,1)-x_center x_spo(isp,2)-y_center];
						delta_x=[x_sp(isp,1)-x_center x_sp(isp,2)-y_center];
						%theta_0=reliableatan(delta_x0(1),delta_x0(2));
						deltaractual_sp(isp)=sqrt(dot(delta_x,delta_x))-sqrt(dot(delta_x0,delta_x0));
					end
					deltarideal_sp(isp)=rampfactor;
				end
				PredXVel=dispload*rampfactordot;
				DispPump=DispPump+PredXVel*dt;		
			elseif CasetoRun==154 || CasetoRun==161
				pforce_sp=zeros(spCount,2);
				%vortex loading
				
				for isp = 1:spCount
					%{
					R_sp(isp)                = sqrt((x_spo(isp,1)-center)^2 + (x_spo(isp,2)-center)^2);
					theta(isp)               = atan2((x_spo(isp,2)-center),(x_spo(isp,1)-center));
					Constant(isp)            = 1 - 32 * (R_sp(isp)-1)^2 + 256 * (R_sp(isp)-1)^4;

					alpha(isp)   = A*sin(C*pi*(n_iter-1)*dt)*Constant(isp);
					beta(isp)    = theta(isp) + alpha(isp);        
					b_r(isp)     = -R_sp(isp)*A^2*(cos(C*pi*(n_iter-1)*dt))^2*C^2*pi^2*(4*R_sp(isp)-3)^4*(4*R_sp(isp)-5)^4+2/psp*2048*(4*R_sp(isp)-5)^2*(R_sp(isp)-1)^2*(4*R_sp(isp)-3)^2*A^2*(sin(C*pi*(n_iter-1)*dt))^2*R_sp(isp)*Mu;
					b_angle(isp) = -A*sin(C*pi*(n_iter-1)*dt)*(R_sp(isp)*C^2*pi^2*(4*R_sp(isp)-3)^2*(4*R_sp(isp)-5)^2+1/psp*64*Mu*(96*R_sp(isp)^3-240*R_sp(isp)^2+188*R_sp(isp)-45));
					b_sp(isp,1)  = b_r(isp) * cos(beta(isp)) - b_angle(isp) * sin(beta(isp));
					b_sp(isp,2)  = b_r(isp) * sin(beta(isp)) + b_angle(isp) * cos(beta(isp));     
					%}
					
					R_sp                = sqrt((x_spo(isp,1)-center)^2 + (x_spo(isp,2)-center)^2);
					theta               = atan2((x_spo(isp,2)-center),(x_spo(isp,1)-center));
					Constant            = 1 - 32 * (R_sp-1)^2 + 256 * (R_sp-1)^4;

					alpha   = A*sin(C*pi*(n_iter-1)*dt)*Constant;
					beta    = theta + alpha;
					alfap   = A^2 * C * pi * Constant;
					b_r     = -R_sp*A^2*(cos(C*pi*(n_iter-1)*dt))^2*C^2*pi^2*(4*R_sp-3)^4*(4*R_sp-5)^4+2/psp*2048*(4*R_sp-5)^2*(R_sp-1)^2*(4*R_sp-3)^2*A^2*(sin(C*pi*(n_iter-1)*dt))^2*R_sp*Mu;
					b_angle = -A*sin(C*pi*(n_iter-1)*dt)*(R_sp*C^2*pi^2*(4*R_sp-3)^2*(4*R_sp-5)^2+1/psp*64*Mu*(96*R_sp^3-240*R_sp^2+188*R_sp-45));
					%pforce_sp(isp,1)=m_sp(isp)*(b_r * cos(beta) - b_angle * sin(beta))/2;
					pforce_sp(isp,1)=m_sp(isp)*(b_r * cos(beta) - b_angle * sin(beta)); %full force for hyperelastic
					%pforce_sp(isp,2)=m_sp(isp)*(b_r * sin(beta) + b_angle * cos(beta))/2;
					pforce_sp(isp,2)=m_sp(isp)*(b_r * sin(beta) + b_angle * cos(beta)); %full force for hyperelastic
					alpha   = A*sin(C*pi*(n_iter)*dt)*Constant; %this is a hotfix! because analytical solution is comparable to the simulation's end of solver
					anerror.v_ssp_an(isp,1)=alfap*cos(C*pi*n_iter*dt)*(-sin(alpha)*(x_spo(isp,1)-center)-cos(alpha)*(x_spo(isp,2)-center));
					anerror.v_ssp_an(isp,2)=alfap*cos(C*pi*n_iter*dt)*(cos(alpha)*(x_spo(isp,1)-center)-sin(alpha)*(x_spo(isp,2)-center));
					
					anerror.u_sp_an(isp,1)   = (A * (cos(alpha)*(x_spo(isp,1)-center) - sin(alpha)*(x_spo(isp,2)-center))) - (x_spo(isp,1)-center);
					anerror.u_sp_an(isp,2)   = (A * (sin(alpha)*(x_spo(isp,1)-center) + cos(alpha)*(x_spo(isp,2)-center))) - (x_spo(isp,2)-center);

					%fair comparison to v_ssp for after generic_solver
				end
				n_iter=n_iter+1;
			elseif CasetoRun==153 %ring only
				pforce_sp=zeros(spCount,2);
				if t_time<2*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				elseif t_time<3*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(2*endcostime)));
					rampfactordot=0;
					rampfactordoubledot=0;
				elseif t_time<5*endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*(t_time-endcostime)));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*(t_time-endcostime)/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*(t_time-endcostime)/(2*endcostime));
				else
					rampfactor=0;
					rampfactordot=0;
					rampfactordoubledot=0;
				end
				
				r0=(0.8+rampfactor)*le_base;
				exprate=7/0.2;
				pforce_base=1.5*E*le_base^2*t0_plane/(4*(1.25*le_base))/(refinementfactor^2);
				k_spring=0.5*E*t0_plane;
				m_relevant=m_sp(1); %assuming all the particle masses are the same
				c_critical=2*sqrt(k_spring*m_relevant);
				c_applied1=0.5*c_critical;
				c_applied2=0.8*m_sp(1)/dt;
				c_applied=min(c_applied1,c_applied2);
				x_tgt=zeros(spCount,2);
				v_tgt=zeros(spCount,2);
				delta_x_wall=zeros(spCount,2);
				delta_v_wall=zeros(spCount,2);
				%thalflife=0.0001;
				%k=log(2)/thalflife;
				for isp=1:spCount
					delta_x_trial_0=[x_spo(isp,1)-x_center x_spo(isp,2)-y_center];
					theta_0=reliableatan(delta_x_trial_0(1),delta_x_trial_0(2));
					r_0=sqrt(dot(delta_x_trial_0,delta_x_trial_0));
					r_tgt=r_0+rampfactor;
					x_tgt(isp,1)=x_center+r_tgt*cos(theta_0);
					x_tgt(isp,2)=y_center+r_tgt*sin(theta_0);
					v_tgt(isp,1)=rampfactordot*cos(theta_0);
					v_tgt(isp,2)=rampfactordot*sin(theta_0);
					%delta_x_trial=[x_sp(isp,1)-x_center x_sp(isp,2)-y_center];
					%theta=reliableatan(delta_x_trial(1),delta_x_trial(2));
					%pforce_sp_scalar(isp)=pforce_base*exp(-exprate*(r+r_adjustor(isp)-r0));
					%1;
					%r=sqrt(dot(delta_x_trial,delta_x_trial));
					for dim=1:2
						delta_x_wall(isp,dim)=x_sp(isp,dim)-x_tgt(isp,dim);
						delta_v_wall(isp,dim)=v_ssp(isp,dim)-v_tgt(isp,dim);
						pforce_sp(isp,dim)=-delta_x_wall(isp,dim)*k_spring-delta_v_wall(isp,dim)*c_applied;
					end
					1;
					%pforce_sp(isp,1)=k_spring*(rampfactor+r+r_adjustor(isp)-r0)*cos(theta)-c_applied*(v_ssp(isp,1)-rampfactordot);
					%pforce_sp(isp,2)=k_spring*(rampfactor+r+r_adjustor(isp)-r0)*sin(theta)-c_applied*(v_ssp(isp,2)-rampfactordot);
				end
				PredXVel=dispload*rampfactordot;
				DispPump=DispPump+PredXVel*dt;			
			elseif CasetoRun==152 %custom donut
				pforce_sp=zeros(spCount,2);
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
					rampfactordoubledot=endcosramp*(pi/(2*endcostime))^2*cos(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
					rampfactordoubledot=0;
				end
				%rampfactormax=endcosramp*(1+pi*(0.17-endcostime)/(2*endcostime));
				%rampfactor=min(rampfactor,rampfactormax);
				r0=(0.8+rampfactor)*le_base;
				exprate=15;
				pforce_base=1.5*E*le_base^2*t0_plane/(4*(1.25*le_base))/(refinementfactor^2);
				
				if pforce_sp_save.saved==1
					for isp=1:spCount
						for idim=1:2
							pforce_sp(isp,idim)=pforce_sp_save.values(isp,idim);
						end
					end
				else
					for isp=1:spCount
						if uncrackable_sp(isp)>0.5
							delta_x_trial=[x_sp(isp,1)-x_center x_sp(isp,2)-y_center];
							theta=reliableatan(delta_x_trial(1),delta_x_trial(2));
							r=sqrt(dot(delta_x_trial,delta_x_trial));
							pforce_sp(isp,1)=pforce_base*rampfactor*cos(theta)*exp(-exprate*(r+r_adjustor(isp)-r0));
							pforce_sp(isp,2)=pforce_base*rampfactor*sin(theta)*exp(-exprate*(r+r_adjustor(isp)-r0));
						end
					end
				end
				PredXVel=dispload*rampfactordot;
				DispPump=DispPump+PredXVel*dt;		
				if pforce_sp_save.saved==0 && t_time>=0.17
					for isp=1:spCount
						for idim=1:2
							pforce_sp_save.values(isp,idim)=pforce_sp(isp,idim);
						end
					end
					pforce_sp_save.saved=1;
				end
			elseif CasetoRun==145
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
				end
				PredXVel=dispload*rampfactordot;
				PredXVel2=-PredXVel;
				DispPump=DispPump+PredXVel*dt;
			elseif CasetoRun==143
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
				end
				PredYVel=-dispload*rampfactordot;
				%PredYVel2=-PredYVel; &only the bottom is pulled
				PredXVel=4*0.15167634039640241135537956256614*dispload*rampfactordot;
				PredXVel2=-PredXVel; %
				DispPump=DispPump+PredYVel2*dt;
			elseif CasetoRun==134 || CasetoRun==136
				if t_time<endcostime
					rampfactor=endcosramp*(1-cos(pi/(2*endcostime)*t_time));
					rampfactordot=endcosramp*pi/(2*endcostime)*sin(pi*t_time/(2*endcostime));
				else
					rampfactor=endcosramp*(1+pi*(t_time-endcostime)/(2*endcostime));
					rampfactordot=endcosramp*pi/(2*endcostime);
				end
				PredXVel=-dispload*rampfactordot;
				PredXVel2=-PredXVel;
				PredYVel=PredXVel;
				PredYVel2=PredXVel2;
				DispPump=DispPump+PredXVel2*dt;
			elseif CasetoRun==112
				ncforce_cracktop=zeros(size(x_crack.center(:,:,1)));
				ncforce_crackbot=zeros(size(x_crack.center(:,:,1)));
				if mod(t_time,(loadtime+pausetime))<=loadtime
					ParticlePredYVel=(dispload*pi*sin((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime);
				else
					ParticlePredYVel=0;
				end
			elseif CasetoRun==83
				% whats this, its all wrong
				for icrackpath=1:length(x_crackcenter)
					ncforce_cracktop=zeros(size(x_crackcenter));
					ncforce_crackbot=zeros(size(x_crackcenter));
				end
			elseif CasetoRun==84 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
				if mod(t_time,(loadtime+pausetime))<=loadtime
					PredYVel=(dispload*pi*sin((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime);
					PredYAcc=(dispload*pi^2*cos((pi*mod(t_time,(loadtime+pausetime)))/loadtime))/(2*loadtime^2);
				else
					PredYVel=0;
					PredYAcc=0;
				end
				PredXVel=PredYVel;
				PredXAcc=PredYAcc;
				%for below is all wrong
				for icrackpath=1:length(x_crackcenter)
					ncforce_cracktop=zeros(size(x_crackcenter));	
					ncforce_crackbot=zeros(size(x_crackcenter));
				end
				DispPump=DispPump+PredYVel*dt;
			elseif CasetoRun==77
				if t_time<1
					crackpressure=100*(0.5-0.5*cos(pi/1*t_time));
				else
					crackpressure=100;
				end
				ncforce_cracktop(8:38,1)=crackpressure*(le(2)/4);
				ncforce_crackbot=-ncforce_cracktop;
			elseif CasetoRun==69 % currently not designed for repetitions
				if t_time<=loadtime
					pforcecurrent=pforcemax*(0.5-0.5*cos(pi*t_time/loadtime));
				else
					pforcecurrent=pforcemax;
				end
				pforce_sp=zeros(sp,2);
				for nsp=1:length(rampedyforceparticle1)
					pforce_sp(rampedyforceparticle1(nsp),2)=-pforcecurrent;
				end
				for nsp=1:length(rampedyforceparticle2)
					pforce_sp(rampedyforceparticle2(nsp),2)=pforcecurrent;
				end
			elseif CasetoRun==230
				for isp=1:spCount
					b_sp(isp,1)=b_sp_base(1)*m_sp(isp)
					b_sp(isp,2)=b_sp_base(2)*m_sp(isp)
				end
			end
			
			%TDL here is where load control is controlled	
			if CasetoRun==229
				%see docs/dmtasetup.tex for parameters
				nsptopsurface=0;
				E_loaded=Et;
				specimen_t=1.3; %mm
				specimen_w=3; %mm
				specimen_A=specimen_w*specimen_t;
				epsilon_amplitude=0.035/100; %0.035 percent
				F_amplitude=E_loaded*specimen_A*epsilon_amplitude;
				frequency=1;%Hz
				omega=2*pi*frequency;
				F0=2*F_amplitude;
				A0=F0;
				A1=F_amplitude;
				omega1=omega;
				omega0=A1*omega1/A0;
				t0=pi/(2*omega0);
				if t_time<t0
					F_current=A0*(1-cos(omega0*t_time));
				else
					F_current=A1*(2+sin(omega1*(t_time-t0)));
				end
				F_loadcontrolled=F_current; %F_loadcontrolled is what's going to be saved
				
				

				
				DispPump=0;
				for isp=1:spCount
					if x_spo(isp,2)>y_end-lp(2)
						nsptopsurface=nsptopsurface+1;
					end
				end
				F_sp_current=F_current/nsptopsurface;
				for isp=1:spCount
					if x_spo(isp,2)>y_end-lp(2)
						pforce_sp(isp,2)=F_sp_current;
						DispPump=DispPump+(x_sp(isp,2)-x_spo(isp,2));
					end
				end
				DispPump=DispPump/nsptopsurface;
			end
			
			%TDL damping at particle here!
			if CasetoRun==217 || CasetoRun==229
				t_halflife=0.01;
				kmax=log(2)/t_halflife;
				kmax=0; %this turned off
				for isp=1:spCount
					if x_spo(isp,2)<2*le_base
						k=kmax;
					elseif x_spo(isp,2)<5*le_base
						k=0;
					else
						k=kmax;
					end
					b_sp(isp,:)=-k*v_ssp(isp,:);
				end
				%{
				for isp=1:spCount
					if x_spo(isp,2)<(2+3/4)*le_base
						k=kmax*abs(x_spo(isp,2)-2*le_base)/(3/4*le_base);
					elseif x_spo(isp,2)<(5-3/4)*le_base
						k=0;
					else
						k=kmax*abs(x_spo(isp,2)-2*le_base)/(3/4*le_base);
					end
					b_sp(isp,:)=-k*v_ssp(isp,:);
				end
				%}
			elseif CasetoRun==228
				t_halflife=0.01;
				kmax=log(2)/t_halflife;
				for isp=1:spCount
					y_trial=x_spo(isp,2);
					if y_trial>y_end-5*le_base || y_trial<y_start+5*le_base
						%k=kmax;
						k=min(abs(y_trial-y_start),abs(y_trial-y_end))/(5*le_base)*kmax;
					else
						k=0;
					end
					b_sp(isp,:)=-k*v_ssp(isp,:);
				end
				%{
				for isp=1:spCount
					if x_spo(isp,2)<(2+3/4)*le_base
						k=kmax*abs(x_spo(isp,2)-2*le_base)/(3/4*le_base);
					elseif x_spo(isp,2)<(5-3/4)*le_base
						k=0;
					else
						k=kmax*abs(x_spo(isp,2)-2*le_base)/(3/4*le_base);
					end
					b_sp(isp,:)=-k*v_ssp(isp,:);
				end
				%}
			end
			
			
			%TDL weakening progression switcher here!
			weakeningfactormax=0;
			if CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207
				%{
				weakeningfactormax=(1-exp(-t_time/0.35));
				for isp=1:spCount
					weakeningfactor_sp(isp)=weakeningfactormax*(x_sp(isp,2)-2*le_base)/(4*le_base-2*le_base);
				end
				%}
			end
			
			%TDL FDS interpolation here
			delta_x_trial=0; %to stop coder whining
			if CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209
				for isp=1:spCount
					depth_sp(isp)=4*le_base-x_spo(isp,2);
				end
				MPMtimemultbase=90;
				scaledtime=t_time*MPMtimemultbase;
				%epsilonshrinkdot_sp=shrinkageratefromFDS(depth_sp,scaledtime,FDS)*MPMtimemultbase;
				%TDL dirletter switcheroo 2
				k_sp=kfromFDS(depth_sp,scaledtime,FDS);
				kdot_sp=kratefromFDS(depth_sp,scaledtime,FDS)*MPMtimemultbase;
				
				%disable weakening below:
				%k_sp=ones(1,spCount);
				%kdot_sp=zeros(1,spCount);
				
				[epsilonshrinkdotx_sp,epsilonshrinkdoty_sp]=shrinkrateFDSnlit(depth_sp,scaledtime,FDS,[2 1]);
				
				epsilonshrinkdotx_sp=epsilonshrinkdotx_sp*MPMtimemultbase;
				epsilonshrinkdoty_sp=epsilonshrinkdoty_sp*MPMtimemultbase;
				
				%triangle x override:
				%epsilonshrinkdoty_sp(1,:)=0; %TDL assumes x shrinkage only
				%for isp=1:spCount
					%epsilonshrinkdotx_sp(isp)=-0.01*(2*le_base-depth_sp(isp))/(2*le_base);
					%epsilonshrinkdotx_sp(isp)=-0.1;
				%end
				
				for isp=1:spCount
					FDS.epsilonshrink(isp,1)=FDS.epsilonshrink(isp,1)+epsilonshrinkdotx_sp(isp)*dt;
					FDS.epsilonshrink(isp,2)=FDS.epsilonshrink(isp,2)+epsilonshrinkdoty_sp(isp)*dt;
				end
				temp_sp=tempfromFDS(depth_sp,scaledtime,FDS);
				tempdot_sp=tempratefromFDS(depth_sp,scaledtime,FDS)*MPMtimemultbase;
				%disable temperature distribution below
				%for isp=1:spCount
				%	temp_sp(isp)=20;
				%	tempdot_sp(isp)=0;
				%end
				thermexprate=0.006/75; %from paper 3
				%thermexprate=0; %from paper 3
				epsilonshrinkdot_sp=tempdot_sp*thermexprate;
				for isp=1:spCount
					weakeningfactor_sp(isp)=min(0.9,max(0,(temp_sp(isp)-20)/(300-20)));
				end
				FDS.firsttempplot=0;
				for isp=1:spCount
					if depth_sp(isp)==min(depth_sp)
						fprintf('%s',['depth_sp(' int2txt(isp) ')=' float2scitxt(5,depth_sp(isp)) char(10)]);
						fprintf('%s',['temp_sp(' int2txt(isp) ')=' float2scitxt(5,temp_sp(isp)) char(10)]);
						fprintf('%s',['k_sp(' int2txt(isp) ')=' float2scitxt(5,k_sp(isp)) char(10)]);
						fprintf('%s',['kdot_sp(' int2txt(isp) ')=' float2scitxt(5,kdot_sp(isp)) char(10)]);
						fprintf('%s',['FDS.epsilonshrink(' int2txt(isp) ',1)=' float2scitxt(5,FDS.epsilonshrink(isp,1)) char(10)]);
						fprintf('%s',['FDS.epsilonshrink(' int2txt(isp) ',2)=' float2scitxt(5,FDS.epsilonshrink(isp,2)) char(10)]);
						break;
					end
				end
				%{
				for isp=1:spCount
					fprintf('%s',['temp_sp(' int2txt(isp) ')=' float2scitxt(5,temp_sp(isp)) char(10)]);
				end
				for isp=1:spCount
					fprintf('%s',['weakeningfactor_sp(' int2txt(isp) ')=' float2scitxt(5,weakeningfactor_sp(isp)) char(10)]);
				end
				input_codegen('its only pause');
				1;
				%}
			elseif CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227
				%experiment dot is no longer used
				experiment.deltahy=zeros(1,5);
				experiment.h0=zeros(1,1);
				experiment.epsilony=zeros(1,5);
				
				experiment.deltahy=10*[2-1.135 2-1.990 2-1.845 2-1.890 2-1.345]; %in mm, hence the 10 multiplier;
				%experiment.deltayh=10*(2-[1.2494 1.6976 1.4704 1.4414 1.1537]);
				experiment.h0=20; % in mm
				for i=1:length(experiment.deltahy)
					experiment.epsilony(i)=log(experiment.deltahy(i)/experiment.h0);
				end
				%TDL new shrinkage for block specimen
				x_crack.tempaccel.dmax=le(1);
				topsurfaceheight=4*le_base;
				if CasetoRun==224
					topsurfaceheight=3*le_base;
				end
				for ipath=1:x_crack.npaths
				for iparticle=1:x_crack.nparticles(ipath)-1
				if x_crack.tempaccel.tagged(iparticle,ipath)==0
					for isp=1:spCount
					if surroundtag_sp(isp)==0
						%visual: https://drive.google.com/file/d/13aiaY4rbn54pX58oYxqZF6wKYoemrUCd/view?usp=sharing
						d1=calcmag(x_sp(isp,:)-x_crack.center(iparticle,:,ipath));
						d2=calcmag(x_sp(isp,:)-x_crack.center(iparticle+1,:,ipath));
						if d1<x_crack.tempaccel.dmax || d2<x_crack.tempaccel.dmax
							surroundtag_sp(isp)=1;
							continue;
						end
						L=calcmag(x_crack.center(iparticle,:,ipath)-x_crack.center(iparticle+1,:,ipath));
						s=(d1+d2+L)/2;
						A=sqrt(s*(s-d1)*(s-d2)*(s-L));
						h=2*A/L;
						L1=sqrt(d1^2-h^2);
						L2=sqrt(d2^2-h^2);
						if h<x_crack.tempaccel.dmax && L1<L && L2<L
							surroundtag_sp(isp)=1;
						end	
					end
					end
					x_crack.tempaccel.tagged(iparticle,ipath)=1;
				end
				end
				end
				for isp=1:spCount
					depth_sp(isp)=topsurfaceheight-x_spo(isp,2);
				end
				denytempaccel=0;
				denytempacceledge=0;
				denyshrinkage=0;
				denyexpansion=0;
				denysoftening=0; %stiffness reduction, aka k and kdot
				denyweakening=0; %weakening factor from thermal, aka weakeningfactor (temp)
				denyfabweakening=1; %weakening factor fabricated, aka weakeningfactor (fabricated)
				shrinkagemode=2; %1: sinpropagate, 2:FDSdensity, 3: gradual overall
				denyshrinkagedepthmultiplier=1; %linear interpolation of shrinkage between top and bottom surfaces
				MPMtimemultbase=2000;
				if CasetoRun==227
					denyexpansion=1;
					denysoftening=1;
					denyweakening=1;
					shrinkagemode=3;
				end
				shrinkbotfactor=0.4417397939717665; %bottom shrinkage relative to top, 1 for default
				t_cool_fds=2000;
				t_cool_mpm=t_cool_fds/MPMtimemultbase;
				if straighttocooling
					t_cool_mpm=0;
				end
				%time acceleration due to being around a crack. no gradual, all sudden, hard edge.
				timeaccelfactor=2;
				if denytempaccel
					for isp=1:spCount
						MPMtimemult_sp1(isp)=MPMtimemultbase;
					end
				else
					for isp=1:spCount
						if t_time>t_cool_mpm
							MPMtimemult_sp1(isp)=MPMtimemultbase;
						elseif time_fds(isp)>=t_cool_fds-dt*MPMtimemultbase/2
							MPMtimemult_sp1(isp)=0;
							time_fds(isp)=t_cool_fds;
						elseif surroundtag_sp(isp)
							MPMtimemult_sp1(isp)=timeaccelfactor*MPMtimemultbase;
						else
							MPMtimemult_sp1(isp)=MPMtimemultbase;
						end
					end
				end
				timeaccelfactoredge=3;
				if denytempacceledge
					for isp=1:spCount
						MPMtimemult_sp2(isp)=MPMtimemultbase;
					end
				else
					for isp=1:spCount
						if t_time>t_cool_mpm
							MPMtimemult_sp2(isp)=MPMtimemultbase;
						elseif time_fds(isp)>=t_cool_fds-dt*MPMtimemultbase/2
							MPMtimemult_sp2(isp)=0;
							time_fds(isp)=t_cool_fds;
						elseif x_spo(isp,1)<25 || x_spo(isp,1)>115
							MPMtimemult_sp2(isp)=timeaccelfactoredge*MPMtimemultbase*(abs(70-x_spo(isp,1))-45)/5;
						else
							MPMtimemult_sp2(isp)=MPMtimemultbase;
						end
					end
				end
				for isp=1:spCount
					MPMtimemult_sp(isp)=max(MPMtimemult_sp1(isp),MPMtimemult_sp2(isp));
				end
				
				
				timeaccelfactoredge=2;
				for isp=1:spCount
					time_fds(isp)=time_fds(isp)+dt*MPMtimemult_sp(isp); %t_time is the time for MPM
				end
				%epsilonshrinkdot_sp=shrinkageratefromFDS(depth_sp,time_fds,FDS)*MPMtimemultbase;
				%TDL dirletter switcheroo 2
				%TDL checking on epsilonshrinkdot_sp
				k_sp=kfromFDS(depth_sp,time_fds,FDS);
				kdot_sp=kratefromFDS(depth_sp,time_fds,FDS);
				for isp=1:spCount
					kdot_sp(isp)=kdot_sp(isp)*MPMtimemult_sp(isp);
				end
				
				%disable weakening below:
				if denysoftening
					k_sp=ones(1,spCount);
					kdot_sp=zeros(1,spCount);
				end
				
				%shrinkage from FDS and literature:
				%[epsilonshrinkdotx_sp,epsilonshrinkdoty_sp]=shrinkrateFDSnlit(depth_sp,time_fds,FDS,[2 1]);
				
				%shrinkage from FDS directly
				epsilonshrinkdotx_sp=shrinkageratefromFDS(depth_sp,time_fds,FDS)/0.3*0.02;
				epsilonshrinkdoty_sp=zeros(size(epsilonshrinkdotx_sp));
				
				%TDL shrinkage progression switcher here!
				for isp=1:spCount
					epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)*MPMtimemult_sp(isp);
					epsilonshrinkdoty_sp(isp)=epsilonshrinkdoty_sp(isp)*MPMtimemult_sp(isp);
				end
				
				
				epsilonshrinkdotx_sp(1,:)=0; %cleaning up x before use below
				%triangular expansion below
				
				%TDL temp-based expansion
				temp_sp=tempfromFDS(depth_sp,time_fds,FDS);
				tempdot_sp=tempratefromFDS(depth_sp,time_fds,FDS);
				for isp=1:spCount
					tempdot_sp(isp)=tempdot_sp(isp)*MPMtimemult_sp(isp);
				end
				tempmin=min(min(min(FDS.temp)));
				tempmax=max(max(max(FDS.temp)));
				maxexpand=0.03/2;

				
				tstart=0;
				tend=0.1;
				shrinkdottgt=0.06;
				if denyexpansion==0
					for isp=1:spCount
						%epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+0.03*(2*le_base-depth_sp(isp))/(2*le_base);
						%epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+0.03;
						%epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+sinpropagate(tstart,tend,shrinkdottgt,t_time,1)*(2*le_base-depth_sp(isp))/(2*le_base);
						%epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+0.03*(2*le_base-depth_sp(isp))/(2*le_base);
						epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+tempdot_sp(isp)/(tempmax-tempmin)*maxexpand;
					end
				end
				
				density_sp=densityfromFDS(depth_sp,time_fds,FDS);
				densitydot_sp=densityratefromFDS(depth_sp,time_fds,FDS);
				for isp=1:spCount
					densitydot_sp(isp)=densitydot_sp(isp)*MPMtimemult_sp(isp);
				end
				densitymax=max(max(max(FDS.density)));
				densitymin=min(min(min(FDS.density)));
				maxshrinkage=-0.13105;
				%TDL tiny maxshrinkage for now, for plotting total shrinkage to make sure shrinkagedepthmultiplier works
				maxshrinkage=-0.0001;
				
				%propagating sin wave below
				if CasetoRun==226 || CasetoRun==227
					if denyshrinkage==0
						for isp=1:spCount
							tstart=1*(depth_sp(isp)/(2*le_base));
							tend=tstart+0.25;
							if shrinkagemode==1
								epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+sinpropagate(tstart,tend,epsilonshrinkmax_sp(isp,1),t_time,1);
								epsilonshrinkdoty_sp(isp)=epsilonshrinkdoty_sp(isp)+sinpropagate(tstart,tend,epsilonshrinkmax_sp(isp,2),t_time,1);
							elseif shrinkagemode==2
								epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)-densitydot_sp(isp)/(densitymax-densitymin)*epsilonshrinkmax_sp(isp,1);
								epsilonshrinkdoty_sp(isp)=epsilonshrinkdoty_sp(isp)-densitydot_sp(isp)/(densitymax-densitymin)*epsilonshrinkmax_sp(isp,2);
							else%if shrinkagemode==3
								%primarily just for showing shrinkage scheme	
								tend=0.5;
								if t_time<tend
									epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+1/tend*epsilonshrinkmax_sp(isp,1);
									epsilonshrinkdoty_sp(isp)=epsilonshrinkdoty_sp(isp)+1/tend*epsilonshrinkmax_sp(isp,2);
								end
							end
						end
					end
				else
					if denyshrinkage==0
						for isp=1:spCount
							tstart=1*(depth_sp(isp)/(2*le_base));
							tend=tstart+0.25;
							if denyshrinkagedepthmultiplier==0
								shrinkagedepthmultiplier=1+(shrinkbotfactor-1)/20*depth_sp(isp)
							else
								shrinkagedepthmultiplier=1;
							end
							if shrinkagemode==1
								epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+sinpropagate(tstart,tend,maxshrinkage,t_time,1)*shrinkagedepthmultiplier;
							else%if shrinkagemode==2
								epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)-densitydot_sp(isp)/(densitymax-densitymin)*maxshrinkage*shrinkagedepthmultiplier;
							end
						end
					end
					epsilonshrinkdoty_sp(1,:)=0; %TDL assumes x shrinkage only
					%strain 0.007 between 0 seconds to 0.25 seconds at the top, 3 seconds to 3.25 seconds at the center
				end
				for isp=1:spCount
					shrinkplot.xshrinkage(isp)=shrinkplot.xshrinkage(isp)+epsilonshrinkdotx_sp(isp)*dt;
					shrinkplot.yshrinkage(isp)=shrinkplot.yshrinkage(isp)+epsilonshrinkdoty_sp(isp)*dt;
				end
				
				%TDL new local-global shrinkage
				
				shrinkage_local_before_sp=shrinkage_local_new_sp;
				shrinkage_global_before_sp=shrinkage_global_new_sp;
				for isp=1:spCount
					shrinkage_local_new_sp(:,:,isp)=shrinkage_local_before_sp(:,:,isp)+[epsilonshrinkdotx_sp(isp) 0;0 epsilonshrinkdoty_sp(isp)]*dt;
				end
				for isp=1:spCount
					%Rback=eye(2);
					Rback=real(poldecomp(F_sp{isp},0));
					Qback=[cos(-orientationoffset(isp)) sin(-orientationoffset(isp)); -sin(-orientationoffset(isp)) cos(-orientationoffset(isp))];
					QbackRback=Qback*Rback;
					%epsilonshrinkdotmat_sp(:,:,isp)=real((QbackRback)*[epsilonshrinkdotx_sp(isp) 0;0 epsilonshrinkdoty_sp(isp)]*transpose(QbackRback));
					shrinkage_global_new_sp(:,:,isp)=real((QbackRback)*shrinkage_local_new_sp(:,:,isp)*transpose(QbackRback));
				end
				
				shrinkagedot_global_sp=(shrinkage_global_new_sp-shrinkage_global_before_sp)/dt;
				epsilonshrinkdotmat_sp=shrinkagedot_global_sp;%epsilonshrinkdotmat_sp is the parameter passed on to inside the function
				
				for isp=1:spCount
					shrinkage_global_sp_vectorized(isp,1)=shrinkage_global_new_sp(1,1,isp);
					shrinkage_global_sp_vectorized(isp,2)=shrinkage_global_new_sp(2,2,isp);
					shrinkage_global_sp_vectorized(isp,3)=shrinkage_global_new_sp(1,2,isp);
				end
				
				shrinkage_sp=shrinkage_global_new_sp;%shrinkage_sp is the parameter passed on to claculate nodal shrinkage, ultimately to calculate at the box
				
				epsilonshrinkdotx_sp(1,:)=0; %TDL assumes y shrinkage only
				epsilonshrinkdoty_sp(1,:)=0; %TDL assumes x shrinkage only
				for isp=1:spCount
					epsilonshrinkdot_sp_vectorized(isp,1)=epsilonshrinkdotmat_sp(1,1,isp);
					epsilonshrinkdot_sp_vectorized(isp,2)=epsilonshrinkdotmat_sp(2,2,isp);
					epsilonshrinkdot_sp_vectorized(isp,3)=epsilonshrinkdotmat_sp(1,2,isp);
				end
				epsilonshrink_sp_vectorized=epsilonshrink_sp_vectorized+epsilonshrinkdot_sp_vectorized*dt;
				%disable temperature distribution below
				temp_sp_temp=temp_sp;
				tempdot_sp_temp=tempdot_sp;

				if denyweakening
					for isp=1:spCount
						temp_sp(isp)=20;
						tempdot_sp(isp)=0;
					end
				end
				%thermexprate=0.006/75; %from paper 3
				thermexprate=0;% disable expansion
				epsilonshrinkdot_sp=tempdot_sp*thermexprate;
				for isp=1:spCount
					weakeningfactor_sp(isp)=min(1-hightempremainingstrength,max(0,(temp_sp(isp)-20)/(300-20)));
				end
				if denyfabweakening==0
					for isp=1:spCount
						x_trial=x_spo(isp,1);
						y_trial=x_spo(isp,2);
						if ((abs(x_trial-4.5*le_base)<0.25*le_base) || (abs(x_trial-(10-4.5)*le_base)<0.25*le_base) || (abs(x_trial-6.5*le_base)<0.25*le_base)) && abs(y_trial-topsurfaceheight)<0.25*le_base
							weakeningfactor_sp(isp)=1-((1-weakeningfactor_sp(isp))*0.95);
						end
					end
				end
				if denyweakening
					temp_sp=temp_sp_temp;
					tempdot_sp=tempdot_sp_temp;
				end
				1;
			elseif CasetoRun==205 || CasetoRun==210
				%TDL shrinkage for log specimen
				
				x_crack.tempaccel.dmax=le(1);
				topsurfaceheight=4*le_base;
				if CasetoRun==224
					topsurfaceheight=3*le_base;
				end
				for ipath=1:x_crack.npaths
				for iparticle=1:x_crack.nparticles(ipath)-1
				if x_crack.tempaccel.tagged(iparticle,ipath)==0
					for isp=1:spCount
					if surroundtag_sp(isp)==0
						%visual: https://drive.google.com/file/d/13aiaY4rbn54pX58oYxqZF6wKYoemrUCd/view?usp=sharing
						d1=calcmag(x_sp(isp,:)-x_crack.center(iparticle,:,ipath));
						d2=calcmag(x_sp(isp,:)-x_crack.center(iparticle+1,:,ipath));
						if d1<x_crack.tempaccel.dmax || d2<x_crack.tempaccel.dmax
							surroundtag_sp(isp)=1;
							continue;
						end
						L=calcmag(x_crack.center(iparticle,:,ipath)-x_crack.center(iparticle+1,:,ipath));
						s=(d1+d2+L)/2;
						A=sqrt(s*(s-d1)*(s-d2)*(s-L));
						h=2*A/L;
						L1=sqrt(d1^2-h^2);
						L2=sqrt(d2^2-h^2);
						if h<x_crack.tempaccel.dmax && L1<L && L2<L
							surroundtag_sp(isp)=1;
						end	
					end
					end
					x_crack.tempaccel.tagged(iparticle,ipath)=1;
				end
				end
				end
				
				for isp=1:spCount
					x_trial=x_spo(isp,1);
					y_trial=x_spo(isp,2);
					delta_x_trial=[x_trial-x_center y_trial-y_center];
					r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
					depth_sp(isp)=(r_cylinder-r_trial)/r_cylinder*20;
					%depth_sp(isp)=(r_cylinder-r_trial);
					1;
				end
				
				
				
				
				denytempaccel=0;
				denyshrinkage=0;
				denyexpansion=0;
				denysoftening=0; %stiffness reduction, aka k and kdot
				denyweakening=0; %weakening factor from thermal, aka weakeningfactor (temp)
				denyfabweakening=1; %weakening factor fabricated, aka weakeningfactor (fabricated)
				shrinkagemode=2; %1: sinpropagate, 2:FDSdensity
				yactive=0;
				MPMtimemultbase=1280*15;
				t_cool_fds=1800;
				t_cool_mpm=t_cool_fds/MPMtimemultbase;
				if straighttocooling
					t_cool_mpm=0;
				end
				timeaccelfactor=2;
				if denytempaccel
					for isp=1:spCount
						MPMtimemult_sp(isp)=MPMtimemultbase;
					end
				else
					for isp=1:spCount
						if t_time>t_cool_mpm
							MPMtimemult_sp(isp)=MPMtimemultbase;
						elseif time_fds(isp)>=t_cool_fds-dt*MPMtimemultbase/2
							MPMtimemult_sp(isp)=0;
							time_fds(isp)=t_cool_fds;
						elseif surroundtag_sp(isp)
							MPMtimemult_sp(isp)=timeaccelfactor*MPMtimemultbase;
						else
							MPMtimemult_sp(isp)=MPMtimemultbase;
						end
					end
				end
				for isp=1:spCount
					time_fds(isp)=time_fds(isp)+dt*MPMtimemult_sp(isp); %t_time is the time for MPM
				end
				
				
				%epsilonshrinkdot_sp=shrinkageratefromFDS(depth_sp,time_fds,FDS)*MPMtimemultbase;
				%TDL dirletter switcheroo 2
				%TDL checking on epsilonshrinkdot_sp
				k_sp=kfromFDS(depth_sp,time_fds,FDS);
				kdot_sp=kratefromFDS(depth_sp,time_fds,FDS);
				for isp=1:spCount
					kdot_sp(isp)=kdot_sp(isp)*MPMtimemult_sp(isp);
				end
				
				%disable weakening below:
				if denysoftening
					k_sp=ones(1,spCount);
					kdot_sp=zeros(1,spCount);
				end
				
				%shrinkage from FDS and literature:
				%[epsilonshrinkdotx_sp,epsilonshrinkdoty_sp]=shrinkrateFDSnlit(depth_sp,time_fds,FDS,[2 1]);
				
				%shrinkage from FDS directly
				epsilonshrinkdotx_sp=shrinkageratefromFDS(depth_sp,time_fds,FDS)/0.3*0.02;
				epsilonshrinkdoty_sp=zeros(size(epsilonshrinkdotx_sp));
				
				%TDL shrinkage progression switcher here!
				for isp=1:spCount
					epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)*MPMtimemult_sp(isp);
					epsilonshrinkdoty_sp(isp)=epsilonshrinkdoty_sp(isp)*MPMtimemult_sp(isp);
				end
				
				
				epsilonshrinkdotx_sp(1,:)=0; %cleaning up x before use below
				if yactive
					epsilonshrinkdoty_sp(1,:)=0; %cleaning up y before use below
				end
				%triangular expansion below
				
				%TDL temp-based expansion
				temp_sp=tempfromFDS(depth_sp,time_fds,FDS);
				tempdot_sp=tempratefromFDS(depth_sp,time_fds,FDS);
				for isp=1:spCount
					tempdot_sp(isp)=tempdot_sp(isp)*MPMtimemult_sp(isp);
				end
				tempmin=min(min(min(FDS.temp)));
				tempmax=max(max(max(FDS.temp)));
				maxexpand=0.03;
				
				
				tstart=0;
				tend=0.1;
				shrinkdottgt=0.06;
				if denyexpansion==0
					for isp=1:spCount
						%epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+0.03*(2*le_base-depth_sp(isp))/(2*le_base);
						%epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+0.03;
						%epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+sinpropagate(tstart,tend,shrinkdottgt,t_time,1)*(2*le_base-depth_sp(isp))/(2*le_base);
						%epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+0.03*(2*le_base-depth_sp(isp))/(2*le_base);
						epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)+tempdot_sp(isp)/(tempmax-tempmin)*maxexpand;
						if yactive
							epsilonshrinkdoty_sp(isp)=epsilonshrinkdoty_sp(isp)+tempdot_sp(isp)/(tempmax-tempmin)*maxexpand;
						end
					end
				end
				
				density_sp=densityfromFDS(depth_sp,time_fds,FDS);
				densitydot_sp=densityratefromFDS(depth_sp,time_fds,FDS);
				for isp=1:spCount
					densitydot_sp(isp)=densitydot_sp(isp)*MPMtimemult_sp(isp);
				end
				densitymax=max(max(max(FDS.density)));
				densitymin=min(min(min(FDS.density)));
				maxshrinkage=-0.13;
				
				if denyshrinkage==0
					for isp=1:spCount
						tstart=3*(depth_sp(isp)/(3*le_base))/15;
						tend=tstart+1/15;
						if shrinkagemode==1
							epsilonshrinkdotx_sp(isp)=sinpropagate(tstart,tend,maxshrinkage,t_time,1);
						else%if shrinkagemode==2
							epsilonshrinkdotx_sp(isp)=epsilonshrinkdotx_sp(isp)-densitydot_sp(isp)/(densitymax-densitymin)*maxshrinkage;
							if yactive
								epsilonshrinkdoty_sp(isp)=epsilonshrinkdoty_sp(isp)-densitydot_sp(isp)/(densitymax-densitymin)*maxshrinkage;
							end
						end
					end
				end
				if yactive
				else
					epsilonshrinkdoty_sp(1,:)=0; %TDL assumes x shrinkage only
				end
				
				for isp=1:spCount
					shrinkplot.xshrinkage(isp)=shrinkplot.xshrinkage(isp)+epsilonshrinkdotx_sp(isp)*dt;
					shrinkplot.yshrinkage(isp)=shrinkplot.yshrinkage(isp)+epsilonshrinkdoty_sp(isp)*dt;
				end
				for isp=1:spCount
					%Rback=eye(2,2);
					Rback=real(poldecomp(F_sp{isp},0));
					Qback=[cos(-orientationoffset(isp)) sin(-orientationoffset(isp)); -sin(-orientationoffset(isp)) cos(-orientationoffset(isp))];
					QbackRback=Qback*Rback;
					%epsilonshrinkdotmat_sp(:,:,isp)=[epsilonshrinkdotx_sp(isp) 0;0 epsilonshrinkdoty_sp(isp)];
					epsilonshrinkdotmat_sp(:,:,isp)=real((QbackRback)*[epsilonshrinkdotx_sp(isp) 0;0 epsilonshrinkdoty_sp(isp)]*transpose(QbackRback));
				end
				for isp=1:spCount
					shrinkage_global_sp_vectorized(isp,1)=shrinkage_global_sp_vectorized(isp,1)+epsilonshrinkdotmat_sp(1,1,isp)*dt;
					shrinkage_global_sp_vectorized(isp,2)=shrinkage_global_sp_vectorized(isp,2)+epsilonshrinkdotmat_sp(2,2,isp)*dt;
					shrinkage_global_sp_vectorized(isp,3)=shrinkage_global_sp_vectorized(isp,3)+epsilonshrinkdotmat_sp(1,2,isp)*dt;
					shrinkage_sp(1,1,isp)=shrinkage_global_sp_vectorized(isp,1);
					shrinkage_sp(2,2,isp)=shrinkage_global_sp_vectorized(isp,2);
					shrinkage_sp(1,2,isp)=shrinkage_global_sp_vectorized(isp,3);
					shrinkage_sp(2,1,isp)=shrinkage_global_sp_vectorized(isp,3);
				end
				
				epsilonshrinkdotx_sp(1,:)=0; %TDL assumes y shrinkage only
				epsilonshrinkdoty_sp(1,:)=0; %TDL assumes x shrinkage only
				for isp=1:spCount
					epsilonshrinkdot_sp_vectorized(isp,1)=epsilonshrinkdotmat_sp(1,1,isp);
					epsilonshrinkdot_sp_vectorized(isp,2)=epsilonshrinkdotmat_sp(2,2,isp);
					epsilonshrinkdot_sp_vectorized(isp,3)=epsilonshrinkdotmat_sp(1,2,isp);
				end
				epsilonshrink_sp_vectorized=epsilonshrink_sp_vectorized+epsilonshrinkdot_sp_vectorized*dt;
				for isp=1:spCount
					FDS.epsilonshrink(isp,1)=FDS.epsilonshrink(isp,1)+epsilonshrinkdotx_sp(isp)*dt;
					FDS.epsilonshrink(isp,2)=FDS.epsilonshrink(isp,2)+epsilonshrinkdoty_sp(isp)*dt;
				end
				%disable temperature distribution below
				temp_sp_temp=temp_sp;
				tempdot_sp_temp=tempdot_sp;
				if denyweakening
					for isp=1:spCount
						temp_sp(isp)=20;
						tempdot_sp(isp)=0;
					end
				end
				%thermexprate=0.006/75; %from paper 3
				thermexprate=0;
				epsilonshrinkdot_sp=tempdot_sp*thermexprate;
				for isp=1:spCount
					weakeningfactor_sp(isp)=min(0.9,max(0,(temp_sp(isp)-20)/(300-20)));
				end
				if denyfabweakening==0
					for isp=1:spCount
						x_trial=x_spo(isp,1);
						y_trial=x_spo(isp,2);
						delta_x_trial=[x_trial-x_center y_trial-y_center];
						angle=reliableatan(delta_x_trial(1),delta_x_trial(2));
						r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
						if ((abs(angle-1/4*pi)<pi/32) || (abs(angle-(1/4+1/2)*pi)<pi/32) || (abs(angle-(1/4+2/2)*pi)<pi/32)) && (r_trial/r_cylinder)>0.9
							weakeningfactor_sp(isp)=1-((1-weakeningfactor_sp(isp))*0.95);
						end
					end
				end
				if denyweakening
					temp_sp=temp_sp_temp;
					tempdot_sp=tempdot_sp_temp;
				end
				FDS.firsttempplot=0;
				for isp=1:spCount
					if depth_sp(isp)==min(depth_sp)
						fprintf('%s',['depth_sp(' int2txt(isp) ')=' float2scitxt(5,depth_sp(isp)) char(10)]);
						fprintf('%s',['temp_sp(' int2txt(isp) ')=' float2scitxt(5,temp_sp(isp)) char(10)]);
						fprintf('%s',['k_sp(' int2txt(isp) ')=' float2scitxt(5,k_sp(isp)) char(10)]);
						fprintf('%s',['kdot_sp(' int2txt(isp) ')=' float2scitxt(5,kdot_sp(isp)) char(10)]);
						fprintf('%s',['FDS.epsilonshrink(' int2txt(isp) ',1)=' float2scitxt(5,FDS.epsilonshrink(isp,1)) char(10)]);
						fprintf('%s',['FDS.epsilonshrink(' int2txt(isp) ',2)=' float2scitxt(5,FDS.epsilonshrink(isp,2)) char(10)]);
						break;
					end
				end
				%{
				for isp=1:spCount
					fprintf('%s',['temp_sp(' int2txt(isp) ')=' float2scitxt(5,temp_sp(isp)) char(10)]);
				end
				for isp=1:spCount
					fprintf('%s',['weakeningfactor_sp(' int2txt(isp) ')=' float2scitxt(5,weakeningfactor_sp(isp)) char(10)]);
				end
				%input_codegen('its only pause');
				1;
				%}
			elseif CasetoRun==207
				for isp=1:spCount
					x_trial=x_spo(isp,1);
					y_trial=x_spo(isp,2);
					delta_x_trial=[x_trial-x_center y_trial-y_center];
					r_trial=sqrt(dot(delta_x_trial,delta_x_trial));
					depth_sp(isp)=r_cylinder-r_trial;
					1;
				end
				k_sp=ones(1,spCount);
				kdot_sp=zeros(1,spCount);
				epsilonshrinkdotx_sp(1,:)=zeros(1,spCount);
				epsilonshrinkdoty_sp(1,:)=zeros(1,spCount);
				orientationoffset2=0;
				for isp=1:spCount
					%if depth_sp(isp)<1.5*le_base
						epsilonshrinkdotx_sp(isp)=-0.001*(3*le_base-depth_sp(isp))/(3*le_base);
					%end
					x_trial=x_spo(isp,1);
					y_trial=x_spo(isp,2);
					delta_x_trial=[x_trial-x_center y_trial-y_center];
					orientationoffset2=reliableatan(delta_x_trial(1),delta_x_trial(2))+pi/2;
					%Rback=eye(2,2);
					Rback=real(poldecomp(F_sp{isp},0));
					Qback=[cos(-orientationoffset2) sin(-orientationoffset2); -sin(-orientationoffset2) cos(-orientationoffset2)];
					QbackRback=Qback*Rback;
					%epsilonshrinkdotmat_sp(:,:,isp)=[epsilonshrinkdotx_sp(isp) 0;0 epsilonshrinkdoty_sp(isp)];
					epsilonshrinkdotmat_sp(:,:,isp)=real((QbackRback)*[epsilonshrinkdotx_sp(isp) 0;0 epsilonshrinkdoty_sp(isp)]*transpose(QbackRback));
				end
				epsilonshrinkdotx_sp(1,:)=0; %TDL assumes y shrinkage only
				epsilonshrinkdoty_sp(1,:)=0; %TDL assumes x shrinkage only
				for isp=1:spCount
					epsilonshrinkdot_sp_vectorized(isp,1)=epsilonshrinkdotmat_sp(1,1,isp);
					epsilonshrinkdot_sp_vectorized(isp,2)=epsilonshrinkdotmat_sp(2,2,isp);
					epsilonshrinkdot_sp_vectorized(isp,3)=epsilonshrinkdotmat_sp(1,2,isp);
				end
				epsilonshrink_sp_vectorized=epsilonshrink_sp_vectorized+epsilonshrinkdot_sp_vectorized*dt;
				for isp=1:spCount
					temp_sp(isp)=20;
					tempdot_sp(isp)=0;
					weakeningfactor_sp(isp)=min(0.9,max(0,(temp_sp(isp)-20)/(300-20)));
				end
			end
			
			%{
			%switchable1
			if CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77
				%disp(['max(max(f_final_vect))=' num2str(max(max(f_final_vect)))]);
				crackedparticle=length(thetacrackrtl)-sum(isnan(thetacrackrtl));
				disp(['n_cracked=' int2txt(crackedparticle)]);
				for i=1:length(thetacrackrtl)		
					if isnan(thetacrackrtl(i))
					else
						disp(['f_final_vect(' int2txt(i) ',:)=' num2str(f_final_vect(i,:))]);
					end
				end
			elseif CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120
			end
			1; % pause here % break here
			%}
			%switchable1
		%	if CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77
		%		if isnan(min(thetacrackrtl))
		%		else
		%			disp('go to line 4525, add a breakpoint')
		%			pause
		%			1;
		%		end
		%	end
			%{
			%switchable1
			if 1==0
				IsItDump=1;
				save([TimeStampedName '-Dump.mat'],'-v7.3', ...
					'tt', ...
					't_time', ...
					'v_ssp', ...
					'x_sp', ...
					'F_sp', ...
					'A_sp', ...
					't_sp', ...
					's_sp', ...
					'p_sp', ...
					'r1_sp', ...
					'r2_sp', ...
					'F_rollerX', ...
					'F_rollerY', ...
					'E_acc', ...
					'e_pl_sp', ...
					'sigma_global_big', ...
					'e_t_global_big', ...
					'e_pl_global_big', ...
					'alphahp', ...
					'f_final_vect', ...
					'surfacewithfmax', ...
					'sigma_local_big', ...
					'DispPump', ...
					'TimeStampedName', ...
					'TLD', ...
					'IsItDump', ...
					'evaltimes', ...
					'stackvars', ...
					'duration', ...
					'ttstart', ...
					'x_crackcenter', ...
					'x_cracktop', ...
					'x_crackbot', ...
					'dudx_sp', ...
					'W_sp', ...
					'thetacrackrtl', ...
					'thetacrack', ...
					'pforce_sp', ...
					'sigmainf', ...
					'G', ...
					'Ga', ...
					'Grelativeerror', ...
					'ntforce_si');
				clear IsItDump
			end
			%}
			%switchable1
			
			if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==8 || CasetoRun==9 || CasetoRun==10 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==64 || CasetoRun==66 || CasetoRun==65 || CasetoRun==70 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 
				fprintf('%s',['t_time=' float2txt(5,t_time) ', DispPump=' float2txt(5,DispPump) '=' float2txt(5,DispPump/le_base) '*le_base' char(10)]);
				%disp(['t_time=' num2str(t_time) ', DispPump=' num2str(DispPump) '=' num2str(DispPump/le_base) '*le_base']);
			elseif CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==117
				fprintf('%s',['refinement=' int2txt(refinementfactor) ', t_time=' float2txt(5,t_time) ', sigmainf=' float2txt(5,sigmainf) char(10)]);
				%disp(['refinement=' num2str(refinementfactor) ', t_time=' num2str(t_time) ', sigmainf=' num2str(sigmainf)]);
			elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
				fprintf('%s',['refinement=' int2txt(refinementfactor) ', t_time=' float2txt(5,t_time) ', DispPump=' float2txt(5,DispPump) char(10)]);
				%disp(['refinement=' num2str(refinementfactor) ', t_time=' num2str(t_time) ', DispPump=' num2str(DispPump)]);
			elseif CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77
				fprintf('%s',['t_time=' float2txt(5,t_time) char(10)]);
				%disp(['t_time=' num2str(t_time)]);
			elseif CasetoRun==69
				fprintf('%s',['t_time=' float2txt(5,t_time) ', pforcecurrent=' float2txt(5,pforcecurrent) char(10)]);
				%disp(['t_time=' num2str(t_time) ', pforcecurrent=' num2str(pforcecurrent)]);
			end
			%the savemarker does not comply with CODER, deactivate for CODER runs!
			%loading below
			%{
			if CloseEnough(t_time,0.36325257129930371702286606705457,1e-5,2)
				save('fesafewafesfeasw.mat');
				1;
			end
			if tt==1
				try
					load('fesafewafesfeasw.mat');
				end
			end
			%}
			
			
			%TDL savemarker 2 start
			%{
			if savemarker.loaded
			else
				savemarker.loaded=1;
				save('TimeStampedNameOld.mat','TimeStampedName');
				for isave=savemarker.size:-1:1
					try
						load([savemarker.name num2str(isave) '.mat']);
						break;
					catch
						1;
					end
				end
				load('TimeStampedNameOld.mat');
			end
			%saving below
			for isave=1:savemarker.size
				if savemarker.saved(isave)
				elseif t_time>=savemarker.time(isave)
					%save('loadedtemp.mat','savemarker.loaded');
					savemarker.loaded=1;
					save([savemarker.name num2str(isave) '.mat']);
					savemarker.saved(isave)=1;
					%load('loadedtemp.mat');
				end
			end
			%}
			%TDL savemarker 2 end


			%if t_time<0.0038975597778895211195648862201324-dt/10
			%	load('fjhkdslagfjkldshaflfdbskjnha.mat');
			%end
			%if t_time<0.0037416573867739403615184645701675-dt/10
			%	load('fhdslafndsgalffdsjkla.mat'); %with old initial values
			%end
			%if t_time<0.0037416573867739403615184645701675-dt/10
			%	load('hfdkjsolahfdjsfhdsfla.mat'); %with revised initial values
			%end
			%if t_time<0.0043652669512362646947467581526325-dt/10
			%	load('fdkjslahfduslahfdshafkjis.mat'); %1 and 6 failing
			%end
			%save([num2str(tt) 'frilanfdsjafdsa']); LWStatus EWStatus
			%save('temp.mat');
			[e_t_schmidtswellsonly,e_t_schmidtglobalmatrixsimple,energy,sigmamaxprincmaxperfy,G,thetac,v_ssp,x_sp,F_sp,A_sp,t_sp,s_sp,p_sp,r1_sp,r2_sp,F_rollerX,F_rollerY,E_acc,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,Fyignore,evaltimes,stackvars,duration,x_crack,dudx_sp,W_sp,thetacrackrtl,thetacrack,s_si,s_si_comb,s_tip_dump,x_tip_dump,s_gauss_dump,x_gauss_dump,s_si_K1,s_tip_K1_dump,r_propdirweighted_dump,u_si_comb,d_tip_dump,d_LOC_tip_dump,dumpresult,Ktangent_local] = ...
				Generic_Solver_Predvel(Ktangent_local,temp0,temp_sp,e_t_schmidtswellsonly,e_t_schmidtglobalmatrixsimple,energy,N0,PredVelVect,deltarideal_sp,LWStatus,EWStatus,tt,ntforce_si,refinementfactor,ParticleswithPredYVel,ParticlePredYVel,Version,CModel,nodeCount,spCount,cellCount,x_sp,x_spo,d_sp,le,NN,LOC,b_sp,A_sp,t_sp,ptraction_sp,v_ssp,s_sp,m_sp,p_sp,nfbcx,nfbcy,fbcx,fbcy,E,nu,F_sp,A_spo,t_spo,dt,r1_sp,r10_sp,r2_sp,r20_sp,NodeswithPredXVel,NodeswithPredXVel2,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredXVel2,PredYVel,PredYVel2,PredXAcc,PredXAcc2,PredYAcc,PredYAcc2,E_acc,epsilonshrinkdot_sp,epsilonshrinkdotmat_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,pforce_sp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,troubleshotparticles,matmodel,k_sp,kdot_sp,weakeningfactor_sp,orientationoffset,ynodedamped,yparticledamped,t0_plane,psp1,ignoremomentum,le_c,LOCX,LOCY,Rdisplayedparticles,t_time,Debugging,x_crack,dudx_sp,W_sp,thetacrackrtl,ncforce_cracktop,ncforce_crackbot,le_base,dumpresult,uncrackable_sp,sigmamaxprincmaxperfy,Efactor_sp,shrinkage_sp);
			
			if CasetoRun==225
				if DispPump>1.2
					return;
				end
			end
			stressnorm=0;
			dispnorm=0;
			
			Ga=0;
			Grelativeerror=0;
			if CasetoRun==144 || CasetoRun==148 || CasetoRun==145 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147
				elasticstrength=9999999;
			elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
				elasticstrength=1e10; %We seem to want to skip the next process, so we put "infinite" elastic strength
			else
				elasticstrength=25; %MPa
			end

			if CasetoRun==115 || CasetoRun==116 || CasetoRun==117
				sigmamaxprinc=zeros(spCount,1);
				for sp_inloop=1:spCount
					sigmamaxprinc(sp_inloop)=0.5*(s_sp(sp_inloop,1)+s_sp(sp_inloop,2))+sqrt((0.5*(s_sp(sp_inloop,1)-s_sp(sp_inloop,2)))^2+s_sp(sp_inloop,3)^2);
				end
				if max(sigmamaxprinc)>elasticstrength
					fprintf('%s',['Material Failure!, spCount=' int2txt(spCount) ', simgainf=' float2txt(5,sigmainf) ', sp=' float2txt(5,FindMax(sigmamaxprinc)) ', x_sp=[' float2txt(5,x_sp(spCount,1)) ',' float2txt(5,x_sp(spCount,2)) ']' char(10)]);
					%disp(['Material Failure!, spCount=' num2str(spCount) ', simgainf=' num2str(sigmainf) ', sp=' num2str(FindMax(sigmamaxprinc)) ', x_sp=[' num2str(x_sp(sp),1) ',' num2str(x_sp(sp),2) ']']);
					%{
					%switchable1
					if exist('refinemenfactorinput')
					%}
					%switchable1
						return;
					%{
					%switchable1
					else
						pause;
					end
					%}
					%switchable1
				end
			elseif CasetoRun==183
			elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
			elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
				sigmamaxprinc=zeros(spCount,1);
				for sp_inloop=1:spCount
					sigmamaxprinc(sp_inloop)=0.5*(s_sp(sp_inloop,1)+s_sp(sp_inloop,2))+sqrt((0.5*(s_sp(sp_inloop,1)-s_sp(sp_inloop,2)))^2+s_sp(sp_inloop,3)^2);
				end
				if max(sigmamaxprinc)>elasticstrength
					fprintf('%s',['Material Failure!, spCount=' int2txt(spCount) ', sp=' float2txt(5,FindMax(sigmamaxprinc)) ', x_sp=[' float2txt(5,x_sp(sp,1)) ',' float2txt(5,x_sp(sp,2)) ']' char(10)]);
					%disp(['Material Failure!, spCount=' num2str(spCount) ', simgainf=' num2str(sigmainf) ', sp=' num2str(FindMax(sigmamaxprinc)) ', x_sp=[' num2str(x_sp(sp),1) ',' num2str(x_sp(sp),2) ']']);
					%{
					%switchable1
					if exist('refinemenfactorinput')
					%}
					%switchable1
						return;
					%{
					%switchable1
					else
						pause;
					end
					%}
					%switchable1
				end
			elseif CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120
				if sigmainf>0.5
					%{
					%switchable1

					if exist('refinemenfactorinput')
						%}
						%switchable1
						SIGMAmxstressnorm=0;
						SIGMAm=0;
						for sp_inloop=1:spCount
							if CasetoRun==120
								x=x_spo(sp_inloop,1)-x_central(1);
								y=x_spo(sp_inloop,2)-x_central(2);
							else
								x=x_sp(sp_inloop,1)-x_central(1);
								y=x_sp(sp_inloop,2)-x_central(2);
							end
							sigmay=real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 + (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2;
							sigmax = - real(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2 - (real(S)*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1))/2 + S*(real((x - y*1i)/((x - y*1i)^2 - a^2)^(1/2)) + real((x + y*1i)/((x + y*1i)^2 - a^2)^(1/2)) - 1);
							sigmaxy = imag(S*a^2*(1/a^2 + (y*2i)/((x + y*1i)^2 - a^2)^(3/2)))/2;
							sigmaerror=s_sp(sp_inloop,:)-[sigmax sigmay sigmaxy];
							SIGMAmxstressnorm=SIGMAmxstressnorm+m_sp(sp_inloop)*sqrt(dot(sigmaerror,sigmaerror));
							SIGMAm=SIGMAm+m_sp(sp_inloop);
						end
						stressnorm=SIGMAmxstressnorm/SIGMAm;
						gridsize=le(1); %assuming size in x and in y are the same
						%{
						%switchable1
					end
					%}
					%switchable1
				end
				K1=sigmainf*sqrt(3.1415926536*a);
				Ga=K1^2*(1-nu^2)/E;
				Grelativeerror=abs(G-Ga)/Ga;
				fprintf('%s',['Ga=' float2txt(5,Ga) ', G=' float2txt(5,G) ', thetac=' float2txt(5,thetac*180/3.1415926536) ' degrees' char(10)]);
				if sigmainf>0.5 
					%{
					%switchable1
					if exist('refinemenfactorinput')
						%}
						%switchable1
						Dmatrix=E/((1+nu)*(1-2*nu))*[1-nu nu 0;nu 1-nu 0;0 0 (1-2*nu)];
						return;
						%{
						%switchable1
					end
					%}
					%switchable1
				end
				1;
			end
			%{
			%switchable1
			if CasetoRun==3 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==17
				save([TimeStampedName '\\evaltimes\\t_time=' char(vpa(t_time)) '.mat'],'-v7.3','evaltimes');
			end
			%}
			%switchable1
			
			%{
			%switchable1
			if CasetoRun==27
				for j=1:size(stackvars,1)
					if stackvars(j,2)==0
						stackvars(j,3)=stackvars(size(stackvars,1),2)/1000;
					else
						stackvars(j,3)=0;
					end
				end
				StressProfile=figure;
				set(StressProfile,'visible','off');
				hold on;
				set(StressProfile,'Position',[0 0 720 1280]);
				currentgcp=gcp;
				title(['cores=' num2str(currentgcp.NumWorkers) ', tt= ' num2str(i) ', t_time=' char(vpa(t_time))]);
				%xlim([0 xupperlimit]);

				BarProfile=barh(stackvars,'stacked');
				set(BarProfile,{'FaceColor'},{'none';'k';'r'},'EdgeColor','none','BarWidth',1);
				%set(BarProfile,'BarWidth',1);
				saveas(StressProfile,[TimeStampedName '\\scheduleotf\\tt=' num2str(tt) ', t_time=' char(vpa(t_time)) '.png']);
				%frame = getframe(StressProfile);
				%writeVideo(writerObj,frame);
				hold off;
				close(StressProfile);
			end
			%}
			%switchable1
			%if CloseEnough(t_time,0.857,1e-5,2)
			%	return
			%end
			%{
			%switchable1
			if CasetoRun==14
				elapsedtime=[elapsedtime toc];
				starttimestep=[starttimestep t_time];
			end
			%}
			%switchable1
			% Update time and step 
			t_time=t_time+dt;
			%{
			%switchable1
			if CasetoRun==14
				endtimestep=[endtimestep t_time];
				save([TimeStampedName '-timehistory.mat'],'-v7.3','elapsedtime','starttimestep','endtimestep','numberofcores','sourcefilename');
			end
			%}
			%switchable1
		end
		
		%% Plot the result

		F=zeros(1,2);
		D=zeros(1,2);
		for i=1:sp_predvelnum
			for j=1:2
			   D(j)=D(j)+(x_sp(displacementmonitoredparticles(i),j)-x_spo(displacementmonitoredparticles(i),j));
			end
		end

		for i=1:length(F_rollerX)
			F(1)=F(1)+F_rollerX(i);
		end
		for i=1:length(F_rollerY)
			F(2)=F(2)+F_rollerY(i);
		end

		%{
		for i=1:2
			F(i)=sum(pforce_sp(:,i));
		end
		%}

		D=D/sp_predvelnum;
		if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==64 || CasetoRun==66 || CasetoRun==65 || CasetoRun==70
			CurrentTLDSize=size(TLD,1);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,1,t_time);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,2,F(2));
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,3,D(2));
		elseif CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==69
		elseif CasetoRun==4
			CurrentTLDSize=size(TLD,1);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,1,t_time);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,2,F(2));
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,3,D(2));
		elseif CasetoRun==5 || CasetoRun==6
			CurrentTLDSize=size(TLD,1);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,1,t_time);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,2,F(2)-sum(Fyignore));
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,3,D(2));
		elseif CasetoRun==7
			CurrentTLDSize=size(TLD,1);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,1,t_time);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,2,F(2)-sum(Fyignore));
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,3,D(2));
		elseif CasetoRun==8 || CasetoRun==9
			CurrentTLDSize=size(TLD,1);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,1,t_time);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,2,F(2));
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,3,D(2));
		elseif CasetoRun==10
			CurrentTLDSize=size(TLD,1);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,1,t_time);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,2,F(2));
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,3,D(2));
		elseif CasetoRun==11
			CurrentTLDSize=size(TLD,1);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,1,t_time);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,2,F(2));
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,3,D(2));
		elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
			CurrentTLDSize=size(TLD,1);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,1,t_time);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,2,F(2));
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,3,D(2));
		elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
			CurrentTLDSize=size(TLD,1);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,1,t_time);
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,2,F(2));
			TLD=MatrixInsertion(TLD,CurrentTLDSize+1,3,D(2));
		end
		%predeterminedvelocityvalue
		%for i=1:length(particleswithpredeterminedvelocities)
			%disp(['v(' num2str(particleswithpredeterminedvelocities(i)) ')=[' num2str(v_ssp(particleswithpredeterminedvelocities(i),1)) ' ' num2str(v_ssp(particleswithpredeterminedvelocities(i),2)) ']']);
			%disp(['d(' num2str(particleswithpredeterminedvelocities(i)) ')=[' num2str(x_sp(particleswithpredeterminedvelocities(i),1)-x_spo(particleswithpredeterminedvelocities(i),1)) ' ' num2str(x_sp(particleswithpredeterminedvelocities(i),2)-x_spo(particleswithpredeterminedvelocities(i),2)) ']']);
		%end
		
		%start of v_ssp_an and u_sp error calculation
		if CasetoRun==154
			anerror.v_err_absolute=anerror.v_ssp_an-v_ssp;
			anerror.v_srsserror=sqrt(dot(anerror.v_err_absolute(:,1),anerror.v_err_absolute(:,1))+dot(anerror.v_err_absolute(:,2),anerror.v_err_absolute(:,2)));
			anerror.v_srssan=sqrt(dot(anerror.v_ssp_an(:,1),anerror.v_ssp_an(:,1))+dot(anerror.v_ssp_an(:,2),anerror.v_ssp_an(:,2)));
			anerror.v_err_relative=anerror.v_srsserror/anerror.v_srssan;

			%anerror.u_sp=x_sp-x_spo;
			for isp=1:spCount
				for idim=1:2
					anerror.u_sp(isp,idim)=x_sp(isp,idim)-x_spo(isp,idim);
				end
			end
			anerror.u_err_absolute=anerror.u_sp_an-anerror.u_sp;
			anerror.u_srsserror=sqrt(dot(anerror.u_err_absolute(:,1),anerror.u_err_absolute(:,1))+dot(anerror.u_err_absolute(:,2),anerror.u_err_absolute(:,2)));
			anerror.u_srssan=sqrt(dot(anerror.u_sp_an(:,1),anerror.u_sp_an(:,1))+dot(anerror.u_sp_an(:,2),anerror.u_sp_an(:,2)));
			anerror.u_err_relative=anerror.u_srsserror/anerror.u_srssan;
		end
		%end of v_ssp_an and u_sp error calculation
		
		%autosavetimemodnew=mod(t_time,autosavetimeinterval);
		%{
		%switchable1
		if justloadedyo==1
			justloadedyo=0;
		else
		%}
		%switchable1
			%ttstart=516; % define ttstart here
			%{
			%switchable1
			save([TimeStampedName '-Master.mat'],'-v7.3', ...
				'tt', ...
				'TimeStampedName', ...
				'TLD', ...
				'ttstart');
			%}
			%switchable1
			if CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
				if tt==1
					savesinglelong(1,[TimeStampedName '-Master-' 'x_crack_bridge_tt_first' '.txt']);
					savesinglelong(1,[TimeStampedName '-Master-' 'x_crack_bridge_tt_last' '.txt']);
					x_crack.bridge.tt_last.savetoken=0;
				end
				if x_crack.bridge.tt_first.savetoken
					savesinglelong(x_crack.bridge.tt_first.value,[TimeStampedName '-Master-' 'x_crack_bridge_tt_first' '.txt']);
					x_crack.bridge.tt_first.savetoken=0;
				end
				if x_crack.bridge.tt_last.savetoken
					savesinglelong(x_crack.bridge.tt_last.value,[TimeStampedName '-Master-' 'x_crack_bridge_tt_last' '.txt']);
					x_crack.bridge.tt_last.savetoken=0;
				end
			end
			parfor i=1:4
				if i==1
					savesinglefloat(energy.kinetic.value,[TimeStampedName '-Slave-' 'energy_kinetic_value' '-' int2txt(tt) '.txt']);
					savesinglefloat(energy.strain.value,[TimeStampedName '-Slave-' 'energy_strain_value' '-' int2txt(tt) '.txt']);
					savesinglefloat(energy.work.value,[TimeStampedName '-Slave-' 'energy_work_value' '-' int2txt(tt) '.txt']);
					savesinglefloat(x_crack.bridge.storedanddissed.value,[TimeStampedName '-Slave-' 'x_crack_bridge_storedanddissed_value' '-' int2txt(tt) '.txt']);
				elseif i==2
					savesinglelong(tt,[TimeStampedName '-Slave-' 'tt' '-' int2txt(tt) '.txt']);
					savesinglefloat(t_time,[TimeStampedName '-Slave-' 't_time' '-' int2txt(tt) '.txt']);
					savesinglefloat(DispPump,[TimeStampedName '-Slave-' 'DispPump' '-' int2txt(tt) '.txt']);
					savesinglefloat(F_loadcontrolled,[TimeStampedName '-Slave-' 'F_loadcontrolled' '-' int2txt(tt) '.txt']);
				elseif i==3
					savematrixfloat(F_rollerX,[TimeStampedName '-Slave-' 'F_rollerX' '-' int2txt(tt) '.txt']);
					savematrixfloat(e_t_schmidtglobalmatrixsimple,[TimeStampedName '-Slave-' 'e_t_schmidtglobalmatrixsimple' '-' int2txt(tt) '.txt']);
					savematrixfloat(e_t_schmidtswellsonly,[TimeStampedName '-Slave-' 'e_t_schmidtswellsonly' '-' int2txt(tt) '.txt']);
				elseif i==4
					%TDL just tag check
					savematrixlong(time_fds,[TimeStampedName '-Slave-' 'time_fds' '-' int2txt(tt) '.txt']);
					savematrixlong(surroundtag_sp,[TimeStampedName '-Slave-' 'surroundtag_sp' '-' int2txt(tt) '.txt']);
					savematrixfloat(F_rollerY,[TimeStampedName '-Slave-' 'F_rollerY' '-' int2txt(tt) '.txt']);
					savematrixfloat(epsilonshrink_sp_vectorized,[TimeStampedName '-Slave-' 'epsilonshrink_sp_vectorized' '-' int2txt(tt) '.txt']);
					savematrixfloat(epsilonshrinkdot_sp_vectorized,[TimeStampedName '-Slave-' 'epsilonshrinkdot_sp_vectorized' '-' int2txt(tt) '.txt']);
					savematrixfloat(temp_sp,[TimeStampedName '-Slave-' 'temp_sp' '-' int2txt(tt) '.txt']);
					savematrixfloat(density_sp,[TimeStampedName '-Slave-' 'density_sp' '-' int2txt(tt) '.txt']);
				end
			end
			if ((CasetoRun~=161) && tt==1) || dumpresult || ((CasetoRun==161) && t_time>=0.5) %targettime
				fprintf('%s',['Saving, tt=' int2txt(tt) char(10)]);
				parfor i=1:4
					if i==1
						savestring(TimeStampedName,[TimeStampedName '-Master-' 'TimeStampedName' '.txt']);
						savematrixfloat(TLD,[TimeStampedName '-Master-' 'TLD' '.txt']);
						
						
						savematrixfloat(v_ssp,[TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(tt) '.txt']);
						savematrixfloat(x_sp,[TimeStampedName '-Slave-' 'x_sp' '-' int2txt(tt) '.txt']);
						savecellmatrixfloat(F_sp,[TimeStampedName '-Slave-' 'F_sp' '-' int2txt(tt) '.txt']);
						if CasetoRun==229 || CasetoRun==230
							savesinglefloat(t0,[TimeStampedName '-Master-' 't0' '.txt']);
						else
							savematrixfloat(A_sp,[TimeStampedName '-Slave-' 'A_sp' '-' int2txt(tt) '.txt']);
							savematrixfloat(t_sp,[TimeStampedName '-Slave-' 't_sp' '-' int2txt(tt) '.txt']);
							savematrix3float(s_si,[TimeStampedName '-Slave-' 's_si' '-' int2txt(tt) '.txt']);
							savematrixfloat(s_si_comb,[TimeStampedName '-Slave-' 's_si_comb' '-' int2txt(tt) '.txt']);
							savematrixfloat(x_gauss_dump,[TimeStampedName '-Slave-' 'x_gauss_dump' '-' int2txt(tt) '.txt']);
							savematrixfloat(s_si_K1,[TimeStampedName '-Slave-' 's_si_K1' '-' int2txt(tt) '.txt']);
							savematrixfloat(u_si_comb,[TimeStampedName '-Slave-' 'u_si_comb' '-' int2txt(tt) '.txt']);
							savematrixfloat(x_crack.bridge.absforce,[TimeStampedName '-Slave-' 'x_crack_bridge_absforce' '-' int2txt(tt) '.txt']);
							savematrixfloat(x_crack.bridge.completeratio,[TimeStampedName '-Slave-' 'x_crack_bridge_completeratio' '-' int2txt(tt) '.txt']);
							savematrixfloat(x_crack.bridge.firsttimeactive,[TimeStampedName '-Slave-' 'x_crack_bridge_firsttimeactive' '-' int2txt(tt) '.txt']);
							savematrixfloat(x_crack.deltatemp,[TimeStampedName '-Slave-' 'x_crack_deltatemp' '-' int2txt(tt) '.txt']);
						end
					elseif i==2
						savematrixfloat(s_sp,[TimeStampedName '-Slave-' 's_sp' '-' int2txt(tt) '.txt']);
						savematrixfloat(r1_sp,[TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(tt) '.txt']);
						savematrixfloat(r2_sp,[TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(tt) '.txt']);
						savematrixfloat(E_acc,[TimeStampedName '-Slave-' 'E_acc' '-' int2txt(tt) '.txt']);
						if CasetoRun==229 || CasetoRun==230
							1;
						else
							savematrixfloat(p_sp,[TimeStampedName '-Slave-' 'p_sp' '-' int2txt(tt) '.txt']);
							savematrixfloat(e_pl_sp,[TimeStampedName '-Slave-' 'e_pl_sp' '-' int2txt(tt) '.txt']);
							savematrixfloat(sigma_global_big,[TimeStampedName '-Slave-' 'sigma_global_big' '-' int2txt(tt) '.txt']);
							savematrixfloat(e_t_global_big,[TimeStampedName '-Slave-' 'e_t_global_big' '-' int2txt(tt) '.txt']);
							savematrixfloat(e_pl_global_big,[TimeStampedName '-Slave-' 'e_pl_global_big' '-' int2txt(tt) '.txt']);
							savematrixfloat(s_tip_dump,[TimeStampedName '-Slave-' 's_tip_dump' '-' int2txt(tt) '.txt']);
							savematrixfloat(s_tip_K1_dump,[TimeStampedName '-Slave-' 's_tip_K1_dump' '-' int2txt(tt) '.txt']);
							savematrixfloat(d_tip_dump,[TimeStampedName '-Slave-' 'd_tip_dump' '-' int2txt(tt) '.txt']);
							savesinglefloat(rampfactor,[TimeStampedName '-Slave-' 'rampfactor' '-' int2txt(tt) '.txt']);
							savematrixfloat(x_crack.bridge.adjusted.absdeltaxmaxi,[TimeStampedName '-Slave-' 'x_crack_bridge_absdeltaxmaxi' '-' int2txt(tt) '.txt']);
						end
						savematrix3floatcell(x_crack.force.top,x_crack.nparticles,x_crack.npaths,[TimeStampedName '-Slave-' 'x_crack_force_top' '-' int2txt(tt) '.txt'])
						
					elseif i==3
						savematrix3floatcell(x_crack.center,x_crack.nparticles,x_crack.npaths,[TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(tt) '.txt'])
						savematrix3floatcell(x_crack.top,x_crack.nparticles,x_crack.npaths,[TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(tt) '.txt'])
						savematrix3floatcell(x_crack.bot,x_crack.nparticles,x_crack.npaths,[TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(tt) '.txt'])
						if CasetoRun==229 || CasetoRun==230
							1;
						else
							savematrixfloat(alphahp,[TimeStampedName '-Slave-' 'alphahp' '-' int2txt(tt) '.txt']);
							savematrixfloat(f_final_vect,[TimeStampedName '-Slave-' 'f_final_vect' '-' int2txt(tt) '.txt']);
							savematrixfloat(surfacewithfmax,[TimeStampedName '-Slave-' 'surfacewithfmax' '-' int2txt(tt) '.txt']);
							savematrixfloat(sigma_local_big,[TimeStampedName '-Slave-' 'sigma_local_big' '-' int2txt(tt) '.txt']);
							savematrixfloat(evaltimes,[TimeStampedName '-Slave-' 'evaltimes' '-' int2txt(tt) '.txt']);
							savematrixfloat(stackvars,[TimeStampedName '-Slave-' 'stackvars' '-' int2txt(tt) '.txt']);
							savematrixfloat(duration,[TimeStampedName '-Slave-' 'duration' '-' int2txt(tt) '.txt']);
							%savematrix3float(x_crack.center,[TimeStampedName '-Slave-' 'x_crack.center' '-' int2txt(tt) '.txt']);
							%savematrix3float(x_crack.top,[TimeStampedName '-Slave-' 'x_crack.top' '-' int2txt(tt) '.txt']);
							%savematrix3float(x_crack.bottom,[TimeStampedName '-Slave-' 'x_crack.bottom' '-' int2txt(tt) '.txt']);
							%savematrixlong(x_crack.nparticles,[TimeStampedName '-Slave-' 'x_crack.nparticles' '-' int2txt(tt) '.txt']);
							%savesinglelong(x_crack.npaths,[TimeStampedName '-Slave-' 'x_crack.npaths' '-' int2txt(tt) '.txt']);
							%savecellmatrixfloat(x_cracktop,[TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(tt) '.txt']);
							%savecellmatrixfloat(x_crackbot,[TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(tt) '.txt']);
							savematrixfloat(x_tip_dump,[TimeStampedName '-Slave-' 'x_tip_dump' '-' int2txt(tt) '.txt']);
							savematrixfloat(d_LOC_tip_dump,[TimeStampedName '-Slave-' 'd_LOC_tip_dump' '-' int2txt(tt) '.txt']);
							savematrixfloat(x_crack.tipcrackratio,[TimeStampedName '-Slave-' 'x_crack_tipcrackratio' '-' int2txt(tt) '.txt']);
							savematrixfloat(x_crack.bridge.base.absdeltax,[TimeStampedName '-Slave-' 'x_crack_bridge_base_absdeltax' '-' int2txt(tt) '.txt']);
						end
						savematrixfloat(shrinkage_global_sp_vectorized,[TimeStampedName '-Slave-' 'shrinkage_global_sp_vectorized' '-' int2txt(tt) '.txt']);
					elseif i==4
						savematrixfloat(thetacrack,[TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(tt) '.txt']);
						if CasetoRun==229 || CasetoRun==230
							1;
						else
							savematrixfloat(pforce_sp,[TimeStampedName '-Slave-' 'pforce_sp' '-' int2txt(tt) '.txt']);
							savesinglefloat(sigmainf,[TimeStampedName '-Slave-' 'sigmainf' '-' int2txt(tt) '.txt']);
							savesinglefloat(G,[TimeStampedName '-Slave-' 'G' '-' int2txt(tt) '.txt']);
							savesinglefloat(Ga,[TimeStampedName '-Slave-' 'Ga' '-' int2txt(tt) '.txt']);
							savesinglefloat(Grelativeerror,[TimeStampedName '-Slave-' 'Grelativeerror' '-' int2txt(tt) '.txt']);
							savematrixfloat(ntforce_si,[TimeStampedName '-Slave-' 'ntforce_si' '-' int2txt(tt) '.txt']);
							%savematrixfloat(asdf,[TimeStampedName '-Slave-' 'asdf' '-' int2txt(tt) '.txt']);
							savematrixfloat(s_gauss_dump,[TimeStampedName '-Slave-' 's_gauss_dump' '-' int2txt(tt) '.txt']);
							savematrixfloat(r_propdirweighted_dump,[TimeStampedName '-Slave-' 'r_propdirweighted_dump' '-' int2txt(tt) '.txt']);
							savematrixfloat(dudx_sp,[TimeStampedName '-Slave-' 'dudx_sp' '-' int2txt(tt) '.txt']);
							savematrixfloat(W_sp,[TimeStampedName '-Slave-' 'W_sp' '-' int2txt(tt) '.txt']);
							savematrixfloat(thetacrackrtl,[TimeStampedName '-Slave-' 'thetacrackrtl' '-' int2txt(tt) '.txt']);
						end
					end
				end
				%start of case-specific data dumps
				if CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180
					parfor i=1:4
						if i==1
							savesinglefloat(pushcol.relative_r_sp.curavg,[TimeStampedName '-Slave-' 'pushcol.relative_r_sp.curavg' '-' int2txt(tt) '.txt']);
							savesinglefloat(pushcol.relative_r_sp.coltgt,[TimeStampedName '-Slave-' 'pushcol.relative_r_sp.coltgt' '-' int2txt(tt) '.txt']);
						elseif i==2
							savesinglefloat(pushcol.relative_r_sp.delta,[TimeStampedName '-Slave-' 'pushcol.relative_r_sp.delta' '-' int2txt(tt) '.txt']);
							savesinglefloat(pushcol.relative_r_sp.springforce,[TimeStampedName '-Slave-' 'pushcol.relative_r_sp.springforce' '-' int2txt(tt) '.txt']);
						elseif i==3
							savesinglefloat(pushcol.v_r_sp.curavg,[TimeStampedName '-Slave-' 'pushcol.v_r_sp.curavg' '-' int2txt(tt) '.txt']);
							savesinglefloat(pushcol.v_r_sp.coltgt,[TimeStampedName '-Slave-' 'pushcol.v_r_sp.coltgt' '-' int2txt(tt) '.txt']);
						elseif i==4
							savesinglefloat(pushcol.v_r_sp.delta,[TimeStampedName '-Slave-' 'pushcol.v_r_sp.delta' '-' int2txt(tt) '.txt']);
							savesinglefloat(pushcol.v_r_sp.dampforce,[TimeStampedName '-Slave-' 'pushcol.v_r_sp.dampforce' '-' int2txt(tt) '.txt']);
						end
					end
				elseif CasetoRun==154 || CasetoRun==161
					parfor i=1:4
						if i==1
							savematrixfloat(anerror.v_ssp_an,[TimeStampedName '-Slave-' 'anerror.v_ssp_an' '-' int2txt(tt) '.txt']);
							savematrixfloat(anerror.u_sp_an,[TimeStampedName '-Slave-' 'anerror.u_sp_an' '-' int2txt(tt) '.txt']);
						elseif i==2
							savematrixfloat(anerror.u_sp,[TimeStampedName '-Slave-' 'anerror.u_sp' '-' int2txt(tt) '.txt']);
							savesinglefloat(anerror.v_srsserror,[TimeStampedName '-Slave-' 'anerror.v_srsserror' '-' int2txt(tt) '.txt']);
							savesinglefloat(anerror.u_srsserror,[TimeStampedName '-Slave-' 'anerror.u_srsserror' '-' int2txt(tt) '.txt']);
						elseif i==3
							savesinglefloat(anerror.v_srssan,[TimeStampedName '-Slave-' 'anerror.v_srssan' '-' int2txt(tt) '.txt']);
							savesinglefloat(anerror.u_srssan,[TimeStampedName '-Slave-' 'anerror.u_srssan' '-' int2txt(tt) '.txt']);
						elseif i==4
							savesinglefloat(anerror.v_err_relative,[TimeStampedName '-Slave-' 'anerror.v_err_relative' '-' int2txt(tt) '.txt']);
							savesinglefloat(anerror.u_err_relative,[TimeStampedName '-Slave-' 'anerror.u_err_relative' '-' int2txt(tt) '.txt']);
						end
					end
				end
				if CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
					parfor i=1:4
						if i==1
							savematrixlong(x_crack.sequence.tipreg,[TimeStampedName '-Slave-' 'x_crack_sequence_tipreg' '-' int2txt(tt) '.txt']);
						elseif i==2
							savematrixlong(x_crack.sequence.merge,[TimeStampedName '-Slave-' 'x_crack_sequence_merge' '-' int2txt(tt) '.txt']);
							savesinglelong(x_crack.npaths,[TimeStampedName '-Slave-' 'x_crack_npaths' '-' int2txt(tt) '.txt']);
						elseif i==3
							savematrixlong(x_crack.nparticles,[TimeStampedName '-Slave-' 'x_crack_nparticles' '-' int2txt(tt) '.txt']);
							savematrixlong(x_crack.terminatedprop,[TimeStampedName '-Slave-' 'x_crack_terminatedprop' '-' int2txt(tt) '.txt']);
						elseif i==4
							savematrixfloat(x_crack.acctipcrackratio,[TimeStampedName '-Slave-' 'x_crack_acctipcrackratio' '-' int2txt(tt) '.txt']);
						end
					end
					x_crack.sequence.tipreg=zeros(200,2);
					x_crack.sequence.merge=zeros(200,2);
					x_crack.acctipcrackratio=zeros(200,2);
				end				%end of case-specific data dumps
				savesinglelong(tt,[TimeStampedName '-Master-' 'tt' '.txt']);
				if ntt<=1
					savesinglelong(tt,[TimeStampedName '-Master-' 'ttstart' '.txt']);
				end
				ntt=ntt+1;
				if CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174
					if ntt>2000
						return;
					end
				elseif CasetoRun==153
					if ntt>999
						return;
					end
				elseif CasetoRun==154 || CasetoRun==161
					%if ntt>2500
					if ntt>600
						return;
					end
				elseif CasetoRun==175 || CasetoRun==194 || CasetoRun==180
					if ntt>1000
						return;
					end
				elseif CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
					if ntt>refinementfactor/5*750
						return;
					end
				elseif CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
					if ntt>1000
						return;
					end
				elseif CasetoRun==229 || CasetoRun==230
					if ntt>10000
						return;
					end
				else
					if ntt>500
						return;
					end
				end
			else
				fprintf('%s',['Skipping tt=' int2txt(tt) char(10)]);
			end
			
			if CasetoRun==161
				if t_time>=0.5 %targettime
					anerror.gridsize=le(1);
					anerror.t_deviation=t_time-0.5 %targettime;
					for isp=1:spCount
						for idim=1:2
							anerror.u_sp(isp,idim)=x_sp(isp,idim)-x_spo(isp,idim);
						end
					end
					anerror.u_err_absolute=anerror.u_sp_an-anerror.u_sp;
					anerror.u_srsserror=sqrt(dot(anerror.u_err_absolute(:,1),anerror.u_err_absolute(:,1))+dot(anerror.u_err_absolute(:,2),anerror.u_err_absolute(:,2)));
					anerror.u_srssan=sqrt(dot(anerror.u_sp_an(:,1),anerror.u_sp_an(:,1))+dot(anerror.u_sp_an(:,2),anerror.u_sp_an(:,2)));
					anerror.u_err_relative=anerror.u_srsserror/anerror.u_srssan;
					savesinglelong(tt,[TimeStampedName '-Master-' 'ttstart' '.txt']);
					savesinglelong(tt,[TimeStampedName '-Master-' 'tt' '.txt']);
					return;
				end
			end
			%{
			%switchable1
			save([TimeStampedName '\\' num2str(tt) '.mat'],'-v7.3', ...
				'tt', ...
				't_time', ...
				'v_ssp', ...
				'x_sp', ...
				'F_sp', ...
				'A_sp', ...
				't_sp', ...
				's_sp', ...
				'p_sp', ...
				'r1_sp', ...
				'r2_sp', ...
				'F_rollerX', ...
				'F_rollerY', ...
				'E_acc', ...
				'e_pl_sp', ...
				'sigma_global_big', ...
				'e_t_global_big', ...
				'e_pl_global_big', ...
				'alphahp', ...
				'f_final_vect', ...
				'surfacewithfmax', ...
				'sigma_local_big', ...
				'DispPump', ...
				'evaltimes', ...
				'stackvars', ...
				'duration', ...
				'x_crackcenter', ...
				'x_cracktop', ...
				'x_crackbot', ...
				'dudx_sp', ...
				'W_sp', ...
				'thetacrackrtl', ...
				'thetacrack', ...
				'pforce_sp', ...
				'sigmainf', ...
				'G', ...
				'Ga', ...
				'Grelativeerror', ...
				'ntforce_si');
			%}
			%switchable1

			%{
			%switchable1

		end
		%}
		%switchable1
		%autosavetimemodprev=autosavetimemodnew;
		
		tt=tt+1;
	end
	tt=tt-1;    
	%{
	close(StressProfile1);
	close(StressProfile2);
	close(StressProfile4);
	%}  
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
	elseif CasetoRun==4
		loadplot=TLD(:,2)/1000;
		dispplot=zeros(1,length(TLD(:,3)));
		for i=1:length(TLD(:,3))
			dispplot(i)=1+TLD(i,3)/50;
		end
	elseif CasetoRun==5 || CasetoRun==6
	elseif CasetoRun==7
	elseif CasetoRun==8 || CasetoRun==9
	elseif CasetoRun==10
	elseif CasetoRun==11
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
	end

	% Start Printing TLD Video
	%{
	%switchable1
	if exist('layer')==0
		layer=[];
	end
	%}
	%switchable1
	if CasetoRun==5
		tt=min(tt,2399);
	end
	%[
	%switchable2
	for switcher=1:5
		PrintResults_parfor(x_crack.tiprename,le_base,switcher,TimeStampedName,videofps,tt,ttstart,DispPump,CModel,LOC,le,NN,d_sp,e_sp,v_ssp,spCount,niCount,E_acc,TLD,plotignore,matmodel,lp,layer,CasetoRun,orientationoffset,xdirletter,ydirletter,x_spo, ...
			ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,thetacrackrtl,refinementfactor,frameskip);
	end
	%]
	%switchable2

	%{
	%switchable1
	%plot(TLD(:,3),TLD(:,2));
	%uisave
	disp(['Look for: ' TimeStampedName]);
	close all;
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
	elseif CasetoRun==4
		plot(dispplot,loadplot);
		hold on;
		set(gca,'color','none');
		hold off;
	elseif CasetoRun==5 || CasetoRun==6
	elseif CasetoRun==7
	elseif CasetoRun==8 || CasetoRun==9
	elseif CasetoRun==10
	elseif CasetoRun==11
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
	end
	soundplay
	%}
	%switchable1
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [e_t_schmidtswellsonly,e_t_schmidtglobalmatrixsimple,energy,sigmamaxprincmaxperfy,G,thetac,v_ssp_out,x_sp_out,F_sp,A_sp,t_sp,s_sp,p_sp,r1_sp,r2_sp,F_rollerX,F_rollerY,E_acc,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,Fyignore,evaltimes,stackvars,duration,x_crack,dudx_sp,W_sp,thetacrackrtl,thetacrack,s_si,s_si_comb,s_tip_dump,x_tip_dump,s_gauss_dump,x_gauss_dump,s_si_K1,s_tip_K1_dump,r_propdirweighted_dump,u_si_comb,d_tip_dump,d_LOC_tip_dump,dumpresult,Ktangent_local] = Generic_Solver_Predvel(Ktangent_local,temp0,temp_sp,e_t_schmidtswellsonly,e_t_schmidtglobalmatrixsimple,energy,N0,PredVelVect,deltarideal_sp,LWStatus,EWStatus,tt,ntforce_si,refinementfactor,ParticleswithPredYVel,ParticlePredYVel,Version,CModel,nodeCount,spCount,cellCount,x_sp,x_spo,d_sp,le,NN,LOC,b_sp,A_sp,t_sp,ptraction_sp,v_ssp,s_sp,m_sp,p_sp,nfbcx,nfbcy,fbcx,fbcy,E,nu,F_sp,A_spo,t_spo,dt,r1_sp,r10_sp,r2_sp,r20_sp,NodeswithPredXVel,NodeswithPredXVel2,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredXVel2,PredYVel,PredYVel2,PredXAcc,PredXAcc2,PredYAcc,PredYAcc2,E_acc,epsilonshrinkdot_sp,epsilonshrinkdotmat_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,pforce_sp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,troubleshotparticles,matmodel,k_sp,kdot_sp,weakeningfactor_sp,orientationoffset,ynodedamped,yparticledamped,t0_plane,psp1,ignoremomentum,le_c,LOCX,LOCY,Rdisplayedparticles,t_time,Debugging,x_crack,dudx_sp,W_sp,thetacrackrtl,ncforce_cracktop,ncforce_crackbot,le_base,dumpresult,uncrackable_sp,sigmamaxprincmaxperfy,Efactor_sp,shrinkage_sp)
	G=0;
	thetac=[];
	niCount=NN(1)*NN(2);fprintf('%s',['marker #620' char(10)]);
	
	s_tip_dump=zeros(200,3);
	coder.varsize('s_tip_dump');
	s_tip_dump=zeros(2,3);
	s_tip_K1_dump=zeros(200,3);
	coder.varsize('s_tip_K1_dump');
	s_tip_K1_dump=zeros(2,3);
	
	x_tip_dump=zeros(200,2);
	coder.varsize('x_tip_dump');
	x_tip_dump=zeros(2,2);
	
	uncrackable_si_comb=zeros(niCount,1);
	k_si_comb=zeros(niCount,1);
	weakeningfactor_si_comb=zeros(niCount,1);
	
	s_gauss_dump=zeros(5000,3);
	coder.varsize('s_gauss_dump');
	s_gauss_dump=zeros(2,3);

	x_gauss_dump=zeros(5000,2);
	coder.varsize('x_gauss_dump');
	x_gauss_dump=zeros(2,2);
	diameter=1; %diameter for the gauss integrator
	if CasetoRun==118 || CasetoRun==173
		diameter=2*le(1);
	elseif CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130
		diameter=0.75;
	elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165
		diameter=1e-9;
	else
		diameter=0.75;
	end
	[xy_gauss W_gauss]=GaussQuadCircle(diameter);
	x_crack.gauss.npoints=size(xy_gauss,1);
	iparticle=1;
	
	for ipath=1:x_crack.npaths
		for itip=1:2
			if itip==1
				iparticle=1;
			elseif itip==2
				iparticle=x_crack.nparticles(ipath);
			end
			for igausspoint=1:x_crack.gauss.npoints
				for dim=1:2
					x_crack.gauss.locs(igausspoint,dim,ipath,itip)=x_crack.center(iparticle,dim,ipath)+xy_gauss(igausspoint,dim);
				end
				x_crack.gauss.weights(igausspoint,ipath,itip)=W_gauss(igausspoint);
			end
		end
	end
	x_crack.boxcalc.width=1.25*le(1);
	x_crack.boxcalc.length=1.25*le(1);
	
	iparticle1=1; %to stop coder whining
	iparticle2=1; %to stop coder whining
	
	for ipath=1:x_crack.npaths
	for itip=1:2
	if x_crack.terminatedprop(ipath,itip)==0
	if x_crack.boxcalc.active(ipath,itip)==1
		if itip==1
			iparticle1=x_crack.nparticles(ipath);
			iparticle2=x_crack.nparticles(ipath)-1;
		elseif itip==2
			iparticle1=1; %last
			iparticle2=2; %second last
		end
		x_crack.boxcalc.lastlinedeltax(1,:)=x_crack.center(iparticle1,:,ipath)-x_crack.center(iparticle2,:,ipath);
		x_crack.boxcalc.tiploc=x_crack.center(iparticle1,:,ipath);
		x_crack.boxcalc.trajectory(ipath,itip)=reliableatan(x_crack.boxcalc.lastlinedeltax(1),x_crack.boxcalc.lastlinedeltax(2));
		x_crack.boxcalc.locs(1,:,ipath,itip)=x_crack.boxcalc.tiploc+x_crack.boxcalc.width/2*[cos(x_crack.boxcalc.trajectory(ipath,itip)-pi/2) sin(x_crack.boxcalc.trajectory(ipath,itip)-pi/2)];
		x_crack.boxcalc.locs(2,:,ipath,itip)=x_crack.boxcalc.locs(1,:,ipath,itip)+x_crack.boxcalc.length*[cos(x_crack.boxcalc.trajectory(ipath,itip)) sin(x_crack.boxcalc.trajectory(ipath,itip))];
		x_crack.boxcalc.locs(3,:,ipath,itip)=x_crack.boxcalc.locs(2,:,ipath,itip)+x_crack.boxcalc.width*[cos(x_crack.boxcalc.trajectory(ipath,itip)+pi/2) sin(x_crack.boxcalc.trajectory(ipath,itip)+pi/2)];
		x_crack.boxcalc.locs(4,:,ipath,itip)=x_crack.boxcalc.locs(3,:,ipath,itip)+x_crack.boxcalc.length*[cos(x_crack.boxcalc.trajectory(ipath,itip)-pi) sin(x_crack.boxcalc.trajectory(ipath,itip)-pi)];
	end
	end
	end
	end
	
	
	%TDL define box strain evaluation here.
	
	%box strain evaluation is called boxcalc, under x_crack.boxcalc
	%% Store particles into cell
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==10 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		if CompareTexts(Version,'CPDI')
			[N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix,CONNECTpn] = Compute_Interpolator_CPDI(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
		elseif CompareTexts(Version,'MPM')
			[N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix] = Compute_Interpolator_MPM(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
		else
			fprintf('%s',['Invalid Version Input' char(10)]);
		end
	elseif CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
		if CompareTexts(Version,'CPDI')
			[N,dN,CONNECT,spElems,mspoints,NODES,CONNECTpn,~] = Compute_Interpolator_CPDI_optimized(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp,0,1);fprintf('%s',['marker #621' char(10)]);
		elseif CompareTexts(Version,'MPM')
			fprintf('%s',['Optimized MPM for patrticles not available yet! 1904122119' char(10)]);
			pause;
			1;
			%[N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix] = Compute_Interpolator_MPM(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
		else
			fprintf('%s',['Invalid Version Input! 1904122120' char(10)]);
			pause;
			1;
		end
	elseif CasetoRun==8 || CasetoRun==9
		if CompareTexts(Version,'CPDI')
			[N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix] = Compute_Interpolator_CPDI_var(spCount,cellCount,x_sp,le_c,NN,LOC,r1_sp,r2_sp,A_sp,LOCX,LOCY);
		elseif CompareTexts(Version,'MPM')
			fprintf('%s',['MPM not available for CasetoRun=' int2txt(CasetoRun) char(10)]);
		else
			fprintf('%s',['Invalid Version Input' char(10)]);
		end
	end
	
	lengthCONNECTpn=niCount;
	lengthCONNECT=spCount;
	niSizes=CONNECTpn.nrparticles;
	spSizes=zeros(1,spCount);
	for sp=1:spCount
		spSizes(sp)=length(CONNECT{sp});
	end
	numberofcrackpaths=x_crack.npaths;
	TheFieldSplitBase3_old=cell(1,niCount);
	for i=1:niCount
		TheFieldSplitBase3_old{i}=zeros(niSizes(i),numberofcrackpaths);
	end
	
	TheFieldSplitBase3=zeros(FindMaxVal(spSizes),lengthCONNECT,numberofcrackpaths);
	%{
	TheFieldSplitBase3=cell(1,lengthCONNECT);
	for sp=1:lengthCONNECT
		TheFieldSplitBase3{sp}=zeros(spSizes(sp),numberofcrackpaths);
	end
	%}
	TheFieldSplit=zeros(FindMaxVal(spSizes),lengthCONNECT);
	%line below to stop coder whining
	TheFieldSplit_boxcalc=zeros(4,4,2,numberofcrackpaths); %iro a.k.a. the relevant node number, corner number, tip number, crackpath number
	if CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		if (CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==77) && x_crack.npaths==0
			%TheFieldSplit=ones(NN(1)*NN(2),spCount); % to stop coder whining
			TheFieldSplit=cell(1,lengthCONNECT);
			for sp=1:lengthCONNECT
				TheFieldSplit{sp}=zeros(1,spSizes(sp));
			end
			fieldnumber=1;
		else
			sp_crack_count=size(x_crack.center(:,:,1),1);
			sp_cracktop_count=sp_crack_count;
			sp_crackbot_count=sp_crack_count;
			
			[N_crack,dN_crack,CONNECT_crack,spElems_crack,mspoints_crack,NODES_crack,Nmatrix_crack,dNxmatrix_crack,dNymatrix_crack,CONNECTpn_crack] = Compute_Interpolator_MPM(sp_crack_count,cellCount,x_crack.center(:,:,1),le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
			[N_cracktop,dN_cracktop,CONNECT_cracktop,spElems_cracktop,mspoints_cracktop,NODES_cracktop,Nmatrix_cracktop,dNxmatrix_cracktop,dNymatrix_cracktop,CONNECTpn_cracktop] = Compute_Interpolator_MPM(sp_cracktop_count,cellCount,x_crack.top(:,:,1),le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
			[N_crackbot,dN_crackbot,CONNECT_crackbot,spElems_crackbot,mspoints_crackbot,NODES_crackbot,Nmatrix_crackbot,dNxmatrix_crackbot,dNymatrix_crackbot,CONNECTpn_crackbot] = Compute_Interpolator_MPM(sp_crackbot_count,cellCount,x_crack.bot(:,:,1),le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
			
			[TheFieldSplit,Nmatrix,dNxmatrix,dNymatrix,Nmatrixtop,Nmatrixbot,NmatrixAll] = SplitField(spSizes,LOC,x_sp,CONNECT,CONNECTpn,x_crack.center(:,:,1),CONNECT_crack,CONNECTpn_crack,Nmatrix,dNxmatrix,dNymatrix,t_time);
		end
		
	elseif CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
		if x_crack.npaths==0;
			TheFieldSplit=ones(NN(1)*NN(2),spCount); % to stop coder whining
			fieldnumber=1;
		else
			NODES_cracktop=zeros(x_crack.npaths,spCount);
			for icrackpath=x_crack.npaths
				sp_crack_count=x_crack.nparticles(icrackpath);
				sp_cracktop_count=x_crack.nparticles(icrackpath);
				sp_crackbot_count=x_crack.nparticles(icrackpath);
				
				[N_crack{icrackpath},dN_crack{icrackpath},CONNECT_crack{icrackpath},spElems_crack{icrackpath},mspoints_crack{icrackpath},NODES_crack{icrackpath},Nmatrix_crack{icrackpath},dNxmatrix_crack{icrackpath},dNymatrix_crack{icrackpath},CONNECTpn_crack{icrackpath}] = Compute_Interpolator_MPM(sp_crack_count,cellCount,x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath),le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
				[N_cracktop{icrackpath},dN_cracktop{icrackpath},CONNECT_cracktop{icrackpath},spElems_cracktop{icrackpath},mspoints_cracktop{icrackpath},NODES_cracktop(icrackpath,1:x_crack.nparticles(icrackpath)),Nmatrix_cracktop{icrackpath},dNxmatrix_cracktop{icrackpath},dNymatrix_cracktop{icrackpath},CONNECTpn_cracktop{icrackpath}] = Compute_Interpolator_MPM(sp_cracktop_count,cellCount,x_crack.top(1:x_crack.nparticles(icrackpath),:,icrackpath),le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
				[N_crackbot{icrackpath},dN_crackbot{icrackpath},CONNECT_crackbot{icrackpath},spElems_crackbot{icrackpath},mspoints_crackbot{icrackpath},NODES_crackbot{icrackpath},Nmatrix_crackbot{icrackpath},dNxmatrix_crackbot{icrackpath},dNymatrix_crackbot{icrackpath},CONNECTpn_crackbot{icrackpath}] = Compute_Interpolator_MPM(sp_crackbot_count,cellCount,x_crack.bot(1:x_crack.nparticles(icrackpath),:,icrackpath),le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
				% please optimize later by:
				% eliminating unneccessary output variables (suspected: only Nmatrix is needed)
				% prealocating cells for variables that do matter
			end
			
			for icrackpath=x_crack.npaths:-1:1;
				%[TheFieldSplit_crack{icrackpath},Nmatrix_crack{icrackpath},dNxmatrix_crack{icrackpath},dNymatrix_crack{icrackpath},NmatrixAll_crack{icrackpath}] = SplitFieldMulti_crack(LOC,x_crackcenter{icrackpath},CONNECT_crack{icrackpath},CONNECTpn_crack{icrackpath},x_crackcenter,CONNECT_crack,CONNECTpn_crack,Nmatrix_crack{icrackpath},dNxmatrix_crack{icrackpath},dNymatrix_crack{icrackpath},t_time,icrackpath,1);
				[TheFieldSplit_cracktop{icrackpath},Nmatrix_cracktop{icrackpath},dNxmatrix_cracktop{icrackpath},dNymatrix_cracktop{icrackpath},NmatrixAll_cracktop{icrackpath}] = SplitFieldMulti_crack(LOC,x_crack.top(1:x_crack.nparticles(icrackpath),:,icrackpath),CONNECT_cracktop{icrackpath},CONNECTpn_cracktop{icrackpath},x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath),CONNECT_crack,CONNECTpn_crack,Nmatrix_cracktop{icrackpath},dNxmatrix_cracktop{icrackpath},dNymatrix_cracktop{icrackpath},t_time,icrackpath,2);
				[TheFieldSplit_crackbot{icrackpath},Nmatrix_crackbot{icrackpath},dNxmatrix_crackbot{icrackpath},dNymatrix_crackbot{icrackpath},NmatrixAll_crackbot{icrackpath}] = SplitFieldMulti_crack(LOC,x_crack.bot(1:x_crack.nparticles(icrackpath),:,icrackpath),CONNECT_crackbot{icrackpath},CONNECTpn_crackbot{icrackpath},x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath),CONNECT_crack,CONNECTpn_crack,Nmatrix_crackbot{icrackpath},dNxmatrix_crackbot{icrackpath},dNymatrix_crackbot{icrackpath},t_time,icrackpath,3);
				
			end
			icrackpath_outloop=1;
			[TheFieldSplit,Nmatrix,dNxmatrix,dNymatrix,NmatrixAll] = SplitFieldMulti(spSizes,LOC,x_sp,CONNECT,CONNECTpn,x_crack.center(1:x_crack.nparticles(icrackpath_outloop),:,icrackpath_outloop),CONNECT_crack,CONNECTpn_crack,Nmatrix,dNxmatrix,dNymatrix,t_time);
		end
	elseif CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
		fprintf('%s',['marker #622' char(10)]);
		x_crack_length=x_crack.npaths;fprintf('%s',['marker #801' char(10)]);
		%x_crack_nulled=coder.nullcopy(x_crackcenter);
		nCrackParticle=zeros(1,x_crack_length);fprintf('%s',['marker #802' char(10)]);
		for i=1:x_crack_length
			nCrackParticle(i)=x_crack.nparticles(i);
		end
		%x_cracktop_nulled=coder.nullcopy(x_cracktop);
		
		%additional for troubleshooting
		[N_crack,dN_crack,CONNECT_crack,spElems_crack,NODES_crack,CONNECTpn_crack]=Compute_Interpolator_MPM_CrackParticleNoCell(t_time,x_crack,le,NN,LOC);fprintf('%s',['marker #623' char(10)]);
		%[N_crack,dN_crack,CONNECT_crack,spElems_crack,NODES_crack,CONNECTpn_crack]=Compute_Interpolator_MPM_CrackParticleNoCell(x_crack,le,NN,LOC);fprintf('%s',['marker #623' char(10)]);
		
		
		TheFieldSplitBase3_cracktop_sp=cell(1,x_crack_length);
		for i=1:x_crack_length
			TheFieldSplitBase3_cracktop_sp{i}=zeros(4,x_crack.nparticles(i),x_crack_length);
		end
		TheFieldSplitBase3_crackbot_sp=cell(1,x_crack_length);
		for i=1:x_crack_length
			TheFieldSplitBase3_crackbot_sp{i}=zeros(4,x_crack.nparticles(i),x_crack_length);
		end
		TheFieldSplitBase3_boxcalc=zeros(x_crack_length,4,4,2,x_crack_length); %trinary digits (length the same as number of paths aka x_crack_length), io_natural, which corner point, which tip, which path (aka ipath);
		TheFieldSplit_cracktop=cell(1,x_crack_length);
		for i=1:x_crack_length
			TheFieldSplit_cracktop{i}=zeros(4,x_crack.nparticles(i));
		end
		
		TheFieldSplit_crackbot=cell(1,x_crack_length);
		for i=1:x_crack_length
			TheFieldSplit_crackbot{i}=zeros(4,x_crack.nparticles(i));
		end
		
		
		%{
		for icrackpath=1:x_crack_length
			sp_crack_count=x_crack.nparticles(icrackpath);
			sp_cracktop_count=x_crack.nparticles(icrackpath);
			sp_crackbot_count=x_crack.nparticles(icrackpath);
			
			%[N_crack{icrackpath},dN_crack{icrackpath},CONNECT_crack{icrackpath},spElems_crack{icrackpath},mspoints_crack{icrackpath},NODES_crack{icrackpath},Nmatrix_crack{icrackpath},CONNECTpn_crack{icrackpath}] = Compute_Interpolator_MPM_optimized(sp_crack_count,cellCount,x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath),le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
			
			[N_cracktop{icrackpath},dN_cracktop{icrackpath},CONNECT_cracktop{icrackpath},spElems_cracktop{icrackpath},mspoints_cracktop{icrackpath},NODES_cracktop(icrackpath,:),Nmatrix_cracktop{icrackpath},CONNECTpn_cracktop{icrackpath}] = Compute_Interpolator_MPM_optimized(sp_cracktop_count,cellCount,x_crack.top(1:x_crack.nparticles(icrackpath),:,icrackpath),le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
			[N_crackbot{icrackpath},dN_crackbot{icrackpath},CONNECT_crackbot{icrackpath},spElems_crackbot{icrackpath},mspoints_crackbot{icrackpath},NODES_crackbot{icrackpath},Nmatrix_crackbot{icrackpath},CONNECTpn_crackbot{icrackpath}] = Compute_Interpolator_MPM_optimized(sp_crackbot_count,cellCount,x_crack.bot(1:x_crack.nparticles(icrackpath),:,icrackpath),le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
			
			% please optimize later by:
			% eliminating unneccessary output variables (suspected: only Nmatrix is needed)
			% prealocating cells for variables that do matter
		end
		%}
		fprintf('%s',['marker #624' char(10)]);
		if x_crack_length==0;
			%TheFieldSplit=ones(NN(1)*NN(2),spCount); % to stop coder whining
			TheFieldSplit=zeros(FindMaxVal(spSizes),lengthCONNECT);
			TheFieldSplit=ones(FindMaxVal(spSizes),lengthCONNECT);
			fieldnumber=1;
		else
			%TDL new splitfield for boxcalc here
			for icrackpath2=1:x_crack_length
				[TheFieldSplitBase3_cracktop_sp{icrackpath2}] = SplitFieldMulti_crackoptimized2_nocell(LOC,x_crack.top(1:x_crack.nparticles(icrackpath2),:,icrackpath2),CONNECT_crack.top,CONNECTpn_crack.top,x_crack,icrackpath2,2,le);
				[TheFieldSplitBase3_crackbot_sp{icrackpath2}] = SplitFieldMulti_crackoptimized2_nocell(LOC,x_crack.bot(1:x_crack.nparticles(icrackpath2),:,icrackpath2),CONNECT_crack.bot,CONNECTpn_crack.bot,x_crack,icrackpath2,3,le);
			end
			fprintf('%s',['marker #625' char(10)]);
			[TheFieldSplitBase3_old,TheFieldSplitBase3_sp,spSizes] = SplitFieldMultiOptimized2(LOC,x_sp,CONNECT,CONNECTpn,x_crack,t_time,le);
			[TheFieldSplitBase3_sp_boxcalc] = SplitFieldMultiOptimized2_boxcalc(LOC,CONNECT_crack.boxcalc,CONNECTpn_crack.boxcalc,x_crack,t_time,le);
			fprintf('%s',['marker #626' char(10)]);
			%shit up there
			ncrackpath=x_crack_length;
			maplist=zeros(1000,ncrackpath);
			maplistsize=1;
			coder.varsize('maplist');
			maplist(1,:)=ones(1,ncrackpath);
			%[TheFieldSplit,maplist,maplistsize]=Base3Mapping(TheFieldSplitBase3_old,CONNECTpn,maplist,maplistsize,spCount);
			[TheFieldSplit,maplist,maplistsize]=Base3Mapping_sp(TheFieldSplitBase3_sp,CONNECT,maplist,maplistsize,niCount);fprintf('%s',['marker #627' char(10)]);
			for icrackpath=1:ncrackpath
				[TheFieldSplit_cracktop{icrackpath},maplist,maplistsize]=Base3Mapping_crack(TheFieldSplitBase3_cracktop_sp{icrackpath},CONNECTpn_crack.top.values(:,:,icrackpath),CONNECT_crack.top.values(:,:,icrackpath),CONNECT_crack.top.nrnodes(icrackpath,:),maplist,maplistsize);
				[TheFieldSplit_crackbot{icrackpath},maplist,maplistsize]=Base3Mapping_crack(TheFieldSplitBase3_crackbot_sp{icrackpath},CONNECTpn_crack.bot.values(:,:,icrackpath),CONNECT_crack.bot.values(:,:,icrackpath),CONNECT_crack.bot.nrnodes(icrackpath,:),maplist,maplistsize);
			end
			
			[TheFieldSplit_boxcalc,maplist,maplistsize]=Base3Mapping_sp_boxcalc(TheFieldSplitBase3_sp_boxcalc,x_crack.boxcalc.active,CONNECT_crack.boxcalc,maplist,maplistsize);fprintf('%s',['marker #627' char(10)]);
			%fieldnumber=size(maplist,1);
			fieldnumber=maplistsize;fprintf('%s',['marker #628' char(10)]);
			%TDL new splitfield boxcalc testrun here
			
			%TDL plot boxes here!
			%{
			plot(x_sp(:,1),x_sp(:,2),'o');
			hold on;
			grid on;
			axis([1.6,5.4,1.6,5.4]*200);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
			for ipath=2:x_crack.npaths
				plot(x_crack.center(1:x_crack.nparticles(ipath),1,ipath),x_crack.center(1:x_crack.nparticles(ipath),2,ipath));
				for itip=1:2
				if x_crack.terminatedprop(ipath,itip)==0
				if x_crack.boxcalc.active(ipath,itip)==1
					plot(x_crack.boxcalc.locs(:,1,ipath,itip),x_crack.boxcalc.locs(:,2,ipath,itip));
				end
				end
				end
			end
			asdf(-pi);
			%}
			%{
			UniqueFieldSplit=unique(TheFieldSplit);
			for icrackpath=1:length(x_crackcenter)
				UniqueFieldSplit=[UniqueFieldSplit;unique(TheFieldSplit_cracktop{icrackpath})];
				UniqueFieldSplit=[UniqueFieldSplit;unique(TheFieldSplit_crackbot{icrackpath})];
			end
			UniqueFieldSplit=unique(UniqueFieldSplit);
			for i=1:size(TheFieldSplit,1)
				for sp_inloop=1:size(TheFieldSplit,2)
					TheFieldSplit(i,sp_inloop)=integermapping(TheFieldSplit(i,sp_inloop),UniqueFieldSplit);
				end
			end
			for icrackpath=1:length(x_crackcenter)
				for i=1:size(TheFieldSplit_cracktop{icrackpath},1)
					for sp_inloop=1:size(TheFieldSplit_cracktop{icrackpath},2)
						TheFieldSplit_cracktop{icrackpath}(i,sp_inloop)=integermapping(TheFieldSplit_cracktop{icrackpath}(i,sp_inloop),UniqueFieldSplit);
						TheFieldSplit_crackbot{icrackpath}(i,sp_inloop)=integermapping(TheFieldSplit_crackbot{icrackpath}(i,sp_inloop),UniqueFieldSplit);
					end
				end
			end
			fieldnumber=length(UniqueFieldSplit);
			%}
			%{
			ncrackpath=size(TheFieldSplitBase3_old,3);
			maplistcounter=1;
			maplist(1,1,:)=ones(1,1,ncrackpath);
			TheFieldSplit=ones(size(TheFieldSplitBase3_old,1),size(TheFieldSplitBase3_old,2));
			for i=1:size(CONNECTpn,1)
				CONNECTpnLength=0;
				for j=1:size(CONNECTpn,2);
					if CONNECTpn(i,j)>0
						CONNECTpnLength=CONNECTpnLength+1;
					else
						break;
					end
				end
				for nsp=1:CONNECTpnLength
					sp=CONNECTpn(i,nsp);
					matchfound=0;
					for imaplist=1:size(maplist,1);
						if sum(maplist(imaplist,1,:)==TheFieldSplitBase3_old(i,sp,:))==ncrackpath;
							matchfound=1;
							TheFieldSplit(i,sp)=imaplist;
							break;
						end
					end
					if matchfound==0
						TheFieldSplit(i,sp)=size(maplist,1)+1;
						maplist(size(maplist,1)+1,1,:)=TheFieldSplitBase3_old(i,sp,:);
					end
				end
			end
			%}
		end
	else
		%TheFieldSplit=ones(NN(1)*NN(2),spCount); % to stop coder whining
		TheFieldSplit=cell(1,lengthCONNECT);
		for sp_inloop=1:lengthCONNECT
			TheFieldSplit{sp_inloop}=zeros(1,spSizes(sp_inloop));
		end
		fieldnumber=1;
	end
	%nodal preallocation
	force_si_loading=zeros(niCount,2,fieldnumber);
	s_si=zeros(niCount,3,fieldnumber);
	s_si_comb=zeros(niCount,3);
	LW_si_comb=zeros(niCount,1);
	EW_si_comb=zeros(niCount,1);

	s_si_K1=zeros(niCount,3);

	u_si=zeros(niCount,2,fieldnumber);
	v_si=zeros(niCount,2,fieldnumber);
	x_si=zeros(niCount,2,fieldnumber);
	x0_si=zeros(niCount,2,fieldnumber);
	niforce_si_spring=zeros(niCount,2,fieldnumber);
	
	u_si_comb=zeros(niCount,2);
	uncrackable_si=zeros(niCount,fieldnumber);
	k_si=zeros(niCount,fieldnumber);
	weakeningfactor_si=zeros(niCount,fieldnumber);
	deltarideal_si=zeros(niCount,fieldnumber);
	deltaractual_si=zeros(niCount,fieldnumber);
	shrinkage_si=zeros(2,2,niCount,fieldnumber);
	shrinkage_si_comb=zeros(2,2,niCount);
	
	%TDL spCount variable declarations in generic_solver
	edot_sp=zeros(spCount,3);
	%Ktangent_local=zeros(6,6,spCount); %no need for this now, it's in the i/o of the generic_solver function
	
	% N: Shape function
	% dN: Gradient of shape function
	% spElems(p): element index where "p" locates
	% mspoints(e): all particles indexes where locate in the cell "e"
	% CONNECT{sp}: list of node numbers connected to particle sp
	% CONNECTpn(i,nsp): list of particle numbers connected to node i
	
	%numberofparticleswithpredeterminedvelocities=length(particleswithpredeterminedvelocities);
	
	%% Mapping from particle to nodes
	%pforce_sp               = [0*ones(spCount,1) 0*ones(spCount,1)];
	%for i=1:numberofparticleswithpredeterminedvelocities  
	%	pforce_sp(particleswithpredeterminedvelocities(i),:)=[100000 0];
	%end
	%{
	for i=1:numberofparticleswithpredeterminedvelocities
		for j=1:2
			v_ssp(particleswithpredeterminedvelocities(i),j)=predeterminedvelocityvalue(i,j);
		end
	end
	%}
	%pforce_sp_boundaryonly
	%v_ssp_out_boundaryonly
	%deltav_ssp
	%calculation of x_crack.force
	
	if CasetoRun==-1
		x_crack.force.top=zeros(200,2,200);
		x_crack.force.bot=zeros(200,2,200);
		x_crack.bridge.firsttimeactive=zeros(200,200);
		for ipath=1:x_crack.npaths
		if x_crack.cohesivepath(ipath)==1
			for iparticle=1:x_crack.nparticles(ipath)
			if x_crack.cohesivepoint(iparticle,ipath)==1
			if iparticle>1 && iparticle<x_crack.nparticles(ipath)
				if x_crack.bridge.isactive(iparticle,ipath)==0
					x_crack.bridge.isactive(iparticle,ipath)=1;
					x_crack.bridge.firsttimeactive(iparticle,ipath)=1;
					for idim=1:2
						x_crack.bridge.firsttimedeltax(iparticle,idim,ipath)=(x_crack.bot(iparticle,idim,ipath)-x_crack.top(iparticle,idim,ipath));
					end
					x_crack.bridge.absfirsttimedeltax(iparticle,ipath)=sqrt(dot(x_crack.bridge.firsttimedeltax(iparticle,:,ipath),x_crack.bridge.firsttimedeltax(iparticle,:,ipath)));
					if x_crack.bridge.absfirsttimedeltax(iparticle,ipath)==0
						x_crack.bridge.kbase2(iparticle,ipath)=1e99;
					else
						x_crack.bridge.kbase2(iparticle,ipath)=x_crack.bridge.yieldforce1/x_crack.bridge.absfirsttimedeltax(iparticle,ipath);
					end
				end
			end
			end
			end
		end
		end
		for ipath=1:x_crack.npaths
			for iparticle=1:x_crack.nparticles(ipath)
				if ipath==2 && iparticle==2
					1;
				end
				for idim=1:2
					x_crack.bridge.base.deltax(iparticle,idim,ipath)=(x_crack.bot(iparticle,idim,ipath)-x_crack.top(iparticle,idim,ipath));
					x_crack.bridge.adjusted.deltax(iparticle,idim,ipath)=x_crack.bridge.base.deltax(iparticle,idim,ipath)-x_crack.bridge.firsttimedeltax(iparticle,idim,ipath);
				end
				x_crack.bridge.base.absdeltax(iparticle,ipath)=sqrt(dot(x_crack.bridge.base.deltax(iparticle,:,ipath),x_crack.bridge.base.deltax(iparticle,:,ipath)));
				
				if x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)>0
					x_crack.bridge.adjusted.absdeltaxbefore(iparticle,ipath)=x_crack.bridge.adjusted.absdeltax(iparticle,ipath);
				end
				
				x_crack.bridge.adjusted.absdeltax(iparticle,ipath)=sqrt(dot(x_crack.bridge.adjusted.deltax(iparticle,:,ipath),x_crack.bridge.adjusted.deltax(iparticle,:,ipath)));
				if x_crack.bridge.base.absdeltax(iparticle,ipath)>x_crack.bridge.base.absdeltaxmax(iparticle,ipath)
					x_crack.bridge.base.absdeltaxmax(iparticle,ipath)=x_crack.bridge.base.absdeltax(iparticle,ipath);
				end
				if x_crack.bridge.isactive(iparticle,ipath)
				if x_crack.bridge.adjusted.absdeltax(iparticle,ipath)>x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)
					x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)=x_crack.bridge.adjusted.absdeltax(iparticle,ipath);
					deltay=x_crack.bridge.yieldforce1/x_crack.bridge.kbase1; %no use whatsoever
					x_crack.bridge.adjusted.absdeltaxmaxi(iparticle,ipath)=max(0,x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)-deltay); %no use whatsoever
				end
				end
			end
		end
		x_crack.bridge.allsevered=1;
		x_crack.bridge.mostsevered=1;
		for ipath=1:x_crack.npaths
		if x_crack.cohesivepath(ipath)==1
			for iparticle=1:x_crack.nparticles(ipath)
			if x_crack.cohesivepoint(iparticle,ipath)==1
			if iparticle>1 && iparticle<x_crack.nparticles(ipath);
				deltay=x_crack.bridge.yieldforce1/x_crack.bridge.kbase2(iparticle,ipath);
				if x_crack.bridge.base.absdeltaxmax(iparticle,ipath)<=deltay
					k_t=x_crack.bridge.kbase2(iparticle,ipath); %current stiffness value
				elseif x_crack.bridge.base.absdeltaxmax(iparticle,ipath)<deltay+x_crack.bridge.deltai1
					maxforce=x_crack.bridge.yieldforce1*(1-(x_crack.bridge.base.absdeltaxmax(iparticle,ipath)-deltay)/x_crack.bridge.deltai1);
					k_t=maxforce/x_crack.bridge.base.absdeltaxmax(iparticle,ipath);
				else
					maxforce=0;
					k_t=0;
				end
				x_crack.bridge.absforcebefore(iparticle,ipath)=x_crack.bridge.absforce(iparticle,ipath);
				x_crack.bridge.absforce(iparticle,ipath)=k_t*x_crack.bridge.base.absdeltax(iparticle,ipath);
				
				%"cheat" dissipation below adjusted
				if x_crack.bridge.absforce(iparticle,ipath)>0
					1;
				end
				x_crack.bridge.storedanddissed.d=(x_crack.bridge.absforce(iparticle,ipath)+x_crack.bridge.absforcebefore(iparticle,ipath))/2*(x_crack.bridge.adjusted.absdeltax(iparticle,ipath)-x_crack.bridge.adjusted.absdeltaxbefore(iparticle,ipath));
				x_crack.bridge.storedanddissed.value=x_crack.bridge.storedanddissed.value+x_crack.bridge.storedanddissed.d;
				
				
				x_crack.bridge.pathcompletemonitor.check=0;
				for icheck=1:x_crack.bridge.pathcompletemonitor.size
					if ipath==x_crack.bridge.pathcompletemonitor.values(icheck)
						x_crack.bridge.pathcompletemonitor.check=1;
						break;
					end
				end
				if x_crack.bridge.tt_first.value==0 && x_crack.bridge.absforce(iparticle,ipath)>0
					if x_crack.bridge.pathcompletemonitor.check
						x_crack.bridge.tt_first.value=tt;
						x_crack.bridge.tt_first.savetoken=1;
					end
				end
				if x_crack.bridge.allsevered==1 && x_crack.bridge.tt_first.value~=0
					if x_crack.bridge.pathcompletemonitor.check
						if x_crack.bridge.absforce(iparticle,ipath)>0
							x_crack.bridge.allsevered=0;
						end
					end
				end
				if x_crack.bridge.mostsevered==1 && x_crack.bridge.tt_first.value~=0 && (iparticle<=3 || iparticle>=x_crack.nparticles(ipath)-3)
					if x_crack.bridge.pathcompletemonitor.check
						if x_crack.bridge.absforce(iparticle,ipath)>0
							x_crack.bridge.mostsevered=0;
						end
					end
				end
				
				for idim=1:2
					if x_crack.bridge.base.absdeltax(iparticle,ipath)>0
						x_crack.force.top(iparticle,idim,ipath)=x_crack.bridge.base.deltax(iparticle,idim,ipath)/x_crack.bridge.base.absdeltax(iparticle,ipath)*x_crack.bridge.absforce(iparticle,ipath);
						x_crack.force.bot(iparticle,idim,ipath)=-x_crack.force.top(iparticle,idim,ipath);
					else
						x_crack.force.top(iparticle,idim,ipath)=0;
						x_crack.force.bot(iparticle,idim,ipath)=0;
					end
				end
			end
			end
			end
		end
		end
		%if x_crack.bridge.allsevered==1 && x_crack.bridge.tt_first.value~=0 && x_crack.bridge.tt_last.value==0;
		if x_crack.bridge.mostsevered==1 && x_crack.bridge.tt_first.value~=0 && x_crack.bridge.tt_last.value==0;
			x_crack.bridge.tt_last.value=tt;
			x_crack.bridge.tt_last.savetoken=1;
		end
	elseif CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==212 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228
		%TDL cohesive force calculation for 200
		%TDL cohesive force calculation for 226
		tempweakening=1; %weakening of cohesive force due to elevated temperature
		1;
		x_crack.force.top=zeros(200,2,200);
		x_crack.force.bot=zeros(200,2,200);
		x_crack.bridge.firsttimeactive=zeros(200,200);
		for ipath=1:x_crack.npaths
		if x_crack.cohesivepath(ipath)==1
			for iparticle=1:x_crack.nparticles(ipath)
				if ipath==2 && iparticle==2
					%TDL cohesive investigation debug
					if sqrt(dot(x_crack.bot(iparticle,:,ipath)-x_crack.top(iparticle,:,ipath),x_crack.bot(iparticle,:,ipath)-x_crack.top(iparticle,:,ipath)))>0
						1;
					end
				end
				if x_crack.cohesivepoint(iparticle,ipath)==1
				if iparticle>1 && iparticle<x_crack.nparticles(ipath)
					if x_crack.bridge.isactive(iparticle,ipath)==0
						x_crack.bridge.isactive(iparticle,ipath)=1;
						x_crack.bridge.firsttimeactive(iparticle,ipath)=1;
						for idim=1:2
							%x_crack.bridge.firsttimedeltax(iparticle,idim,ipath)=(x_crack.bot(iparticle,idim,ipath)-x_crack.top(iparticle,idim,ipath))*0.99;
							x_crack.bridge.firsttimedeltax(iparticle,idim,ipath)=(x_crack.bot(iparticle,idim,ipath)-x_crack.top(iparticle,idim,ipath))*1;
						end
					end
				end
				end
			end
		end
		end
		for ipath=1:x_crack.npaths
			for iparticle=1:x_crack.nparticles(ipath)
				if ipath==2 && iparticle==3
					if sqrt(dot(x_crack.bot(iparticle,:,ipath)-x_crack.top(iparticle,:,ipath),x_crack.bot(iparticle,:,ipath)-x_crack.top(iparticle,:,ipath)))>0
						if x_crack.nparticles(2)>3
							1;
						end
					end
				end
				for idim=1:2
					x_crack.bridge.base.deltax(iparticle,idim,ipath)=(x_crack.bot(iparticle,idim,ipath)-x_crack.top(iparticle,idim,ipath));
					x_crack.bridge.adjusted.deltax(iparticle,idim,ipath)=x_crack.bridge.base.deltax(iparticle,idim,ipath)-x_crack.bridge.firsttimedeltax(iparticle,idim,ipath);
				end
				x_crack.bridge.base.absdeltax(iparticle,ipath)=sqrt(dot(x_crack.bridge.base.deltax(iparticle,:,ipath),x_crack.bridge.base.deltax(iparticle,:,ipath)));
				
				if x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)>0
					x_crack.bridge.adjusted.absdeltaxbefore(iparticle,ipath)=x_crack.bridge.adjusted.absdeltax(iparticle,ipath);
				end
				
				x_crack.bridge.adjusted.absdeltax(iparticle,ipath)=sqrt(dot(x_crack.bridge.adjusted.deltax(iparticle,:,ipath),x_crack.bridge.adjusted.deltax(iparticle,:,ipath)));
				if x_crack.bridge.base.absdeltax(iparticle,ipath)>x_crack.bridge.base.absdeltaxmax(iparticle,ipath)
					x_crack.bridge.base.absdeltaxmax(iparticle,ipath)=x_crack.bridge.base.absdeltax(iparticle,ipath);
				end
				if x_crack.bridge.isactive(iparticle,ipath)
				if x_crack.bridge.adjusted.absdeltax(iparticle,ipath)>x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)
					x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)=x_crack.bridge.adjusted.absdeltax(iparticle,ipath);
					deltay=x_crack.bridge.yieldforce1/x_crack.bridge.kbase1;
					x_crack.bridge.adjusted.absdeltaxmaxi(iparticle,ipath)=max(0,x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)-deltay);
				end
				end
			end
		end
		x_crack.bridge.allsevered=1;
		x_crack.bridge.mostsevered=1;
		for ipath=1:x_crack.npaths
		if x_crack.cohesivepath(ipath)==1
			for iparticle=1:x_crack.nparticles(ipath)
				if ipath==2 && iparticle==3
					if sqrt(dot(x_crack.bot(iparticle,:,ipath)-x_crack.top(iparticle,:,ipath),x_crack.bot(iparticle,:,ipath)-x_crack.top(iparticle,:,ipath)))>0
						if x_crack.nparticles(2)>3
							%TDL breakpoint for force test
							1;
						end
					end
				end
			if x_crack.cohesivepoint(iparticle,ipath)==1
			if iparticle>1 && iparticle<x_crack.nparticles(ipath);
				deltay=x_crack.bridge.deltae2(iparticle,ipath);
				if x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)<deltay
					k_t=x_crack.bridge.yieldforce2(iparticle,ipath)/x_crack.bridge.deltae2(iparticle,ipath); %current stiffness value
				elseif x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)<deltay+x_crack.bridge.deltai2(iparticle,ipath)
					maxforce=x_crack.bridge.yieldforce2(iparticle,ipath)*(1-(x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)-deltay)/x_crack.bridge.deltai2(iparticle,ipath));
					k_t=maxforce/x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath);
				else
					maxforce=0;
					k_t=0;
				end
				x_crack.bridge.completeratio(iparticle,ipath)=x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)/(deltay+x_crack.bridge.deltai2(iparticle,ipath));
				x_crack.bridge.absforcebefore(iparticle,ipath)=x_crack.bridge.absforce(iparticle,ipath);
				x_crack.bridge.absforce(iparticle,ipath)=k_t*x_crack.bridge.adjusted.absdeltax(iparticle,ipath);
				if tempweakening==1
					abstemp=x_crack.deltatemp(iparticle,ipath)+temp0
					weakeningfactor=min(1,max(0.1,1-(abstemp-temp0)/(300-temp0)))
					x_crack.bridge.absforce(iparticle,ipath)=x_crack.bridge.absforce(iparticle,ipath)*weakeningfactor
				end
				
				%"cheat" dissipation below
				if x_crack.bridge.absforce(iparticle,ipath)>0
					1;
				end
				x_crack.bridge.storedanddissed.d=(x_crack.bridge.absforce(iparticle,ipath)+x_crack.bridge.absforcebefore(iparticle,ipath))/2*(x_crack.bridge.adjusted.absdeltax(iparticle,ipath)-x_crack.bridge.adjusted.absdeltaxbefore(iparticle,ipath));
				x_crack.bridge.storedanddissed.value=x_crack.bridge.storedanddissed.value+x_crack.bridge.storedanddissed.d;
				
				
				x_crack.bridge.pathcompletemonitor.check=0;
				for icheck=1:x_crack.bridge.pathcompletemonitor.size
					if ipath==x_crack.bridge.pathcompletemonitor.values(icheck)
						x_crack.bridge.pathcompletemonitor.check=1;
						break;
					end
				end
				if x_crack.bridge.tt_first.value==0 && x_crack.bridge.absforce(iparticle,ipath)>0
					if x_crack.bridge.pathcompletemonitor.check
						x_crack.bridge.tt_first.value=tt;
						x_crack.bridge.tt_first.savetoken=1;
					end
				end
				if x_crack.bridge.allsevered==1 && x_crack.bridge.tt_first.value~=0
					if x_crack.bridge.pathcompletemonitor.check
						if x_crack.bridge.absforce(iparticle,ipath)>0
							x_crack.bridge.allsevered=0;
						end
					end
				end
				if x_crack.bridge.mostsevered==1 && x_crack.bridge.tt_first.value~=0 && (iparticle<=3 || iparticle>=x_crack.nparticles(ipath)-3)
					if x_crack.bridge.pathcompletemonitor.check
						if x_crack.bridge.absforce(iparticle,ipath)>0
							x_crack.bridge.mostsevered=0;
						end
					end
				end
				
				for idim=1:2
					if x_crack.bridge.adjusted.absdeltax(iparticle,ipath)>0
						x_crack.force.top(iparticle,idim,ipath)=x_crack.bridge.adjusted.deltax(iparticle,idim,ipath)/x_crack.bridge.adjusted.absdeltax(iparticle,ipath)*x_crack.bridge.absforce(iparticle,ipath);
						x_crack.force.bot(iparticle,idim,ipath)=-x_crack.force.top(iparticle,idim,ipath);
					else
						x_crack.force.top(iparticle,idim,ipath)=0;
						x_crack.force.bot(iparticle,idim,ipath)=0;
					end
				end
			end
			end
			end
		end
		end
		%if x_crack.bridge.allsevered==1 && x_crack.bridge.tt_first.value~=0 && x_crack.bridge.tt_last.value==0;
		if x_crack.bridge.mostsevered==1 && x_crack.bridge.tt_first.value~=0 && x_crack.bridge.tt_last.value==0;
			x_crack.bridge.tt_last.value=tt;
			x_crack.bridge.tt_last.savetoken=1;
		end
	%TDL switch 217 and 228 cohesive cases
	elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218
		x_crack.force.top=zeros(200,2,200);
		x_crack.force.bot=zeros(200,2,200);
		x_crack.bridge.firsttimeactive=zeros(200,200);
		for ipath=1:x_crack.npaths
		if x_crack.cohesivepath(ipath)==1
			for iparticle=1:x_crack.nparticles(ipath)
				if ipath==2 && iparticle==2
					1;
				end
			if x_crack.cohesivepoint(iparticle,ipath)==1
			if iparticle>1 && iparticle<x_crack.nparticles(ipath)
				if x_crack.bridge.isactive(iparticle,ipath)==0
					x_crack.bridge.isactive(iparticle,ipath)=1;
					x_crack.bridge.firsttimeactive(iparticle,ipath)=1;
					for idim=1:2
						%x_crack.bridge.firsttimedeltax(iparticle,idim,ipath)=(x_crack.bot(iparticle,idim,ipath)-x_crack.top(iparticle,idim,ipath))*0.99;
						x_crack.bridge.firsttimedeltax(iparticle,idim,ipath)=(x_crack.bot(iparticle,idim,ipath)-x_crack.top(iparticle,idim,ipath))*1;
					end
				end
			end
			end
			end
		end
		end
		for ipath=1:x_crack.npaths
			for iparticle=1:x_crack.nparticles(ipath)
				if ipath==2 && iparticle==2
					1;
				end
				for idim=1:2
					x_crack.bridge.base.deltax(iparticle,idim,ipath)=(x_crack.bot(iparticle,idim,ipath)-x_crack.top(iparticle,idim,ipath));
					x_crack.bridge.adjusted.deltax(iparticle,idim,ipath)=x_crack.bridge.base.deltax(iparticle,idim,ipath)-x_crack.bridge.firsttimedeltax(iparticle,idim,ipath);
				end
				x_crack.bridge.base.absdeltax(iparticle,ipath)=sqrt(dot(x_crack.bridge.base.deltax(iparticle,:,ipath),x_crack.bridge.base.deltax(iparticle,:,ipath)));
				
				if x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)>0
					x_crack.bridge.adjusted.absdeltaxbefore(iparticle,ipath)=x_crack.bridge.adjusted.absdeltax(iparticle,ipath);
				end
				
				x_crack.bridge.adjusted.absdeltax(iparticle,ipath)=sqrt(dot(x_crack.bridge.adjusted.deltax(iparticle,:,ipath),x_crack.bridge.adjusted.deltax(iparticle,:,ipath)));
				if x_crack.bridge.base.absdeltax(iparticle,ipath)>x_crack.bridge.base.absdeltaxmax(iparticle,ipath)
					x_crack.bridge.base.absdeltaxmax(iparticle,ipath)=x_crack.bridge.base.absdeltax(iparticle,ipath);
				end
				if x_crack.bridge.isactive(iparticle,ipath)
				if x_crack.bridge.adjusted.absdeltax(iparticle,ipath)>x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)
					x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)=x_crack.bridge.adjusted.absdeltax(iparticle,ipath);
					deltay=x_crack.bridge.yieldforce1/x_crack.bridge.kbase1;
					x_crack.bridge.adjusted.absdeltaxmaxi(iparticle,ipath)=max(0,x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)-deltay);
				end
				end
			end
		end
		x_crack.bridge.allsevered=1;
		x_crack.bridge.mostsevered=1;
		for ipath=1:x_crack.npaths
		if x_crack.cohesivepath(ipath)==1
			for iparticle=1:x_crack.nparticles(ipath)
			if x_crack.cohesivepoint(iparticle,ipath)==1
			if iparticle>1 && iparticle<x_crack.nparticles(ipath);
				deltay=x_crack.bridge.yieldforce1/x_crack.bridge.kbase1;
				if x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)<deltay
					k_t=x_crack.bridge.kbase1; %current stiffness value
				elseif x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)<deltay+x_crack.bridge.deltai1
					maxforce=x_crack.bridge.yieldforce1*(1-(x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath)-deltay)/x_crack.bridge.deltai1);
					k_t=maxforce/x_crack.bridge.adjusted.absdeltaxmax(iparticle,ipath);
				else
					maxforce=0;
					k_t=0;
				end
				x_crack.bridge.absforcebefore(iparticle,ipath)=x_crack.bridge.absforce(iparticle,ipath);
				x_crack.bridge.absforce(iparticle,ipath)=k_t*x_crack.bridge.adjusted.absdeltax(iparticle,ipath);
				
				%"cheat" dissipation below
				if x_crack.bridge.absforce(iparticle,ipath)>0
					1;
				end
				x_crack.bridge.storedanddissed.d=(x_crack.bridge.absforce(iparticle,ipath)+x_crack.bridge.absforcebefore(iparticle,ipath))/2*(x_crack.bridge.adjusted.absdeltax(iparticle,ipath)-x_crack.bridge.adjusted.absdeltaxbefore(iparticle,ipath));
				x_crack.bridge.storedanddissed.value=x_crack.bridge.storedanddissed.value+x_crack.bridge.storedanddissed.d;
				
				
				x_crack.bridge.pathcompletemonitor.check=0;
				for icheck=1:x_crack.bridge.pathcompletemonitor.size
					if ipath==x_crack.bridge.pathcompletemonitor.values(icheck)
						x_crack.bridge.pathcompletemonitor.check=1;
						break;
					end
				end
				if x_crack.bridge.tt_first.value==0 && x_crack.bridge.absforce(iparticle,ipath)>0
					if x_crack.bridge.pathcompletemonitor.check
						x_crack.bridge.tt_first.value=tt;
						x_crack.bridge.tt_first.savetoken=1;
					end
				end
				if x_crack.bridge.allsevered==1 && x_crack.bridge.tt_first.value~=0
					if x_crack.bridge.pathcompletemonitor.check
						if x_crack.bridge.absforce(iparticle,ipath)>0
							x_crack.bridge.allsevered=0;
						end
					end
				end
				if x_crack.bridge.mostsevered==1 && x_crack.bridge.tt_first.value~=0 && (iparticle<=3 || iparticle>=x_crack.nparticles(ipath)-3)
					if x_crack.bridge.pathcompletemonitor.check
						if x_crack.bridge.absforce(iparticle,ipath)>0
							x_crack.bridge.mostsevered=0;
						end
					end
				end
				
				for idim=1:2
					if x_crack.bridge.adjusted.absdeltax(iparticle,ipath)>0
						x_crack.force.top(iparticle,idim,ipath)=x_crack.bridge.adjusted.deltax(iparticle,idim,ipath)/x_crack.bridge.adjusted.absdeltax(iparticle,ipath)*x_crack.bridge.absforce(iparticle,ipath);
						x_crack.force.bot(iparticle,idim,ipath)=-x_crack.force.top(iparticle,idim,ipath);
					else
						x_crack.force.top(iparticle,idim,ipath)=0;
						x_crack.force.bot(iparticle,idim,ipath)=0;
					end
				end
			end
			end
			end
		end
		end
		%if x_crack.bridge.allsevered==1 && x_crack.bridge.tt_first.value~=0 && x_crack.bridge.tt_last.value==0;
		if x_crack.bridge.mostsevered==1 && x_crack.bridge.tt_first.value~=0 && x_crack.bridge.tt_last.value==0;
			x_crack.bridge.tt_last.value=tt;
			x_crack.bridge.tt_last.savetoken=1;
		end
	end
	
	if CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
		[temp_si,temp_si_comb,shrinkage_si,shrinkage_si_comb,orientationoffset_si,orientationoffset_si_comb,mEfactor_si,x0_si,x_si,deltarideal_si,LW_si_comb,EW_si_comb,nmass_si,nmass_si_comb,nmomentum_si,niforce_si,neforce_si,traction_si,pforce_si,ncforce_si,s_si,s_si_comb,u_si,u_si_comb,v_si,uncrackable_si,uncrackable_si_comb,k_si,k_si_comb,weakeningfactor_si,weakeningfactor_si_comb,~]=Interpolate_Particle_To_Grid_WithPredeterminedVelocity2_optimized(temp_sp,shrinkage_sp,orientationoffset,weakeningfactor_sp,k_sp,LOC,N_crack,CONNECT_crack,NODES_crack,TheFieldSplit_cracktop,TheFieldSplit_crackbot,x_crack,deltarideal_sp,NODES,nodeCount,CONNECT,le,N,dN,spCount,b_sp,A_sp,t_sp,ptraction_sp,v_ssp,s_sp,m_sp,pforce_sp,TheFieldSplit,CasetoRun,fieldnumber,x_sp,x_spo,uncrackable_sp,LWStatus,EWStatus,Efactor_sp); fprintf('%s',['marker #630' char(10)]);
		1;
	else
		[nmass_si,nmomentum_si,niforce_si,neforce_si,traction_si,pforce_si,ncforce_si,~]=Interpolate_Particle_To_Grid_WithPredeterminedVelocity2(NODES,nodeCount,CONNECT,le,N,dN,spCount,b_sp,A_sp,t_sp,ptraction_sp,v_ssp,s_sp,m_sp,pforce_sp,Nmatrix,dNxmatrix,dNymatrix,ncforce_cracktop,ncforce_crackbot,Nmatrix_cracktop,Nmatrix_crackbot,TheFieldSplit,CasetoRun,CONNECTpn);
	end

	% nmass_si: nodal mass
	% nmomentum_si: nodal momentum
	% niforce_si: nodal internal force
	% neforce_si: nodal external force
	% traction_si: nodal traction
	
	%% Update momentum
	% Update force and momentum
	
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - 0.1*nmomentum_si; %legit damping
	elseif CasetoRun==4
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si;
	elseif CasetoRun==64 || CasetoRun==65 || CasetoRun==70
		Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
		for i=1:length(ynodedamped)
			Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:,1)+Nmatrix(ynodedamped(i),:,2)+Nmatrix(ynodedamped(i),:,3);
		end
		yparticledampedtowhichnode=zeros(1,length(yparticledamped));
		ydampingnodaldisplacement=zeros(1,length(ynodedamped));
		ydampingnodalvelocity=zeros(1,length(ynodedamped));
		for i=1:length(yparticledamped)
			yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
			ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
			ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
		end
		ynodalreactionforce=zeros(size(niforce_si));
		ydampedBCstiffness=le(1)*t0_plane*E/le(2);
		thalflife=0.5;
		k=log(2)/thalflife;
		dampingratio=0.1;
		ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
		ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
		for i=1:length(ydampingnodaldisplacement)
			ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
		end
		
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
	elseif CasetoRun==66 || CasetoRun==69 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + - 0.1*nmomentum_si; %legit damping
	elseif CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==120 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si; %no damping
	elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==125 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.01;
		k=log(2)/t_halflife;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==171
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.001;
		k=log(2)/t_halflife;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==165
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.0001;
		k=log(2)/t_halflife;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==182
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.01;
		k=log(2)/t_halflife;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);	
	elseif CasetoRun==183
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.01;
		k=log(2)/t_halflife;
		k=0;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - k*nmomentum_si; %with damping
		
		
		eadcb.disp.tgt=zeros(1,1);
		eadcb.disp.actual=zeros(1,1);
		eadcb.vel.tgt=zeros(1,1);
		eadcb.vel.actual=zeros(1,1);
		eadcb.stiffness.ideal=zeros(1,1);
		eadcb.stiffness.actual=zeros(1,1);
		eadcb.dampingratio=zeros(1,1);
		eadcb.sprungmass.ideal=zeros(1,1);
		eadcb.sprungmass.actual=zeros(1,1);
		eadcb.dampingcoeff=zeros(1,1);
		eadcb.returnforce=zeros(1,1);
		eadcb.springforce=zeros(1,1);
		eadcb.dampingforce=zeros(1,1);
		eadcb.dim=zeros(1,1);
		eadcb.N=zeros(1,1);
		eadcb.m_si=zeros(1,1);
		eadcb.mv_si=zeros(1,1); %momentum
		eadcb.v_si=zeros(1,1);
		eadcb.mu_si=zeros(1,1);
		eadcb.u_si=zeros(1,1);
		
		eadcb.sprungmass.ideal=p_sp(1)*le(1)*le(2)*t0_plane/2;
		eadcb.dampingratio=0.5;
		eadcb.stiffness.ideal=E*t0_plane;
		%eadcb.dampingcoeff=eadcb.dampingratio*eadcb.sprungmass.ideal/dt;
		
		
		eadcb.dim=1;
		for iro=1:PredVelVect.nX
			io=PredVelVect.XNodes(iro);
			eadcb.m_si=0;
			eadcb.mu_si=0;
			eadcb.mv_si=0;
			for irp=1:N0.CONNECTpn.nrparticles(io)
				ip=N0.CONNECTpn.values(io,irp);
				eadcb.N=N0.Npn.values(io,irp);
				eadcb.m_si=eadcb.m_si+eadcb.N*m_sp(ip);
			end
			ip=N0.CONNECTpn.values(io,1);
			eadcb.N=N0.Npn.values(io,1);
			for irp=2:N0.CONNECTpn.nrparticles(io)
				if N0.Npn.values(io,irp)>eadcb.N
					ip=N0.CONNECTpn.values(io,irp);
					eadcb.N=N0.Npn.values(io,irp);
				end
			end
			if eadcb.m_si>0
				eadcb.u_si=x_sp(ip,eadcb.dim)-x_spo(ip,eadcb.dim);
				eadcb.v_si=v_ssp(ip,eadcb.dim);
				eadcb.sprungmass.actual=eadcb.m_si; %1st layer only
				eadcb.stiffness.actual=eadcb.stiffness.ideal*eadcb.sprungmass.actual/eadcb.sprungmass.ideal;
				eadcb.dampingcoeff=eadcb.dampingratio*2*sqrt(eadcb.stiffness.actual*eadcb.sprungmass.actual);
				eadcb.disp.tgt=PredVelVect.XDisp(iro);
				eadcb.vel.tgt=PredVelVect.XVel(iro);
				eadcb.disp.actual=eadcb.u_si; %1st layer only
				eadcb.vel.actual=eadcb.v_si; %1st layer only
				eadcb.springforce=-eadcb.stiffness.actual*(eadcb.disp.actual-eadcb.disp.tgt);
				eadcb.dampingforce=-eadcb.dampingcoeff*(eadcb.vel.actual-eadcb.vel.tgt);
				eadcb.returnforce=0*eadcb.springforce+eadcb.dampingforce;
				nforce_si(io,eadcb.dim,1)=eadcb.returnforce; %1st layer only
			end
			if u_si(io,eadcb.dim,1)~=0 && iro==9
				1;
			end
		end


		eadcb.dim=2;
		for iro=1:PredVelVect.nY
			io=PredVelVect.YNodes(iro);
			eadcb.m_si=0;
			eadcb.mu_si=0;
			eadcb.mv_si=0;
			for irp=1:N0.CONNECTpn.nrparticles(io)
				ip=N0.CONNECTpn.values(io,irp);
				eadcb.N=N0.Npn.values(io,irp);
				eadcb.m_si=eadcb.m_si+eadcb.N*m_sp(ip);
			end
			ip=N0.CONNECTpn.values(io,1);
			eadcb.N=N0.Npn.values(io,1);
			for irp=2:N0.CONNECTpn.nrparticles(io)
				if N0.Npn.values(io,irp)>eadcb.N
					ip=N0.CONNECTpn.values(io,irp);
					eadcb.N=N0.Npn.values(io,irp);
				end
			end
			if eadcb.m_si>0
				eadcb.u_si=x_sp(ip,eadcb.dim)-x_spo(ip,eadcb.dim);
				eadcb.v_si=v_ssp(ip,eadcb.dim);
				eadcb.sprungmass.actual=eadcb.m_si; %1st layer only
				eadcb.stiffness.actual=eadcb.stiffness.ideal*eadcb.sprungmass.actual/eadcb.sprungmass.ideal;
				eadcb.dampingcoeff=eadcb.dampingratio*2*sqrt(eadcb.stiffness.actual*eadcb.sprungmass.actual);
				eadcb.dampingcoeff=eadcb.dampingratio*eadcb.sprungmass.ideal/dt;
				eadcb.disp.tgt=PredVelVect.YDisp(iro);
				eadcb.vel.tgt=PredVelVect.YVel(iro);
				eadcb.disp.actual=eadcb.u_si; %1st layer only
				eadcb.vel.actual=eadcb.v_si; %1st layer only
				eadcb.springforce=-eadcb.stiffness.actual*(eadcb.disp.actual-eadcb.disp.tgt);
				eadcb.dampingforce=-eadcb.dampingcoeff*(eadcb.vel.actual-eadcb.vel.tgt);
				eadcb.returnforce=0*eadcb.springforce+eadcb.dampingforce;
				nforce_si(io,eadcb.dim,1)=eadcb.returnforce; %1st layer only
			end
			if u_si(io,eadcb.dim,1)~=0 && iro==9
				1;
			end
		end
		
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==217 || CasetoRun==229
		
		nivforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal Internal force
		
		%TDL nodal viscoelasticity
		if 1
			deltaepsilonglobal=zeros(6,1);
			deltaepsilon=zeros(6,1);
			sigma_local=zeros(6,1);
			sigma_rotated=zeros(6,1);
			s_sp_rotated=zeros(1,3);
			
			tandelta=0.03;
			omega=2*pi;
			
			Comp=[1/Er -nurt/Et -nurl/El 0 0 0;
				-nurt/Et 1/Et -nutl/El 0 0 0;
				-nurl/El -nutl/El 1/El 0 0 0;
				0 0 0 1/Grt 0 0;
				0 0 0 0 1/Gtl 0;
				0 0 0 0 0 1/Grl];
			
			C=Comp^-1;
			
			[nvelo_si] = Interpolate_velocity_back_optimized(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp,N,dN,nmass_si,TheFieldSplit,fieldnumber);fprintf('%s',['marker #725' char(10)]);
			
			L_sp=cell(1,spCount);
			dESP=cell(1,spCount);
			s_sp_visc=cell(1,spCount);
			for i=1:spCount
				L_sp{i}=zeros(2,2);
				dESP{i}=zeros(2,2);
				s_sp_visc{i}=zeros(2,2);
			end
			
			%direction locality hierarchy from the broadest:
				%GLOBAL: structural-level coordinate
					%same as global BACKROTATED or simply BACKROTATED
				%ROTATED: direction rotated according to material rotation i.e. Q (orientationoffset) and R (poldecopm(F))
					%seldom called as LOCAL ROTATED or RTL
				%LOCAL: direction of material-model level, already adjusted the RTL directions to adhere with the material model requirement of voigt R-T-L direction order.
				
			
			for c=1:cellCount
				mpts = mspoints{c};
				
				for sp = 1:length(mpts)
					spid = mpts(sp);
					
					Rback=poldecomp(F_sp{spid},0);
					Qback=[cos(-orientationoffset(spid)) sin(-orientationoffset(spid)); -sin(-orientationoffset(spid)) cos(-orientationoffset(spid))];
					
					R=transpose(Rback);
					Q=[cos(orientationoffset(spid)) sin(orientationoffset(spid)); -sin(orientationoffset(spid)) cos(orientationoffset(spid))];
					
					RQ=R*Q;
					QbackRback=Qback*Rback;
					
					L_sp{spid} = zeros(2,2);
					for j=1:NODES(spid)
						if dN{spid}(1,j)==0 && dN{spid}(2,j)==0
							continue
						end
						npid = CONNECT{spid}(j);
						L_sp{spid} = L_sp{spid} + (nvelo_si(npid,:,TheFieldSplit(j,spid))'*dN{spid}(:,j)');
					end
					dESP{spid} = ((L_sp{spid} + L_sp{spid}')/2)*dt; 
					
					dESP_rotated=(RQ)*dESP{spid}*transpose(RQ);
					
					deltaepsilonglobal(1,1)=real(dESP_rotated(1,1));
					deltaepsilonglobal(2,1)=real(dESP_rotated(2,2));
					deltaepsilonglobal(3,1)=0;
					deltaepsilonglobal(4,1)=real(dESP_rotated(1,2));
					deltaepsilonglobal(5,1)=0;
					deltaepsilonglobal(6,1)=0;
					
					xdir=RTLtranslator(xdirletter{spid});
					ydir=RTLtranslator(ydirletter{spid});
					zdir=RTLtranslator(zdirletter{spid});
					xydir=RTLtranslator(xydirletter{spid});
					yzdir=RTLtranslator(yzdirletter{spid});
					xzdir=RTLtranslator(xzdirletter{spid});
					
					deltaepsilon(xdir,1)=deltaepsilonglobal(1);
					deltaepsilon(ydir,1)=deltaepsilonglobal(2);
					deltaepsilon(zdir,1)=deltaepsilonglobal(3);
					deltaepsilon(xydir,1)=deltaepsilonglobal(4);
					deltaepsilon(yzdir,1)=deltaepsilonglobal(5);
					deltaepsilon(xzdir,1)=deltaepsilonglobal(6);
					
					sigma_local=zeros(6,1);
					for ivoigtdir=1:3
						if t_time<dt/2
							K_taken=C;
						else
							K_taken=Ktangent_local(:,:,spid);
						end
						etadamp=max(0,K_taken(ivoigtdir,ivoigtdir))*tandelta/omega;
						sigma_local(ivoigtdir)=etadamp*deltaepsilon(ivoigtdir)/dt;
					end	
					
					sigma_rotated(1)=sigma_local(xdir);
					sigma_rotated(2)=sigma_local(ydir);
					sigma_rotated(3)=sigma_local(zdir);
					sigma_rotated(4)=sigma_local(xydir);
					sigma_rotated(5)=sigma_local(yzdir);
					sigma_rotated(6)=sigma_local(xzdir);
					
					s_sp_rotated(1)=sigma_rotated(1);
					s_sp_rotated(2)=sigma_rotated(2);
					s_sp_rotated(3)=sigma_rotated(4);
					
					s_sp_mat_rotated=[s_sp_rotated(1) s_sp_rotated(3);s_sp_rotated(3) s_sp_rotated(2)];
					s_sp_mat_backrotated=(QbackRback)*s_sp_mat_rotated*transpose(QbackRback);
					for idim=1:2
						for jdim=1:2
							s_sp_visc{spid}(idim,jdim)=real(s_sp_mat_backrotated(idim,jdim));
						end
					end
					
					
					%TDL continue here:
						%return s_sp back to matrix format
					
				end
			end
			for sp=1:spCount
				for j=1:NODES(sp)
					npid                           = CONNECT{sp}(j);
					if N{sp}(j)==0
						continue
					end
					% Internal forces
					nivforce_si(npid,:,TheFieldSplit(j,sp))        = nivforce_si(npid,:,TheFieldSplit(j,sp)) - (A_sp(sp)*t_sp(sp)*s_sp_visc{sp}*dN{sp}(:,j))' ;%- 0.07*v_ssp(sp,:); %damping
				end
			end
		end
		
		
		
		
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.1;
		k=log(2)/t_halflife;
		k=0;
		%TDL Damping Settings
		nforce_si=niforce_si+neforce_si+traction_si+pforce_si-k*nmomentum_si+ncforce_si+nivforce_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==230
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.01;
		
		%fprintf('%s',['before t_halflife loadvariable' char(10)]);
		t_halflife_loaded=loadvariable('t_halflife');
		%fprintf('%s',['after t_halflife loadvariable' char(10)]);
		%fprintf('%s',['t_halflife_loaded.found=' int2txt(t_halflife_loaded.found) char(10)]);
		%fprintf('%s',['t_halflife_loaded.valuetext=' t_halflife_loaded.valuetext char(10)]);
		if t_halflife_loaded.found
			t_halflife=str2float(t_halflife_loaded.valuetext);
		end
		%fprintf('%s',['t_halflife=' float2scitxt(5,t_halflife) char(10)]);
	
		if t_halflife_loaded.found
			k=log(2)/t_halflife;
		else
			k=0
		end
		%fprintf('%s',['before k loadvariable' char(10)]);
		k_loaded=loadvariable('k');
		%fprintf('%s',['after k loadvariable' char(10)]);
		%fprintf('%s',['k_loaded.found=' int2txt(k_loaded.found) char(10)]);
		%fprintf('%s',['k_loaded.valuetext=' k_loaded.valuetext char(10)]);
		if k_loaded.found
			k=str2float(k_loaded.valuetext);
		end
		%fprintf('%s',['k=' float2scitxt(5,k) char(10)]);
		
		%k=0;
		nforce_si=niforce_si+neforce_si+traction_si+pforce_si-k*nmomentum_si+ncforce_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==207
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.01;
		k=log(2)/t_halflife;
		nforce_si=niforce_si+neforce_si+traction_si+pforce_si-k*nmomentum_si+ncforce_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==201
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.01;
		k=log(2)/t_halflife;
		k=0;
		nforce_si=niforce_si+neforce_si+traction_si+pforce_si-k*nmomentum_si+ncforce_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==199
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.01;
		k=log(2)/t_halflife;
		k=0;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==177 || CasetoRun==179 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.01;
		k=log(2)/t_halflife;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==124
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.01/2;
		k=log(2)/t_halflife;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==152
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.0001;
		k=log(2)/t_halflife;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==150
		%pforce_si experiment
		x_center=7*le_base;
		y_center=7*le_base;
		k_spring=E*t0_plane;
		for ifield=1:fieldnumber
			for ino=1:niCount
				if uncrackable_si(ino,ifield)>0
					deltax0_si=[x0_si(ino,1,ifield)-x_center x0_si(ino,2,ifield)-y_center];
					r0_si=sqrt(dot(deltax0_si,deltax0_si));
					deltax_si=[x_si(ino,1,ifield)-x_center x_si(ino,2,ifield)-y_center];
					r_si=sqrt(dot(deltax_si,deltax_si));
					theta_si=reliableatan(deltax_si(1),deltax_si(2));
					deltaractual_si(ino,ifield)=r_si-r0_si;
					radialforce_si=-k_spring*(deltaractual_si(ino,ifield)-deltarideal_si(ino,ifield))
					force_si_loading(ino,:,ifield)=radialforce_si*[cos(theta_si) sin(theta_si)]*uncrackable_si(ino,ifield);
				end
			end
		end
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.001;
		k=log(2)/t_halflife;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + force_si_loading - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==155
		%phase pump loading
		x_center=7*le_base;
		y_center=7*le_base;
		%nPredVel=8
		%PredVelVect.nX=2;
		%PredVelVect.nY=2;
		%{
		for io=1:niCount
			if CloseEnough(LOC(io,1),10*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(1)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),10*le_base,1e-3,1)
				PredVelVect.YNodes(1)=io;
			elseif CloseEnough(LOC(io,1),4*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(2)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),4*le_base,1e-3,1)
				PredVelVect.YNodes(2)=io;
			end
		end
		%}
		%{
		for io=1:niCount
			if CloseEnough(LOC(io,1),10*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(1)=io;
				PredVelVect.YNodes(1)=io;
			elseif CloseEnough(LOC(io,1),9*le_base,1e-3,1) && CloseEnough(LOC(io,2),9*le_base,1e-3,1)
				PredVelVect.XNodes(2)=io;
				PredVelVect.YNodes(2)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),10*le_base,1e-3,1)
				PredVelVect.XNodes(3)=io;
				PredVelVect.YNodes(3)=io;
			elseif CloseEnough(LOC(io,1),5*le_base,1e-3,1) && CloseEnough(LOC(io,2),9*le_base,1e-3,1)
				PredVelVect.XNodes(4)=io;
				PredVelVect.YNodes(4)=io;
			elseif CloseEnough(LOC(io,1),4*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(5)=io;
				PredVelVect.YNodes(5)=io;
			elseif CloseEnough(LOC(io,1),5*le_base,1e-3,1) && CloseEnough(LOC(io,2),5*le_base,1e-3,1)
				PredVelVect.XNodes(6)=io;
				PredVelVect.YNodes(6)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),4*le_base,1e-3,1)
				PredVelVect.XNodes(7)=io;
				PredVelVect.YNodes(7)=io;
			elseif CloseEnough(LOC(io,1),9*le_base,1e-3,1) && CloseEnough(LOC(io,2),5*le_base,1e-3,1)
				PredVelVect.XNodes(8)=io;
				PredVelVect.YNodes(8)=io;
			end
		end
		%}
		
		for iX=1:PredVelVect.nX
			io=PredVelVect.XNodes(iX);
			deltax_si=[LOC(io,1)-x_center LOC(io,2)-y_center];
			theta_si=reliableatan(deltax_si(1),deltax_si(2));
			PredVelVect.XPhase(iX)=1;
			PredVelVect.XVel(iX)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
			PredVelVect.XAcc(iX)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
		end

		for iY=1:PredVelVect.nY
			io=PredVelVect.YNodes(iY);
			deltax_si=[LOC(io,1)-x_center LOC(io,2)-y_center];
			theta_si=reliableatan(deltax_si(1),deltax_si(2));
			PredVelVect.YPhase(iY)=1;
			PredVelVect.YVel(iY)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
			PredVelVect.YAcc(iY)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
		end
		
		%{
		iPredVel=0;
		for iPredVel=1:nPredVel
			io=PredVelVect.XNodes(iPredVel);
			deltax_si=[LOC(io,1)-x_center LOC(io,2)-y_center];
			theta_si=reliableatan(deltax_si(1),deltax_si(2));
			PredVelVect.XPhase(iPredVel)=1;
			PredVelVect.YPhase(iPredVel)=1;
			PredVelVect.XVel(iPredVel)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
			PredVelVect.YVel(iPredVel)=PredXVel*sin(theta_si);
			PredVelVect.XAcc(iPredVel)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
			PredVelVect.YAcc(iPredVel)=PredXAcc*sin(theta_si);
		end
		%}
		%{
		k_spring=E*t0_plane;
		
		nPredVel=0;
		for ino=1:niCount
			if uncrackable_si(ino,1)>=1 && sum(nmass_si(ino,:))<=2*m_sp(1)
				nPredVel=nPredVel+1;
			end
		end
		PredVelVect.nX=nPredVel;
		PredVelVect.nY=nPredVel;
		iPredVel=0;
		for ino=1:niCount
			if uncrackable_si(ino,1)>=1 && sum(nmass_si(ino,:))<=2*m_sp(1)
				iPredVel=iPredVel+1;
				deltax_si=[LOC(ino,1)-x_center LOC(ino,2)-y_center];
				theta_si=reliableatan(deltax_si(1),deltax_si(2));
				PredVelVect.XNodes(iPredVel)=ino;
				PredVelVect.YNodes(iPredVel)=ino;
				%PredVelVect.XPhase(iPredVel)=uncrackable_si(ino,1);
				%PredVelVect.YPhase(iPredVel)=uncrackable_si(ino,1);
				PredVelVect.XPhase(iPredVel)=1;
				PredVelVect.YPhase(iPredVel)=1;
				PredVelVect.XVel(iPredVel)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
				PredVelVect.YVel(iPredVel)=PredXVel*sin(theta_si);
				PredVelVect.XAcc(iPredVel)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
				PredVelVect.YAcc(iPredVel)=PredXAcc*sin(theta_si);
			end
		end
		%}
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.0001; %works
		k=log(2)/t_halflife;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + force_si_loading - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174
		%phase pump loading
		x_center=7*le_base;
		y_center=7*le_base;
		%nPredVel=8
		%PredVelVect.nX=2;
		%PredVelVect.nY=2;
		%{
		for io=1:niCount
			if CloseEnough(LOC(io,1),10*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(1)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),10*le_base,1e-3,1)
				PredVelVect.YNodes(1)=io;
			elseif CloseEnough(LOC(io,1),4*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(2)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),4*le_base,1e-3,1)
				PredVelVect.YNodes(2)=io;
			end
		end
		%}
		%{
		for io=1:niCount
			if CloseEnough(LOC(io,1),10*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(1)=io;
				PredVelVect.YNodes(1)=io;
			elseif CloseEnough(LOC(io,1),9*le_base,1e-3,1) && CloseEnough(LOC(io,2),9*le_base,1e-3,1)
				PredVelVect.XNodes(2)=io;
				PredVelVect.YNodes(2)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),10*le_base,1e-3,1)
				PredVelVect.XNodes(3)=io;
				PredVelVect.YNodes(3)=io;
			elseif CloseEnough(LOC(io,1),5*le_base,1e-3,1) && CloseEnough(LOC(io,2),9*le_base,1e-3,1)
				PredVelVect.XNodes(4)=io;
				PredVelVect.YNodes(4)=io;
			elseif CloseEnough(LOC(io,1),4*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(5)=io;
				PredVelVect.YNodes(5)=io;
			elseif CloseEnough(LOC(io,1),5*le_base,1e-3,1) && CloseEnough(LOC(io,2),5*le_base,1e-3,1)
				PredVelVect.XNodes(6)=io;
				PredVelVect.YNodes(6)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),4*le_base,1e-3,1)
				PredVelVect.XNodes(7)=io;
				PredVelVect.YNodes(7)=io;
			elseif CloseEnough(LOC(io,1),9*le_base,1e-3,1) && CloseEnough(LOC(io,2),5*le_base,1e-3,1)
				PredVelVect.XNodes(8)=io;
				PredVelVect.YNodes(8)=io;
			end
		end
		%}
		
		for iX=1:PredVelVect.nX
			io=PredVelVect.XNodes(iX);
			deltax_si=[LOC(io,1)-x_center LOC(io,2)-y_center];
			theta_si=reliableatan(deltax_si(1),deltax_si(2));
			PredVelVect.XPhase(iX)=1;
			PredVelVect.XVel(iX)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
			PredVelVect.XAcc(iX)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
		end

		for iY=1:PredVelVect.nY
			io=PredVelVect.YNodes(iY);
			deltax_si=[LOC(io,1)-x_center LOC(io,2)-y_center];
			theta_si=reliableatan(deltax_si(1),deltax_si(2));
			PredVelVect.YPhase(iY)=1;
			PredVelVect.YVel(iY)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
			PredVelVect.YAcc(iY)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
		end
		
		%{
		iPredVel=0;
		for iPredVel=1:nPredVel
			io=PredVelVect.XNodes(iPredVel);
			deltax_si=[LOC(io,1)-x_center LOC(io,2)-y_center];
			theta_si=reliableatan(deltax_si(1),deltax_si(2));
			PredVelVect.XPhase(iPredVel)=1;
			PredVelVect.YPhase(iPredVel)=1;
			PredVelVect.XVel(iPredVel)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
			PredVelVect.YVel(iPredVel)=PredXVel*sin(theta_si);
			PredVelVect.XAcc(iPredVel)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
			PredVelVect.YAcc(iPredVel)=PredXAcc*sin(theta_si);
		end
		%}
		%{
		k_spring=E*t0_plane;
		
		nPredVel=0;
		for ino=1:niCount
			if uncrackable_si(ino,1)>=1 && sum(nmass_si(ino,:))<=2*m_sp(1)
				nPredVel=nPredVel+1;
			end
		end
		PredVelVect.nX=nPredVel;
		PredVelVect.nY=nPredVel;
		iPredVel=0;
		for ino=1:niCount
			if uncrackable_si(ino,1)>=1 && sum(nmass_si(ino,:))<=2*m_sp(1)
				iPredVel=iPredVel+1;
				deltax_si=[LOC(ino,1)-x_center LOC(ino,2)-y_center];
				theta_si=reliableatan(deltax_si(1),deltax_si(2));
				PredVelVect.XNodes(iPredVel)=ino;
				PredVelVect.YNodes(iPredVel)=ino;
				%PredVelVect.XPhase(iPredVel)=uncrackable_si(ino,1);
				%PredVelVect.YPhase(iPredVel)=uncrackable_si(ino,1);
				PredVelVect.XPhase(iPredVel)=1;
				PredVelVect.YPhase(iPredVel)=1;
				PredVelVect.XVel(iPredVel)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
				PredVelVect.YVel(iPredVel)=PredXVel*sin(theta_si);
				PredVelVect.XAcc(iPredVel)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
				PredVelVect.YAcc(iPredVel)=PredXAcc*sin(theta_si);
			end
		end
		%}
		fprintf('%s',['marker #631' char(10)]);
		%t_halflife test
		%t_halflife=0.0001; %works
		t_halflife=100;
		k=log(2)/t_halflife;
		k=0;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + force_si_loading - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==158
		%phase pump loading
		x_center=7*le_base;
		y_center=7*le_base;
		%nPredVel=8
		%PredVelVect.nX=2;
		%PredVelVect.nY=2;
		%{
		for io=1:niCount
			if CloseEnough(LOC(io,1),10*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(1)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),10*le_base,1e-3,1)
				PredVelVect.YNodes(1)=io;
			elseif CloseEnough(LOC(io,1),4*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(2)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),4*le_base,1e-3,1)
				PredVelVect.YNodes(2)=io;
			end
		end
		%}
		%{
		for io=1:niCount
			if CloseEnough(LOC(io,1),10*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(1)=io;
				PredVelVect.YNodes(1)=io;
			elseif CloseEnough(LOC(io,1),9*le_base,1e-3,1) && CloseEnough(LOC(io,2),9*le_base,1e-3,1)
				PredVelVect.XNodes(2)=io;
				PredVelVect.YNodes(2)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),10*le_base,1e-3,1)
				PredVelVect.XNodes(3)=io;
				PredVelVect.YNodes(3)=io;
			elseif CloseEnough(LOC(io,1),5*le_base,1e-3,1) && CloseEnough(LOC(io,2),9*le_base,1e-3,1)
				PredVelVect.XNodes(4)=io;
				PredVelVect.YNodes(4)=io;
			elseif CloseEnough(LOC(io,1),4*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(5)=io;
				PredVelVect.YNodes(5)=io;
			elseif CloseEnough(LOC(io,1),5*le_base,1e-3,1) && CloseEnough(LOC(io,2),5*le_base,1e-3,1)
				PredVelVect.XNodes(6)=io;
				PredVelVect.YNodes(6)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),4*le_base,1e-3,1)
				PredVelVect.XNodes(7)=io;
				PredVelVect.YNodes(7)=io;
			elseif CloseEnough(LOC(io,1),9*le_base,1e-3,1) && CloseEnough(LOC(io,2),5*le_base,1e-3,1)
				PredVelVect.XNodes(8)=io;
				PredVelVect.YNodes(8)=io;
			end
		end
		%}
		
		for iX=1:PredVelVect.nX
			io=PredVelVect.XNodes(iX);
			deltax_si=[LOC(io,1)-x_center LOC(io,2)-y_center];
			theta_si=reliableatan(deltax_si(1),deltax_si(2));
			PredVelVect.XPhase(iX)=1;
			PredVelVect.XVel(iX)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
			PredVelVect.XAcc(iX)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
		end

		for iY=1:PredVelVect.nY
			io=PredVelVect.YNodes(iY);
			deltax_si=[LOC(io,1)-x_center LOC(io,2)-y_center];
			theta_si=reliableatan(deltax_si(1),deltax_si(2));
			PredVelVect.YPhase(iY)=1;
			PredVelVect.YVel(iY)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
			PredVelVect.YAcc(iY)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
		end
		
		%{
		iPredVel=0;
		for iPredVel=1:nPredVel
			io=PredVelVect.XNodes(iPredVel);
			deltax_si=[LOC(io,1)-x_center LOC(io,2)-y_center];
			theta_si=reliableatan(deltax_si(1),deltax_si(2));
			PredVelVect.XPhase(iPredVel)=1;
			PredVelVect.YPhase(iPredVel)=1;
			PredVelVect.XVel(iPredVel)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
			PredVelVect.YVel(iPredVel)=PredXVel*sin(theta_si);
			PredVelVect.XAcc(iPredVel)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
			PredVelVect.YAcc(iPredVel)=PredXAcc*sin(theta_si);
		end
		%}
		%{
		k_spring=E*t0_plane;
		
		nPredVel=0;
		for ino=1:niCount
			if uncrackable_si(ino,1)>=1 && sum(nmass_si(ino,:))<=2*m_sp(1)
				nPredVel=nPredVel+1;
			end
		end
		PredVelVect.nX=nPredVel;
		PredVelVect.nY=nPredVel;
		iPredVel=0;
		for ino=1:niCount
			if uncrackable_si(ino,1)>=1 && sum(nmass_si(ino,:))<=2*m_sp(1)
				iPredVel=iPredVel+1;
				deltax_si=[LOC(ino,1)-x_center LOC(ino,2)-y_center];
				theta_si=reliableatan(deltax_si(1),deltax_si(2));
				PredVelVect.XNodes(iPredVel)=ino;
				PredVelVect.YNodes(iPredVel)=ino;
				%PredVelVect.XPhase(iPredVel)=uncrackable_si(ino,1);
				%PredVelVect.YPhase(iPredVel)=uncrackable_si(ino,1);
				PredVelVect.XPhase(iPredVel)=1;
				PredVelVect.YPhase(iPredVel)=1;
				PredVelVect.XVel(iPredVel)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
				PredVelVect.YVel(iPredVel)=PredXVel*sin(theta_si);
				PredVelVect.XAcc(iPredVel)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
				PredVelVect.YAcc(iPredVel)=PredXAcc*sin(theta_si);
			end
		end
		%}
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.0001; %works
		k=log(2)/t_halflife;
		k=0; %overridden, no damping
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + force_si_loading - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==156 || CasetoRun==159
		%phase pump loading
		x_center=7*le_base;
		y_center=7*le_base;
		%nPredVel=8
		%PredVelVect.nX=2;
		%PredVelVect.nY=2;
		%{
		for io=1:niCount
			if CloseEnough(LOC(io,1),10*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(1)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),10*le_base,1e-3,1)
				PredVelVect.YNodes(1)=io;
			elseif CloseEnough(LOC(io,1),4*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(2)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),4*le_base,1e-3,1)
				PredVelVect.YNodes(2)=io;
			end
		end
		%}
		%{
		for io=1:niCount
			if CloseEnough(LOC(io,1),10*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(1)=io;
				PredVelVect.YNodes(1)=io;
			elseif CloseEnough(LOC(io,1),9*le_base,1e-3,1) && CloseEnough(LOC(io,2),9*le_base,1e-3,1)
				PredVelVect.XNodes(2)=io;
				PredVelVect.YNodes(2)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),10*le_base,1e-3,1)
				PredVelVect.XNodes(3)=io;
				PredVelVect.YNodes(3)=io;
			elseif CloseEnough(LOC(io,1),5*le_base,1e-3,1) && CloseEnough(LOC(io,2),9*le_base,1e-3,1)
				PredVelVect.XNodes(4)=io;
				PredVelVect.YNodes(4)=io;
			elseif CloseEnough(LOC(io,1),4*le_base,1e-3,1) && CloseEnough(LOC(io,2),7*le_base,1e-3,1)
				PredVelVect.XNodes(5)=io;
				PredVelVect.YNodes(5)=io;
			elseif CloseEnough(LOC(io,1),5*le_base,1e-3,1) && CloseEnough(LOC(io,2),5*le_base,1e-3,1)
				PredVelVect.XNodes(6)=io;
				PredVelVect.YNodes(6)=io;
			elseif CloseEnough(LOC(io,1),7*le_base,1e-3,1) && CloseEnough(LOC(io,2),4*le_base,1e-3,1)
				PredVelVect.XNodes(7)=io;
				PredVelVect.YNodes(7)=io;
			elseif CloseEnough(LOC(io,1),9*le_base,1e-3,1) && CloseEnough(LOC(io,2),5*le_base,1e-3,1)
				PredVelVect.XNodes(8)=io;
				PredVelVect.YNodes(8)=io;
			end
		end
		%}
		%{
		for iX=1:PredVelVect.nX
			io=PredVelVect.XNodes(iX);
			deltax_si=[LOC(io,1)-x_center LOC(io,2)-y_center];
			theta_si=reliableatan(deltax_si(1),deltax_si(2));
			PredVelVect.XPhase(iX)=1;
			PredVelVect.XVel(iX)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
			PredVelVect.XAcc(iX)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
		end

		for iY=1:PredVelVect.nY
			io=PredVelVect.YNodes(iY);
			deltax_si=[LOC(io,1)-x_center LOC(io,2)-y_center];
			theta_si=reliableatan(deltax_si(1),deltax_si(2));
			PredVelVect.YPhase(iY)=1;
			PredVelVect.YVel(iY)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
			PredVelVect.YAcc(iY)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
		end
		%}
		%{
		iPredVel=0;
		for iPredVel=1:nPredVel
			io=PredVelVect.XNodes(iPredVel);
			deltax_si=[LOC(io,1)-x_center LOC(io,2)-y_center];
			theta_si=reliableatan(deltax_si(1),deltax_si(2));
			PredVelVect.XPhase(iPredVel)=1;
			PredVelVect.YPhase(iPredVel)=1;
			PredVelVect.XVel(iPredVel)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
			PredVelVect.YVel(iPredVel)=PredXVel*sin(theta_si);
			PredVelVect.XAcc(iPredVel)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
			PredVelVect.YAcc(iPredVel)=PredXAcc*sin(theta_si);
		end
		%}
		
		k_spring=E*t0_plane;
		
		nPredVel=0;
		for ino=1:niCount
			if uncrackable_si(ino,1)>=1 && sum(nmass_si(ino,:))<=2*m_sp(1)
				nPredVel=nPredVel+1;
			end
		end
		PredVelVect.nX=nPredVel;
		PredVelVect.nY=nPredVel;
		iPredVel=0;
		for ino=1:niCount
			if uncrackable_si(ino,1)>=1 && sum(nmass_si(ino,:))<=2*m_sp(1)
				iPredVel=iPredVel+1;
				deltax_si=[LOC(ino,1)-x_center LOC(ino,2)-y_center];
				theta_si=reliableatan(deltax_si(1),deltax_si(2));
				PredVelVect.XNodes(iPredVel)=ino;
				PredVelVect.YNodes(iPredVel)=ino;
				%PredVelVect.XPhase(iPredVel)=uncrackable_si(ino,1);
				%PredVelVect.YPhase(iPredVel)=uncrackable_si(ino,1);
				PredVelVect.XPhase(iPredVel)=1;
				PredVelVect.YPhase(iPredVel)=1;
				PredVelVect.XVel(iPredVel)=PredXVel*cos(theta_si); %PredXVel is just piggybacked to pass on PredVel magnitude
				PredVelVect.YVel(iPredVel)=PredXVel*sin(theta_si);
				PredVelVect.XAcc(iPredVel)=PredXAcc*cos(theta_si); %PredXAcc is just piggybacked to pass on PredAcc magnitude
				PredVelVect.YAcc(iPredVel)=PredXAcc*sin(theta_si);
			end
		end
		
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0.001; %works
		k=log(2)/t_halflife;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + force_si_loading - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==153 || CasetoRun==154 || CasetoRun==161
		fprintf('%s',['marker #631' char(10)]);
		t_halflife=0; %bogus inputs to prevent the chance of coder whining
		k=log(2); % bogus inputs to prevent the chance of coder whining
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==126 || CasetoRun==118 || CasetoRun==173 || CasetoRun==127
		fprintf('%s',['marker #631' char(10)]);
		%t_halflife=0.0002; %25 times the damping
		t_halflife=0.002; %25 times the damping
		k=log(2)/t_halflife;
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - k*nmomentum_si; %with damping
		fprintf('%s',['marker #632' char(10)]);
	elseif CasetoRun==121
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ntforce_si; %no damping
	elseif CasetoRun==77
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ncforce_si; %no damping
	elseif CasetoRun==67
		Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
		for i=1:length(ynodedamped)
			Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:,1)+Nmatrix(ynodedamped(i),:,2)+Nmatrix(ynodedamped(i),:,3);
		end
		yparticledampedtowhichnode=zeros(1,length(yparticledamped));
		ydampingnodaldisplacement=zeros(1,length(ynodedamped));
		ydampingnodalvelocity=zeros(1,length(ynodedamped));
		for i=1:length(yparticledamped)
			yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
			ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
			ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
		end
		ynodalreactionforce=zeros(size(niforce_si));
		ydampedBCstiffness=le(1)*t0_plane*E/le(2);
		thalflife=0.5;
		k=log(2)/thalflife;
		dampingratio=0.1;
		ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
		ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
		for i=1:length(ydampingnodaldisplacement)
			ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
		end
		
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
	elseif CasetoRun==5 || CasetoRun==6
		ymomentumignore_prev=m_sp.*v_ssp(:,2).*ignoremomentum;
		Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
		for i=1:length(ynodedamped)
			Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:);
		end
		yparticledampedtowhichnode=zeros(1,length(yparticledamped));
		ydampingnodaldisplacement=zeros(1,length(ynodedamped));
		ydampingnodalvelocity=zeros(1,length(ynodedamped));
		for i=1:length(yparticledamped)
			yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
			ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
			ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
		end
		ynodalreactionforce=zeros(size(niforce_si));
		ydampedBCstiffness=le(1)*t0_plane*El/le(2);
		thalflife=0.5;
		k=log(2)/thalflife;
		dampingratio=0.1;
		ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
		ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
		for i=1:length(ydampingnodaldisplacement)
			ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
		end
		
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
	elseif CasetoRun==7
		ymomentumignore_prev=m_sp.*v_ssp(:,2).*ignoremomentum;
		Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
		for i=1:length(ynodedamped)
			Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:);
		end
		yparticledampedtowhichnode=zeros(1,length(yparticledamped));
		ydampingnodaldisplacement=zeros(1,length(ynodedamped));
		ydampingnodalvelocity=zeros(1,length(ynodedamped));
		for i=1:length(yparticledamped)
			yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
			ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
			ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
		end
		ynodalreactionforce=zeros(size(niforce_si));
		ydampedBCstiffness=le(1)*t0_plane*El/le(2);
		thalflife=0.5;
		k=log(2)/thalflife;
		dampingratio=0.1;
		ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
		ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
		for i=1:length(ydampingnodaldisplacement)
			ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
		end
		
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
		%nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - 0.1*nmomentum_si; %legit damping
	elseif CasetoRun==8 || CasetoRun==9
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si - 0.1*nmomentum_si; %legit damping;
	elseif CasetoRun==10
		ymomentumignore_prev=m_sp.*v_ssp(:,2).*ignoremomentum;
		Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
		for i=1:length(ynodedamped)
			Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:);
		end
		yparticledampedtowhichnode=zeros(1,length(yparticledamped));
		ydampingnodaldisplacement=zeros(1,length(ynodedamped));
		ydampingnodalvelocity=zeros(1,length(ynodedamped));
		for i=1:length(yparticledamped)
			yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
			ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
			ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
		end
		ynodalreactionforce=zeros(size(niforce_si));
		ydampedBCstiffness=le(1)*t0_plane*El/le(2);
		thalflife=0.5;
		k=log(2)/thalflife;
		dampingratio=0.1;
		ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
		ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
		for i=1:length(ydampingnodaldisplacement)
			ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
		end
		
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
	 elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		ymomentumignore_prev=m_sp.*v_ssp(:,2).*ignoremomentum;
		Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
		for i=1:length(ynodedamped)
			Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:);
		end
		yparticledampedtowhichnode=zeros(1,length(yparticledamped));
		ydampingnodaldisplacement=zeros(1,length(ynodedamped));
		ydampingnodalvelocity=zeros(1,length(ynodedamped));
		for i=1:length(yparticledamped)
			yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
			ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
			ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
		end
		ynodalreactionforce=zeros(size(niforce_si));
		ydampedBCstiffness=le(1)*t0_plane*El/le(2);
		thalflife=0.5;
		k=log(2)/thalflife;
		dampingratio=0.1;
		ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
		ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
		for i=1:length(ydampingnodaldisplacement)
			ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
		end
		
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
		%nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - 0.1*nmomentum_si; %legit damping
	 elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		ymomentumignore_prev=m_sp.*v_ssp(:,2).*ignoremomentum;
		Nmatrixmaxfinder=zeros(length(ynodedamped),size(Nmatrix,2));
		for i=1:length(ynodedamped)
			Nmatrixmaxfinder(i,:)=Nmatrix(ynodedamped(i),:);
		end
		yparticledampedtowhichnode=zeros(1,length(yparticledamped));
		ydampingnodaldisplacement=zeros(1,length(ynodedamped));
		ydampingnodalvelocity=zeros(1,length(ynodedamped));
		for i=1:length(yparticledamped)
			yparticledampedtowhichnode(i)=FindMax(Nmatrixmaxfinder(:,yparticledamped(i)));
			ydampingnodaldisplacement(yparticledampedtowhichnode(i))=ydampingnodaldisplacement(yparticledampedtowhichnode(i))+(x_sp(yparticledamped(i),2)-x_spo(yparticledamped(i),2));
			ydampingnodalvelocity(yparticledampedtowhichnode(i))=ydampingnodalvelocity(yparticledampedtowhichnode(i))+v_ssp(yparticledamped(i),2);
		end
		ynodalreactionforce=zeros(size(niforce_si));
		ydampedBCstiffness=le(1)*t0_plane*El/le(2);
		thalflife=0.5;
		k=log(2)/thalflife;
		dampingratio=0.1;
		ydampedBCdamping=k*psp1*le(1)*le(2)*t0_plane;
		ydampedBCdamping=dampingratio*2*sqrt(ydampedBCstiffness*psp1*le(1)*le(2)*t0_plane);
		for i=1:length(ydampingnodaldisplacement)
			ynodalreactionforce(ynodedamped(i),2)=-ydampedBCstiffness*ydampingnodaldisplacement(i)-ydampedBCdamping*ydampingnodalvelocity(i);
		end
		
		nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - k*nmomentum_si; %BC damping
		%nforce_si      = niforce_si + neforce_si + traction_si + pforce_si + ynodalreactionforce - 0.1*nmomentum_si; %legit damping
	end
	
	nmomentum_si   = nmomentum_si + nforce_si*dt;
	
	% Boundary condition
	[nforce_si]     = Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,nforce_si); % Boundary condition for nodal force
	[nmomentum_si]  = Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,nmomentum_si); % Boundary condition for nodal force
	
	%predvel experiment
	%nmomentum_si=nmomentum_si*(0.5^(1/1000)); %damping
	if CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
		%fieldnumber=max(max(TheFieldSplit));
		fprintf('%s',['marker #633' char(10)]);
		F_rollerX=zeros(1,length(NodeswithPredXVel));
		for i=1:length(NodeswithPredXVel)
			for j=1:1
				nmomentum_si_old=nmomentum_si(NodeswithPredXVel(i),j,:);
				for field=1:1
					nmomentum_si(NodeswithPredXVel(i),j,field)=nmass_si(NodeswithPredXVel(i),field)*PredXVel;
					nforce_si(NodeswithPredXVel(i),j,field)=nmass_si(NodeswithPredXVel(i),field)*PredXAcc;
				end
				F_rollerX(i)=sum((nmomentum_si(NodeswithPredXVel(i),j,:)-nmomentum_si_old(1,1,:)))/dt;
			end
			%F_roller(i,2)=0;
		end
		for i=1:length(NodeswithPredXVel2)
			for j=1:1
				nmomentum_si_old=nmomentum_si(NodeswithPredXVel2(i),j,:);
				for field=1:1
					nmomentum_si(NodeswithPredXVel2(i),j,field)=nmass_si(NodeswithPredXVel2(i),field)*PredXVel2;
					nforce_si(NodeswithPredXVel2(i),j,field)=nmass_si(NodeswithPredXVel2(i),field)*PredXAcc2;
				end
				F_rollerX(i)=sum((nmomentum_si(NodeswithPredXVel2(i),j,:)-nmomentum_si_old(1,1,:)))/dt;
			end
			%F_roller(i,2)=0;
		end
		
		
		F_rollerY=zeros(1,length(NodeswithPredYVel));
		for i=1:length(NodeswithPredYVel)
			for j=2:2
				nmomentum_si_old=nmomentum_si(NodeswithPredYVel(i),j,:);
				for field=1:1
					nmomentum_si(NodeswithPredYVel(i),j,field)=nmass_si(NodeswithPredYVel(i),field)*PredYVel;
					nforce_si(NodeswithPredYVel(i),j,field)=nmass_si(NodeswithPredYVel(i),field)*PredYAcc;
				end
				F_rollerY(i)=sum((nmomentum_si(NodeswithPredYVel(i),j,:)-nmomentum_si_old(1,1,:)))/dt;
			end
			%F_roller(i,2)=0;
		end
		for i=1:length(NodeswithPredYVel2)
			for j=2:2
				nmomentum_si_old=nmomentum_si(NodeswithPredYVel2(i),j,:);
				for field=1:1
					nmomentum_si(NodeswithPredYVel2(i),j,field)=nmass_si(NodeswithPredYVel2(i),field)*PredYVel2;
					nforce_si(NodeswithPredYVel2(i),j,field)=nmass_si(NodeswithPredYVel2(i),field)*PredYAcc2;
				end
			end
			%F_roller(i,2)=0;
		end
		fprintf('%s',['marker #634' char(10)]);
	elseif CasetoRun==183
		%183 PredVel ni Protocol
		%fieldnumber=max(max(TheFieldSplit));
		fprintf('%s',['marker #633' char(10)]);
		
		
		F_rollerX=zeros(1,PredVelVect.nX);


		F_rollerY=zeros(1,PredVelVect.nY);
		fprintf('%s',['marker #634' char(10)]);
	elseif CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==192 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
		%TDL imposition of moving BC nodes/values
		%186 PredVel ni Protocol
		%additions: One Sided F_roller calculations, total actuator work calculation
		%fieldnumber=max(max(TheFieldSplit));
		energy.work.ddt=0;
		fprintf('%s',['marker #633' char(10)]);
		F_rollerX=zeros(1,PredVelVect.nX);
		for i=1:PredVelVect.nX
			nmomentum_si_old=nmomentum_si(PredVelVect.XNodes(i),1,1);
			nforce_si_old=nforce_si(PredVelVect.XNodes(i),1,1);
			nmomentum_si(PredVelVect.XNodes(i),1,1)=PredVelVect.XPhase(i)*nmass_si(PredVelVect.XNodes(i),1)*PredVelVect.XVel(i)+(1-PredVelVect.XPhase(i))*nmomentum_si_old; %only field #1 is restrained
			nforce_si(PredVelVect.XNodes(i),1,1)=PredVelVect.XPhase(i)*nmass_si(PredVelVect.XNodes(i),1)*PredVelVect.XAcc(i)+(1-PredVelVect.XPhase(i))*nforce_si_old;
			F_rollerX(i)=(nmomentum_si(PredVelVect.XNodes(i),1,1)-nmomentum_si_old)/dt;
			energy.work.ddt=energy.work.ddt+F_rollerX(i)*PredVelVect.XVel(i);
			%F_roller(i,2)=0;
		end

		F_rollerY=zeros(1,PredVelVect.nY);
		for i=1:PredVelVect.nY
			nmomentum_si_old=nmomentum_si(PredVelVect.YNodes(i),2,1);
			nforce_si_old=nforce_si(PredVelVect.YNodes(i),2,1);
			nmomentum_si(PredVelVect.YNodes(i),2,1)=PredVelVect.YPhase(i)*nmass_si(PredVelVect.YNodes(i),1)*PredVelVect.YVel(i)+(1-PredVelVect.YPhase(i))*nmomentum_si_old;
			nforce_si(PredVelVect.YNodes(i),2,1)=PredVelVect.YPhase(i)*nmass_si(PredVelVect.YNodes(i),1)*PredVelVect.YAcc(i)+(1-PredVelVect.YPhase(i))*nforce_si_old;
			F_rollerY(i)=(nmomentum_si(PredVelVect.YNodes(i),2,1)-nmomentum_si_old)/dt;
			energy.work.ddt=energy.work.ddt+F_rollerY(i)*PredVelVect.YVel(i);
			if PredVelVect.YVel(i)<0
				F_rollerY(i)=0;
			end
			%F_roller(i,2)=0;
		end
		energy.work.value=energy.work.value+energy.work.ddt*dt;
		fprintf('%s',['marker #634' char(10)]);
	elseif CasetoRun==124 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==118 || CasetoRun==173
		%124 PredVel ni Protocol
		%fieldnumber=max(max(TheFieldSplit));
		fprintf('%s',['marker #633' char(10)]);
		F_rollerX=zeros(1,PredVelVect.nX);
		for i=1:PredVelVect.nX
			nmomentum_si_old=nmomentum_si(PredVelVect.XNodes(i),1,1);
			nforce_si_old=nforce_si(PredVelVect.XNodes(i),1,1);
			nmomentum_si(PredVelVect.XNodes(i),1,1)=PredVelVect.XPhase(i)*nmass_si(PredVelVect.XNodes(i),1)*PredVelVect.XVel(i)+(1-PredVelVect.XPhase(i))*nmomentum_si_old; %only field #1 is restrained
			nforce_si(PredVelVect.XNodes(i),1,1)=PredVelVect.XPhase(i)*nmass_si(PredVelVect.XNodes(i),1)*PredVelVect.XAcc(i)+(1-PredVelVect.XPhase(i))*nforce_si_old;
			F_rollerX(i)=sum((nmomentum_si(PredVelVect.XNodes(i),1,1)-nmomentum_si_old(1,1)))/dt;
			%F_roller(i,2)=0;
		end

		F_rollerY=zeros(1,PredVelVect.nY);
		for i=1:PredVelVect.nY
			nmomentum_si_old=nmomentum_si(PredVelVect.YNodes(i),2,1);
			nforce_si_old=nforce_si(PredVelVect.YNodes(i),2,1);
			nmomentum_si(PredVelVect.YNodes(i),2,1)=PredVelVect.YPhase(i)*nmass_si(PredVelVect.YNodes(i),1)*PredVelVect.YVel(i)+(1-PredVelVect.YPhase(i))*nmomentum_si_old;
			nforce_si(PredVelVect.YNodes(i),2,1)=PredVelVect.YPhase(i)*nmass_si(PredVelVect.YNodes(i),1)*PredVelVect.YAcc(i)+(1-PredVelVect.YPhase(i))*nforce_si_old;
			F_rollerY(i)=sum((nmomentum_si(PredVelVect.YNodes(i),2)-nmomentum_si_old(1,1)))/dt;
			%F_roller(i,2)=0;
		end
		fprintf('%s',['marker #634' char(10)]);
	else
		fieldnumber=size(Nmatrix,3);
		
		F_rollerX=zeros(1,length(NodeswithPredXVel));
		for i=1:length(NodeswithPredXVel)
			for j=1:1
				nmomentum_si_old=nmomentum_si(NodeswithPredXVel(i),j,:);
				for field=1:fieldnumber
					nmomentum_si(NodeswithPredXVel(i),j,field)=nmass_si(NodeswithPredXVel(i),field)*PredXVel;
					nmomentum_si(NodeswithPredXVel(i),j,field)=nmass_si(NodeswithPredXVel(i),field)*PredXVel;
				end
				F_rollerX(i)=sum((nmomentum_si(NodeswithPredXVel(i),j,:)-nmomentum_si_old(1,1,:)))/dt;
				%nforce_si(NodeswithPredVel(i),j)=0;
			end
			%F_roller(i,2)=0;
		end
		
		for i=1:length(NodeswithPredXVel2)
			for j=1:1
				nmomentum_si_old=nmomentum_si(NodeswithPredXVel2(i),j,:);
				for field=1:fieldnumber
					nmomentum_si(NodeswithPredXVel2(i),j,field)=nmass_si(NodeswithPredXVel2(i),field)*PredXVel2;
				end
				F_rollerX(i)=sum((nmomentum_si(NodeswithPredXVel2(i),j,:)-nmomentum_si_old(1,1,:)))/dt;
				%nforce_si(NodeswithPredVel(i),j)=0;
			end
			%F_roller(i,2)=0;
		end
		
		
		F_rollerY=zeros(1,length(NodeswithPredYVel));
		for i=1:length(NodeswithPredYVel)
			for j=2:2
				nmomentum_si_old=nmomentum_si(NodeswithPredYVel(i),j,:);
				for field=1:fieldnumber
					nmomentum_si(NodeswithPredYVel(i),j,field)=nmass_si(NodeswithPredYVel(i),field)*PredYVel;
				end
				F_rollerY(i)=sum((nmomentum_si(NodeswithPredYVel(i),j,:)-nmomentum_si_old(1,1,:)))/dt;
				%nforce_si(NodeswithPredVel(i),j)=0;
			end
			%F_roller(i,2)=0;
		end
		
		for i=1:length(NodeswithPredYVel2)
			for j=2:2
				nmomentum_si_old=nmomentum_si(NodeswithPredYVel2(i),j,:);
				for field=1:fieldnumber
					nmomentum_si(NodeswithPredYVel2(i),j,field)=nmass_si(NodeswithPredYVel2(i),field)*PredYVel2;
				end
				%nforce_si(NodeswithPredVel(i),j)=0;
			end
			%F_roller(i,2)=0;
		end
	end
	if CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
		fprintf('%s',['marker #635' char(10)]);
		[v_ssp_out,x_sp_out] = Update_Prtcl_Posn_WPredVOR_optmzd(PredVelVect,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredXVel2,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredXVel2,PredYVel,PredYVel2,TheFieldSplit,fieldnumber,spSizes,CasetoRun);fprintf('%s',['marker #636' char(10)]);
		% updates particle position from nodal momentum
		% updates particle velocity from force balance
		% applies displacement-controlled dirichlet boundary
		% zero displacement dirichlet (fixed boundary) are dealt with separately via "dirichlet" function
	else
		[v_ssp_out,x_sp_out] = Update_Particle_Position_WithPredVel2(Nmatrix,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredXVel2,NodeswithPredXVel2,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredXVel2,PredYVel,PredYVel2,fieldnumber);
	end
	
	v_ssp_out=real(v_ssp_out);
	x_sp_out=real(x_sp_out);
	if CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		if (CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77) && length(x_crack)==0 %this should have been x_crackcenter
		elseif CasetoRun==84 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==96
			for icrackpath=1:length(x_crackcenter)
				[x_cracktop{icrackpath}] = UpdateCrackPosition_multi(Nmatrix_cracktop{icrackpath},NmatrixAll_cracktop{icrackpath},dt,nmass_si,nmomentum_si,x_cracktop{icrackpath});
				[x_crackbot{icrackpath}] = UpdateCrackPosition_multi(Nmatrix_crackbot{icrackpath},NmatrixAll_crackbot{icrackpath},dt,nmass_si,nmomentum_si,x_crackbot{icrackpath});
				for spcrack=1:size(x_crackcenter{icrackpath},1)
					x_crackcenter{icrackpath}(spcrack,:)=(x_cracktop{icrackpath}(spcrack,:)+x_crackbot{icrackpath}(spcrack,:))/2;
				end
			end
		elseif CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
			%NODES_cracktop_nullcopy=coder.nullcopy(NODES_cracktop); 
			%x_cracktop_nullcopy=coder.nullcopy(x_cracktop);
			%CONNECT_cracktop_nullcopy=coder.nullcopy(CONNECT_cracktop);
			%TheFieldSplit_cracktop_nullcopy=coder.nullcopy(TheFieldSplit_cracktop);
			%NODES_crackbot_nullcopy=coder.nullcopy(NODES_crackbot);
			%x_crackbot_nullcopy=coder.nullcopy(x_crackbot);
			%CONNECT_crackbot_nullcopy=coder.nullcopy(CONNECT_crackbot);
			%TheFieldSplit_crackbot_nullcopy=coder.nullcopy(TheFieldSplit_crackbot);
			fprintf('%s',['marker #637' char(10)]);
			x_crack=UpdateCrackPosition_multioptimized_topandbot(m_sp,N_crack,NODES_crack,CONNECT_crack,dt,nmass_si,nmomentum_si,x_crack,TheFieldSplit_cracktop,TheFieldSplit_crackbot,CasetoRun);
			%{
			for icrackpath=1:x_crack.npaths
				
				[temp_x_crack_top]=UpdateCrackPosition_multioptimized(N_cracktop{icrackpath},NODES_cracktop(icrackpath,:),CONNECT_cracktop_nullcopy{icrackpath},dt,nmass_si,nmomentum_si,x_crack.top(1:x_crack.nparticles(icrackpath),:,icrackpath),TheFieldSplit_cracktop{icrackpath});
				for i=1:size(temp_x_crack_top,1)
					for j=1:size(temp_x_crack_top,2)
						x_crack.top(i,j,icrackpath)=temp_x_crack_top(i,j);
					end
				end
				%fiasco went down above, solved for now
				[temp_x_crack_bot]=UpdateCrackPosition_multioptimized(N_crackbot{icrackpath},NODES_crackbot_nullcopy{icrackpath},CONNECT_crackbot_nullcopy{icrackpath},dt,nmass_si,nmomentum_si,x_crack.bot(1:x_crack.nparticles(icrackpath),:,icrackpath),TheFieldSplit_crackbot{icrackpath});
				for i=1:size(temp_x_crack_bot,1)
					for j=1:size(temp_x_crack_bot,2)
						x_crack.bot(i,j,icrackpath)=temp_x_crack_bot(i,j);
					end
				end
			end
			%x_cracktop_nullcopy=coder.nullcopy(x_cracktop);
			%x_crackbot_nullcopy=coder.nullcopy(x_crackbot);
			%}
			
			for icrackpath=1:x_crack.npaths
				for spcrack=1:x_crack.nparticles(icrackpath)
					for idimension=1:size(x_crack.center(:,:,icrackpath),2)
						x_crack.center(spcrack,idimension,icrackpath)=(x_crack.top(spcrack,idimension,icrackpath)+x_crack.bot(spcrack,idimension,icrackpath))/2;
					end
				end
			end
			fprintf('%s',['marker #638' char(10)]);
			
			%interpolate nodal temperature to crack particle below
			for icrackpath=1:x_crack.npaths
				for sp = 1:x_crack.nparticles(icrackpath)
					deltatemp=0;
					dx_sp=zeros(1,2);
					sigmaN=0;
					for j = 1:4
						
						npid	                       = CONNECT_crack.center.values(sp,j,icrackpath);
						%low mass filter
						if nmass_si(npid,TheFieldSplit_cracktop{icrackpath}(j,sp))<0.0001*m_sp(1)
							continue;
						end
						
						sigmaN=sigmaN+N_crack.center(1,j,sp,icrackpath);
						deltatemp=deltatemp+(temp_si_comb(npid)-temp0)*N_crack.center(1,j,sp,icrackpath);
					end
					%Nscale crack
					if sigmaN>0
						for i=1:2
							%x_crack.center(sp,i,icrackpath)=x_crack.center(sp,i,icrackpath)+dx_sp(1,i)/sigmaN;
							x_crack.deltatemp(sp,icrackpath)=deltatemp/sigmaN;
						end
					end
				end
			end
			
			fprintf('%s',['marker #638b' char(10)]);

		else
			%[x_crackcenter,x_cracktop,x_crackbot]=UpdateCrackPosition(x_crackcenter,x_cracktop,x_crackbot,nmass_si,nmomentum_si,Nmatrix_crack,Nmatrix_cracktop,Nmatrix_crackbot,dt,Nmatrixtop,Nmatrixbot,v_ssp_out,m_sp);
			[x_crack.center(1:x_crack.nparticles(1),:,1),x_crack.top(1:x_crack.nparticles(1),:,1),x_crack.bot(1:x_crack.nparticles(1),:,1)]=UpdateCrackPosition2(x_crack.center(:,:,1),x_crack.top(1:x_crack.nparticles(1),:,1),x_crack.bot(1:x_crack.nparticles(1),:,1),nmass_si,nmomentum_si,Nmatrix_crack,Nmatrix_cracktop,Nmatrix_crackbot,dt,Nmatrix,v_ssp_out,m_sp,nfbcx,nfbcy,fbcx,fbcy);
			% Nmatrix_crack: MPM Nmatrix for crack particles (green)
			% Nmatrix_cracktop: MPM Nmatrix for crack top surface particles (red)
			% Nmatrix_crackbot: MPM Nmatrix for crack bot surface particles (blue)
		end
	end
	Fyignore=[];
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
	elseif CasetoRun==4
	elseif CasetoRun==5 || CasetoRun==6
		ymomentumignore_new=m_sp.*v_ssp_out(:,2).*ignoremomentum;
		Fyignore=(ymomentumignore_new-ymomentumignore_prev)/dt;
	elseif CasetoRun==7
		ymomentumignore_new=m_sp.*v_ssp_out(:,2).*ignoremomentum;
		Fyignore=(ymomentumignore_new-ymomentumignore_prev)/dt;
	elseif CasetoRun==8 || CasetoRun==9
	elseif CasetoRun==10
		ymomentumignore_new=m_sp.*v_ssp_out(:,2).*ignoremomentum;
		Fyignore=(ymomentumignore_new-ymomentumignore_prev)/dt;
	elseif CasetoRun==11 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		ymomentumignore_new=m_sp.*v_ssp_out(:,2).*ignoremomentum;
		Fyignore=(ymomentumignore_new-ymomentumignore_prev)/dt;
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		ymomentumignore_new=m_sp.*v_ssp_out(:,2).*ignoremomentum;
		Fyignore=(ymomentumignore_new-ymomentumignore_prev)/dt;
	end
	%{
	[nvelo_si,L_si] = Interpolate_velocity_back(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp_out,N,dN,nmass_si);
	
	
	for i=1:length(NodeswithPredVel)
		for j=1:2
			nforce_si(NodeswithPredVel(i),j)=nmass_si(NodeswithPredVel(i))*PredAcc(j);
			for k=1:2
				nforce_si(NodeswithPredVel(i),j)=nforce_si(NodeswithPredVel(i),j)+L_si(i,j,k)*nmomentum_si(NodeswithPredVel(i),k);
			end
		end
	end
	[v_ssp_out,x_sp_out] = Update_Particle_Position_WithPredVel(NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredVel,PredVel);
	%}
	%% Update solid particle velocity and position
	% velocity particle: v_ssp
	% position particle: x_sp
	% displacement particle: d_sp
	%{
	for i=1:numberofparticleswithpredeterminedvelocities
		for j=1:2
			v_ssp_out(particleswithpredeterminedvelocities(i),j)=predeterminedvelocityvalue(i,j);
		end
	end
	%}
	%{
	for i=1:numberofparticleswithpredeterminedvelocities
		%v_ssp(particleswithpredeterminedvelocities(i),1)=predeterminedvelocityvalue(1);
		%v_ssp(particleswithpredeterminedvelocities(i),2)=predeterminedvelocityvalue(2);
		%x_sp_out(particleswithpredeterminedvelocities(i),1)=x_sp(particleswithpredeterminedvelocities(i),1)+predeterminedvelocityvalue(1)*dt;
		%x_sp_out(particleswithpredeterminedvelocities(i),2)=x_sp(particleswithpredeterminedvelocities(i),2)+predeterminedvelocityvalue(2)*dt;
	end
	%}
	%% Mapping nodal velocity back to node
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==4 || CasetoRun==5 || CasetoRun==6 || CasetoRun==7 || CasetoRun==10 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		if CompareTexts(Version,'CPDI')
			[N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix,CONNECTpn] = Compute_Interpolator_CPDI(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp);
		elseif CompareTexts(Version,'MPM')
		else
			fprintf('%s',['Invalid Version Input' char(10)]);
		end
	elseif CasetoRun==8 || CasetoRun==9
		if CompareTexts(Version,'CPDI')
			[N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix] = Compute_Interpolator_CPDI_var(spCount,cellCount,x_sp,le_c,NN,LOC,r1_sp,r2_sp,A_sp,LOCX,LOCY);
		elseif CompareTexts(Version,'MPM')
		else
			fprintf('%s',['Invalid Version Input' char(10)]);
		end
	elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
	elseif CasetoRun==154 || CasetoRun==161
		%quan's cpdi fix goes here
		
		%fix activated
		[N,dN,CONNECT,spElems,mspoints,NODES,CONNECTpn,~] = Compute_Interpolator_CPDI_optimized(spCount,cellCount,x_sp_out,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp,0,1);fprintf('%s',['marker #815' char(10)]);
		if x_crack_length==0;
			%TheFieldSplit=ones(NN(1)*NN(2),spCount); % to stop coder whining
			TheFieldSplit=zeros(FindMaxVal(spSizes),lengthCONNECT);
			TheFieldSplit=ones(FindMaxVal(spSizes),lengthCONNECT);
			fieldnumber=1;
		else
			fprintf('%s',['marker #811' char(10)]);
			[TheFieldSplitBase3_old,TheFieldSplitBase3_sp,spSizes] = SplitFieldMultiOptimized2(LOC,x_sp_out,CONNECT,CONNECTpn,x_crack,t_time,le);
			fprintf('%s',['marker #814' char(10)]);
			%shit up there
			ncrackpath=x_crack_length;
			maplist=zeros(1000,ncrackpath);
			maplistsize=1;
			coder.varsize('maplist');
			maplist(1,:)=ones(1,ncrackpath);
			[TheFieldSplit,maplist,maplistsize]=Base3Mapping_sp(TheFieldSplitBase3_sp,CONNECT,maplist,maplistsize,niCount);fprintf('%s',['marker #812' char(10)]);
			fieldnumber=maplistsize;fprintf('%s',['marker #813' char(10)]);
		end
		
		%Recalculate TheFieldSplit_sp only?
	end
	
	if CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
		fprintf('%s',['marker #639' char(10)]);
		[nvelo_si] = Interpolate_velocity_back_optimized(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp_out,N,dN,nmass_si,TheFieldSplit,fieldnumber);fprintf('%s',['marker #640' char(10)]);
	elseif CasetoRun==154 || CasetoRun==161
		%quan's cpdi fix for nmass
		fprintf('%s',['marker #639' char(10)]);
		[nvelo_si] = Interpolate_velocity_back_optimized_msp(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp_out,N,dN,TheFieldSplit,fieldnumber);fprintf('%s',['marker #640' char(10)]);
	else
		[nvelo_si,~] = Interpolate_velocity_back(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp_out,N,dN,nmass_si,Nmatrix,dNxmatrix,dNymatrix);
	end
	% Boundary condition
	[nvelo_si] = Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,nvelo_si); % Boundary condition for nodal force
	%% Update effective stress
	AbeforeQ=zeros(2,2,2,2,spCount); %to stop coder whining
	AbeforeQ_rtl=zeros(2,2,2,2,spCount); %to prevent coder whining
	if CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
		fprintf('%s',['marker #641' char(10)]);
		if CloseEnough(t_time,0.0013958250738250609253310319246566,1e-5,2)
			1;
		end
		%sse_sp: specific (volume) elastic strain energy
		[e_t_schmidtswellsonly,e_t_schmidtglobalmatrixsimple,sse_sp,F_sp,A_sp,t_sp,s_sp,p_sp,E_acc,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,evaltimes,stackvars,duration,dudx_sp,W_sp,thetacrackrtl,thetacrack,justcracked,Qacoustic,h,RQ,QbackRback,AbeforeQ,Ktangent_local] = ...
			Update_Stress_par_optimized(e_t_schmidtswellsonly,e_t_schmidtglobalmatrixsimple,CModel,NODES,dt,cellCount,mspoints,CONNECT,nvelo_si,dN,E,nu,F_sp,A_spo,t_spo,m_sp,s_sp,p_sp,A_sp,t_sp,E_acc,epsilonshrinkdot_sp,epsilonshrinkdotmat_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,troubleshotparticles,matmodel,k_sp,kdot_sp,weakeningfactor_sp,orientationoffset,Rdisplayedparticles,t_time,Debugging,spCount,dudx_sp,W_sp,thetacrackrtl,TheFieldSplit,fieldnumber,Efactor_sp);
		%LOC and everything previous is temporary here
		fprintf('%s',['marker #642' char(10)]);
		if max(max(alphahp))>0
			1;
		end
	else
		[F_sp,A_sp,t_sp,s_sp,p_sp,E_acc,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,evaltimes,stackvars,duration,dudx_sp,W_sp,thetacrackrtl,thetacrack,justcracked,Qacoustic,h,RQ,QbackRback,AbeforeQ_rtl] = ...
			Update_Stress_par(CModel,NODES,dt,cellCount,mspoints,CONNECT,nvelo_si,dN,E,nu,F_sp,A_spo,t_spo,m_sp,s_sp,p_sp,A_sp,t_sp,E_acc,epsilonshrinkdot_sp,epsilonshrinkdotmat_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,troubleshotparticles,matmodel,k_sp,kdot_sp,weakeningfactor_sp,orientationoffset,Rdisplayedparticles,t_time,Debugging,Nmatrix,dNxmatrix,dNymatrix,spCount,dudx_sp,W_sp,thetacrackrtl); %this function is deactivated, check zz2008221605.m for last working version
	end
	f_nucleate=2;
	n=zeros(2,1);
	expansion=2;
	icrackparticle=0;
	AbeforeQ_si=zeros(2,2,2,2,nodeCount,fieldnumber);
	AbeforeQ_si_active=zeros(nodeCount,fieldnumber);
	if (CasetoRun==72) && length(x_crack)==0 %x_crack here is all wrong, shouldve been x_crackcenter, cant change it now bcs x_crackcenter is not passed to the function
		s_max_max=-inf;
		s_max_max_num=0;
		thetamax=zeros(1,spCount);
		thetamin=zeros(1,spCount);
		s_max=zeros(1,spCount);
		s_min=zeros(1,spCount);
		s_shear=zeros(1,spCount);
		for sp=1:spCount
			theta=1/2*atan(2*s_sp(sp,3)/(s_sp(sp,1)-s_sp(sp,2)));
			s_first=(s_sp(sp,1)+s_sp(sp,2))/2+(s_sp(sp,1)-s_sp(sp,2))/2*cos(2*theta)+s_sp(sp,3)*sin(2*theta);
			s_second=(s_sp(sp,1)+s_sp(sp,2))/2-(s_sp(sp,1)-s_sp(sp,2))/2*cos(2*theta)-s_sp(sp,3)*sin(2*theta);
			if s_first>s_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
			s_max(sp)=max(s_first,s_second);
			s_min(sp)=min(s_first,s_second);
			s_shear(sp)=(s_max(sp)-s_min(sp))/2;
			if s_max(sp)>s_max_max
				s_max_max_num=sp;
				s_max_max=s_max(sp);
				s_max_theta=thetamin(sp);
			end
		end
		fprintf('%s',['s_max_max=' float2txt(5,s_max_max) ', s_max_theta=' float2txt(5,s_max_theta) ', s_max_max_num=' float2txt(5,s_max_max_num) char(10)]);
		if s_max_max>f_nucleate
			lp=zeros(1,1);
			lp(1)=le(1)/2;
			s_max_theta=mod(s_max_theta+pi,pi)-pi;
			x_crack(2,:)=x_sp(s_max_max_num,:)-lp(1)/2*[cos(s_max_theta) sin(s_max_theta)];
			x_crack(3,:)=x_sp(s_max_max_num,:)+lp(1)/2*[cos(s_max_theta) sin(s_max_theta)];
			x_crack(1,:)=x_crack(2,:)-le(1)*[cos(s_max_theta) sin(s_max_theta)];
			x_cracktop=x_crack;
			x_crackbot=x_crack;
		end
	elseif CasetoRun==73
	elseif CasetoRun==123 || CasetoRun==125 || CasetoRun==126 || CasetoRun==128 || CasetoRun==130
		
		%crack propagation of 123 (gauss average)
		%currently propagation only
		no=niCount;
		%s_tip(ipath,dim,itip);
		int_s_tip_dA=zeros(x_crack.npaths,3,2); %ipath, dimension, which tip
		s_tip=zeros(x_crack.npaths,3,2); %ipath, dimension, which tip
		s_tip_gauss=zeros(x_crack.npaths,3,2,x_crack.gauss.npoints); %ipath, dimension, which tip, igausspoint
		deltax_previous=zeros(1,2,1);
		theta_crack_trial=zeros(1,2);
		deltatheta_crack=zeros(1,2);
		s_tip_dump=zeros(2*x_crack.npaths,3);
		s_tip_K1_dump=zeros(2*x_crack.npaths,3);
		x_tip_dump=zeros(2*x_crack.npaths,2);
		s_gauss_dump=zeros(2*x_crack.gauss.npoints*x_crack.npaths,3);
		x_gauss_dump=zeros(2*x_crack.gauss.npoints*x_crack.npaths,2);
		sigmaW=zeros(1,1);
		icrackparticle=1;
		tip_dumpcounter=0;
		gauss_dumpcounter=0;
		for tip=2:-1:1
			%tip=1: particle of highest index
			%tip=2: particle of lowerst index
			for ipath=1:x_crack.npaths
				if tip==2
					icrackparticle=x_crack.nparticles(ipath);
				elseif tip==1
					icrackparticle=1;
				end
				for igausspoint=1:x_crack.gauss.npoints
					for nio=1:4
						io=CONNECT_crack.gauss(igausspoint,nio,ipath,tip);
						for dim=1:3
							s_tip_gauss(ipath,dim,tip,igausspoint)=s_tip_gauss(ipath,dim,tip,igausspoint)+s_si_comb(io,dim)*N_crack.gauss(1,nio,igausspoint,ipath,tip);
						end
					end
					gauss_dumpcounter=gauss_dumpcounter+1;
					for dim=1:3
						s_gauss_dump(gauss_dumpcounter,dim)=s_tip_gauss(ipath,dim,tip,igausspoint);
					end
					for dim=1:2
						x_gauss_dump(gauss_dumpcounter,dim)=x_crack.gauss.locs(igausspoint,dim,ipath,tip);
					end
				end
				%plot(x_tip_dump(1:200,1),x_tip_dump(1:200,2),'o');
				sigmaW=0;
				for igausspoint=1:x_crack.gauss.npoints
					for dim=1:3
						int_s_tip_dA(ipath,dim,tip)=int_s_tip_dA(ipath,dim,tip)+s_tip_gauss(ipath,dim,tip,igausspoint)*x_crack.gauss.weights(igausspoint,ipath,tip);
					end
					sigmaW=sigmaW+x_crack.gauss.weights(igausspoint,ipath,tip);
				end
				1;
				for dim=1:3
					s_tip(ipath,dim,tip)=int_s_tip_dA(ipath,dim,tip)/sigmaW;
				end
				1;
				tip_dumpcounter=tip_dumpcounter+1;
				for dim=1:3
					s_tip_dump(tip_dumpcounter,dim)=s_tip(ipath,dim,tip);
				end
				1;
				for dim=1:2
					x_tip_dump(tip_dumpcounter,dim)=x_crack.center(icrackparticle,dim,ipath);
				end
				s_tip_max=(s_tip(ipath,1,tip)+s_tip(ipath,2,tip))/2+sqrt( ((s_tip(ipath,1,tip)-s_tip(ipath,2,tip))/2)^2 + (s_tip(ipath,3,tip))^2 ); %calculate principal stress
				elasticstrength=0.0125;
				if s_tip_max>elasticstrength
					theta_crack=0.5*(pi-reliableatan((s_tip(ipath,1,tip)-s_tip(ipath,2,tip))/2,-s_tip(ipath,3,tip)));
					crackextension=le(1);
					if tip==2
						deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
					elseif tip==1
						deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
					end
					%theta_previous=reliableatan(deltax_previous(1,1,1),deltax_previous(1,2,1));
					theta_crack_trial(1)=theta_crack;
					theta_crack_trial(2)=mod(theta_crack+pi,2*pi); %two possibilities for crack angle, 
					if (deltax_previous(1,1,1)*cos(theta_crack_trial(1))+deltax_previous(1,2,1)*sin(theta_crack_trial(1)))>0 % cos of theta_crack_trial with current crack tip trajectory
						theta_crack=theta_crack_trial(1);
					else
						theta_crack=theta_crack_trial(2);
					end
					if tip==2
						x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+crackextension*cos(theta_crack);
						x_crack.top(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
						x_crack.bot(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
						x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+crackextension*sin(theta_crack);
						x_crack.top(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
						x_crack.bot(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
					elseif tip==1
						for icrackparticlemove=x_crack.nparticles(ipath):-1:1
							for dim=1:2
								x_crack.center(icrackparticlemove+1,dim,ipath)=x_crack.center(icrackparticlemove,dim,ipath);
								x_crack.top(icrackparticlemove+1,dim,ipath)=x_crack.top(icrackparticlemove,dim,ipath);
								x_crack.bot(icrackparticlemove+1,dim,ipath)=x_crack.bot(icrackparticlemove,dim,ipath);
							end
						end
						x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+crackextension*cos(theta_crack);
						x_crack.top(1,1,ipath)=x_crack.center(1,1,ipath);
						x_crack.bot(1,1,ipath)=x_crack.center(1,1,ipath);
						x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+crackextension*sin(theta_crack);
						x_crack.top(1,2,ipath)=x_crack.center(1,2,ipath);
						x_crack.bot(1,2,ipath)=x_crack.center(1,2,ipath);
					end
					x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
				end
			end
		end
		1;
		
		%{
		justcrackednodes=zeros(1,no);
		crackanglenodes=zeros(1,no);
		nfield=fieldnumber;
		elasticstrength=0.125;
		for io=1:no
			for ifield=1:nfield
				sigmamaxprinc=(s_si(io,1,ifield)+s_si(io,2,ifield))/2+sqrt(((s_si(io,1,ifield)-s_si(io,2,ifield))/2)^2+(s_si(io,3,ifield))^2);
				if sigmamaxprinc>elasticstrength
					justcrackednodes(io)=1;
					crackanglenodes(io)=0.5*(pi-reliableatan((s_sp(1,1)-s_sp(1,2))/2,-s_sp(1,3)));
				end
			end
		end
		fprintf('%s',['marker #643b' char(10)]);
		if sum(justcrackednodes)>0
			justcrackedlist=zeros(sum(justcrackednodes),1);
			justcrackedcounter=0;
			for io=1:no
				if justcrackednodes(io)
					justcrackedcounter=justcrackedcounter+1;
					justcrackedlist(justcrackedcounter)=io;
				end
			end
			
			justcrackedlist=CrackParticleClustering_nodes(LOC,1.5*le(1),justcrackedlist);
			ntestedangle=size(Qacoustic{justcrackedlist{1}(1)},3);
			theta=zeros(ntestedangle,1);
			errorntestedangle=36*1*1*1;
			error=zeros(1,errorntestedangle);
			
			for crackgroup=1:length(justcrackedlist)
				justcrackedcounter=length(justcrackedlist{crackgroup});	
				x_justcrackedcenter=zeros(2,1);
				x_justcrackedcenter(1)=sum(LOC(justcrackedlist{crackgroup},1))/justcrackedcounter;
				x_justcrackedcenter(2)=sum(LOC(justcrackedlist{crackgroup},2))/justcrackedcounter;
				for i=1:errorntestedangle
					theta(i)=(i-1)/36*1*1*1*pi;
					error(i)=0;
					for spc=1:justcrackedcounter
						error(i)=error(i)+(mod(thetacrack(justcrackedlist{crackgroup}(spc))-theta(i)+pi/2,pi)-pi/2)^2;
					end
				end
				thetajustcrackedcenter=theta(FindMin(error));
				considered=ones(x_crack.npaths,2);
				distancelist=zeros(x_crack.npaths,2);
				thetapropagationlist=zeros(x_crack.npaths,2);
				n_nairncrack0=0;
				n_nairncrack1=0;
				for icrackpath=x_crack.npaths:-1:1
					for whichtip=1:2
						if whichtip==1
							n_nairncrack1=x_crack.nparticles(icrackpath);
							n_nairncrack0=n_nairncrack1-1;
						elseif whichtip==2
							n_nairncrack1=1;
							n_nairncrack0=2;
						else
							fprintf('%s',['whichtip error! 1904151959' char(10)]);
							pause;
							1;
						end
						
						x_cracktip=x_crack.center(n_nairncrack1,:,icrackpath);
						thetatocrackcenter=reliableatan(x_justcrackedcenter(1)-x_cracktip(1),x_justcrackedcenter(2)-x_cracktip(2));
						theta_prev=reliableatan(x_crack.center(n_nairncrack1,1,icrackpath)-x_crack.center(n_nairncrack0,1,icrackpath),x_crack.center(n_nairncrack1,2,icrackpath)-x_crack.center(n_nairncrack0,2,icrackpath));
						deltatheta_tocrackvsprev=mod(thetatocrackcenter-theta_prev+pi,2*pi)-pi;
						if abs(deltatheta_tocrackvsprev)>pi
							fprintf('%s',['deltatheta_tocrackvsprev error! 1904112048' char(10)]);
							pause;
							1;
						end
						if abs(deltatheta_tocrackvsprev)>pi/2
							considered(icrackpath,whichtip)=0;
							distancelist(icrackpath,whichtip)=inf;
							continue;
						end
						propagationlength=sqrt((x_crack.center(n_nairncrack1,1,icrackpath)-x_justcrackedcenter(1))^2+(x_crack.center(n_nairncrack1,2,icrackpath)-x_justcrackedcenter(2))^2);
						if propagationlength>1.5*le(1)
							considered(icrackpath,whichtip)=0;
							distancelist(icrackpath,whichtip)=inf;
							continue;
						end
						distancelist(icrackpath,whichtip)=propagationlength;
						for i=1:36*1*1*1
							theta(i)=(i-1)/36*1*1*1*2*pi;
							error(i)=(mod(thetajustcrackedcenter-theta(i)+pi/2,pi)-pi/2)^2+(mod(thetatocrackcenter-theta(i)+pi,2*pi)-pi)^2;
						end
						theta_crackpropagation=theta(FindMin(error));
						theta_crackpropagation=mod(theta_crackpropagation-theta_prev+pi,2*pi)+theta_prev-pi;
						thetapropagationlist(icrackpath,whichtip)=theta_crackpropagation;
					end
				end
				if sum(sum(considered))>0
					ncrackandwhichtip=FindMinMatrix(distancelist);
					icrackpath=ncrackandwhichtip(1);
					whichtip=ncrackandwhichtip(2);
					if whichtip==1
						n_nairncrack1=x_crack.nparticles(icrackpath);
					else
						n_nairncrack1=1;
					end
					propagationlength=distancelist(icrackpath,whichtip);
					theta_crackpropagation=thetapropagationlist(icrackpath,whichtip);
					idealpropagationlength=le(1)/4; %assuming lp(1)==lp(2)
					%propagationlengthreductionfactor=max([1 round(propagationlength/idealpropagationlength)]);
					propagationlengthreductionfactor=1;
					if whichtip==1
						x_crack.nparticles(icrackpath)=x_crack.nparticles(icrackpath)+propagationlengthreductionfactor;
						for i=1:propagationlengthreductionfactor
							x_crack.center(n_nairncrack1+i,:,icrackpath)=[x_crack.center(n_nairncrack1,1,icrackpath)+i/propagationlengthreductionfactor*propagationlength*cos(theta_crackpropagation) x_crack.center(n_nairncrack1,2,icrackpath)+i/propagationlengthreductionfactor*propagationlength*sin(theta_crackpropagation)];
							x_crack.top(n_nairncrack1+i,:,icrackpath)=x_crack.center(n_nairncrack1+i,:,icrackpath);
							x_crack.bot(n_nairncrack1+i,:,icrackpath)=x_crack.center(n_nairncrack1+i,:,icrackpath);
						end
					elseif whichtip==2
						for i=x_crack.nparticles(icrackpath):-1:1
							x_crack.center(i+propagationlengthreductionfactor,:,icrackpath)=x_crack.center(i,:,icrackpath);
							x_crack.top(i+propagationlengthreductionfactor,:,icrackpath)=x_crack.top(i,:,icrackpath);
							x_crack.bot(i+propagationlengthreductionfactor,:,icrackpath)=x_crack.bot(i,:,icrackpath);
						end
						x_crack.nparticles(icrackpath)=x_crack.nparticles(icrackpath)+propagationlengthreductionfactor;
						n_nairncrack1=n_nairncrack1+propagationlengthreductionfactor;
						for i=1:propagationlengthreductionfactor
							x_crack.center(n_nairncrack1-i,:,icrackpath)=[x_crack.center(n_nairncrack1,1,icrackpath)+i/propagationlengthreductionfactor*propagationlength*cos(theta_crackpropagation) x_crack.center(n_nairncrack1,2,icrackpath)+i/propagationlengthreductionfactor*propagationlength*sin(theta_crackpropagation)];
							x_crack.top(n_nairncrack1-i,:,icrackpath)=x_crack.center(n_nairncrack1-i,:,icrackpath);
							x_crack.bot(n_nairncrack1-i,:,icrackpath)=x_crack.center(n_nairncrack1-i,:,icrackpath);
						end
					else
						fprintf('%s',['which tip error! 1904151909' char(10)]);
						pause;
						1;
					end
				else
					intheprevention=0;
					preventiondistance=0.075*le_base;
					preventionangle=pi/4;
					for icrackpath=1:x_crack.npaths;
						for spcrack=1:(x_crack.nparticles(icrackpath)-1)
							vector1a=[(x_justcrackedcenter(1)-x_crack.center(spcrack,1,icrackpath));(x_justcrackedcenter(2)-x_crack.center(spcrack,2,icrackpath))];
							vector1b=[(x_justcrackedcenter(1)-x_crack.center(spcrack+1,1,icrackpath));(x_justcrackedcenter(2)-x_crack.center(spcrack+1,2,icrackpath))];
							distance1a=sqrt(dot(vector1a,vector1a));
							distance1b=sqrt(dot(vector1b,vector1b));
							
							distance1a_old=sqrt((x_justcrackedcenter(1)-x_crack.center(spcrack,1,icrackpath))^2+(x_justcrackedcenter(2)-x_crack.center(spcrack,2,icrackpath))^2);
							distance1b_old=sqrt((x_justcrackedcenter(1)-x_crack.center(spcrack+1,1,icrackpath))^2+(x_justcrackedcenter(2)-x_crack.center(spcrack+1,2,icrackpath))^2);
							
							distance1=min([distance1a distance1b]);
							
							area2=abs(TriangleArea(x_justcrackedcenter,x_crack.center(spcrack,:,icrackpath),x_crack.center(spcrack+1,:,icrackpath)));
							
							inbetween2vector=[(x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath));(x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath))];
							
							inbetween2=sqrt(dot(inbetween2vector,inbetween2vector));
							
							inbetween2_old=sqrt((x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath))^2+(x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath))^2);
							distance2=area2/inbetween2;
							
							signcos1=dot(vector1a,inbetween2vector);
							signcos2=dot(vector1b,inbetween2vector);
							
							if signcos1*signcos2>0
								distance=distance1;
							else
								distance=distance2;
							end
							
							if distance<preventiondistance
								thetanairncrack=reliableatan(x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath),x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath));
								
								absdeltatheta=abs(mod(thetanairncrack-thetajustcrackedcenter+pi/2,pi)-pi/2);
								
								if absdeltatheta<preventionangle
									intheprevention=1;
								end
							end
							if intheprevention==1
								break;
							end
						end
						if intheprevention==1
							break;
						end
					end
					if intheprevention==0
						thetainitiate=mod(thetajustcrackedcenter-pi,pi)+pi; %always pointing down, pi<theta<2*pi
						icrackpath=x_crack.npaths+1;
						x_crack.npaths=x_crack.npaths+1;
						x_crack.nparticles(icrackpath)=2;
						x_crack.center(2,2,icrackpath)=x_justcrackedcenter(2)+le(1)/2/2*sin(thetainitiate); %assuming le(1)=le(2);
						x_crack.center(2,1,icrackpath)=x_justcrackedcenter(1)+le(1)/2/2*cos(thetainitiate);
						x_crack.center(1,2,icrackpath)=x_justcrackedcenter(2)-le(1)/2/2*sin(thetainitiate);
						x_crack.center(1,1,icrackpath)=x_justcrackedcenter(1)-le(1)/2/2*cos(thetainitiate);
						%fprintf('%s',['>>line 8967: size(x_crack' int2txt(icrackpath) '},1)=' int2txt(x_crack.nparticles(icrackpath)) char(10)]);
						%fprintf('%s',['>>line 8968: size(x_cracktop{' int2txt(icrackpath) '},1)=' int2txt(size(x_cracktop{icrackpath},1)) char(10)]);
						%{
						for i=1:size(x_cracktop{icrackpath},1)
							for j=1:size(x_cracktop{icrackpath},2)
								%fprintf('%s',['>>line 8973: x_cracktop{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_cracktop{icrackpath}(i,j)) char(10)]);
							end
						end
						for i=1:size(x_crackbot{icrackpath},1)
							for j=1:size(x_crackbot{icrackpath},2)
								%fprintf('%s',['>>line 8980: x_crackbot{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackbot{icrackpath}(i,j)) char(10)]);
							end
						end
						for i=1:size(x_crackcenter{icrackpath},1)
							for j=1:size(x_crackcenter{icrackpath},2)
								%fprintf('%s',['>>line 8987: x_crackcenter{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackcenter{icrackpath}(i,j)) char(10)]);
							end
						end
						%}
						for i=1:x_crack.nparticles(icrackpath)
							for j=1:2
								%fprintf('%s',['>>line 8973: x_crackcenter{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackcenter{icrackpath}(i,j)) char(10)]);
								x_crack.top(i,j,icrackpath)=x_crack.center(i,j,icrackpath);
								x_crack.bot(i,j,icrackpath)=x_crack.center(i,j,icrackpath);
							end
						end
						%shit below
						%x_cracktop{icrackpath}=x_crackcenter{icrackpath};
						%x_crackbot{icrackpath}=x_crackcenter{icrackpath};
						%shit above
					end
					%soundplay
					1;
				end
				
				%{
				%switchable1
				soundplay;
				%}
				%switchable1
				1; %pause multi average and propagate here
			end
			
		end
		fprintf('%s',['marker #644b' char(10)]);
		%}
	elseif CasetoRun==127 || CasetoRun==132 || CasetoRun==131
		%crack propagation of 118 (node centric not particle)
		%node centric propagation
		%no gauss propagation
		%currently propagation only
		no=niCount;
		%s_tip(ipath,dim,itip);
		s_tip=zeros(x_crack.npaths,3,2);
		s_tip_K1=zeros(x_crack.npaths,3,2); %ncrackpaths; dimension (x and y); which tip
		deltax_previous=zeros(1,2,1);
		theta_crack_trial=zeros(1,2);
		deltatheta_crack=zeros(1,2);
		s_tip_dump=zeros(2*x_crack.npaths,3);
		s_tip_K1_dump=zeros(2*x_crack.npaths,3);
		x_tip_dump=zeros(2*x_crack.npaths,2);
		K1_maxradius=3*le(1);
		K1_estimate=zeros(1,2);
		K1_distance=zeros(1,2);
		for tip=1:2
			%tip=1: particle of highest index
			%tip=2: particle of lowerst index
			for ipath=1:x_crack.npaths
				if tip==1
					icrackparticle=x_crack.nparticles(ipath);
				elseif tip==2
					icrackparticle=1;
				end
				closestro=1; % i of (relevant) node with highest N
				for ro=2:4
					if N_crack.center(1,ro,icrackparticle,ipath)>N_crack.center(1,ro-1,icrackparticle,ipath)
						closestro=ro;
					end
				end
				closestio=CONNECT_crack.center.values(icrackparticle,closestro,ipath);
				for dim=1:2
					K1_distance(dim)=LOC(closestio,dim)-x_crack.center(icrackparticle,dim,ipath);
				end
				K1_r=sqrt(dot(K1_distance,K1_distance));
				K1_theta=reliableatan(K1_distance(1),K1_distance(2));
				K1_estimate(1)=s_si_comb(closestio,1)*sqrt(2*pi*K1_r)/(cos(K1_theta/2)*(1-sin(K1_theta/2)*sin(3*K1_theta/2))); %K1 related to sigmaxx
				K1_estimate(2)=s_si_comb(closestio,2)*sqrt(2*pi*K1_r)/(cos(K1_theta/2)*(1+sin(K1_theta/2)*sin(3*K1_theta/2))); %K1 related to sigmayy
				K1_estimate_taken=0.5*abs(sum(K1_estimate));
				
				for io=1:niCount %what's the proper term for niCount now, "no" (Number of nOdes)?
					for dim=1:2
						K1_distance(dim)=LOC(io,dim)-x_crack.center(icrackparticle,dim,ipath);
					end
					K1_r=sqrt(dot(K1_distance,K1_distance));
					if K1_r<K1_maxradius
						K1_theta=reliableatan(K1_distance(1),K1_distance(2));
						s_si_K1(io,1)=K1_estimate_taken/sqrt(2*pi*K1_r)*(cos(K1_theta/2)*(1-sin(K1_theta/2)*sin(3*K1_theta/2))); %K1 related to sigmaxx
						s_si_K1(io,2)=K1_estimate_taken/sqrt(2*pi*K1_r)*(cos(K1_theta/2)*(1+sin(K1_theta/2)*sin(3*K1_theta/2))); %K1 related to sigmayy
						s_si_K1(io,3)=K1_estimate_taken/sqrt(2*pi*K1_r)*(cos(K1_theta/2)*sin(K1_theta/2)*cos(3*K1_theta/2)); %K1 related to sigmayy
					end
				end
				for nio=1:4
					io=CONNECT_crack.center.values(icrackparticle,nio,ipath);
					for dim=1:3
						s_tip(ipath,dim,tip)=s_tip(ipath,dim,tip)+s_si_comb(io,dim)*N_crack.center(1,nio,icrackparticle,ipath);
						s_tip_K1(ipath,dim,tip)=s_tip_K1(ipath,dim,tip)+s_si_K1(io,dim)*N_crack.center(1,nio,icrackparticle,ipath);
					end
				end
				for dim=1:3
					s_tip_dump(2*(ipath-1)+tip,dim)=s_tip(ipath,dim,tip);
					s_tip_K1_dump(2*(ipath-1)+tip,dim)=s_tip_K1(ipath,dim,tip);
				end
				for dim=1:2
					x_tip_dump(2*(ipath-1)+tip,dim)=x_crack.center(icrackparticle,dim,ipath);
				end
				s_tip_max=(s_tip(ipath,1,tip)+s_tip(ipath,2,tip))/2+sqrt( ((s_tip(ipath,1,tip)-s_tip(ipath,2,tip))/2)^2 + (s_tip(ipath,3,tip))^2 ); %calculate principal stress
				elasticstrength=0.0125;
				if s_tip_max>elasticstrength
					theta_crack=0.5*(pi-reliableatan((s_tip(ipath,1,tip)-s_tip(ipath,2,tip))/2,-s_tip(ipath,3,tip)));
					crackextension=le(1);
					if tip==1
						deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
					elseif tip==2
						deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
					end
					%theta_previous=reliableatan(deltax_previous(1,1,1),deltax_previous(1,2,1));
					theta_crack_trial(1)=theta_crack;
					theta_crack_trial(2)=mod(theta_crack+pi,2*pi); %two possibilities for crack angle, 
					if (deltax_previous(1,1,1)*cos(theta_crack_trial(1))+deltax_previous(1,2,1)*sin(theta_crack_trial(1)))>0 % cos of theta_crack_trial with current crack tip trajectory
						theta_crack=theta_crack_trial(1);
					else
						theta_crack=theta_crack_trial(2);
					end
					if tip==1
						x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+crackextension*cos(theta_crack);
						x_crack.top(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
						x_crack.bot(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
						x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+crackextension*sin(theta_crack);
						x_crack.top(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
						x_crack.bot(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
					elseif tip==2
						for icrackparticlemove=x_crack.nparticles(ipath):-1:1
							for dim=1:2
								x_crack.center(icrackparticlemove+1,dim,ipath)=x_crack.center(icrackparticlemove,dim,ipath);
								x_crack.top(icrackparticlemove+1,dim,ipath)=x_crack.top(icrackparticlemove,dim,ipath);
								x_crack.bot(icrackparticlemove+1,dim,ipath)=x_crack.bot(icrackparticlemove,dim,ipath);
							end
						end
						x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+crackextension*cos(theta_crack);
						x_crack.top(1,1,ipath)=x_crack.center(1,1,ipath);
						x_crack.bot(1,1,ipath)=x_crack.center(1,1,ipath);
						x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+crackextension*sin(theta_crack);
						x_crack.top(1,2,ipath)=x_crack.center(1,2,ipath);
						x_crack.bot(1,2,ipath)=x_crack.center(1,2,ipath);
					end
					x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
				end
			end
		end
	elseif CasetoRun==133 || CasetoRun==135 || CasetoRun==134 || CasetoRun==129 || CasetoRun==138
		%crack propagation of 133
		%propagation denied for this
		%node centric propagation
		%no gauss propagation
		%currently propagation only
		no=niCount;
		%s_tip(ipath,dim,itip);
		s_tip=zeros(x_crack.npaths,3,2);
		s_tip_K1=zeros(x_crack.npaths,3,2); %ncrackpaths; dimension (x and y); which tip
		deltax_previous=zeros(1,2,1);
		theta_crack_trial=zeros(1,2);
		deltatheta_crack=zeros(1,2);
		s_tip_dump=zeros(2*x_crack.npaths,3);
		s_tip_K1_dump=zeros(2*x_crack.npaths,3);
		x_tip_dump=zeros(2*x_crack.npaths,2);
		r_propdirweighted_dump=zeros(2*x_crack.npaths,2);
		K1_maxradius=3*le(1);
		K1_estimate=zeros(1,2);
		K1_distance=zeros(1,2);
		r_propdirweighted=zeros(x_crack.npaths,2,2); %crackpath num, dimension, which tip
		sigma_maxprinc_magnitude=0;
		r_propdircompliment=zeros(1,2);
		a_transform=zeros(2,2);
		s_tip_tensor=zeros(2,2);
		s_tip_tensor_transformed=zeros(2,2);
		%r_propdirweighted=zeros(1,2); %dimension only
		for tip=1:2
			%tip=1: particle of highest index
			%tip=2: particle of lowerst index
			for ipath=1:x_crack.npaths
				if tip==1
					icrackparticle=x_crack.nparticles(ipath);
				elseif tip==2
					icrackparticle=1;
				end
				closestro=1; % i of (relevant) node with highest N
				for ro=2:4
					if N_crack.center(1,ro,icrackparticle,ipath)>N_crack.center(1,ro-1,icrackparticle,ipath)
						closestro=ro;
					end
				end
				closestio=CONNECT_crack.center.values(icrackparticle,closestro,ipath);
				for dim=1:2
					K1_distance(dim)=LOC(closestio,dim)-x_crack.center(icrackparticle,dim,ipath);
				end
				K1_r=sqrt(dot(K1_distance,K1_distance));
				K1_theta=reliableatan(K1_distance(1),K1_distance(2));
				K1_estimate(1)=s_si_comb(closestio,1)*sqrt(2*pi*K1_r)/(cos(K1_theta/2)*(1-sin(K1_theta/2)*sin(3*K1_theta/2))); %K1 related to sigmaxx
				K1_estimate(2)=s_si_comb(closestio,2)*sqrt(2*pi*K1_r)/(cos(K1_theta/2)*(1+sin(K1_theta/2)*sin(3*K1_theta/2))); %K1 related to sigmayy
				K1_estimate_taken=0.5*abs(sum(K1_estimate));
				
				for io=1:niCount %what's the proper term for niCount now, "no" (Number of nOdes)?
					for dim=1:2
						K1_distance(dim)=LOC(io,dim)-x_crack.center(icrackparticle,dim,ipath);
					end
					K1_r=sqrt(dot(K1_distance,K1_distance));
					if K1_r<K1_maxradius
						K1_theta=reliableatan(K1_distance(1),K1_distance(2));
						s_si_K1(io,1)=K1_estimate_taken/sqrt(2*pi*K1_r)*(cos(K1_theta/2)*(1-sin(K1_theta/2)*sin(3*K1_theta/2))); %K1 related to sigmaxx
						s_si_K1(io,2)=K1_estimate_taken/sqrt(2*pi*K1_r)*(cos(K1_theta/2)*(1+sin(K1_theta/2)*sin(3*K1_theta/2))); %K1 related to sigmayy
						s_si_K1(io,3)=K1_estimate_taken/sqrt(2*pi*K1_r)*(cos(K1_theta/2)*sin(K1_theta/2)*cos(3*K1_theta/2)); %K1 related to sigmayy
					end
				end
				sigma_maxprinc_magnitude=0;
				for nio=1:4
					io=CONNECT_crack.center.values(icrackparticle,nio,ipath);
					% insert vector interpolation here
					maxprinc_thetastress=-0.5*reliableatan(0.5*(s_si_comb(io,1)-s_si_comb(io,2)),-s_si_comb(io,3));
					maxprinc_magnitude=0.5*(s_si_comb(io,1)+s_si_comb(io,2))+sqrt((0.5*(s_si_comb(io,1)-s_si_comb(io,2)))^2+(s_si_comb(io,3))^2);
					sigma_maxprinc_magnitude=sigma_maxprinc_magnitude+maxprinc_magnitude;
					maxprinc_thetapropagation=maxprinc_thetastress+pi/2;
					maxprinc_n_propagation=[cos(maxprinc_thetapropagation) sin(maxprinc_thetapropagation)];
					maxprinc_n_distance=zeros(1,2);
					for dim=1:2
						maxprinc_n_distance(dim)=LOC(io,dim)-x_crack.center(icrackparticle,dim,ipath);
					end
					maxprinc_n_propagation=maxprinc_n_propagation*sign(dot(maxprinc_n_propagation,maxprinc_n_distance));
					for dim=1:2
						if maxprinc_magnitude>0
							r_propdirweighted(ipath,dim,tip)=r_propdirweighted(ipath,dim,tip)+maxprinc_magnitude*maxprinc_n_propagation(dim);
						end
					end
					%tempmarker7
					for dim=1:3
						s_tip(ipath,dim,tip)=s_tip(ipath,dim,tip)+s_si_comb(io,dim)*N_crack.center(1,nio,icrackparticle,ipath);
						s_tip_K1(ipath,dim,tip)=s_tip_K1(ipath,dim,tip)+s_si_K1(io,dim)*N_crack.center(1,nio,icrackparticle,ipath);
					end
				end
				r_propdirweighted_magnitude=sqrt(dot(r_propdirweighted(ipath,:,tip),r_propdirweighted(ipath,:,tip)));
				for dim=1:2
					r_propdirweighted(ipath,dim,tip)=r_propdirweighted(ipath,dim,tip)/r_propdirweighted_magnitude;
				end
				r_propangle=reliableatan(r_propdirweighted(ipath,1,tip),r_propdirweighted(ipath,2,tip));
				r_propdircompliment(1)=cos(r_propangle); %equivalent to sin(theta+90 degrees)
				r_propdircompliment(2)=-sin(r_propangle); %equivalent to cos(theta+90 degrees)
				for dim=1:2
					a_transform(1,dim)=r_propdirweighted(ipath,dim,tip);
					a_transform(2,dim)=r_propdircompliment(dim);
				end
				s_tip_tensor(1,1)=s_tip(ipath,1,tip);
				s_tip_tensor(1,2)=s_tip(ipath,3,tip);
				s_tip_tensor(2,1)=s_tip(ipath,3,tip);
				s_tip_tensor(2,2)=s_tip(ipath,2,tip);
				for dim_i=1:2
					for dim_j=1:2
						s_tip_tensor_transformed(2,2)=s_tip_tensor_transformed(2,2)+a_transform(2,dim_i)*a_transform(2,dim_j)*s_tip_tensor(dim_i,dim_j);
					end
				end
				for dim=1:3
					s_tip_dump(2*(ipath-1)+tip,dim)=s_tip(ipath,dim,tip);
					s_tip_K1_dump(2*(ipath-1)+tip,dim)=s_tip_K1(ipath,dim,tip);
				end
				for dim=1:2
					x_tip_dump(2*(ipath-1)+tip,dim)=x_crack.center(icrackparticle,dim,ipath);
					r_propdirweighted_dump(2*(ipath-1)+tip,dim)=r_propdirweighted(ipath,dim,tip);
				end
				s_tip_max=(s_tip(ipath,1,tip)+s_tip(ipath,2,tip))/2+sqrt( ((s_tip(ipath,1,tip)-s_tip(ipath,2,tip))/2)^2 + (s_tip(ipath,3,tip))^2 ); %calculate principal stress
				if CasetoRun==138 || CasetoRun==133 || CasetoRun==139
					elasticstrength=9999999;
				else
					elasticstrength=0.0125;
				end
				if s_tip_tensor_transformed(2,2)>elasticstrength
					theta_crack=r_propangle;
					crackextension=le(1);
					if tip==1
						deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
					elseif tip==2
						deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
					end
					%theta_previous=reliableatan(deltax_previous(1,1,1),deltax_previous(1,2,1));
					theta_crack_trial(1)=theta_crack;
					theta_crack_trial(2)=mod(theta_crack+pi,2*pi); %two possibilities for crack angle, 
					if (deltax_previous(1,1,1)*cos(theta_crack_trial(1))+deltax_previous(1,2,1)*sin(theta_crack_trial(1)))>0 % cos of theta_crack_trial with current crack tip trajectory
						theta_crack=theta_crack_trial(1);
					%{
					else
						fprintf('%s',['line 10411>> crack direction reversed!' char(10)]);
						theta_crack=theta_crack_trial(2);
					end
					%}
						if tip==1
							x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+crackextension*cos(theta_crack);
							x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+crackextension*sin(theta_crack);
							for idim=1:2
								x_crack.top(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
								x_crack.bot(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
							end
							x_crack.cohesivepoint(icrackparticle+1,ipath)=1;
						elseif tip==2
							for icrackparticlemove=x_crack.nparticles(ipath):-1:1
								for idim=1:2
									x_crack.center(icrackparticlemove+1,idim,ipath)=x_crack.center(icrackparticlemove,idim,ipath);
									x_crack.top(icrackparticlemove+1,idim,ipath)=x_crack.top(icrackparticlemove,idim,ipath);
									x_crack.bot(icrackparticlemove+1,idim,ipath)=x_crack.bot(icrackparticlemove,idim,ipath);
								end
							end
							x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+crackextension*cos(theta_crack);
							x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+crackextension*sin(theta_crack);
							for idim=1:2
								x_crack.top(1,idim,ipath)=x_crack.center(1,idim,ipath);
								x_crack.bot(1,idim,ipath)=x_crack.center(1,idim,ipath);
							end
							x_crack.cohesivepoint(1,ipath)=1;
						end
						x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
					else
						fprintf('%s',['line 10412>> propagation denied!' char(10)]);
					end
				end
			end
		end
	elseif CasetoRun==200 || CasetoRun==203 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==207 || CasetoRun==201
		%crack propagation of 200
		% of 199 but with alternative method 1
		
		%new declarations start here
		
		pltip.mode=zeros(1,1); %mode==1: fully rectangular; mode==2: trapezoid mode==3: triangular
		pltip.B=zeros(3,8); %B matrix for calculating strain from nodal displacements
		pltip.crossmarker=zeros(1,1);
		pltip.epsilon_tip=zeros(3,2);
		pltip.posbefore=zeros(8,1);
		pltip.posafter=zeros(8,1);
		
		pltip.dESP=zeros(2,2);
		pltip.R=zeros(2,2);
		pltip.Rback=zeros(2,2);
		pltip.Q=zeros(2,2);
		pltip.Qback=zeros(2,2);
		pltip.RQ=zeros(2,2);
		pltip.QbackRback=zeros(2,2);
		
		pltip.sigma_global_big=zeros(6,1);
		pltip.e_t_global_big=zeros(6,1);
		pltip.e_pl_global_big=zeros(6,1);
		pltip.alpha_in=zeros(1,7);
		pltip.xdirletter=blanks(2);
		pltip.ydirletter=blanks(2);
		pltip.zdirletter=blanks(2);
		pltip.xzdirletter=blanks(2);
		pltip.xydirletter=blanks(2);
		pltip.yzdirletter=blanks(2);
		pltip.spid=zeros(1,1);
		pltip.thetacrackrtl=zeros(1,1);
		pltip.dudx_rtl=zeros(2,2);
		pltip.s_sp=zeros(1,3);
		pltip.AbeforeQ_rtl=zeros(2,2,2,2);
		pltip.div.direction=zeros(1,3);
		pltip.div.tippos=zeros(1,2);%position of crack tip in global coordinate
		pltip.div.extension=zeros(1,1);%extension length of ghost tip for division
		pltip.div.deltaxtip=zeros(1,2);
		pltip_div_io_natural.pos=zeros(4,2);
		pltip_div_io_natural.source=zeros(1,4); %0 for regular io numbr, 1 for up/down, 2 for generated (for two averaging)
		pltip_div_io_natural.ionumber=zeros(1,4); %0 for empty, number for io number
		pltip_div_io_natural.upordown=zeros(1,4); %0 for empty, 1 for up, 2 for down
		pltip_div_io_natural.u_si=zeros(4,2);
		pltip_div_io_natural.cell.LOC=zeros(4,2); %for debugging purpose only, listing LOCs of nodes arouund the cell where crack tip is located, index follows io_natural, i.e. 1, 2, 3, 4 correspond to bottom left, bottom right, top right, and top left respectively.
		pltip_div_io_natural.cell.u_si=zeros(4,2); %for debugging purpose only, listing u_si(s) of nodes arouund the cell where crack tip is located, index follows io_natural, i.e. 1, 2, 3, 4 correspond to bottom left, bottom right, top right, and top left respectively.
		pltip.div.io_natural=repmat(pltip_div_io_natural,1,2); %only number 1 is used for regular calculation, number 2 is used for two quad averaging
		
		pltip_div_perpupdown.pos=zeros(1,2);%position of ghost tip 90 degrees up (CCW)
		pltip_div_perpupdown.crossdistance=zeros(1,1);
		pltip_div_perpupdown.iontgt=zeros(1,1);%io_natural target, as in intersection happens with which line? if it is line between io_natural==1 and io_natural==2, then iontgt=1; if it is line between io_natural==2 and io_natural==3, then iontgt=2; if it is line between io_natural==4 and io_natural==1, then iontgt=4.
		pltip_div_perpupdown.direction=zeros(1,1);
		pltip.div.perpup=repmat(pltip_div_perpupdown,1,3);
		pltip.div.perpdown=repmat(pltip_div_perpupdown,1,3);
		pltip.angle.values=zeros(1,100);
		pltip.angle.weights=zeros(1,100);
		pltip.angle.size=zeros(1,1);
		pltip.angle.chosen=zeros(1,1);
		curindex=zeros(1,1); %carries pltip.angle.size value for temporary use, for shorter lines and better readability
		cursize=zeros(1,1); %carries pltip.angle.size value for temporary use, but size was already decided and only called to pass on to angleaverage function, for shorter lines and better readability. cursize is essentially pltip.angle.size for the current nodeCount and fieldnumber
		
		
		ref.io_natural=zeros(1,5);%-2, -1, current, +1, +2
		ref.nio_outside=zeros(1,5);
		ref.io=zeros(1,5);
		ref.ratio=zeros(1,1);
		
		initcut.expansion=zeros(1,1);	
		initcut.CrossDir=zeros(1,1);
		initcut.RelativeLocation=zeros(1,1);
		initcut.RelativeLocationMin=zeros(1,1);
		initcut.firstevaluation=zeros(1,1);
		initcut.actuallycut=zeros(1,1);
		%the two above are actually redundant, since even though they serve different functions we can still just use one and repurpose the other, however for better readability we use both anyway.
		
		
		coder.varsize('pltip.xdirletter');
		coder.varsize('pltip.ydirletter');
		coder.varsize('pltip.zdirletter');
		coder.varsize('pltip.xydirletter');
		coder.varsize('pltip.yzdirletter');
		coder.varsize('pltip.xzdirletter');
		
		pltip.xdirletter=xdirletter{1};
		pltip.ydirletter=ydirletter{1};
		pltip.zdirletter=zdirletter{1};
		pltip.xydirletter=xydirletter{1};
		pltip.xzdirletter=xzdirletter{1};
		pltip.yzdirletter=yzdirletter{1};
		pltip.div.extension=2*le(1);
		
		propagationsignal=zeros(1,1);
		ntestedangle=36;
		AbeforeQ_tip=zeros(2,2,2,2); %only one 4th order tensor, recycled for every tip calculated
		dudx_tip=zeros(2,2);
		nldudxhl.values=zeros(1,2*ntestedangle);
		nldudxhl.sizes=zeros(1,1);
		h_localminima.sizes=zeros(1,1);
		h_localminima.values=zeros(2,2*ntestedangle);
		localminima1index.values=zeros(1,ntestedangle);
		localminima1index.sizes=zeros(1,1);
		localminima2index.values=zeros(1,ntestedangle);
		localminima2index.sizes=zeros(1,1);
		localminimaindex.values=zeros(1,2*ntestedangle);
		localminimaindex.sizes=zeros(1,1);
		h_crackdecision=zeros(2,1);
		FindMaxnldudxhl=zeros(1,1);
		crackindex=zeros(1,1);
		thetamin=zeros(1,1);
		theta_crack=zeros(1,1);
		%new declarations end here
		[AbeforeQ_si,AbeforeQ_si_active]=Interpolate_AbeforeQ(AbeforeQ,NODES,nodeCount,CONNECT,N,spCount,m_sp,TheFieldSplit,CasetoRun,fieldnumber);
		no=niCount;
		%s_tip(ipath,dim,itip);
		s_tip=zeros(x_crack.npaths,3,2);
		s_tip_K1=zeros(x_crack.npaths,3,2); %ncrackpaths; dimension (x and y); which tip
		deltax_previous=zeros(1,2,1);
		theta_crack_trial=zeros(1,2);
		deltatheta_crack=zeros(1,2);
		s_tip_dump=zeros(2*x_crack.npaths,3);
		d_tip_dump=zeros(2*x_crack.npaths,8);
		d_LOC_tip_dump=zeros(2*x_crack.npaths,8);
		s_tip_K1_dump=zeros(2*x_crack.npaths,3);
		u_tip_dump=zeros(2*x_crack.npaths,8);
		x_tip_dump=zeros(2*x_crack.npaths,2);
		r_propdirweighted_dump=zeros(2*x_crack.npaths,2);
		K1_maxradius=3*le(1);
		K1_estimate=zeros(1,2);
		K1_distance=zeros(1,2);
		r_propdirweighted=zeros(x_crack.npaths,2,2); %crackpath num, dimension, which tip
		sigma_maxprinc_magnitude=0;
		r_propdircompliment=zeros(1,2);
		a_transform=zeros(2,2);
		s_tip_tensor=zeros(2,2);
		s_tip_tensor_transformed=zeros(2,2);
		LOC_avg=zeros(1,2);
		nio_designator=zeros(1,4);
		d_natural=zeros(8,1);
		delta_x=zeros(1,2);
		epsilon_tip=zeros(3,1);
		x_crack_ghosttip=zeros(1,2);
		x1=zeros(1,2);
		x2=zeros(1,2);
		x3=zeros(1,2);
		x4=zeros(1,2);
		Area=zeros(1,4);
		foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
		foundcrossing.icrackparticle3=zeros(1,200); %so not to clash with iparticle
		foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
		foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.
		%nio_designator(1): in the natural coordinates, node 1 associates with which nio?
		%nio_designator(2): in the natural coordinates, node 2 associates with which nio?
		%nio_designator(3): in the natural coordinates, node 3 associates with which nio?
		%nio_designator(4): in the natural coordinates, node 4 associates with which nio?
		
		io_natural_cross_before=0;
		io_natural_cross_after=0;
		io_natural_sides=zeros(1,4);
		
		elasticstrength=0.0125; %to stop coder whining
		elasticstrength=1e10; %cracking denied
		k_dumpresult=0.99;
		elasticstrengthbase=elasticstrength;
		
		%r_propdirweighted=zeros(1,2); %dimension only
		
		%r_propdirweighted=zeros(1,2); %dimension only
		%allowpropagation=1;
		
		%propagation starts below
		for tip=1:2
			%tip=1: particle of highest index
			%tip=2: particle of lowest index
			for ipath=1:x_crack.npaths
				if x_crack.terminatedprop(ipath,tip)==0
					if tip==1
						icrackparticle=x_crack.nparticles(ipath);
					elseif tip==2
						icrackparticle=1;
					end
					LOC_avg=zeros(1,2);
					for nio=1:4
						io=CONNECT_crack.center.values(icrackparticle,nio,ipath);
						for dim=1:2
							LOC_avg(1,dim)=LOC_avg(1,dim)+LOC(io,dim);
						end
					end
					for dim=1:2
						LOC_avg(1,dim)=LOC_avg(1,dim)/4;
					end
					for nio=1:4
						io=CONNECT_crack.center.values(icrackparticle,nio,ipath);
						if LOC(io,1)<LOC_avg(1,1)
							if LOC(io,2)<LOC_avg(1,2)
								nio_designator(1)=nio;
							elseif LOC(io,2)>LOC_avg(1,2) %can just write else, but this way it's more readable. also equal is not possible, so I left it out
								nio_designator(4)=nio;
							end
						elseif LOC(io,1)>LOC_avg(1,1) %same drill, trying to improve readability
							if LOC(io,2)<LOC_avg(1,2)
								nio_designator(2)=nio;
							elseif LOC(io,2)>LOC_avg(1,2)
								nio_designator(3)=nio;
							end
						end
					end
					%allowpropagation=1;
					tip_crackability=0;
					tip_weakeningfactor=0;
					tip_k=0;
					AbeforeQ_tip=zeros(2,2,2,2);
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						tip_crackability=tip_crackability+uncrackable_si_comb(io)*N_crack.center(1,nio_outside,icrackparticle,ipath);
						tip_weakeningfactor=tip_weakeningfactor+weakeningfactor_si_comb(io)*N_crack.center(1,nio_outside,icrackparticle,ipath);
						tip_k=tip_k+k_si_comb(io)*N_crack.center(1,nio_outside,icrackparticle,ipath);
					end
					%start of interpolating angle
					%principle's same as above but using the function angleaverage instead
					pltip.angle.size=0;
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						
						pltip.angle.size=pltip.angle.size+1;
						curindex=pltip.angle.size;
						pltip.angle.values(curindex)=orientationoffset_si_comb(io);
						pltip.angle.weights(curindex)=N_crack.center(1,nio_outside,icrackparticle,ipath);
					end
					pltip.angle.chosen=angleaverage(pltip.angle.values,pltip.angle.weights,18,5,2);
					%end of interpolating angle
					
					%finding where the crack cuts the cell
					for itrial=1:x_crack.nparticles(ipath)-1
						io_natural_cross_before=0;
						io_natural_cross_after=0;
						io_natural_sides=zeros(1,4);
						if tip==1
							x1(1,1)=x_crack.center(icrackparticle-(itrial-1),1,ipath);
							x1(1,2)=x_crack.center(icrackparticle-(itrial-1),2,ipath);
							x2(1,1)=x_crack.center(icrackparticle-itrial,1,ipath);
							x2(1,2)=x_crack.center(icrackparticle-itrial,2,ipath);
						elseif tip==2
							x1(1,1)=x_crack.center(1+(itrial-1),1,ipath);
							x1(1,2)=x_crack.center(1+(itrial-1),2,ipath);
							x2(1,1)=x_crack.center(1+itrial,1,ipath);
							x2(1,2)=x_crack.center(1+itrial,2,ipath);
						end
											
						for io_natural=1:4
							nio_outside=nio_designator(io_natural);
							io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
							x3(1,1)=LOC(io,1);
							x3(1,2)=LOC(io,2);
							nio_outside=nio_designator(mod(io_natural+1-1,4)+1);
							io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
							x4(1,1)=LOC(io,1);
							x4(1,2)=LOC(io,2);
							Area(1)=TriangleArea(x1,x2,x3);
							Area(2)=TriangleArea(x1,x2,x4);
							Area(3)=TriangleArea(x3,x4,x1);
							Area(4)=TriangleArea(x3,x4,x2);
							if (Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0) || (Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0)
								%before and before-1: top(2) for tip==1, bottom(3) for tip==2
								%after and after+1: bottom(3) for tip==1, top(2) for tip==1
								io_natural_cross_before=io_natural;
								if tip==1
									io_natural_sides(io_natural_cross_before)=2;
									io_natural_sides(mod(io_natural_cross_before-1-1,4)+1)=2;
								elseif tip==2
									io_natural_sides(io_natural_cross_before)=3;
									io_natural_sides(mod(io_natural_cross_before-1-1,4)+1)=3;
								end
								
								io_natural_cross_after=mod(io_natural+1-1,4)+1;
								if tip==1
									io_natural_sides(io_natural_cross_after)=3;							
									io_natural_sides(mod(io_natural_cross_after+1-1,4)+1)=3;
								elseif tip==2
									io_natural_sides(io_natural_cross_after)=2;
									io_natural_sides(mod(io_natural_cross_after+1-1,4)+1)=2;
								end
								break;
							end
						end
						if io_natural_cross_before>0
							break;
						end
					end
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						if AbeforeQ_si_active(io,1)==1
							for dim1=1:2
							for dim2=1:2
							for dim3=1:2
							for dim4=1:2
								AbeforeQ_tip(dim1,dim2,dim3,dim4)=AbeforeQ_tip(dim1,dim2,dim3,dim4)+AbeforeQ_si(dim1,dim2,dim3,dim4,io,1)*N_crack.center(1,nio_outside,icrackparticle,ipath);
							end
							end
							end
							end
						end
						dudx_tip=dudx_tip+u_si(io,:,1)'*dN_crack.center(:,nio_outside,icrackparticle,ipath)';
						%the way is inspired form the following:
						%L_sp{spid} = L_sp{spid} + (nvelo_si(npid,:,TheFieldSplit(j,spid))'*dN{spid}(:,j)');
					end
					x_crack.Efactor(ipath,tip)=0;
					x_crack.mEfactor(ipath,tip)=0;
					x_crack.mass(ipath,tip)=0;
					lowmassstrikes=0;
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						if sum(nmass_si(io,:))<1.25*m_sp(1)
							lowmassstrikes=lowmassstrikes+1;
						end
					end
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						if CasetoRun==174
							x_crack.mEfactor(ipath,tip)=x_crack.mEfactor(ipath,tip)+N_crack.center(1,nio_outside,icrackparticle,ipath)*mEfactor_si(io,1);
							x_crack.mass(ipath,tip)=x_crack.mass(ipath,tip)+N_crack.center(1,nio_outside,icrackparticle,ipath)*nmass_si(io,1);
						end
						for dim=1:2
							index=2*(io_natural-1)+dim;
							if io_natural_sides(io_natural)==2
								d_natural(index,1)=u_si(io,dim,TheFieldSplit_cracktop{ipath}(nio_outside,icrackparticle));
							elseif io_natural_sides(io_natural)==3
								d_natural(index,1)=u_si(io,dim,TheFieldSplit_crackbot{ipath}(nio_outside,icrackparticle));
							else
								d_natural(index,1)=u_si_comb(io,dim);
							end
						end
						%if uncrackable_si_comb(io)>0.25
						if tip_crackability>0.125
							x_crack.terminatedprop(ipath,tip)=1;
							break;
						elseif lowmassstrikes>=2
							%allowpropagation=0;
							x_crack.terminatedprop(ipath,tip)=1;
							x_crack.openedgetip(ipath,tip)=1;
							if tip==1
								deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
								x_crack.cohesivepoint(icrackparticle,ipath)=0;
							elseif tip==2
								deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
								x_crack.cohesivepoint(1,ipath)=0;
							end
							if tip==1
								%CLEAR EDGE EXTENSION
								%might need idim=1:2 loop, but don't touch if still works OK?
								%did it anyway
								
								% no shift here, just adding to the list
								for idim=1:2
									x_crack.center(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle,idim,ipath)+deltax_previous(idim);
									x_crack.top(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
									x_crack.bot(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
								end
							elseif tip==2
								% shift here
								
								%shift loop below:
								for icrackparticlemove=x_crack.nparticles(ipath):-1:1
									for idim=1:2
										x_crack.center(icrackparticlemove+1,idim,ipath)=x_crack.center(icrackparticlemove,idim,ipath);
										x_crack.top(icrackparticlemove+1,idim,ipath)=x_crack.top(icrackparticlemove,idim,ipath);
										x_crack.bot(icrackparticlemove+1,idim,ipath)=x_crack.bot(icrackparticlemove,idim,ipath);
										
										x_crack.force.top(icrackparticlemove+1,idim,ipath)=x_crack.force.top(icrackparticlemove,idim,ipath);
										x_crack.force.bot(icrackparticlemove+1,idim,ipath)=x_crack.force.bot(icrackparticlemove,idim,ipath);
										x_crack.bridge.base.deltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.base.deltax(icrackparticlemove,idim,ipath);
										x_crack.bridge.adjusted.deltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.adjusted.deltax(icrackparticlemove,idim,ipath);
										x_crack.bridge.firsttimedeltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.firsttimedeltax(icrackparticlemove,idim,ipath);
										%(icrackparticlemove+1,idim,ipath)
										%(icrackparticlemove,idim,ipath)
										%
									end
									x_crack.bridge.absforce(icrackparticlemove+1,ipath)=x_crack.bridge.absforce(icrackparticlemove,ipath);
									x_crack.bridge.isactive(icrackparticlemove+1,ipath)=x_crack.bridge.isactive(icrackparticlemove,ipath);
									x_crack.bridge.firsttimeactive(icrackparticlemove+1,ipath)=x_crack.bridge.firsttimeactive(icrackparticlemove,ipath);
									x_crack.bridge.adjusted.absdeltaxmax(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmax(icrackparticlemove,ipath);
									x_crack.bridge.base.absdeltax(icrackparticlemove+1,ipath)=x_crack.bridge.base.absdeltax(icrackparticlemove,ipath);
									x_crack.bridge.adjusted.absdeltax(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltax(icrackparticlemove,ipath);
									x_crack.bridge.adjusted.absdeltaxmaxi(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmaxi(icrackparticlemove,ipath);
									x_crack.bridge.kbase2(icrackparticlemove+1,ipath)=x_crack.bridge.kbase2(icrackparticlemove,ipath);
									x_crack.bridge.yieldforce2(icrackparticlemove+1,ipath)=x_crack.bridge.yieldforce2(icrackparticlemove,ipath);
									x_crack.bridge.deltai2(icrackparticlemove+1,ipath)=x_crack.bridge.deltai2(icrackparticlemove,ipath);
									x_crack.bridge.deltae2(icrackparticlemove+1,ipath)=x_crack.bridge.deltae2(icrackparticlemove,ipath);
									
									x_crack.bridge.failuresurface(icrackparticlemove+1,ipath)=x_crack.bridge.failuresurface(icrackparticlemove,ipath);
									x_crack.bridge.fractureenergy(icrackparticlemove+1,ipath)=x_crack.bridge.fractureenergy(icrackparticlemove,ipath);
									x_crack.bridge.strength(icrackparticlemove+1,ipath)=x_crack.bridge.strength(icrackparticlemove,ipath);
									x_crack.bridge.effectivespacing(icrackparticlemove+1,ipath)=x_crack.bridge.effectivespacing(icrackparticlemove,ipath);
									x_crack.bridge.nodalenergy(icrackparticlemove+1,ipath)=x_crack.bridge.nodalenergy(icrackparticlemove,ipath);
									
									x_crack.cohesivepoint(icrackparticlemove+1,ipath)=x_crack.cohesivepoint(icrackparticlemove,ipath);
								end
								
								%adding to the list here:
								for idim=1:2
									x_crack.center(1,idim,ipath)=x_crack.center(2,idim,ipath)+deltax_previous(idim);
									x_crack.top(1,idim,ipath)=x_crack.center(1,idim,ipath);
									x_crack.bot(1,idim,ipath)=x_crack.center(1,idim,ipath);
								end
							end
							x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
							break;
						end
					end
					% start of criterion evaluation of crack propagation
					propagationsignal=0;
					
					if x_crack.terminatedprop(ipath,tip)==1
						continue;
					end
					% Separation calculation
					if tip==1
						pltip.div.deltaxtip=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
						pltip.div.tippos=x_crack.center(icrackparticle,:,ipath);
					elseif tip==2
						pltip.div.deltaxtip=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
						pltip.div.tippos=x_crack.center(1,:,ipath);
					end
					
					
					pltip.div.io_natural(1).pos=zeros(4,2);
					pltip.div.io_natural(1).source=zeros(1,4); %0 for regular io numbr, 1 for up/down
					pltip.div.io_natural(1).ionumber=zeros(1,4); %0 for empty, number for io number
					pltip.div.io_natural(1).upordown=zeros(1,4); %0 for empty, 1 for up, 2 for down
					
					%TDL below is for testing only, delete later
					%{
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						if io_natural==1
							u_si(io,:,1)=[2 -1];
						elseif io_natural==2
							u_si(io,:,1)=[2 -2];
						elseif io_natural==3
							u_si(io,:,1)=[1 4];
						else%if io_natural==4
							u_si(io,:,1)=[1 2];
						end
					end
					%}
					%TDL above is for testing only, delete later
					
					for iperp=1:3
						if iperp==1
							pltip.div.direction(iperp)=reliableatan(pltip.div.deltaxtip(1),pltip.div.deltaxtip(2));
						elseif iperp==2
							if pltip.div.deltaxtip(1)>0
								pltip.div.direction(iperp)=0;
							else
								pltip.div.direction(iperp)=pi;
							end
						else%if iperp==3
							if pltip.div.deltaxtip(2)>0
								pltip.div.direction(iperp)=pi/2;
							else
								pltip.div.direction(iperp)=-pi/2;
							end
						end
						pltip.div.perpup(iperp).direction=pltip.div.direction(iperp)+pi/2;
						pltip.div.perpdown(iperp).direction=pltip.div.direction(iperp)-pi/2;
						pltip.div.perpup(iperp).pos=pltip.div.tippos+pltip.div.extension*[cos(pltip.div.perpup(iperp).direction) sin(pltip.div.perpup(iperp).direction)];
						pltip.div.perpdown(iperp).pos=pltip.div.tippos+pltip.div.extension*[cos(pltip.div.perpdown(iperp).direction) sin(pltip.div.perpdown(iperp).direction)];
						pltip.div.perpup(iperp).crossdistance=pltip.div.extension;
						pltip.div.perpdown(iperp).crossdistance=pltip.div.extension;	
						for io_natural=1:4
							%io_natural=1: line spans between io_natural=1 and io_natural=2, target: y negative
							%io_natural=2: line spans between io_natural=2 and io_natural=3, target: x positive
							%io_natural=3: line spans between io_natural=3 and io_natural=4, target: y positive
							%io_natural=4: line spans between io_natural=4 and io_natural=1, target: x negative
							nio_outside=nio_designator(io_natural);
							io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
							pltip.div.io_natural(1).cell.LOC(io_natural,:)=LOC(io,:);
							pltip.div.io_natural(1).cell.u_si(io_natural,:)=u_si(io,:,1);
							xtgt=LOC(io,1);
							ytgt=LOC(io,2);
							if io_natural==1
								%io_natural=1: line spans between io_natural=1 and io_natural=2, target: y negative
								if pltip.div.perpup(iperp).pos(2)<ytgt
									pltip.div.perpup(iperp).iontgt=io_natural;
									pltip.div.perpup(iperp).crossdistance=pltip.div.perpup(iperp).crossdistance/(pltip.div.tippos(2)-pltip.div.perpup(iperp).pos(2))*(pltip.div.tippos(2)-ytgt);
									pltip.div.perpup(iperp).pos=pltip.div.tippos+pltip.div.perpup(iperp).crossdistance*[cos(pltip.div.perpup(iperp).direction) sin(pltip.div.perpup(iperp).direction)];
								end
								if pltip.div.perpdown(iperp).pos(2)<ytgt
									pltip.div.perpdown(iperp).iontgt=io_natural;
									pltip.div.perpdown(iperp).crossdistance=pltip.div.perpdown(iperp).crossdistance/(pltip.div.tippos(2)-pltip.div.perpdown(iperp).pos(2))*(pltip.div.tippos(2)-ytgt);
									pltip.div.perpdown(iperp).pos=pltip.div.tippos+pltip.div.perpdown(iperp).crossdistance*[cos(pltip.div.perpdown(iperp).direction) sin(pltip.div.perpdown(iperp).direction)];
								end
							elseif io_natural==2
								%io_natural=2: line spans between io_natural=2 and io_natural=3, target: x positive
								if pltip.div.perpup(iperp).pos(1)>xtgt
									pltip.div.perpup(iperp).iontgt=io_natural;
									pltip.div.perpup(iperp).crossdistance=pltip.div.perpup(iperp).crossdistance/(pltip.div.tippos(1)-pltip.div.perpup(iperp).pos(1))*(pltip.div.tippos(1)-xtgt);
									pltip.div.perpup(iperp).pos=pltip.div.tippos+pltip.div.perpup(iperp).crossdistance*[cos(pltip.div.perpup(iperp).direction) sin(pltip.div.perpup(iperp).direction)];
								end
								if pltip.div.perpdown(iperp).pos(1)>xtgt
									pltip.div.perpdown(iperp).iontgt=io_natural;
									pltip.div.perpdown(iperp).crossdistance=pltip.div.perpdown(iperp).crossdistance/(pltip.div.tippos(1)-pltip.div.perpdown(iperp).pos(1))*(pltip.div.tippos(1)-xtgt);
									pltip.div.perpdown(iperp).pos=pltip.div.tippos+pltip.div.perpdown(iperp).crossdistance*[cos(pltip.div.perpdown(iperp).direction) sin(pltip.div.perpdown(iperp).direction)];
								end
							elseif io_natural==3
								%io_natural=3: line spans between io_natural=3 and io_natural=4, target: y positive
								if pltip.div.perpup(iperp).pos(2)>ytgt
									pltip.div.perpup(iperp).iontgt=io_natural;
									pltip.div.perpup(iperp).crossdistance=pltip.div.perpup(iperp).crossdistance/(pltip.div.tippos(2)-pltip.div.perpup(iperp).pos(2))*(pltip.div.tippos(2)-ytgt);
									pltip.div.perpup(iperp).pos=pltip.div.tippos+pltip.div.perpup(iperp).crossdistance*[cos(pltip.div.perpup(iperp).direction) sin(pltip.div.perpup(iperp).direction)];
								end
								if pltip.div.perpdown(iperp).pos(2)>ytgt
									pltip.div.perpdown(iperp).iontgt=io_natural;
									pltip.div.perpdown(iperp).crossdistance=pltip.div.perpdown(iperp).crossdistance/(pltip.div.tippos(2)-pltip.div.perpdown(iperp).pos(2))*(pltip.div.tippos(2)-ytgt);
									pltip.div.perpdown(iperp).pos=pltip.div.tippos+pltip.div.perpdown(iperp).crossdistance*[cos(pltip.div.perpdown(iperp).direction) sin(pltip.div.perpdown(iperp).direction)];
								end
							else%if io_natural==4, cant write this or coder will whine
								%io_natural=4: line spans between io_natural=4 and io_natural=1, target: x negative
								if pltip.div.perpup(iperp).pos(1)<xtgt
									pltip.div.perpup(iperp).iontgt=io_natural;
									pltip.div.perpup(iperp).crossdistance=pltip.div.perpup(iperp).crossdistance/(pltip.div.tippos(1)-pltip.div.perpup(iperp).pos(1))*(pltip.div.tippos(1)-xtgt);
									pltip.div.perpup(iperp).pos=pltip.div.tippos+pltip.div.perpup(iperp).crossdistance*[cos(pltip.div.perpup(iperp).direction) sin(pltip.div.perpup(iperp).direction)];
								end
								if pltip.div.perpdown(iperp).pos(1)<xtgt
									pltip.div.perpdown(iperp).iontgt=io_natural;
									pltip.div.perpdown(iperp).crossdistance=pltip.div.perpdown(iperp).crossdistance/(pltip.div.tippos(1)-pltip.div.perpdown(iperp).pos(1))*(pltip.div.tippos(1)-xtgt);
									pltip.div.perpdown(iperp).pos=pltip.div.tippos+pltip.div.perpdown(iperp).crossdistance*[cos(pltip.div.perpdown(iperp).direction) sin(pltip.div.perpdown(iperp).direction)];
								end
							end
						end
						if iperp==1 
							if (mod(pltip.div.perpup(iperp).iontgt-pltip.div.perpdown(iperp).iontgt-1,4)+1)==1
								pltip.mode=3;
							elseif abs(pltip.div.perpup(1).iontgt-pltip.div.perpdown(1).iontgt)==2
								pltip.mode=1;
							elseif roll4(pltip.div.perpup(1).iontgt-pltip.div.perpdown(1).iontgt)==3
								pltip.mode=2;
							end
							if pltip.mode==3
							else
								break;
							end
						end
					end
					pltip.div.io_natural(2).cell.LOC=pltip.div.io_natural(1).cell.LOC;
					pltip.div.io_natural(2).cell.u_si=pltip.div.io_natural(1).cell.u_si;
					
					%recalculation of pltip.div.perpup and pltip.div.perpdown for triangle to double squares
					
					1;
					%new "nodal" positions and displacements
					iperpmin=zeros(1,1);
					iperpmax=zeros(1,1);
					iperp2=zeros(1,1);
					
					%hfjfhjlksa.m
					if pltip.mode==1 || pltip.mode==3
						%regular distorted quad
						%below is universal for all four
						
						%io_natural_overboard starts at pltip.div.perpdown(1).iontgt, i.e. where the down extension intercepts the cell edge. for example, pltip.div.perpdown(1).iontgt=1 means it intersects edge between io_natural=1 and io_natural=2, etc. The io_natural_overboard goes from pltip.div.perpdown(1).iontgt all the way to pltip.div.perpdown(1).iontgt+3, not caring about going over 4. that is taken care of by having io_natural with 4 mod and -1+1 additions, so that if it goes overboard, io_natural rolls back
						%io_natural_relcounter is the relative counter, io_natural_relcounter=1 would be the 1st node to analise, which is the node as the result of intersection between 
						if pltip.mode==1
							iperpmin=1;
							iperpmax=1;
						elseif pltip.mode==3
							iperpmin=2;
							iperpmax=3;
						end
						
						for iperp=iperpmin:iperpmax
							if iperp==1
								iperp2=iperp;
							else
								iperp2=iperp-1;
							end
							io_natural_relcounter=0;
							for io_natural_overboard=pltip.div.perpdown(iperp).iontgt:pltip.div.perpdown(iperp).iontgt+3
								io_natural_relcounter=io_natural_relcounter+1;
								io_natural=mod(io_natural_overboard-1,4)+1;
								if io_natural_relcounter==1
									pltip.div.io_natural(iperp2).source(io_natural)=1;
								elseif io_natural_relcounter==2
									pltip.div.io_natural(iperp2).source(io_natural)=0;
								elseif io_natural_relcounter==3
									pltip.div.io_natural(iperp2).source(io_natural)=0;
								else%if io_natural_relcounter==4, but coder would whine
									pltip.div.io_natural(iperp2).source(io_natural)=1;
								end
							end
							for io_natural=1:4
								if pltip.div.io_natural(iperp2).source(io_natural)==0
									nio_outside=nio_designator(io_natural);
									io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
									pltip.div.io_natural(iperp2).ionumber(io_natural)=io;
									pltip.div.io_natural(iperp2).pos(io_natural,:)=LOC(io,:);
									pltip.div.io_natural(iperp2).u_si(io_natural,:)=u_si(io,:,1);
								end	
							end
							
							io_natural_relcounter=0;
							for io_natural_overboard=pltip.div.perpdown(iperp).iontgt:pltip.div.perpdown(iperp).iontgt+3
								io_natural_relcounter=io_natural_relcounter+1;
								io_natural=mod(io_natural_overboard-1,4)+1;
								if io_natural_relcounter==1
									if pltip.div.io_natural(iperp2).source(io_natural)==0 %0 for regular io numbr, 1 for up/down
										DUMMY=input_codegen('io_natural_relcounter predicts wrong!');
									end
									pltip.div.io_natural(iperp2).upordown(io_natural)=2; %2=down, 1=up
									pltip.div.io_natural(iperp2).pos(io_natural,:)=pltip.div.perpdown(iperp).pos;
								elseif io_natural_relcounter==4
									if pltip.div.io_natural(iperp2).source(io_natural)==0
										DUMMY=input_codegen('io_natural_relcounter predicts wrong!');
									end
									pltip.div.io_natural(iperp2).upordown(io_natural)=1; %1=up, 2=down
									pltip.div.io_natural(iperp2).pos(io_natural,:)=pltip.div.perpup(iperp).pos;
								end
							end
							
							io_natural_relcounter=0;
							for io_natural_overboard=pltip.div.perpdown(iperp).iontgt:pltip.div.perpdown(iperp).iontgt+3
								io_natural_relcounter=io_natural_relcounter+1;
								io_natural=roll4(io_natural_overboard);
								io_natural_after=roll4(io_natural_overboard+1);
								nio_outside=nio_designator(io_natural);
								io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
								nio_outside_after=nio_designator(io_natural_after);
								io_after=CONNECT_crack.center.values(icrackparticle,nio_outside_after,ipath);
								if io_natural_relcounter==1
									pltip.div.io_natural(iperp2).u_si(io_natural,:)=u_si(io,:,1)+(u_si(io_after,:,1)-u_si(io,:,1))/calcmag(LOC(io_after,:)-LOC(io,:))*calcmag(pltip.div.io_natural(iperp2).pos(io_natural,:)-LOC(io,:));
								elseif io_natural_relcounter==3
									pltip.div.io_natural(iperp2).u_si(io_natural_after,:)=u_si(io,:,1)+(u_si(io_after,:,1)-u_si(io,:,1))/calcmag(LOC(io_after,:)-LOC(io,:))*calcmag(pltip.div.io_natural(iperp2).pos(io_natural_after,:)-LOC(io,:));
								end
							end
							%above is universal for all four
						end
					%hfjfhjlksa.m
					elseif pltip.mode==2
						%double distorted quad average
						%[D]TDL evaluate below 
						%below identifies the source of coordinate
						io_natural_relcounter=0;
						for io_natural_overboard=pltip.div.perpdown(1).iontgt:pltip.div.perpdown(1).iontgt+3
							io_natural_relcounter=io_natural_relcounter+1;
							io_natural=roll4(io_natural_overboard);
							%io_natural refers to trapezoid, io_natural_recounter refers to trapezoid as well, with io_natural_recounter==1 refers to bottom left corner
							if io_natural_relcounter==1
								pltip.div.io_natural(1).source(io_natural)=1;
								pltip.div.io_natural(2).source(io_natural)=1;
							elseif io_natural_relcounter==2
								pltip.div.io_natural(1).source(io_natural)=0;
								pltip.div.io_natural(2).source(io_natural)=1;
							elseif io_natural_relcounter==3
								pltip.div.io_natural(1).source(io_natural)=2;
								pltip.div.io_natural(2).source(io_natural)=2;
							else %if io_natural_relcounter==4, but coder would whine
								pltip.div.io_natural(1).source(io_natural)=1;
								pltip.div.io_natural(2).source(io_natural)=0;
							end
						end
						%below assigns io number and coordinates if trapezoid coincides with the cell it's in
						for iavg=1:2
							for io_natural=1:4
								if pltip.div.io_natural(iavg).source(io_natural)==0
									nio_outside=nio_designator(io_natural);
									io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
									pltip.div.io_natural(iavg).ionumber(io_natural)=io;
									pltip.div.io_natural(iavg).pos(io_natural,:)=LOC(io,:);
									pltip.div.io_natural(iavg).u_si(io_natural,:)=u_si(io,:,1);
								end
							end
						end
						
						
						%below assigns coordinates of intersections
						for iavg=1:2
							io_natural_relcounter=0;
							for io_natural_overboard=pltip.div.perpdown(1).iontgt:pltip.div.perpdown(1).iontgt+3
								io_natural_relcounter=io_natural_relcounter+1;
								io_natural=roll4(io_natural_overboard);
								ref.io_natural(1)=roll4(io_natural-2);
								ref.io_natural(2)=roll4(io_natural-1);
								ref.io_natural(3)=roll4(io_natural+0);
								ref.io_natural(4)=roll4(io_natural+1);
								ref.io_natural(5)=roll4(io_natural+2);
								for iref=1:5
									ref.nio_outside(iref)=nio_designator(ref.io_natural(iref));
									ref.io(iref)=CONNECT_crack.center.values(icrackparticle,ref.nio_outside(iref),ipath);
								end
								if io_natural_relcounter==1
									if iavg==1
										if pltip.div.io_natural(iavg).source(io_natural)~=1 %0 for regular io numbr, 1 for up/down
											DUMMY=input_codegen('io_natural_relcounter predicts wrong!');
										end
										pltip.div.io_natural(iavg).upordown(io_natural)=2; %2=down, 1=up
										pltip.div.io_natural(iavg).pos(io_natural,:)=pltip.div.perpdown(1).pos;

										ref.ratio=(calcmag(pltip.div.io_natural(iavg).pos(io_natural,:)-LOC(ref.io(3),:)))/(calcmag(LOC(ref.io(4),:)-LOC(ref.io(3),:)));
										pltip.div.io_natural(iavg).u_si(io_natural,:)=(1-ref.ratio)*u_si(ref.io(3),:,1)+ref.ratio*u_si(ref.io(4),:,1);
									else%if iavg==2
										if pltip.div.io_natural(iavg).source(ref.io_natural(4))~=1 %0 for regular io numbr, 1 for up/down
											DUMMY=input_codegen('io_natural_relcounter predicts wrong!');
										end
										pltip.div.io_natural(iavg).upordown(ref.io_natural(4))=2; %2=down, 1=up
										pltip.div.io_natural(iavg).pos(ref.io_natural(4),:)=pltip.div.perpdown(1).pos;
										
										ref.ratio=(calcmag(pltip.div.io_natural(iavg).pos(ref.io_natural(4),:)-LOC(ref.io(3),:)))/(calcmag(LOC(ref.io(4),:)-LOC(ref.io(3),:)));
										pltip.div.io_natural(iavg).u_si(ref.io_natural(4),:)=(1-ref.ratio)*u_si(ref.io(3),:,1)+ref.ratio*u_si(ref.io(4),:,1);
									end
								elseif io_natural_relcounter==4
									if iavg==1
										if pltip.div.io_natural(iavg).source(io_natural)~=1
											DUMMY=input_codegen('io_natural_relcounter predicts wrong!');
										end
										pltip.div.io_natural(iavg).upordown(io_natural)=1; %1=up, 2=down
										pltip.div.io_natural(iavg).pos(io_natural,:)=pltip.div.perpup(1).pos;
										
										ref.ratio=(calcmag(pltip.div.io_natural(iavg).pos(io_natural,:)-LOC(ref.io(3),:)))/(calcmag(LOC(ref.io(4),:)-LOC(ref.io(3),:)));
										pltip.div.io_natural(iavg).u_si(io_natural,:)=(1-ref.ratio)*u_si(ref.io(3),:,1)+ref.ratio*u_si(ref.io(4),:,1);
									else%if iavg==2
										if pltip.div.io_natural(iavg).source(roll4(io_natural+1))~=1
											DUMMY=input_codegen('io_natural_relcounter predicts wrong!');
										end
										pltip.div.io_natural(iavg).upordown(roll4(io_natural+1))=1; %1=up, 2=down
										pltip.div.io_natural(iavg).pos(roll4(io_natural+1),:)=pltip.div.perpup(1).pos;
										
										ref.ratio=(calcmag(pltip.div.io_natural(iavg).pos(ref.io_natural(4),:)-LOC(ref.io(3),:)))/(calcmag(LOC(ref.io(4),:)-LOC(ref.io(3),:)));
										pltip.div.io_natural(iavg).u_si(ref.io_natural(4),:)=(1-ref.ratio)*u_si(ref.io(3),:,1)+ref.ratio*u_si(ref.io(4),:,1);
									end
								end
							end
						end
						
						%below assigns coordinates and displacements for doubled intersection
						for iavg=1:2
							io_natural_relcounter=0;
							for io_natural_overboard=pltip.div.perpdown(1).iontgt:pltip.div.perpdown(1).iontgt+3
								io_natural_relcounter=io_natural_relcounter+1;
								io_natural=roll4(io_natural_overboard);
								nio_outside=nio_designator(io_natural);
								io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
								if pltip.div.io_natural(iavg).source(io_natural)==2
									ref.io_natural(1)=roll4(io_natural-2);
									ref.io_natural(2)=roll4(io_natural-1);
									ref.io_natural(3)=roll4(io_natural+0);
									ref.io_natural(4)=roll4(io_natural+1);
									ref.io_natural(5)=roll4(io_natural+2);
									for iref=1:5
										ref.nio_outside(iref)=nio_designator(ref.io_natural(iref));
										ref.io(iref)=CONNECT_crack.center.values(icrackparticle,ref.nio_outside(iref),ipath);
									end
									if iavg==1
										ref.ratio=(calcmag(pltip.div.io_natural(iavg).pos(ref.io_natural(4),:)-LOC(ref.io(1),:)))/(calcmag(LOC(ref.io(4),:)-LOC(ref.io(1),:)));
										pltip.div.io_natural(iavg).pos(io_natural,:)=(1-ref.ratio)*LOC(ref.io(2),:)+ref.ratio*LOC(ref.io(3),:);
										pltip.div.io_natural(iavg).u_si(io_natural,:)=(1-ref.ratio)*u_si(ref.io(2),:,1)+ref.ratio*u_si(ref.io(3),:,1);
									elseif iavg==2
										ref.ratio= ...
											(calcmag(pltip.div.io_natural(iavg).pos(ref.io_natural(2),:)-LOC(ref.io(1),:))) ... 
											/(calcmag(LOC(ref.io(2),:)-LOC(ref.io(1),:)));
										pltip.div.io_natural(iavg).pos(io_natural,:)=(1-ref.ratio)*LOC(ref.io(4),:)+ref.ratio*LOC(ref.io(3),:);
										pltip.div.io_natural(iavg).u_si(io_natural,:)=(1-ref.ratio)*u_si(ref.io(4),:,1)+ref.ratio*u_si(ref.io(3),:,1);
									end
								end
							end
						end	
						%[D]TDL evaluate above 
						%[D]TDL write below for iavg==2
						%loop below is not necessary anymore since the assignments are piggibacking off of ref.ratio calculation (loop above)
						%{
						io_natural_relcounter=0;
						for io_natural_overboard=pltip.div.perpdown(1).iontgt:pltip.div.perpdown(1).iontgt+3
							io_natural_relcounter=io_natural_relcounter+1;
							io_natural=roll4(io_natural_overboard);
							io_natural_after=roll4(io_natural_overboard+1);
							nio_outside=nio_designator(io_natural);
							io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
							nio_outside_after=nio_designator(io_natural_after);
							io_after=CONNECT_crack.center.values(icrackparticle,nio_outside_after,ipath);
							if io_natural_relcounter==1
								pltip.div.io_natural(iavg).u_si(io_natural,:)=u_si(io,:,1)+(u_si(io_after,:,1)-u_si(io,:,1))/(LOC(io_after,1)-LOC(io,1))*(pltip.div.io_natural(iavg).pos(io_natural,1)-LOC(io,1));
							elseif io_natural_relcounter==3
								pltip.div.io_natural(iavg).u_si(io_natural_after,:)=u_si(io,:,1)+(u_si(io_after,:,1)-u_si(io,:,1))/(LOC(io_after,1)-LOC(io,1))*(pltip.div.io_natural(iavg).pos(io_natural_after,1)-LOC(io,1));
							end
						end
						%}
						%[D]TDL write above for iavg==2
					elseif pltip.mode==-99 %used to be pltip.mode==3
						%double perfect quad average
						%fhdjkslhfkdjsa.m
						pltip.mode=3;
						%below is universal for all four
						
						%io_natural_overboard starts at pltip.div.perpdown(1).iontgt, i.e. where the down extension intercepts the cell edge. for example, pltip.div.perpdown(1).iontgt=1 means it intersects edge between io_natural=1 and io_natural=2, etc. The io_natural_overboard goes from pltip.div.perpdown(1).iontgt all the way to pltip.div.perpdown(1).iontgt+3, not caring about going over 4. that is taken care of by having io_natural with 4 mod and -1+1 additions, so that if it goes overboard, io_natural rolls back
						%io_natural_relcounter is the relative counter, io_natural_relcounter=1 would be the 1st node to analise, which is the node as the result of intersection between 
						
						%assigning source of coordinates
						pltip.div.io_natural(1).source(1)=1;
						pltip.div.io_natural(1).source(2)=0;
						pltip.div.io_natural(1).source(3)=1;
						%io_natural==1 of the triangle coincides with bottom intersection
						%io_natural==2 of the triangle coincides with cell corner
						%io_natural==3 of the triangle coincides with top intersection
						
						%assigning position and displacement for coinciding corner
						io_natural=roll4(pltip.div.perpdown(1).iontgt+1); %this is io_natural for the corner of the cell. io_natural for the triangle is still 2
						
						ref.io_natural(1)=roll4(io_natural-2);
						ref.io_natural(2)=roll4(io_natural-1);
						ref.io_natural(3)=roll4(io_natural+0); %for that one 90deg corner
						ref.io_natural(4)=roll4(io_natural+1);
						ref.io_natural(5)=roll4(io_natural+2);
						%ref.io's are relative to io for corner
						for iref=1:5
							ref.nio_outside(iref)=nio_designator(ref.io_natural(iref));
							ref.io(iref)=CONNECT_crack.center.values(icrackparticle,ref.nio_outside(iref),ipath);
						end
						
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						pltip.div.io_natural(1).ionumber(2)=io;
						pltip.div.io_natural(1).pos(2,:)=LOC(io,:);
						pltip.div.io_natural(1).u_si(2,:)=u_si(io,:,1);
						
						%assigning position for intersectings
						pltip.div.io_natural(1).upordown(1)=2; %2=down, 1=up
						pltip.div.io_natural(1).pos(1,:)=pltip.div.perpdown(1).pos;
						pltip.div.io_natural(1).upordown(3)=1; %2=down, 1=up
						pltip.div.io_natural(1).pos(3,:)=pltip.div.perpup(1).pos;
						
						%assigning u_si for intersecting bottom
						ref.ratio=calcmag(pltip.div.io_natural(1).pos(2,:)-pltip.div.io_natural(1).pos(1,:))/calcmag(pltip.div.io_natural(1).pos(2,:)-LOC(ref.io(2),:));
						pltip.div.io_natural(1).u_si(1,:)=u_si(ref.io(3),:,1)*(1-ref.ratio)+u_si(ref.io(2),:,1)*(ref.ratio);
						
						%assigning u_si for intersecting top
						ref.ratio=calcmag(pltip.div.io_natural(1).pos(2,:)-pltip.div.io_natural(1).pos(3,:))/calcmag(pltip.div.io_natural(1).pos(2,:)-LOC(ref.io(4),:));
						pltip.div.io_natural(1).u_si(3,:)=u_si(ref.io(3),:,1)*(1-ref.ratio)+u_si(ref.io(4),:,1)*(ref.ratio);
						%above is universal for all four
						%fhdjkslhfkdjsa.m
					else
						input_codegen('pltip.mode not matched!')
					end
					
					%strain calculation below
					1;
					if pltip.mode==-99 %used to be pltip.mode==3 %for triangle
						d_natural(1,1)=pltip.div.io_natural(1).u_si(1,1);
						d_natural(2,1)=pltip.div.io_natural(1).u_si(1,2);
						d_natural(3,1)=pltip.div.io_natural(1).u_si(2,1);
						d_natural(4,1)=pltip.div.io_natural(1).u_si(2,2);
						d_natural(5,1)=pltip.div.io_natural(1).u_si(3,1);
						d_natural(6,1)=pltip.div.io_natural(1).u_si(3,2);
						
						u1=pltip.div.io_natural(1).u_si(1,1);
						v1=pltip.div.io_natural(1).u_si(1,2);
						u2=pltip.div.io_natural(1).u_si(2,1);
						v2=pltip.div.io_natural(1).u_si(2,2);
						u3=pltip.div.io_natural(1).u_si(3,1);
						v3=pltip.div.io_natural(1).u_si(3,2);
						
						J_x1=pltip.div.io_natural(1).pos(1,1);
						J_y1=pltip.div.io_natural(1).pos(1,2);
						J_x2=pltip.div.io_natural(1).pos(2,1);
						J_y2=pltip.div.io_natural(1).pos(2,2);
						J_x3=pltip.div.io_natural(1).pos(3,1);
						J_y3=pltip.div.io_natural(1).pos(3,2);
						
						pltip.B(1:3,1:6)=[-1/J_x2 0 1/J_x2 0 0 0;0 (J_x3-J_x2)/(J_x2*J_y3) 0 -J_x3/(J_x2*J_y3) 0 1/J_y3;(J_x3-J_x2)/(J_x2*J_y3) -1/J_x2 -J_x3/(J_x2*J_y3) 1/J_x2 1/J_y3 0];
						
						epsilon_tip=pltip.B(1:3,1:6)*d_natural(1:6,1);
						1;
					else%if pltip.mode==1 || pltip.mode==2
						% Classic FEM Below
						a=le(2)/2;
						b=le(1)/2;
						
						%new system insertion starts here
						if t_time>0.0140
							1;
						end
						d_natural(1,1)=pltip.div.io_natural(1).u_si(1,1);
						d_natural(2,1)=pltip.div.io_natural(1).u_si(1,2);
						d_natural(3,1)=pltip.div.io_natural(1).u_si(2,1);
						d_natural(4,1)=pltip.div.io_natural(1).u_si(2,2);
						d_natural(5,1)=pltip.div.io_natural(1).u_si(3,1);
						d_natural(6,1)=pltip.div.io_natural(1).u_si(3,2);
						d_natural(7,1)=pltip.div.io_natural(1).u_si(4,1);
						d_natural(8,1)=pltip.div.io_natural(1).u_si(4,2);
						LOC_avg=(pltip.div.io_natural(1).pos(1,:)+pltip.div.io_natural(1).pos(2,:)+pltip.div.io_natural(1).pos(3,:)+pltip.div.io_natural(1).pos(4,:))/4;
						a=((pltip.div.io_natural(1).pos(3,2)-pltip.div.io_natural(1).pos(2,2))+(pltip.div.io_natural(1).pos(4,2)-pltip.div.io_natural(1).pos(1,2)))/2;
						b=((pltip.div.io_natural(1).pos(2,1)-pltip.div.io_natural(1).pos(1,1))+(pltip.div.io_natural(1).pos(3,1)-pltip.div.io_natural(1).pos(4,1)))/2;
						%new system insertion ends here
						
						%[D]TDL new split arrangement below
						
						eta=0; %to stop coder whining
						xi=0; %to stop coder whining
						
						navg=zeros(1,1);
						if pltip.mode==2 || pltip.mode==3
							navg=2;
						elseif pltip.mode==1
							navg=1;
						else
							DUMMY=input_codegen('invalid pltip.mode!');
						end
						for iavg=1:navg
							u1=pltip.div.io_natural(iavg).u_si(1,1);
							v1=pltip.div.io_natural(iavg).u_si(1,2);
							u2=pltip.div.io_natural(iavg).u_si(2,1);
							v2=pltip.div.io_natural(iavg).u_si(2,2);
							u3=pltip.div.io_natural(iavg).u_si(3,1);
							v3=pltip.div.io_natural(iavg).u_si(3,2);
							u4=pltip.div.io_natural(iavg).u_si(4,1);
							v4=pltip.div.io_natural(iavg).u_si(4,2);
							
							J_x1=pltip.div.io_natural(iavg).pos(1,1);
							J_y1=pltip.div.io_natural(iavg).pos(1,2);
							J_x2=pltip.div.io_natural(iavg).pos(2,1);
							J_y2=pltip.div.io_natural(iavg).pos(2,2);
							J_x3=pltip.div.io_natural(iavg).pos(3,1);
							J_y3=pltip.div.io_natural(iavg).pos(3,2);
							J_x4=pltip.div.io_natural(iavg).pos(4,1);
							J_y4=pltip.div.io_natural(iavg).pos(4,2);
							J_x=x_crack.center(icrackparticle,1,ipath);
							J_y=x_crack.center(icrackparticle,2,ipath);
							
							%pltip.posbefore=[J_x1;J_y1;J_x2;J_y2;J_x3;J_y3;J_x4;J_y4]; %[D]TDL delete for coder
							for irepeat=1:10
								%if (J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)==0 || (J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)==0
								if abs(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)<le(1)/2*(1e-5) || abs(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)<le(1)/2*(1e-5)
									%disp(['fix attempt number' num2str(irepeat)]); %[D]TDL delete for coder
									J_x1=J_x1+le(1)*(1e-5)*(rand-0.5);
									J_y1=J_y1+le(1)*(1e-5)*(rand-0.5);
									J_x2=J_x2+le(1)*(1e-5)*(rand-0.5);
									J_y2=J_y2+le(1)*(1e-5)*(rand-0.5);
									J_x3=J_x3+le(1)*(1e-5)*(rand-0.5);
									J_y3=J_y3+le(1)*(1e-5)*(rand-0.5);
									J_x4=J_x4+le(1)*(1e-5)*(rand-0.5);
									J_y4=J_y4+le(1)*(1e-5)*(rand-0.5);
								else
									%disp('fix successful!'); %[D]TDL delete for coder
									break;
								end
							end
							%pltip.posafter=[J_x1;J_y1;J_x2;J_y2;J_x3;J_y3;J_x4;J_y4]; %[D]TDL delete for coder
							1; 
							
							if (J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)~=0
								eta=(J_x*J_y1)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)-(J_x^2*J_y1^2-2*J_x^2*J_y1*J_y2+2*J_x^2*J_y1*J_y3-2*J_x^2*J_y1*J_y4+J_x^2*J_y2^2-2*J_x^2*J_y2*J_y3+2*J_x^2*J_y2*J_y4+J_x^2*J_y3^2-2*J_x^2*J_y3*J_y4+J_x^2*J_y4^2-2*J_x*J_x1*J_y*J_y1+2*J_x*J_x1*J_y*J_y2-2*J_x*J_x1*J_y*J_y3+2*J_x*J_x1*J_y*J_y4+2*J_x*J_x1*J_y1*J_y3+2*J_x*J_x1*J_y2*J_y3-4*J_x*J_x1*J_y2*J_y4-2*J_x*J_x1*J_y3^2+2*J_x*J_x1*J_y3*J_y4+2*J_x*J_x2*J_y*J_y1-2*J_x*J_x2*J_y*J_y2+2*J_x*J_x2*J_y*J_y3-2*J_x*J_x2*J_y*J_y4-4*J_x*J_x2*J_y1*J_y3+2*J_x*J_x2*J_y1*J_y4+2*J_x*J_x2*J_y2*J_y4+2*J_x*J_x2*J_y3*J_y4-2*J_x*J_x2*J_y4^2-2*J_x*J_x3*J_y*J_y1+2*J_x*J_x3*J_y*J_y2-2*J_x*J_x3*J_y*J_y3+2*J_x*J_x3*J_y*J_y4-2*J_x*J_x3*J_y1^2+2*J_x*J_x3*J_y1*J_y2+2*J_x*J_x3*J_y1*J_y3+2*J_x*J_x3*J_y1*J_y4-4*J_x*J_x3*J_y2*J_y4+2*J_x*J_x4*J_y*J_y1-2*J_x*J_x4*J_y*J_y2+2*J_x*J_x4*J_y*J_y3-2*J_x*J_x4*J_y*J_y4+2*J_x*J_x4*J_y1*J_y2-4*J_x*J_x4*J_y1*J_y3-2*J_x*J_x4*J_y2^2+2*J_x*J_x4*J_y2*J_y3+2*J_x*J_x4*J_y2*J_y4+J_x1^2*J_y^2-2*J_x1^2*J_y*J_y3+J_x1^2*J_y3^2-2*J_x1*J_x2*J_y^2+2*J_x1*J_x2*J_y*J_y3+2*J_x1*J_x2*J_y*J_y4-2*J_x1*J_x2*J_y3*J_y4+2*J_x1*J_x3*J_y^2+2*J_x1*J_x3*J_y*J_y1-4*J_x1*J_x3*J_y*J_y2+2*J_x1*J_x3*J_y*J_y3-4*J_x1*J_x3*J_y*J_y4-2*J_x1*J_x3*J_y1*J_y3+4*J_x1*J_x3*J_y2*J_y4-2*J_x1*J_x4*J_y^2+2*J_x1*J_x4*J_y*J_y2+2*J_x1*J_x4*J_y*J_y3-2*J_x1*J_x4*J_y2*J_y3+J_x2^2*J_y^2-2*J_x2^2*J_y*J_y4+J_x2^2*J_y4^2-2*J_x2*J_x3*J_y^2+2*J_x2*J_x3*J_y*J_y1+2*J_x2*J_x3*J_y*J_y4-2*J_x2*J_x3*J_y1*J_y4+2*J_x2*J_x4*J_y^2-4*J_x2*J_x4*J_y*J_y1+2*J_x2*J_x4*J_y*J_y2-4*J_x2*J_x4*J_y*J_y3+2*J_x2*J_x4*J_y*J_y4+4*J_x2*J_x4*J_y1*J_y3-2*J_x2*J_x4*J_y2*J_y4+J_x3^2*J_y^2-2*J_x3^2*J_y*J_y1+J_x3^2*J_y1^2-2*J_x3*J_x4*J_y^2+2*J_x3*J_x4*J_y*J_y1+2*J_x3*J_x4*J_y*J_y2-2*J_x3*J_x4*J_y1*J_y2+J_x4^2*J_y^2-2*J_x4^2*J_y*J_y2+J_x4^2*J_y2^2)^(1/2)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)-(J_x1*J_y)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)-(J_x*J_y2)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)+(J_x2*J_y)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)+(J_x*J_y3)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)+(J_x1*J_y2)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)-(J_x2*J_y1)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)-(J_x3*J_y)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)-(J_x*J_y4)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)+(J_x4*J_y)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)+(J_x3*J_y4)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)-(J_x4*J_y3)/(J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3);
							else
								DUMMY=input_codegen('invalid nodal positions! (eta)');
							end
							if (J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)~=0
								xi=(J_x1*J_y)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)-(J_x*J_y1)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)-(J_x^2*J_y1^2-2*J_x^2*J_y1*J_y2+2*J_x^2*J_y1*J_y3-2*J_x^2*J_y1*J_y4+J_x^2*J_y2^2-2*J_x^2*J_y2*J_y3+2*J_x^2*J_y2*J_y4+J_x^2*J_y3^2-2*J_x^2*J_y3*J_y4+J_x^2*J_y4^2-2*J_x*J_x1*J_y*J_y1+2*J_x*J_x1*J_y*J_y2-2*J_x*J_x1*J_y*J_y3+2*J_x*J_x1*J_y*J_y4+2*J_x*J_x1*J_y1*J_y3+2*J_x*J_x1*J_y2*J_y3-4*J_x*J_x1*J_y2*J_y4-2*J_x*J_x1*J_y3^2+2*J_x*J_x1*J_y3*J_y4+2*J_x*J_x2*J_y*J_y1-2*J_x*J_x2*J_y*J_y2+2*J_x*J_x2*J_y*J_y3-2*J_x*J_x2*J_y*J_y4-4*J_x*J_x2*J_y1*J_y3+2*J_x*J_x2*J_y1*J_y4+2*J_x*J_x2*J_y2*J_y4+2*J_x*J_x2*J_y3*J_y4-2*J_x*J_x2*J_y4^2-2*J_x*J_x3*J_y*J_y1+2*J_x*J_x3*J_y*J_y2-2*J_x*J_x3*J_y*J_y3+2*J_x*J_x3*J_y*J_y4-2*J_x*J_x3*J_y1^2+2*J_x*J_x3*J_y1*J_y2+2*J_x*J_x3*J_y1*J_y3+2*J_x*J_x3*J_y1*J_y4-4*J_x*J_x3*J_y2*J_y4+2*J_x*J_x4*J_y*J_y1-2*J_x*J_x4*J_y*J_y2+2*J_x*J_x4*J_y*J_y3-2*J_x*J_x4*J_y*J_y4+2*J_x*J_x4*J_y1*J_y2-4*J_x*J_x4*J_y1*J_y3-2*J_x*J_x4*J_y2^2+2*J_x*J_x4*J_y2*J_y3+2*J_x*J_x4*J_y2*J_y4+J_x1^2*J_y^2-2*J_x1^2*J_y*J_y3+J_x1^2*J_y3^2-2*J_x1*J_x2*J_y^2+2*J_x1*J_x2*J_y*J_y3+2*J_x1*J_x2*J_y*J_y4-2*J_x1*J_x2*J_y3*J_y4+2*J_x1*J_x3*J_y^2+2*J_x1*J_x3*J_y*J_y1-4*J_x1*J_x3*J_y*J_y2+2*J_x1*J_x3*J_y*J_y3-4*J_x1*J_x3*J_y*J_y4-2*J_x1*J_x3*J_y1*J_y3+4*J_x1*J_x3*J_y2*J_y4-2*J_x1*J_x4*J_y^2+2*J_x1*J_x4*J_y*J_y2+2*J_x1*J_x4*J_y*J_y3-2*J_x1*J_x4*J_y2*J_y3+J_x2^2*J_y^2-2*J_x2^2*J_y*J_y4+J_x2^2*J_y4^2-2*J_x2*J_x3*J_y^2+2*J_x2*J_x3*J_y*J_y1+2*J_x2*J_x3*J_y*J_y4-2*J_x2*J_x3*J_y1*J_y4+2*J_x2*J_x4*J_y^2-4*J_x2*J_x4*J_y*J_y1+2*J_x2*J_x4*J_y*J_y2-4*J_x2*J_x4*J_y*J_y3+2*J_x2*J_x4*J_y*J_y4+4*J_x2*J_x4*J_y1*J_y3-2*J_x2*J_x4*J_y2*J_y4+J_x3^2*J_y^2-2*J_x3^2*J_y*J_y1+J_x3^2*J_y1^2-2*J_x3*J_x4*J_y^2+2*J_x3*J_x4*J_y*J_y1+2*J_x3*J_x4*J_y*J_y2-2*J_x3*J_x4*J_y1*J_y2+J_x4^2*J_y^2-2*J_x4^2*J_y*J_y2+J_x4^2*J_y2^2)^(1/2)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)+(J_x*J_y2)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)-(J_x2*J_y)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)-(J_x*J_y3)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)+(J_x3*J_y)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)+(J_x*J_y4)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)-(J_x4*J_y)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)-(J_x1*J_y4)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)+(J_x2*J_y3)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)-(J_x3*J_y2)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)+(J_x4*J_y1)/(J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2);
							else
								DUMMY=input_codegen('invalid nodal positions! (xi)');
							end
							1;
							if (J_x1*J_y2-J_x2*J_y1-J_x1*J_y3+J_x3*J_y1+J_x2*J_y4-J_x4*J_y2-J_x3*J_y4+J_x4*J_y3)==0 || (J_x1*J_y3-J_x3*J_y1-J_x1*J_y4-J_x2*J_y3+J_x3*J_y2+J_x4*J_y1+J_x2*J_y4-J_x4*J_y2)==0
								DUMMY=input_codegen('invalid nodal positions! (Jacobian Calculation)');
							else
								Jacobian= ...
									[J_x2/4-J_x1/4+J_x3/4-J_x4/4+(J_x1*eta)/4-(J_x2*eta)/4+(J_x3*eta)/4-(J_x4*eta)/4,J_y2/4-J_y1/4+J_y3/4-J_y4/4+(J_y1*eta)/4-(J_y2*eta)/4+(J_y3*eta)/4-(J_y4*eta)/4;
									J_x3/4-J_x2/4-J_x1/4+J_x4/4+(J_x1*xi)/4-(J_x2*xi)/4+(J_x3*xi)/4-(J_x4*xi)/4,J_y3/4-J_y2/4-J_y1/4+J_y4/4+(J_y1*xi)/4-(J_y2*xi)/4+(J_y3*xi)/4-(J_y4*xi)/4];
								pltip.epsilon_tip(:,iavg)=1/det(Jacobian)* ... 
									[(J_y1/4+J_y2/4-J_y3/4-J_y4/4-(J_y1*xi)/4+(J_y2*xi)/4-(J_y3*xi)/4+(J_y4*xi)/4)*(u1/4-u2/4-u3/4+u4/4-(eta*u1)/4+(eta*u2)/4-(eta*u3)/4+(eta*u4)/4)-(J_y1/4-J_y2/4-J_y3/4+J_y4/4-(J_y1*eta)/4+(J_y2*eta)/4-(J_y3*eta)/4+(J_y4*eta)/4)*(u1/4+u2/4-u3/4-u4/4-(u1*xi)/4+(u2*xi)/4-(u3*xi)/4+(u4*xi)/4);
									(J_x1/4-J_x2/4-J_x3/4+J_x4/4-(J_x1*eta)/4+(J_x2*eta)/4-(J_x3*eta)/4+(J_x4*eta)/4)*(v1/4+v2/4-v3/4-v4/4-(v1*xi)/4+(v2*xi)/4-(v3*xi)/4+(v4*xi)/4)-(J_x1/4+J_x2/4-J_x3/4-J_x4/4-(J_x1*xi)/4+(J_x2*xi)/4-(J_x3*xi)/4+(J_x4*xi)/4)*(v1/4-v2/4-v3/4+v4/4-(eta*v1)/4+(eta*v2)/4-(eta*v3)/4+(eta*v4)/4);
									(J_x1/4-J_x2/4-J_x3/4+J_x4/4-(J_x1*eta)/4+(J_x2*eta)/4-(J_x3*eta)/4+(J_x4*eta)/4)*(u1/4+u2/4-u3/4-u4/4-(u1*xi)/4+(u2*xi)/4-(u3*xi)/4+(u4*xi)/4)-(J_x1/4+J_x2/4-J_x3/4-J_x4/4-(J_x1*xi)/4+(J_x2*xi)/4-(J_x3*xi)/4+(J_x4*xi)/4)*(u1/4-u2/4-u3/4+u4/4-(eta*u1)/4+(eta*u2)/4-(eta*u3)/4+(eta*u4)/4)-(J_y1/4-J_y2/4-J_y3/4+J_y4/4-(J_y1*eta)/4+(J_y2*eta)/4-(J_y3*eta)/4+(J_y4*eta)/4)*(v1/4+v2/4-v3/4-v4/4-(v1*xi)/4+(v2*xi)/4-(v3*xi)/4+(v4*xi)/4)+(J_y1/4+J_y2/4-J_y3/4-J_y4/4-(J_y1*xi)/4+(J_y2*xi)/4-(J_y3*xi)/4+(J_y4*xi)/4)*(v1/4-v2/4-v3/4+v4/4-(eta*v1)/4+(eta*v2)/4-(eta*v3)/4+(eta*v4)/4)];
							end
						end %end of iavg loop
						epsilon_tip=zeros(3,1);
						for idim=1:3
							for iavg=1:navg
								epsilon_tip(idim,1)=epsilon_tip(idim,1)+pltip.epsilon_tip(idim,iavg);
							end
							epsilon_tip(idim,1)=epsilon_tip(idim,1)/navg;
						end
					end
					%[D]TDL construction in frafxhagsxlf.m above 66 lines
					%[D]TDL new split arrangement above
					
					%{
					N_FEM=zeros(2,8);
					N_FEM(1,1)=1/4*(1-xi)*(1-eta);
					N_FEM(2,2)=N_FEM(1,1);
					N_FEM(1,3)=1/4*(1+xi)*(1-eta);
					N_FEM(2,4)=N_FEM(1,3);
					N_FEM(1,5)=1/4*(1+xi)*(1+eta);
					N_FEM(2,6)=N_FEM(1,5);
					N_FEM(1,7)=1/4*(1-xi)*(1+eta);
					N_FEM(2,8)=N_FEM(1,7);
					%}
					
					%asdf(-pi); %to induce error for checking, turn "pause on error" on!
					%use cutvisualizer.m to visualize cut, nodal displacements, etc.
					
					D=E/((1+nu)*(1-2*nu))*[1-nu nu 0;nu 1-nu 0;0 0 (1-2*nu)];
					
					s_tip_temp=D*epsilon_tip;
					
					for idim=1:3
						s_tip(ipath,idim,tip)=s_tip_temp(idim,1);
					end
					for idim=1:3
						s_tip_dump(2*(ipath-1)+tip,idim)=s_tip(ipath,idim,tip);
						s_tip_K1_dump(2*(ipath-1)+tip,idim)=s_tip_K1(ipath,idim,tip);
					end
					for idim=1:8
						d_tip_dump(2*(ipath-1)+tip,idim)=d_natural(idim,1);
						io_natural=ceil(idim/2);
						xydim=mod(idim-1,2)+1;
						d_LOC_tip_dump(2*(ipath-1)+tip,idim)=LOC(CONNECT_crack.center.values(icrackparticle,nio_designator(io_natural),ipath),xydim);
					end
					for idim=1:2
						x_tip_dump(2*(ipath-1)+tip,idim)=x_crack.center(icrackparticle,idim,ipath);
					end
					s_tip_max=(s_tip(ipath,1,tip)+s_tip(ipath,2,tip))/2+sqrt( ((s_tip(ipath,1,tip)-s_tip(ipath,2,tip))/2)^2 + (s_tip(ipath,3,tip))^2 ); %calculate principal stress
					
					
					pltip.dESP(1,1)=epsilon_tip(1);
					pltip.dESP(1,2)=epsilon_tip(3);
					pltip.dESP(2,1)=epsilon_tip(3);
					pltip.dESP(2,2)=epsilon_tip(2);
					pltip.R=eye(2);
					pltip.Rback=eye(2);
					pltip.Q=[cos(pltip.angle.chosen) sin(pltip.angle.chosen); -sin(pltip.angle.chosen) cos(pltip.angle.chosen)];
					pltip.Qback=[cos(-pltip.angle.chosen) sin(-pltip.angle.chosen); -sin(-pltip.angle.chosen) cos(-pltip.angle.chosen)];
					pltip.RQ=pltip.R*pltip.Q;
					pltip.QbackRback=pltip.Qback*pltip.Rback;
					pltip.dESP=(pltip.RQ)*pltip.dESP*transpose(pltip.RQ);
					%[s_sp,e_pl,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax]=Wood_Schmidt17(dESP,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp);
					%tip_weakeningfactor=0.9;
					[pltip.s_sp,DUMMY1,DUMMY2,DUMMY3,DUMMY4,DUMMY5,DUMMY6,surfacewithfmax,DUMMY8,pltip.AbeforeQ_rtl,~]= ...
						Wood_Schmidt17(tip_k,0,0,pltip.dESP,pltip.sigma_global_big,pltip.e_t_global_big,pltip.e_pl_global_big,pltip.alpha_in,pltip.xdirletter,pltip.ydirletter,pltip.zdirletter,pltip.xydirletter,pltip.yzdirletter,pltip.xzdirletter,ftl*(1-tip_weakeningfactor),ftr*(1-tip_weakeningfactor),ftt*(1-tip_weakeningfactor),fcl*(1-tip_weakeningfactor),fcr*(1-tip_weakeningfactor),fct*(1-tip_weakeningfactor),fvrt*(1-tip_weakeningfactor),fvrl*(1-tip_weakeningfactor),fvtl*(1-tip_weakeningfactor),Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,t_time,dt,pltip.spid,Debugging,pltip.thetacrackrtl,pltip.dudx_rtl);
					
					%DUMMY5 is alpha_hp 
					if sum(DUMMY5)>0
						1;
					end
					if sum(sum(alphahp))>0
						1;
					end
					lambdamin=inf;
					thetamin=NaN;
					lambda1=zeros(ntestedangle,1);
					lambda2=zeros(ntestedangle,1);
					theta=zeros(ntestedangle,1);
					theta_crack=zeros(1,1);
					n=zeros(2,1);
					h=zeros(2,2,ntestedangle);
					Qacoustic=zeros(2,2,ntestedangle);
					%AbeforeQ_tip=pltip.AbeforeQ_rtl; %no longer in use, we use orientationoffset interpolation now, as calculated in the for stacks below
					
					for idim1=1:2
					for idim2=1:2
					for idim3=1:2
					for idim4=1:2
					for idim5=1:2
					for idim6=1:2
					for idim7=1:2
					for idim8=1:2
						AbeforeQ_tip(idim1,idim2,idim3,idim4)=AbeforeQ_tip(idim1,idim2,idim3,idim4)+real(pltip.QbackRback(idim1,idim5)*pltip.QbackRback(idim2,idim6)*pltip.QbackRback(idim3,idim7)*pltip.QbackRback(idim4,idim8)*pltip.AbeforeQ_rtl(idim5,idim6,idim7,idim8));
					end
					end
					end
					end
					end
					end
					end
					end
					
					AbeforeQ_breaksignal=0;
					for itestedangle=1:ntestedangle
						theta(itestedangle)=(itestedangle)/ntestedangle*2*pi;
						n(1)=cos(theta(itestedangle));
						n(2)=sin(theta(itestedangle));
						for idim1=1:2
						for idim2=1:2
						for idim3=1:2
						for idim4=1:2
							if isnan(AbeforeQ_tip(idim1,idim2,idim3,idim4))
								AbeforeQ_breaksignal=1;
							end
							Qacoustic(idim2,idim3,itestedangle)=Qacoustic(idim2,idim3,itestedangle)+n(idim1)*AbeforeQ_tip(idim1,idim2,idim3,idim4)*n(idim4);
						end
						end
						end
						end
						if AbeforeQ_breaksignal
							break;
						end
						[h_eig,lambda_eig]=eig(Qacoustic(:,:,itestedangle));
						h(:,:,itestedangle)=real(h_eig);
						lambda1(itestedangle)=real(lambda_eig(1,1));
						lambda2(itestedangle)=real(lambda_eig(2,2));
					end
					1;
					if AbeforeQ_breaksignal
						continue;
					end
					lambdamin=min([lambda1;lambda2]);
					if length(lambdamin)>1
						fprintf('%s',['length(lamdabmin)>1!' char(10)]);
						DUMMY=input_codegen('error 201004-1301 (this is bogus input)');
					end
					if lambdamin>=0
						theta_crack=NaN;
						propagationsignal=0;
					else
						%asdf(-pi);
						propagationsignal=1;
						localminima1index.sizes=0;
						localminima1index.values=zeros(1,ntestedangle);
						localminima2index.sizes=0;
						localminima2index.values=zeros(1,ntestedangle);
						for itestedangle=1:ntestedangle
							if lambda1(itestedangle)<0 && lambda1(itestedangle)<=lambda1(mod((itestedangle-1)-1,ntestedangle)+1) && lambda1(itestedangle)<=lambda1(mod((itestedangle+1)-1,ntestedangle)+1)
								localminima1index.sizes=localminima1index.sizes+1;
								localminima1index.values(localminima1index.sizes)=itestedangle;
							end
							if lambda2(itestedangle)<0 && lambda2(itestedangle)<=lambda2(mod((itestedangle-1)-1,ntestedangle)+1) && lambda2(itestedangle)<=lambda2(mod((itestedangle+1)-1,ntestedangle)+1)
								localminima2index.sizes=localminima2index.sizes+1;
								localminima2index.values(localminima2index.sizes)=itestedangle;
							end
						end
						nldudxhl.sizes=localminima1index.sizes+localminima2index.sizes;
						nldudxhl.values=zeros(1,2*ntestedangle);
						h_localminima.sizes=localminima1index.sizes+localminima2index.sizes;
						h_localminima.values=zeros(2,2*ntestedangle);
						for ilocalminima=1:localminima1index.sizes
							n(1)=cos(theta(localminima1index.values(ilocalminima)));
							n(2)=sin(theta(localminima1index.values(ilocalminima)));
							nldudxhl.values(ilocalminima)=real(transpose(n)*dudx_tip*h(:,1,localminima1index.values(ilocalminima)));
							nldudxhl.sizes=ilocalminima;
							h_localminima.values(:,ilocalminima)=h(:,1,localminima1index.values(ilocalminima));
							h_localminima.sizes=ilocalminima;
						end
						for ilocalminima=1:localminima2index.sizes
							n(1)=cos(theta(localminima2index.values(ilocalminima)));
							n(2)=sin(theta(localminima2index.values(ilocalminima)));
							nldudxhl.values(ilocalminima+localminima1index.sizes)=real(transpose(n)*dudx_tip*h(:,2,localminima2index.values(ilocalminima)));
							nldudxhl.sizes=ilocalminima+localminima1index.sizes;
							h_localminima.values(:,ilocalminima+localminima1index.sizes)=h(:,2,localminima2index.values(ilocalminima));
							h_localminima.sizes=ilocalminima+localminima1index.sizes;
						end
						for ilocalminima=1:localminima1index.sizes
							localminimaindex.values(ilocalminima)=localminima1index.values(ilocalminima);
							localminimaindex.sizes=ilocalminima;
						end
						for ilocalminima=1:localminima2index.sizes
							localminimaindex.values(ilocalminima+localminima1index.sizes)=localminima2index.values(ilocalminima);
							localminimaindex.sizes=localminima1index.sizes+ilocalminima;
						end
						FindMaxnldudxhl=FindMax(nldudxhl.values(1:nldudxhl.sizes));
						crackindex=localminimaindex.values(FindMaxnldudxhl);
						thetamin=theta(crackindex);
						h_crackdecision=zeros(2,1);
						h_crackdecision(:,1)=h_localminima.values(:,FindMaxnldudxhl);
						theta_crack=mod(thetamin+pi/2+pi/2,pi)+pi/2;
					end
					
					% end of criterion evaluation of crack propagation
					
					% propagation signal designates whether crack should propagate or not
					
					if x_crack.terminatedprop(ipath,tip)==0 && propagationsignal==1
						%TDL catch propagation
						%if t_time>0.35078038001005700489847644365468
							%asdf(-pi);
						%end
						%asdf(-pi);
						dumpresult=1;
						x_crack.bridge.failuresurface(icrackparticle,ipath)=surfacewithfmax(1);
						if surfacewithfmax(1)==1
							x_crack.bridge.fractureenergy(icrackparticle,ipath)=Gftr;
							x_crack.bridge.strength(icrackparticle,ipath)=ftr;
						elseif surfacewithfmax(1)==3
							x_crack.bridge.fractureenergy(icrackparticle,ipath)=Gftt;
							x_crack.bridge.strength(icrackparticle,ipath)=ftt;
						elseif surfacewithfmax(1)==5
							x_crack.bridge.fractureenergy(icrackparticle,ipath)=Gftl;
							x_crack.bridge.strength(icrackparticle,ipath)=ftl;
						else
							x_crack.bridge.fractureenergy(icrackparticle,ipath)=0;
							x_crack.bridge.strength(icrackparticle,ipath)=ftl;
						end
						x_crack.bridge.yieldforce2(icrackparticle,ipath)=x_crack.bridge.strength(icrackparticle,ipath)*x_crack.spacing;
						baselength=x_crack.bridge.fractureenergy(icrackparticle,ipath)/x_crack.bridge.yieldforce2(icrackparticle,ipath);
						x_crack.bridge.deltae2(icrackparticle,ipath)=0.1*baselength;
						x_crack.bridge.deltai2(icrackparticle,ipath)=0.9*baselength;
						
						%crackextension=x_crack.spacing;
						crackextension=2*le_base;
						if tip==1
							deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
						elseif tip==2
							deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
						end
						theta_crack_trial(1)=theta_crack;
						theta_crack_trial(2)=mod(theta_crack+pi,2*pi); %two possibilities for crack angle, 
						if (deltax_previous(1,1,1)*cos(theta_crack_trial(1))+deltax_previous(1,2,1)*sin(theta_crack_trial(1)))>0 % cos of theta_crack_trial with current crack tip trajectory
							theta_crack=theta_crack_trial(1);
						else
							theta_crack=theta_crack_trial(2);
						end
						if tip==1
							%STRENGTH EXCEEDING PROPAGATION
							x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+crackextension*cos(theta_crack);
							x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+crackextension*sin(theta_crack);
							for idim=1:2
								for iNN=1:NN(idim)-1;
									linepostgt=(iNN-0.5)*le(idim);
									pltip.crossmarker=0;
									for jNN=1:NN(idim);
										edgepos=jNN*le(idim);	
										if (x_crack.center(icrackparticle,idim,ipath)-edgepos)*(linepostgt-edgepos)<0
											pltip.crossmarker=1;
											break;
										end
									end
									if pltip.crossmarker==0
										continue;
									end
									if abs(x_crack.center(icrackparticle,idim,ipath)-linepostgt)<le(idim)/1000
										continue;
									end
									if (x_crack.center(icrackparticle+1,idim,ipath)-linepostgt)*(x_crack.center(icrackparticle,idim,ipath)-linepostgt)<0
										crackextension=crackextension*(linepostgt-x_crack.center(icrackparticle,idim,ipath))/(x_crack.center(icrackparticle+1,idim,ipath)-x_crack.center(icrackparticle,idim,ipath));
										
										x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+crackextension*cos(theta_crack);
										x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+crackextension*sin(theta_crack);
									end
								end
							end
							for idim=1:2
								x_crack.top(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
								x_crack.bot(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
							end
							x_crack.bridge.effectivespacing(icrackparticle,ipath)=(calcmag(x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle+1,:,ipath))+calcmag(x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath)))/2;
							x_crack.bridge.nodalenergy(icrackparticle,ipath)=x_crack.bridge.effectivespacing(icrackparticle,ipath)*t0_plane*x_crack.bridge.fractureenergy(icrackparticle,ipath);
							
							x_crack.cohesivepoint(icrackparticle+1,ipath)=1;
							x_crack.sequence.tipreg(ipath,tip)=1;

							crackextension=x_crack.spacing;
							x_crack_ghosttip(1,1)=x_crack.center(icrackparticle,1,ipath)+3*crackextension*cos(theta_crack);
							x_crack_ghosttip(1,2)=x_crack.center(icrackparticle,2,ipath)+3*crackextension*sin(theta_crack);
						elseif tip==2
							for icrackparticlemove=x_crack.nparticles(ipath):-1:1
								for idim=1:2
									x_crack.center(icrackparticlemove+1,idim,ipath)=x_crack.center(icrackparticlemove,idim,ipath);
									x_crack.top(icrackparticlemove+1,idim,ipath)=x_crack.top(icrackparticlemove,idim,ipath);
									x_crack.bot(icrackparticlemove+1,idim,ipath)=x_crack.bot(icrackparticlemove,idim,ipath);
									
									x_crack.force.top(icrackparticlemove+1,idim,ipath)=x_crack.force.top(icrackparticlemove,idim,ipath);
									x_crack.force.bot(icrackparticlemove+1,idim,ipath)=x_crack.force.bot(icrackparticlemove,idim,ipath);
									x_crack.bridge.base.deltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.base.deltax(icrackparticlemove,idim,ipath);
									x_crack.bridge.adjusted.deltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.adjusted.deltax(icrackparticlemove,idim,ipath);
									x_crack.bridge.firsttimedeltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.firsttimedeltax(icrackparticlemove,idim,ipath);
								end
								x_crack.bridge.absforce(icrackparticlemove+1,ipath)=x_crack.bridge.absforce(icrackparticlemove,ipath);
								x_crack.bridge.isactive(icrackparticlemove+1,ipath)=x_crack.bridge.isactive(icrackparticlemove,ipath);
								x_crack.bridge.firsttimeactive(icrackparticlemove+1,ipath)=x_crack.bridge.firsttimeactive(icrackparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltaxmax(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmax(icrackparticlemove,ipath);
								x_crack.bridge.base.absdeltax(icrackparticlemove+1,ipath)=x_crack.bridge.base.absdeltax(icrackparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltax(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltax(icrackparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltaxmaxi(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmaxi(icrackparticlemove,ipath);
								x_crack.bridge.kbase2(icrackparticlemove+1,ipath)=x_crack.bridge.kbase2(icrackparticlemove,ipath);
								x_crack.bridge.yieldforce2(icrackparticlemove+1,ipath)=x_crack.bridge.yieldforce2(icrackparticlemove,ipath);
								x_crack.bridge.deltai2(icrackparticlemove+1,ipath)=x_crack.bridge.deltai2(icrackparticlemove,ipath);
								x_crack.cohesivepoint(icrackparticlemove+1,ipath)=x_crack.cohesivepoint(icrackparticlemove,ipath);
							end
							x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+crackextension*cos(theta_crack);
							x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+crackextension*sin(theta_crack);
							for idim=1:2
								for iNN=1:NN(idim)-1;
									linepostgt=(iNN-0.5)*le(idim);
									pltip.crossmarker=0;
									for jNN=1:NN(idim);
										edgepos=jNN*le(idim);	
										if (x_crack.center(2,idim,ipath)-edgepos)*(linepostgt-edgepos)<0
											pltip.crossmarker=1;
											break;
										end
									end
									if pltip.crossmarker==0
										continue;
									end
									if abs(x_crack.center(2,idim,ipath)-linepostgt)<le(idim)/1000
										continue;
									end
									if (x_crack.center(2,idim,ipath)-linepostgt)*(x_crack.center(1,idim,ipath)-linepostgt)<0
										crackextension=crackextension*(linepostgt-x_crack.center(2,idim,ipath))/(x_crack.center(1,idim,ipath)-x_crack.center(2,idim,ipath));
										
										x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+crackextension*cos(theta_crack);
										x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+crackextension*sin(theta_crack);
									end
								end
							end
							for idim=1:2
								x_crack.top(1,idim,ipath)=x_crack.center(1,idim,ipath);
								x_crack.bot(1,idim,ipath)=x_crack.center(1,idim,ipath);
							end
							x_crack.bridge.effectivespacing(2,ipath)=(calcmag(x_crack.center(2,:,ipath)-x_crack.center(3,:,ipath))+calcmag(x_crack.center(2,:,ipath)-x_crack.center(1,:,ipath)))/2;
							x_crack.bridge.nodalenergy(2,ipath)=x_crack.bridge.effectivespacing(2,ipath)*t0_plane*x_crack.bridge.fractureenergy(2,ipath);
							
							x_crack.cohesivepoint(1,ipath)=1;
							x_crack.sequence.tipreg(ipath,tip)=1;
							
							crackextension=x_crack.spacing;
							x_crack_ghosttip(1,1)=x_crack.center(2,1,ipath)+3*crackextension*cos(theta_crack);
							x_crack_ghosttip(1,2)=x_crack.center(2,2,ipath)+3*crackextension*sin(theta_crack);
						end
						
						if tip==1
							x1(1,1)=x_crack.center(icrackparticle,1,ipath);
							x1(1,2)=x_crack.center(icrackparticle,2,ipath);
						elseif tip==2
							x1(1,1)=x_crack.center(2,1,ipath);
							x1(1,2)=x_crack.center(2,2,ipath);
						end
						x2(1,1)=x_crack_ghosttip(1,1);
						x2(1,2)=x_crack_ghosttip(1,2);
						
						foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
						foundcrossing.icrackparticle3=zeros(1,200); %so not to clash with iparticle
						foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
						foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.
						
						for ipath2=1:x_crack.npaths
							for icrackparticle2=1:(x_crack.nparticles(ipath2)-1)
								if ipath2==ipath
									%icrackparticle: deals with the propagation, what's currently the particle as the tip
									%icrackparticle2: the loop for checking crack crossing
									if tip==1 && icrackparticle2>=icrackparticle-2
										continue;
									elseif tip==2 && icrackparticle2<=2
										continue;
									end
								end
								%start of crossing checks
								for dim=1:2
									x3(1,dim)=x_crack.center(icrackparticle2,dim,ipath2);
									x4(1,dim)=x_crack.center(icrackparticle2+1,dim,ipath2);
								end
								Area(1)=TriangleArea(x1,x2,x3);
								Area(2)=TriangleArea(x1,x2,x4);
								Area(3)=TriangleArea(x3,x4,x1);
								Area(4)=TriangleArea(x3,x4,x2);
								if (Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0) || (Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0)
									foundcrossing.size3=foundcrossing.size3+1;
									foundcrossing.ipath3(foundcrossing.size3)=ipath2;
									foundcrossing.icrackparticle3(foundcrossing.size3)=icrackparticle2;
									foundcrossing.ratio(foundcrossing.size3)=abs(Area(3))/(abs(Area(3))+abs(Area(4)));%ratio between 1-crossing distance to 1-2 distance
								end
								%end of crossing checks
							end
						end
						foundcrossing_ratio_min=2;
						for ifoundcrossing=1:foundcrossing.size3
							if foundcrossing.ratio(ifoundcrossing)<foundcrossing_ratio_min
								foundcrossing_ratio_min=foundcrossing.ratio(ifoundcrossing);
								x_crack.sequence.merge(ipath,tip)=foundcrossing.ipath3(ifoundcrossing);
							end
						end
						if foundcrossing.size3>0
							x_crack.terminatedprop(ipath,tip)=1;
							if tip==1
								x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+foundcrossing_ratio_min*3.1*crackextension*cos(theta_crack);
								x_crack.top(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.bot(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+foundcrossing_ratio_min*3.1*crackextension*sin(theta_crack);
								x_crack.top(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
								x_crack.bot(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
							elseif tip==2
								x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+foundcrossing_ratio_min*3.1*crackextension*cos(theta_crack);
								x_crack.top(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.bot(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+foundcrossing_ratio_min*3.1*crackextension*sin(theta_crack);
								x_crack.top(1,2,ipath)=x_crack.center(1,2,ipath);
								x_crack.bot(1,2,ipath)=x_crack.center(1,2,ipath);
							end
						end
						x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
					end
				end
			end
		end
		
		%initiation starts below
		%bogus indent for below
			fprintf('%s',['marker #643b' char(10)]);
			denyinitiation=0;
			if CasetoRun==207
				denyinitiation=1;
			end
			if denyinitiation==0 && sum(justcracked)>0
				dumpresult=1;
				
				justcrackedlist=zeros(sum(justcracked),1);
				justcrackedcounter=0;
				for isp=1:spCount
					if justcracked(isp)
						justcrackedcounter=justcrackedcounter+1;
						justcrackedlist(justcrackedcounter)=isp;
					end
				end
				
				%justcrackedlist=CrackParticleClustering_nodes(LOC,1.5*le(1),justcrackedlist);
				fprintf('%s',['marker #702' char(10)]);
				%ntestedangle=size(Qacoustic{justcrackedlist{1}(1)},3);
				ntestedangle=36;
				fprintf('%s',['marker #703' char(10)]);
				theta=zeros(ntestedangle,1);
				fprintf('%s',['marker #704' char(10)]);
				errorntestedangle=36*1*1*1;
				error=zeros(1,errorntestedangle);
				
				x_justcrackedcenter=zeros(2,1);
				for rsp=1:length(justcrackedlist)
					isp=justcrackedlist(rsp);	
					%justcrackedcounter=length(justcrackedlist{rsp});	
					mindistance=le(1)*NN(1);
					currentpos=0;
					for inn=1:NN(1)-1 %[D]TDL check for NN?
						if abs(le(1)*(inn-0.5)-x_sp(isp,1))<mindistance
							mindistance=abs(le(1)*(inn-0.5)-x_sp(isp,1));
							currentpos=le(1)*(inn-0.5);
						end
					end
					x_justcrackedcenter(1)=currentpos;
					
					mindistance=le(2)*NN(2);
					currentpos=0;
					for inn=1:NN(2)-1 %[D]TDL check for NN?
						if abs(le(1)*(inn-0.5)-x_sp(isp,2))<mindistance
							mindistance=abs(le(2)*(inn-0.5)-x_sp(isp,2));
							currentpos=le(2)*(inn-0.5);
						end
					end
					x_justcrackedcenter(2)=currentpos;
					%x_justcrackedcenter(1)=sum(LOC(justcrackedlist{rsp},1))/justcrackedcounter;
					%x_justcrackedcenter(2)=sum(LOC(justcrackedlist{rsp},2))/justcrackedcounter;
					%{
					for i=1:errorntestedangle
						theta(i)=(i-1)/36*1*1*1*pi;
						error(i)=0;
						for spc=1:justcrackedcounter
							error(i)=error(i)+(mod(thetacrack(justcrackedlist{rsp}(spc))-theta(i)+pi/2,pi)-pi/2)^2;
						end
					end
					%}
					thetajustcrackedcenter=thetacrack(isp);
					%thetajustcrackedcenter=theta(FindMin(error));
					%considered=ones(x_crack.npaths,2);
					%distancelist=zeros(x_crack.npaths,2);
					%thetapropagationlist=zeros(x_crack.npaths,2);
					%n_nairncrack0=0;
					%n_nairncrack1=0;
					
					intheprevention=0;
					preventiondistance=1.5*le(1);
					preventionangle=pi/4;
					for icrackpath=1:x_crack.npaths;
						for spcrack=1:(x_crack.nparticles(icrackpath)-1)
							vector1a=[(x_justcrackedcenter(1)-x_crack.center(spcrack,1,icrackpath));(x_justcrackedcenter(2)-x_crack.center(spcrack,2,icrackpath))];
							vector1b=[(x_justcrackedcenter(1)-x_crack.center(spcrack+1,1,icrackpath));(x_justcrackedcenter(2)-x_crack.center(spcrack+1,2,icrackpath))];
							distance1a=sqrt(dot(vector1a,vector1a));
							distance1b=sqrt(dot(vector1b,vector1b));
							
							distance1a_old=sqrt((x_justcrackedcenter(1)-x_crack.center(spcrack,1,icrackpath))^2+(x_justcrackedcenter(2)-x_crack.center(spcrack,2,icrackpath))^2);
							distance1b_old=sqrt((x_justcrackedcenter(1)-x_crack.center(spcrack+1,1,icrackpath))^2+(x_justcrackedcenter(2)-x_crack.center(spcrack+1,2,icrackpath))^2);
							
							distance1=min([distance1a distance1b]);
							
							area2=abs(TriangleArea(x_justcrackedcenter,x_crack.center(spcrack,:,icrackpath),x_crack.center(spcrack+1,:,icrackpath)));
							
							inbetween2vector=[(x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath));(x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath))];
							
							inbetween2=sqrt(dot(inbetween2vector,inbetween2vector));
							
							inbetween2_old=sqrt((x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath))^2+(x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath))^2);
							distance2=area2/inbetween2;
							
							signcos1=dot(vector1a,inbetween2vector);
							signcos2=dot(vector1b,inbetween2vector);
							
							if signcos1*signcos2>0
								distance=distance1;
							else
								distance=distance2;
							end
							
							if distance<preventiondistance
								thetanairncrack=reliableatan(x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath),x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath));
								
								absdeltatheta=abs(mod(thetanairncrack-thetajustcrackedcenter+pi/2,pi)-pi/2);
								
								if absdeltatheta<preventionangle
									intheprevention=1;
								end
							end
							if intheprevention==1
								break;
							end
						end
						if intheprevention==1
							break;
						end
					end
					fprintf('%s',['intheprevention=' int2txt(intheprevention) char(10)]);
					if intheprevention==0
						thetainitiate=mod(thetajustcrackedcenter-pi,pi)+pi; %always pointing down, pi<theta<2*pi
						icrackpath=x_crack.npaths+1;
						x_crack.npaths=x_crack.npaths+1;
						fprintf('%s',['CasetoRun=' int2txt(CasetoRun) char(10)]);
						if CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==194
							x_crack.nparticles(icrackpath)=3;
							x_crack.center(3,2,icrackpath)=x_justcrackedcenter(2)+le(1)/2*sin(thetainitiate); %assuming le(1)=le(2);
							x_crack.center(3,1,icrackpath)=x_justcrackedcenter(1)+le(1)/2*cos(thetainitiate);
							x_crack.center(1,2,icrackpath)=x_justcrackedcenter(2)-le(1)/2*sin(thetainitiate);
							x_crack.center(1,1,icrackpath)=x_justcrackedcenter(1)-le(1)/2*cos(thetainitiate);
							x_crack.center(2,2,icrackpath)=x_justcrackedcenter(2);
							x_crack.center(2,1,icrackpath)=x_justcrackedcenter(1);
							x_crack.cohesivepath(icrackpath)=1;
							x_crack.cohesivepoint(1,icrackpath)=1;
							x_crack.cohesivepoint(2,icrackpath)=1;
							x_crack.cohesivepoint(3,icrackpath)=1;
						elseif CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
							if sin(thetainitiate)==0 || cos(thetainitiate)==0
								multiplier=1;
							else
								multiplier=min([1/abs(cos(thetainitiate)) 1/abs(sin(thetainitiate))]);
							end
							%TDL under construction
							%growing the crack one by one
							%step 0: define center as x_crack.center(2,:,icrackpath) (temporary, will change on step 3) at x_justrackedcenter
							%step 1: grow to +1/3 multiplier as x_crack.center(3,:,icrackpath)
							%step 2: grow the +2/3 multipler as x_crack.center(4,:,icrackpath)
							%step 3: move back x_crack.center(2,:,icrackpath) to -1/3 multipler, by first assigning -1/3 multiplier to particle #1, then migrating
							%step 4: grow to -2/3 multiplier x_crack.center(1,:,icrackpath)
							%thus, migration is only needed when step 3 ends with crack tip termination and step 4 doesn't go
							
							%start of step 0
								x_crack.cohesivepath(icrackpath)=1;
								x_crack.nparticles(icrackpath)=1;
								x_crack.center(2,1,icrackpath)=x_justcrackedcenter(1); 
								x_crack.center(2,2,icrackpath)=x_justcrackedcenter(2); 
								x_crack.cohesivepoint(2,icrackpath)=1;
							%end of step 0

							%start of step 1
								x_crack.nparticles(icrackpath)=x_crack.nparticles(icrackpath)+1;
								initcut.expansion=1/3*multiplier*le(1); %assuming le(1)=le(2);
								x_crack.center(3,1,icrackpath)=x_crack.center(2,1,icrackpath)+initcut.expansion*cos(thetainitiate); 
								x_crack.center(3,2,icrackpath)=x_crack.center(2,2,icrackpath)+initcut.expansion*sin(thetainitiate); 
								x_crack.cohesivepoint(3,icrackpath)=1; %first we assume it's not terminated
								x1=x_crack.center(2,:,icrackpath);
								x2=x_crack.center(3,:,icrackpath);
								
								%below tries to check potential crossings with all other existing cracks
								initcut.firstevaluation=1;
								initcut.actuallycut=0;
								%the two above are actually redundant, since even though they serve different functions we can still just use one and repurpose for the other necessity, however for better readability we use both anyway.
								
								for icrackpath2=1:x_crack.npaths-1 %maximum npath is the newly initiated crack, thus -1 so it doesn't compare to itself
								for icrackparticle=1:x_crack.nparticles(icrackpath2)-1 %this -1 is because if we have n particles, we have n-1 spans.
									x3=x_crack.center(icrackparticle,:,icrackpath2);
									x4=x_crack.center(icrackparticle+1,:,icrackpath2);
									[initcut.CrossDir,initcut.RelativeLocation]=FindCrossing(x1,x2,x3,x4);
									if initcut.CrossDir~=0
										initcut.actuallycut=1;	
										%if this is the first evaluation (initcut.firstevaluation==1, or simply initcut.firstevaluation) or current value (initcut.RelativeLocation) is less than current minimum value (initcut.RelativeLocationMin), then we take the current value as the new minimum.
										if initcut.firstevaluation || initcut.RelativeLocation<initcut.RelativeLocationMin
											initcut.RelativeLocationMin=initcut.RelativeLocation;
										end
										initcut.firstevaluation=0;
									end
								end
								end
								
								%if a cut is detected, we terminate and go no further
								if initcut.actuallycut
									x_crack.center(3,1,icrackpath)=x_crack.center(2,1,icrackpath)+initcut.RelativeLocationMin*initcut.expansion*cos(thetainitiate); %assuming le(1)=le(2);
									x_crack.center(3,2,icrackpath)=x_crack.center(2,2,icrackpath)+initcut.RelativeLocationMin*initcut.expansion*sin(thetainitiate); %assuming le(1)=le(2);
									x_crack.terminatedprop(icrackpath,1)=1; %ipath, itip (1 or 2), we terminate 1st tip
									x_crack.cohesivepoint(3,icrackpath)=0;
								%else
									%we move to step 2
								end
							%end of step 1
							
							%start of step 2
							if initcut.actuallycut==0 %(if no cut is detected)
								%first we assume it's not terminated
								x_crack.nparticles(icrackpath)=x_crack.nparticles(icrackpath)+1;
								initcut.expansion=2/3*multiplier*le(1); %assuming le(1)=le(2);
								x_crack.center(4,1,icrackpath)=x_crack.center(3,1,icrackpath)+initcut.expansion*cos(thetainitiate); %assuming le(1)=le(2), also assuming no cut, crack not terminated
								x_crack.center(4,2,icrackpath)=x_crack.center(3,2,icrackpath)+initcut.expansion*sin(thetainitiate);
								x_crack.cohesivepoint(4,icrackpath)=1; %again, assuming crack isn't terminated and cohesivepoint still goes
								x1=x_crack.center(3,:,icrackpath);
								x2=x_crack.center(4,:,icrackpath);
								
								%below tries to check potential crossings with all other existing cracks (besides itself of course)
								initcut.firstevaluation=1;
								initcut.actuallycut=0;
								%again, both are actually redundant, can get away with using only one, but for better readibility I keep both of them
								
								for icrackpath2=1:x_crack.npaths-1
								for icrackparticle=1:x_crack.nparticles(icrackpath2)-1
									x3=x_crack.center(icrackparticle,:,icrackpath2);
									x4=x_crack.center(icrackparticle+1,:,icrackpath2);
									[initcut.CrossDir,initcut.RelativeLocation]=FindCrossing(x1,x2,x3,x4);
									if initcut.CrossDir~=0
										initcut.actuallycut=1;
										if initcut.firstevaluation || initcut.RelativeLocation<initcut.RelativeLocationMin
											initcut.RelativeLocationMin=initcut.RelativeLocation;
										end
										initcut.firstevaluation=0;
									end	
								end
								end
							end
							
							%if a cut is detected, we terminate
							if initcut.actuallycut
								x_crack.center(4,1,icrackpath)=x_crack.center(3,1,icrackpath)+initcut.RelativeLocationMin*initcut.expansion*cos(thetainitiate); %assuming le(1)=le(2);
								x_crack.center(4,2,icrackpath)=x_crack.center(3,2,icrackpath)+initcut.RelativeLocationMin*initcut.expansion*sin(thetainitiate);
								x_crack.terminatedprop(icrackpath,1)=1; %tip #1, for the maximum particle number
								x_crack.cohesivepoint(4,icrackpath)=0;
							%else
								%then no overrides, we've already defined everything beforehand
							end
							%end of step 2
							
							%start of step 3
								%first, assume it's not terminated. also we first assign to number 1 temporarily, as we'll migrate it to 2 later
								%x_crack.nparticles(icrackpath)=x_crack.nparticles(icrackpath)+1; %we still assume 3 particles, we just borrow number 1. if turns out we dont need it, we migrate everything of 2 3 4 to 1 2 3.
								initcut.expansion=1/3*multiplier*le(1); %assuming le(1)=le(2);
								x_crack.center(1,1,icrackpath)=x_crack.center(2,1,icrackpath)-initcut.expansion*cos(thetainitiate); 
								x_crack.center(1,2,icrackpath)=x_crack.center(2,2,icrackpath)-initcut.expansion*sin(thetainitiate);
								x_crack.cohesivepoint(1,icrackpath)=1; %first we assume it's not terminated
								x1=x_crack.center(2,:,icrackpath);
								x2=x_crack.center(1,:,icrackpath);

								%below tries to check potential crossings with all other existing cracks, except itself of course
								initcut.firstevaluation=1;
								initcut.actuallycut=0;
								%again, the two above are redundant. they serve different functions, but just using actually cut can actually serve both needs. however I'm keeping both for better readability.
								
								for icrackpath2=1:x_crack.npaths-1
								for icrackparticle=1:x_crack.nparticles(icrackpath2)-1
									x3=x_crack.center(icrackparticle,:,icrackpath2);
									x4=x_crack.center(icrackparticle+1,:,icrackpath2);
									[initcut.CrossDir,initcut.RelativeLocation]=FindCrossing(x1,x2,x3,x4);
									if initcut.CrossDir~=0
										initcut.actuallycut=1;
										if initcut.firstevaluation || initcut.RelativeLocation<initcut.RelativeLocationMin
											initcut.RelativeLocationMin=initcut.RelativeLocation;
										end
										initcut.firstevaluation=0;
									end
								end
								end
								
								%if cut detected, extend only up to the cut
								if initcut.actuallycut
									x_crack.center(1,1,icrackpath)=x_crack.center(2,1,icrackpath)-initcut.RelativeLocationMin*initcut.expansion*cos(thetainitiate);
									x_crack.center(1,2,icrackpath)=x_crack.center(2,2,icrackpath)-initcut.RelativeLocationMin*initcut.expansion*sin(thetainitiate);
									x_crack.terminatedprop(icrackpath,2)=1; %tip #2 (crack particle number 1)
									x_crack.cohesivepoint(1,icrackpath)=0;
								end
									
								%assigning 1 back to 2
									x_crack.center(2,1,icrackpath)=x_crack.center(1,1,icrackpath);
									x_crack.center(2,2,icrackpath)=x_crack.center(1,2,icrackpath);
									x_crack.cohesivepoint(2,icrackpath)=x_crack.cohesivepoint(1,icrackpath);
								%end of assigning 1 back to 2
								
								%below migrates 2 3 4 to 1 2 3 if cut is detected
								if initcut.actuallycut
									for icrackparticlemove=1:x_crack.nparticles(icrackpath)
										x_crack.center(icrackparticlemove,1,icrackpath)=x_crack.center(icrackparticlemove+1,1,icrackpath);
										x_crack.center(icrackparticlemove,2,icrackpath)=x_crack.center(icrackparticlemove+1,2,icrackpath);
										x_crack.cohesivepoint(icrackparticlemove,icrackpath)=x_crack.cohesivepoint(icrackparticlemove+1,icrackpath);
									end
									x_crack.center(x_crack.nparticles(icrackpath)+1,1,icrackpath)=0;
									x_crack.center(x_crack.nparticles(icrackpath)+1,2,icrackpath)=0;
									x_crack.cohesivepoint(x_crack.nparticles(icrackpath)+1,icrackpath)=0;
								end
							%end of step 3
							
							%start of step 4
								if initcut.actuallycut==0
									x_crack.nparticles(icrackpath)=x_crack.nparticles(icrackpath)+1;
									initcut.expansion=2/3*multiplier*le(1); %assuming le(1)=le(2);
									x_crack.center(1,1,icrackpath)=x_crack.center(2,1,icrackpath)-initcut.expansion*cos(thetainitiate);
									x_crack.center(1,2,icrackpath)=x_crack.center(2,2,icrackpath)-initcut.expansion*sin(thetainitiate);
									x_crack.cohesivepoint(1,icrackpath)=1;
									x1=x_crack.center(2,:,icrackpath);
									x2=x_crack.center(1,:,icrackpath);
									
									%below tries ot check potential crossings with all other existing cracks (besides itself of course)
									initcut.firstevaluation=1;
									initcut.actuallycut=0;
									%again, both are actually redundant, can get away with using only one, but for better readibility I keep both of them
										
									for icrackpath2=1:x_crack.npaths-1
									for icrackparticle=1:x_crack.nparticles(icrackpath2)-1
										x3=x_crack.center(icrackparticle,:,icrackpath2);
										x4=x_crack.center(icrackparticle+1,:,icrackpath2);
										[initcut.CrossDir,initcut.RelativeLocation]=FindCrossing(x1,x2,x3,x4);
										if initcut.CrossDir~=0
											initcut.actuallycut=1;
											if initcut.firstevaluation || initcut.RelativeLocation<initcut.RelativeLocationMin
												initcut.RelativeLocationMin=initcut.RelativeLocation;
											end
											initcut.firstevaluation=0;
										end
									end
									end
									%if a cut is detected, we terminate
									if initcut.actuallycut
										x_crack.center(1,1,icrackpath)=x_crack.center(2,1,icrackpath)-initcut.RelativeLocationMin*initcut.expansion*cos(thetainitiate); 
										x_crack.center(1,2,icrackpath)=x_crack.center(2,2,icrackpath)-initcut.RelativeLocationMin*initcut.expansion*sin(thetainitiate);
										x_crack.terminatedprop(icrackpath,2)=1;
										x_crack.cohesivepoint(1,icrackpath)=0;
									end	
								end
							%end of step 4
							
							%{
							x_crack.center(1,1,icrackpath)=x_justcrackedcenter(1)-1*multiplier*le(1)*cos(thetainitiate); %assuming le(1)=le(2);
							x_crack.center(1,2,icrackpath)=x_justcrackedcenter(2)-1*multiplier*le(1)*sin(thetainitiate);
							x_crack.center(2,1,icrackpath)=x_justcrackedcenter(1)-1/3*multiplier*le(1)*cos(thetainitiate);
							x_crack.center(2,2,icrackpath)=x_justcrackedcenter(2)-1/3*multiplier*le(1)*sin(thetainitiate);
							x_crack.center(3,1,icrackpath)=x_justcrackedcenter(1)+1/3*multiplier*le(1)*cos(thetainitiate);
							x_crack.center(3,2,icrackpath)=x_justcrackedcenter(2)+1/3*multiplier*le(1)*sin(thetainitiate);
							x_crack.center(4,1,icrackpath)=x_justcrackedcenter(1)+1*multiplier*le(1)*cos(thetainitiate);
							x_crack.center(4,2,icrackpath)=x_justcrackedcenter(2)+1*multiplier*le(1)*sin(thetainitiate);
							x_crack.cohesivepath(icrackpath)=1;
							x_crack.cohesivepoint(1,icrackpath)=1;
							x_crack.cohesivepoint(2,icrackpath)=1;
							x_crack.cohesivepoint(3,icrackpath)=1;
							x_crack.cohesivepoint(4,icrackpath)=1;
							%}
						else
							x_crack.nparticles(icrackpath)=2;
							fprintf('%s',['under x_crack.nparticles(icrackpath)=2;' char(10)]);
							fprintf('%s',['icrackpath=' int2txt(icrackpath) char(10)]);
							fprintf('%s',['x_crack.nparticles(icrackpath)=' int2txt(x_crack.nparticles(icrackpath)) char(10)]);
							for ipath=1:x_crack.npaths
								for iparticle=1:x_crack.nparticles(ipath)
									fprintf('%s',['x_crack.center(' int2txt(iparticle) ',:,' int2txt(ipath) ')=[' float2scitxt(5,x_crack.center(iparticle,1,ipath)) ' ' float2scitxt(5,x_crack.center(iparticle,2,ipath)) ']' char(10)]);
								end
							end
							
							x_crack.center(2,2,icrackpath)=x_justcrackedcenter(2)+le(1)/2*sin(thetainitiate); %assuming le(1)=le(2);
							fprintf('%s',['under x_crack.center(2,2,icrackpath)=x_justcrackedcenter(2)+le(1)/2*sin(thetainitiate);' char(10)]);
							fprintf('%s',['icrackpath=' int2txt(icrackpath)]);
							fprintf('%s',['le(1)=' float2scitxt(5,le(1))]);
							fprintf('%s',['thetainitiate=' float2scitxt(5,thetainitiate) ' rad =' float2scitxt(5,thetainitiate/3.1415926536*180) ' deg']);
							fprintf('%s',['x_crack.center(2,2,icrackpath)=' int2txt(x_crack.center(2,2,icrackpath))]);
							for ipath=1:x_crack.npaths
								for iparticle=1:x_crack.nparticles(ipath)
									fprintf('%s',['x_crack.center(' int2txt(iparticle) ',:,' int2txt(ipath) ')=[' float2scitxt(5,x_crack.center(iparticle,1,ipath)) ' ' float2scitxt(5,x_crack.center(iparticle,2,ipath)) ']' char(10)]);
								end
							end
							
							x_crack.center(2,1,icrackpath)=x_justcrackedcenter(1)+le(1)/2*cos(thetainitiate);
							fprintf('%s',['under x_crack.center(2,1,icrackpath)=x_justcrackedcenter(1)+le(1)/2*cos(thetainitiate);' char(10)]);
							fprintf('%s',['icrackpath=' int2txt(icrackpath)]);
							fprintf('%s',['x_crack.center(2,1,icrackpath)=' int2txt(x_crack.center(2,1,icrackpath))]);
							for ipath=1:x_crack.npaths
								for iparticle=1:x_crack.nparticles(ipath)
									fprintf('%s',['x_crack.center(' int2txt(iparticle) ',:,' int2txt(ipath) ')=[' float2scitxt(5,x_crack.center(iparticle,1,ipath)) ' ' float2scitxt(5,x_crack.center(iparticle,2,ipath)) ']' char(10)]);
								end
							end
							
							x_crack.center(1,2,icrackpath)=x_justcrackedcenter(2)-le(1)/2*sin(thetainitiate);
							fprintf('%s',['under x_crack.center(1,2,icrackpath)=x_justcrackedcenter(2)-le(1)/2*sin(thetainitiate);' char(10)]);
							fprintf('%s',['icrackpath=' int2txt(icrackpath)]);
							fprintf('%s',['x_crack.center(1,2,icrackpath)=' int2txt(x_crack.center(1,2,icrackpath))]);
							for ipath=1:x_crack.npaths
								for iparticle=1:x_crack.nparticles(ipath)
									fprintf('%s',['x_crack.center(' int2txt(iparticle) ',:,' int2txt(ipath) ')=[' float2scitxt(5,x_crack.center(iparticle,1,ipath)) ' ' float2scitxt(5,x_crack.center(iparticle,2,ipath)) ']' char(10)]);
								end
							end
							
							x_crack.center(1,1,icrackpath)=x_justcrackedcenter(1)-le(1)/2*cos(thetainitiate);
							fprintf('%s',['under x_crack.center(1,1,icrackpath)=x_justcrackedcenter(1)-le(1)/2*cos(thetainitiate);' char(10)]);
							fprintf('%s',['icrackpath=' int2txt(icrackpath)]);
							fprintf('%s',['x_crack.center(1,1,icrackpath)=' int2txt(x_crack.center(1,1,icrackpath))]);
							for ipath=1:x_crack.npaths
								for iparticle=1:x_crack.nparticles(ipath)
									fprintf('%s',['x_crack.center(' int2txt(iparticle) ',:,' int2txt(ipath) ')=[' float2scitxt(5,x_crack.center(iparticle,1,ipath)) ' ' float2scitxt(5,x_crack.center(iparticle,2,ipath)) ']' char(10)]);
								end
							end
							%input_codegen('put anything man')
						end
						%fprintf('%s',['>>line 8967: size(x_crackcenter' int2txt(icrackpath) '},1)=' int2txt(x_crack.nparticles(icrackpath)) char(10)]);
						%fprintf('%s',['>>line 8968: size(x_cracktop{' int2txt(icrackpath) '},1)=' int2txt(size(x_cracktop{icrackpath},1)) char(10)]);
						%{
						for i=1:size(x_cracktop{icrackpath},1)
							for j=1:size(x_cracktop{icrackpath},2)
								%fprintf('%s',['>>line 8973: x_cracktop{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_cracktop{icrackpath}(i,j)) char(10)]);
							end
						end
						for i=1:size(x_crackbot{icrackpath},1)
							for j=1:size(x_crackbot{icrackpath},2)
								%fprintf('%s',['>>line 8980: x_crackbot{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackbot{icrackpath}(i,j)) char(10)]);
							end
						end
						for i=1:size(x_crackcenter{icrackpath},1)
							for j=1:size(x_crackcenter{icrackpath},2)
								%fprintf('%s',['>>line 8987: x_crackcenter{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackcenter{icrackpath}(i,j)) char(10)]);
							end
						end
						%}
						for i=1:x_crack.nparticles(icrackpath)
							for j=1:2
								%fprintf('%s',['>>line 8973: x_crackcenter{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackcenter{icrackpath}(i,j)) char(10)]);
								x_crack.top(i,j,icrackpath)=x_crack.center(i,j,icrackpath);
								x_crack.bot(i,j,icrackpath)=x_crack.center(i,j,icrackpath);
							end
						end
						%shit below
						%x_cracktop{icrackpath}=x_crackcenter{icrackpath};
						%x_crackbot{icrackpath}=x_crackcenter{icrackpath};
						%shit above
					end
					%soundplay
					1;
				end
			end
			%{
			if x_crack.npaths>=3
				for ipath=1:x_crack.npaths
					for iparticle=1:x_crack.nparticles(ipath)
						fprintf('%s',['x_crack.center(' int2txt(iparticle) ',:,' int2txt(ipath) ')=[' float2scitxt(5,x_crack.center(iparticle,1,ipath)) ' ' float2scitxt(5,x_crack.center(iparticle,2,ipath)) ']' char(10)]);
					end
				end
			end
			%}
		%bogus indent for above	
		1;
%TDL start editing in fhdjsfklsdahfhdjksa.m
	elseif CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==211 || CasetoRun==212
		%crack propagation of 210
		% of 200 but with dynamic box instead
		
		%new declarations start here
		
		
		%restarting zero-mass calculation
		debugprint1=0;
		debugprint2=0;
		debugprint3=0; %for dumping displacements with expansion
		debugprint4=0; %for low mass initiation denial
		debugprint5=0; %for elasticstrength and pauses
		debugprint6=0; %for propagation of 210 in general, with pauses
		
		
		%fprintf('%s',['before debugprint1 loadvariable' char(10)]);
		debugprint1_loaded=loadvariable('debugprint1');
		%fprintf('%s',['after debugprint1 loadvariable' char(10)]);
		%fprintf('%s',['debugprint1_loaded.found=' int2txt(debugprint1_loaded.found) char(10)]);
		%fprintf('%s',['debugprint1_loaded.valuetext=' debugprint1_loaded.valuetext char(10)]);
		if debugprint1_loaded.found
			debugprint1=str2long(debugprint1_loaded.valuetext);
		end
		%fprintf('%s',['debugprint1=' float2scitxt(5,debugprint1) char(10)]);
		
		%fprintf('%s',['before debugprint2 loadvariable' char(10)]);
		debugprint2_loaded=loadvariable('debugprint2');
		%fprintf('%s',['after debugprint2 loadvariable' char(10)]);
		%fprintf('%s',['debugprint2_loaded.found=' int2txt(debugprint2_loaded.found) char(10)]);
		%fprintf('%s',['debugprint2_loaded.valuetext=' debugprint2_loaded.valuetext char(10)]);
		if debugprint2_loaded.found
			debugprint2=str2long(debugprint2_loaded.valuetext);
		end
		%fprintf('%s',['debugprint2=' float2scitxt(5,debugprint2) char(10)]);
		
		%fprintf('%s',['before debugprint3 loadvariable' char(10)]);
		debugprint3_loaded=loadvariable('debugprint3');
		%fprintf('%s',['after debugprint3 loadvariable' char(10)]);
		%fprintf('%s',['debugprint3_loaded.found=' int2txt(debugprint3_loaded.found) char(10)]);
		%fprintf('%s',['debugprint3_loaded.valuetext=' debugprint3_loaded.valuetext char(10)]);
		if debugprint3_loaded.found
			debugprint3=str2long(debugprint3_loaded.valuetext);
		end
		%fprintf('%s',['debugprint3=' float2scitxt(5,debugprint3) char(10)]);
		
		%fprintf('%s',['before debugprint4 loadvariable' char(10)]);
		debugprint4_loaded=loadvariable('debugprint4');
		%fprintf('%s',['after debugprint4 loadvariable' char(10)]);
		%fprintf('%s',['debugprint4_loaded.found=' int2txt(debugprint4_loaded.found) char(10)]);
		%fprintf('%s',['debugprint4_loaded.valuetext=' debugprint4_loaded.valuetext char(10)]);
		if debugprint4_loaded.found
			debugprint4=str2long(debugprint4_loaded.valuetext);
		end
		%fprintf('%s',['debugprint4=' float2scitxt(5,debugprint4) char(10)]);
		
		%fprintf('%s',['before debugprint5 loadvariable' char(10)]);
		debugprint5_loaded=loadvariable('debugprint5');
		%fprintf('%s',['after debugprint5 loadvariable' char(10)]);
		%fprintf('%s',['debugprint5_loaded.found=' int2txt(debugprint5_loaded.found) char(10)]);
		%fprintf('%s',['debugprint5_loaded.valuetext=' debugprint5_loaded.valuetext char(10)]);
		if debugprint5_loaded.found
			debugprint5=str2long(debugprint5_loaded.valuetext);
		end
		%fprintf('%s',['debugprint5=' float2scitxt(5,debugprint5) char(10)]);
		
		%fprintf('%s',['before debugprint6 loadvariable' char(10)]);
		debugprint6_loaded=loadvariable('debugprint6');
		%fprintf('%s',['after debugprint6 loadvariable' char(10)]);
		%fprintf('%s',['debugprint6_loaded.found=' int2txt(debugprint6_loaded.found) char(10)]);
		%fprintf('%s',['debugprint6_loaded.valuetext=' debugprint6_loaded.valuetext char(10)]);
		if debugprint6_loaded.found
			debugprint6=str2long(debugprint6_loaded.valuetext);
		end
		%fprintf('%s',['debugprint6=' float2scitxt(5,debugprint6) char(10)]);
		
		if debugprint6
			printtext(1,'we are here in propagation of 210');
		end
		
		fractureenergymultiplier=1;
		%TDL stretch cohesion via strengthfactor
		strengthfactor=1/4; %how much strength is reduced (if less than 1) in the context of cohesion. to maintain the same energy, strengthreduction higher than 
		
		
		denyinitiation=0;
		denypropagation=0;
		
		
		%fprintf('%s',['before denyinitiation loadvariable' char(10)]);
		denyinitiation_loaded=loadvariable('denyinitiation');
		%fprintf('%s',['after denyinitiation loadvariable' char(10)]);
		%fprintf('%s',['denyinitiation_loaded.found=' int2txt(denyinitiation_loaded.found) char(10)]);
		%fprintf('%s',['denyinitiation_loaded.valuetext=' denyinitiation_loaded.valuetext char(10)]);
		if denyinitiation_loaded.found
			denyinitiation=str2long(denyinitiation_loaded.valuetext);
		end
		%fprintf('%s',['denyinitiation=' float2scitxt(5,denyinitiation) char(10)]);
		
		
		%fprintf('%s',['before denypropagation loadvariable' char(10)]);
		denypropagation_loaded=loadvariable('denypropagation');
		%fprintf('%s',['after denypropagation loadvariable' char(10)]);
		%fprintf('%s',['denypropagation_loaded.found=' int2txt(denypropagation_loaded.found) char(10)]);
		%fprintf('%s',['denypropagation_loaded.valuetext=' denypropagation_loaded.valuetext char(10)]);
		if denypropagation_loaded.found
			denypropagation=str2long(denypropagation_loaded.valuetext);
		end
		%fprintf('%s',['denypropagation=' float2scitxt(5,denypropagation) char(10)]);
		
		if CasetoRun==222 || CasetoRun==225
			denyinitiation=1;
			denypropagation=1;
		elseif CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226
			%denyinitiation=1;
			%denypropagation=1;
		elseif CasetoRun==227
			denyinitiation=1;
			denypropagation=1;
		end
		x_crack.boxcalc.zeromass=zeros(200,2,4); %ipath, which tip, which corner. zero-mass marker for corners, to help merging
		foundcrossing_ratio_min=zeros(1,1); %used twice in two ifs, declare here to stop coder whining
		x_crack_ghosttip=zeros(1,2);
		x1=zeros(1,2);
		x2=zeros(1,2);
		x3=zeros(1,2);
		x4=zeros(1,2);
		
		pltip.mode=zeros(1,1); %mode==1: fully rectangular; mode==2: trapezoid mode==3: triangular
		pltip.B=zeros(3,8); %B matrix for calculating strain from nodal displacements
		pltip.crossmarker=zeros(1,1);
		pltip.epsilon_tip=zeros(3,2);
		pltip.posbefore=zeros(8,1);
		pltip.posafter=zeros(8,1);
		
		pltip.dESP=zeros(2,2);
		pltip.R=zeros(2,2);
		pltip.Rback=zeros(2,2);
		pltip.Q=zeros(2,2);
		pltip.Qback=zeros(2,2);
		pltip.RQ=zeros(2,2);
		pltip.QbackRback=zeros(2,2);
		
		pltip.sigma_global_big=zeros(6,1);
		pltip.e_t_global_big=zeros(6,1);
		pltip.e_pl_global_big=zeros(6,1);
		pltip.alpha_in=zeros(1,7);
		pltip.xdirletter=blanks(2);
		pltip.ydirletter=blanks(2);
		pltip.zdirletter=blanks(2);
		pltip.xzdirletter=blanks(2);
		pltip.xydirletter=blanks(2);
		pltip.yzdirletter=blanks(2);
		pltip.spid=zeros(1,1);
		pltip.thetacrackrtl=zeros(1,1);
		pltip.dudx_rtl=zeros(2,2);
		pltip.s_sp=zeros(1,3);
		pltip.AbeforeQ_rtl=zeros(2,2,2,2);
		pltip.div.direction=zeros(1,3);
		pltip.div.tippos=zeros(1,2);%position of crack tip in global coordinate
		pltip.div.extension=zeros(1,1);%extension length of ghost tip for division
		pltip.div.deltaxtip=zeros(1,2);
		pltip_div_io_natural.pos=zeros(4,2);
		pltip_div_io_natural.source=zeros(1,4); %0 for regular io numbr, 1 for up/down, 2 for generated (for two averaging)
		pltip_div_io_natural.ionumber=zeros(1,4); %0 for empty, number for io number
		pltip_div_io_natural.upordown=zeros(1,4); %0 for empty, 1 for up, 2 for down
		pltip_div_io_natural.u_si=zeros(4,2);
		pltip_div_io_natural.cell.LOC=zeros(4,2); %for debugging purpose only, listing LOCs of nodes arouund the cell where crack tip is located, index follows io_natural, i.e. 1, 2, 3, 4 correspond to bottom left, bottom right, top right, and top left respectively.
		pltip_div_io_natural.cell.u_si=zeros(4,2); %for debugging purpose only, listing u_si(s) of nodes arouund the cell where crack tip is located, index follows io_natural, i.e. 1, 2, 3, 4 correspond to bottom left, bottom right, top right, and top left respectively.
		pltip.div.io_natural=repmat(pltip_div_io_natural,1,2); %only number 1 is used for regular calculation, number 2 is used for two quad averaging
		
		pltip_div_perpupdown.pos=zeros(1,2);%position of ghost tip 90 degrees up (CCW)
		pltip_div_perpupdown.crossdistance=zeros(1,1);
		pltip_div_perpupdown.iontgt=zeros(1,1);%io_natural target, as in intersection happens with which line? if it is line between io_natural==1 and io_natural==2, then iontgt=1; if it is line between io_natural==2 and io_natural==3, then iontgt=2; if it is line between io_natural==4 and io_natural==1, then iontgt=4.
		pltip_div_perpupdown.direction=zeros(1,1);
		pltip.div.perpup=repmat(pltip_div_perpupdown,1,3);
		pltip.div.perpdown=repmat(pltip_div_perpupdown,1,3);
		pltip.angle.values=zeros(1,100);
		pltip.angle.weights=zeros(1,100);
		pltip.angle.size=zeros(1,1);
		pltip.angle.chosen=zeros(1,1);
		curindex=zeros(1,1); %carries pltip.angle.size value for temporary use, for shorter lines and better readability
		cursize=zeros(1,1); %carries pltip.angle.size value for temporary use, but size was already decided and only called to pass on to angleaverage function, for shorter lines and better readability. cursize is essentially pltip.angle.size for the current nodeCount and fieldnumber
		
		
		ref.io_natural=zeros(1,5);%-2, -1, current, +1, +2
		ref.nio_outside=zeros(1,5);
		ref.io=zeros(1,5);
		ref.ratio=zeros(1,1);
		
		initcut.expansion=zeros(1,1);	
		initcut.CrossDir=zeros(1,1);
		initcut.RelativeLocation=zeros(1,1);
		initcut.RelativeLocationMin=zeros(1,1);
		initcut.firstevaluation=zeros(1,1);
		initcut.actuallycut=zeros(1,1);
		
		tip_surfacewithfmax=zeros(1,1);
		%the two above are actually redundant, since even though they serve different functions we can still just use one and repurpose the other, however for better readability we use both anyway.
		
		
		coder.varsize('pltip.xdirletter');
		coder.varsize('pltip.ydirletter');
		coder.varsize('pltip.zdirletter');
		coder.varsize('pltip.xydirletter');
		coder.varsize('pltip.yzdirletter');
		coder.varsize('pltip.xzdirletter');
		
		pltip.xdirletter=xdirletter{1};
		pltip.ydirletter=ydirletter{1};
		pltip.zdirletter=zdirletter{1};
		pltip.xydirletter=xydirletter{1};
		pltip.xzdirletter=xzdirletter{1};
		pltip.yzdirletter=yzdirletter{1};
		pltip.div.extension=2*le(1);
		
		propagationsignal=zeros(1,1);
		ntestedangle=36;
		AbeforeQ_tip=zeros(2,2,2,2); %only one 4th order tensor, recycled for every tip calculated
		dudx_tip=zeros(2,2);
		shrinkage_tip=zeros(2,2);
		nldudxhl.values=zeros(1,2*ntestedangle);
		nldudxhl.sizes=zeros(1,1);
		h_localminima.sizes=zeros(1,1);
		h_localminima.values=zeros(2,2*ntestedangle);
		localminima1index.values=zeros(1,ntestedangle);
		localminima1index.sizes=zeros(1,1);
		localminima2index.values=zeros(1,ntestedangle);
		localminima2index.sizes=zeros(1,1);
		localminimaindex.values=zeros(1,2*ntestedangle);
		localminimaindex.sizes=zeros(1,1);
		h_crackdecision=zeros(2,1);
		FindMaxnldudxhl=zeros(1,1);
		crackindex=zeros(1,1);
		thetamin=zeros(1,1);
		theta_crack=zeros(1,1);
		%new declarations end here
		[AbeforeQ_si,AbeforeQ_si_active]=Interpolate_AbeforeQ(AbeforeQ,NODES,nodeCount,CONNECT,N,spCount,m_sp,TheFieldSplit,CasetoRun,fieldnumber);
		no=niCount;
		%s_tip(ipath,dim,itip);
		s_tip=zeros(x_crack.npaths,3,2);
		s_tip_K1=zeros(x_crack.npaths,3,2); %ncrackpaths; dimension (x and y); which tip
		deltax_previous=zeros(1,2,1);
		theta_crack_trial=zeros(1,2);
		deltatheta_crack=zeros(1,2);
		s_tip_dump=zeros(2*x_crack.npaths,3);
		d_tip_dump=zeros(2*x_crack.npaths,8);
		d_LOC_tip_dump=zeros(2*x_crack.npaths,8);
		s_tip_K1_dump=zeros(2*x_crack.npaths,3);
		u_tip_dump=zeros(2*x_crack.npaths,8);
		x_tip_dump=zeros(2*x_crack.npaths,2);
		r_propdirweighted_dump=zeros(2*x_crack.npaths,2);
		K1_maxradius=3*le(1);
		K1_estimate=zeros(1,2);
		K1_distance=zeros(1,2);
		r_propdirweighted=zeros(x_crack.npaths,2,2); %crackpath num, dimension, which tip
		sigma_maxprinc_magnitude=0;
		r_propdircompliment=zeros(1,2);
		a_transform=zeros(2,2);
		s_tip_tensor=zeros(2,2);
		s_tip_tensor_transformed=zeros(2,2);
		LOC_avg=zeros(1,2);
		nio_designator=zeros(1,4);
		d_natural=zeros(8,1);
		delta_x=zeros(1,2);
		epsilon_tip=zeros(3,1);
		x_crack_ghosttip=zeros(1,2);
		x1=zeros(1,2);
		x2=zeros(1,2);
		x3=zeros(1,2);
		x4=zeros(1,2);
		Area=zeros(1,4);
		foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
		foundcrossing.iparticle3=zeros(1,200); %so not to clash with iparticle
		foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
		foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.
		%nio_designator(1): in the natural coordinates, node 1 associates with which nio?
		%nio_designator(2): in the natural coordinates, node 2 associates with which nio?
		%nio_designator(3): in the natural coordinates, node 3 associates with which nio?
		%nio_designator(4): in the natural coordinates, node 4 associates with which nio?
		
		propagationmethod=1;
		if matmodel(1)==1
			propagationmethod=1;
		else
			propagationmethod=2;
		end
		
		if debugprint6
			printfloat(1,propagationmethod,'at 24131, propagationmethod');
		end
		
		io_natural_cross_before=0;
		io_natural_cross_after=0;
		io_natural_sides=zeros(1,4);
		
		elasticstrength=25;
		elasticstrength_loaded=loadvariable('elasticstrength');
		if elasticstrength_loaded.found
			elasticstrength=str2float(elasticstrength_loaded.valuetext);
		end
		debugprint9=0;
		debugprint9_loaded=loadvariable('debugprint9');
		if debugprint9_loaded.found
			debugprint9=str2float(debugprint9_loaded.valuetext);
		end
		if debugprint9
			printfloat(1,elasticstrength,'in 24689, elasticstrength');
		end
		
		k_dumpresult=0.99;
		elasticstrengthbase=elasticstrength;
		
		if debugprint6
			printfloat(1,elasticstrengthbase,'at 24143, elasticstrengthbase');
			printfloat(1,elasticstrength,'at 24144, elasticstrength');
		end
		
		%r_propdirweighted=zeros(1,2); %dimension only
		
		%r_propdirweighted=zeros(1,2); %dimension only
		%allowpropagation=1;
		
		%propagation starts below
		for itip=1:2
			%itip=1: particle of highest index
			%itip=2: particle of lowest index
			for ipath=1:x_crack.npaths
				if x_crack.terminatedprop(ipath,itip)==0
					if itip==1
						iparticle=x_crack.nparticles(ipath);
					elseif itip==2
						iparticle=1;
					end
					LOC_avg=zeros(1,2);
					for nio=1:4
						io=CONNECT_crack.center.values(iparticle,nio,ipath);
						for dim=1:2
							LOC_avg(1,dim)=LOC_avg(1,dim)+LOC(io,dim);
						end
					end
					for dim=1:2
						LOC_avg(1,dim)=LOC_avg(1,dim)/4;
					end
					for nio=1:4
						io=CONNECT_crack.center.values(iparticle,nio,ipath);
						if LOC(io,1)<LOC_avg(1,1)
							if LOC(io,2)<LOC_avg(1,2)
								nio_designator(1)=nio;
							elseif LOC(io,2)>LOC_avg(1,2) %can just write else, but this way it's more readable. also equal is not possible, so I left it out
								nio_designator(4)=nio;
							end
						elseif LOC(io,1)>LOC_avg(1,1) %same drill, trying to improve readability
							if LOC(io,2)<LOC_avg(1,2)
								nio_designator(2)=nio;
							elseif LOC(io,2)>LOC_avg(1,2)
								nio_designator(3)=nio;
							end
						end
					end
					%allowpropagation=1;
					tip_crackability=0;
					tip_weakeningfactor=0;
					tip_k=0;
					AbeforeQ_tip=zeros(2,2,2,2);
					shrinkage_tip=zeros(2,2);
					dudx_tip=zeros(2,2);
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(iparticle,nio_outside,ipath);
						tip_crackability=tip_crackability+uncrackable_si_comb(io)*N_crack.center(1,nio_outside,iparticle,ipath);
						tip_weakeningfactor=tip_weakeningfactor+weakeningfactor_si_comb(io)*N_crack.center(1,nio_outside,iparticle,ipath);
						tip_k=tip_k+k_si_comb(io)*N_crack.center(1,nio_outside,iparticle,ipath);
						shrinkage_tip=shrinkage_tip+shrinkage_si_comb(:,:,io)*N_crack.center(1,nio_outside,iparticle,ipath);
						dudx_tip=dudx_tip+u_si(io,:,1)'*dN_crack.center(:,nio_outside,iparticle,ipath)';
					end
					if tip_crackability>0.125
						x_crack.terminatedprop(ipath,itip)=1;
						continue;
					end
					%start of interpolating angle
					%principle's same as above but using the function angleaverage instead
					pltip.angle.size=0;
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(iparticle,nio_outside,ipath);
						
						pltip.angle.size=pltip.angle.size+1;
						curindex=pltip.angle.size;
						pltip.angle.values(curindex)=orientationoffset_si_comb(io);
						pltip.angle.weights(curindex)=N_crack.center(1,nio_outside,iparticle,ipath);
					end
					pltip.angle.chosen=angleaverage(pltip.angle.values,pltip.angle.weights,18,5,2);
					%end of interpolating angle
					
					x_crack.boxcalc.u_global=zeros(4,2); %which corner point, dimension; displacements in global coordinate
					x_crack.boxcalc.u_local=zeros(4,2); %which corner point, dimension; displacements in local (box) coordinate
					n1=zeros(1,2);
					n2=zeros(1,2);
					A=zeros(2,2);
					
					n1=[cos(x_crack.boxcalc.trajectory(ipath,itip)) sin(x_crack.boxcalc.trajectory(ipath,itip))];
					n2=[cos(x_crack.boxcalc.trajectory(ipath,itip)+pi/2) sin(x_crack.boxcalc.trajectory(ipath,itip)+pi/2)];
					d_natural_local=zeros(8,1);
					A=[n1;n2];
					
					
					%start of CLEAR EDGE EXTENSION
					lowmassstrikes=0;
					clearedgedetected=0;
					for icornerpoint=1:4
						for io_natural=1:4
							io=CONNECT_crack.boxcalc(icornerpoint,io_natural,ipath,itip);
							if sum(nmass_si(io,:))<0.01*m_sp(1)
								clearedgedetected=1;
								break;
							elseif sum(nmass_si(io,:))<1.25*m_sp(1)
								lowmassstrikes=lowmassstrikes+1;
							end
							if lowmassstrikes>=4
								clearedgedetected=1;
								break;
							end
						end
						if clearedgedetected==1
							break;
						end
					end
					if clearedgedetected==1
						x_crack.terminatedprop(ipath,itip)=1;
						deltax_previous=0;
						trajectory_previous=0;
						if itip==1
							deltax_previous=x_crack.center(iparticle,:,ipath)-x_crack.center(iparticle-1,:,ipath);
							x_crack.cohesivepoint(iparticle,ipath)=0;
						elseif itip==2
							deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
							x_crack.cohesivepoint(1,ipath)=0;
						end
						trajectory_previous=reliableatan(deltax_previous(1),deltax_previous(2));
						clearedgeextension=zeros(1,2);
						if x_crack.boxcalc.active(ipath,itip)==1
							clearedgeextension=(x_crack.boxcalc.length+le(1))*[cos(trajectory_previous) sin(trajectory_previous)];
						else
							clearedgeextension=(2*le(1))*[cos(trajectory_previous) sin(trajectory_previous)];
						end
						if itip==1
							%might need idim=1:2 loop, but don't touch if still works OK?
							%did it anyway
							
							% no shift here, just adding to the list
							for idim=1:2
								x_crack.center(iparticle+1,idim,ipath)=x_crack.center(iparticle,idim,ipath)+clearedgeextension(idim);
								x_crack.top(iparticle+1,idim,ipath)=x_crack.center(iparticle+1,idim,ipath);
								x_crack.bot(iparticle+1,idim,ipath)=x_crack.center(iparticle+1,idim,ipath);
							end
						elseif itip==2
							% shift here
							
							%shift loop below:
							for iparticlemove=x_crack.nparticles(ipath):-1:1
								for idim=1:2
									x_crack.center(iparticlemove+1,idim,ipath)=x_crack.center(iparticlemove,idim,ipath);
									x_crack.top(iparticlemove+1,idim,ipath)=x_crack.top(iparticlemove,idim,ipath);
									x_crack.bot(iparticlemove+1,idim,ipath)=x_crack.bot(iparticlemove,idim,ipath);
									
									x_crack.force.top(iparticlemove+1,idim,ipath)=x_crack.force.top(iparticlemove,idim,ipath);
									x_crack.force.bot(iparticlemove+1,idim,ipath)=x_crack.force.bot(iparticlemove,idim,ipath);
									x_crack.bridge.base.deltax(iparticlemove+1,idim,ipath)=x_crack.bridge.base.deltax(iparticlemove,idim,ipath);
									x_crack.bridge.adjusted.deltax(iparticlemove+1,idim,ipath)=x_crack.bridge.adjusted.deltax(iparticlemove,idim,ipath);
									x_crack.bridge.firsttimedeltax(iparticlemove+1,idim,ipath)=x_crack.bridge.firsttimedeltax(iparticlemove,idim,ipath);
									%(iparticlemove+1,idim,ipath)
									%(iparticlemove,idim,ipath)
									%
								end
								x_crack.bridge.completeratio(iparticlemove+1,ipath)=x_crack.bridge.completeratio(iparticlemove,ipath);
								x_crack.bridge.absforce(iparticlemove+1,ipath)=x_crack.bridge.absforce(iparticlemove,ipath);
								x_crack.bridge.isactive(iparticlemove+1,ipath)=x_crack.bridge.isactive(iparticlemove,ipath);
								x_crack.bridge.firsttimeactive(iparticlemove+1,ipath)=x_crack.bridge.firsttimeactive(iparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltaxmax(iparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmax(iparticlemove,ipath);
								x_crack.bridge.base.absdeltax(iparticlemove+1,ipath)=x_crack.bridge.base.absdeltax(iparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltax(iparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltax(iparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltaxmaxi(iparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmaxi(iparticlemove,ipath);
								x_crack.bridge.kbase2(iparticlemove+1,ipath)=x_crack.bridge.kbase2(iparticlemove,ipath);
								x_crack.bridge.yieldforce2(iparticlemove+1,ipath)=x_crack.bridge.yieldforce2(iparticlemove,ipath);
								x_crack.bridge.deltai2(iparticlemove+1,ipath)=x_crack.bridge.deltai2(iparticlemove,ipath);
								x_crack.bridge.deltae2(iparticlemove+1,ipath)=x_crack.bridge.deltae2(iparticlemove,ipath);
								
								x_crack.bridge.failuresurface(iparticlemove+1,ipath)=x_crack.bridge.failuresurface(iparticlemove,ipath);
								x_crack.bridge.fractureenergy(iparticlemove+1,ipath)=x_crack.bridge.fractureenergy(iparticlemove,ipath);
								x_crack.bridge.strength(iparticlemove+1,ipath)=x_crack.bridge.strength(iparticlemove,ipath);
								x_crack.bridge.effectivespacing(iparticlemove+1,ipath)=x_crack.bridge.effectivespacing(iparticlemove,ipath);
								x_crack.bridge.nodalenergy(iparticlemove+1,ipath)=x_crack.bridge.nodalenergy(iparticlemove,ipath);
								
								x_crack.cohesivepoint(iparticlemove+1,ipath)=x_crack.cohesivepoint(iparticlemove,ipath);
								x_crack.tempaccel.tagged(iparticlemove+1,ipath)=x_crack.tempaccel.tagged(iparticlemove,ipath);
							end
							x_crack.cohesivepoint(1,ipath)=0;
							x_crack.tempaccel.tagged(1,ipath)=0;
							
							%adding to the list here:
							for idim=1:2
								x_crack.center(1,idim,ipath)=x_crack.center(2,idim,ipath)+clearedgeextension(idim);
								x_crack.top(1,idim,ipath)=x_crack.center(1,idim,ipath);
								x_crack.bot(1,idim,ipath)=x_crack.center(1,idim,ipath);
							end
						end
						%start of CROSSING FINDER
							zm.trajectory=zeros(1,2);
							zm.ghostparticle=zeros(1,2);
							zm.angle=zeros(1,1);
							zm.distance=zeros(1,1);
							for idim=1:2
								if itip==1
									x1(1,idim)=x_crack.center(iparticle,idim,ipath);
									x2(1,idim)=x_crack.center(iparticle,idim,ipath)+clearedgeextension(idim);
								elseif itip==2
									x1(1,idim)=x_crack.center(2,idim,ipath);
									x2(1,idim)=x_crack.center(2,idim,ipath)+clearedgeextension(idim);
								end
							end
							zm.trajectory=clearedgeextension;
							foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
							foundcrossing.iparticle3=zeros(1,200); %so not to clash with iparticle
							foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
							foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.
							for ipath2=1:x_crack.npaths
								for iparticle2=1:(x_crack.nparticles(ipath2)-1)
									if ipath2==ipath
										%iparticle: deals with the propagation, what's currently the particle as the itip
										%iparticle2: the loop for checking crack crossing
										if itip==1 && iparticle2>=iparticle-2
											continue;
										elseif itip==2 && iparticle2<=2
											continue;
										end
									end
									%start of crossing checks
									for dim=1:2
										x3(1,dim)=x_crack.center(iparticle2,dim,ipath2);
										x4(1,dim)=x_crack.center(iparticle2+1,dim,ipath2);
									end
									Area(1)=TriangleArea(x1,x2,x3);
									Area(2)=TriangleArea(x1,x2,x4);
									Area(3)=TriangleArea(x3,x4,x1);
									Area(4)=TriangleArea(x3,x4,x2);
									if (Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0) || (Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0)
										foundcrossing.size3=foundcrossing.size3+1;
										foundcrossing.ipath3(foundcrossing.size3)=ipath2;
										foundcrossing.iparticle3(foundcrossing.size3)=iparticle2;
										foundcrossing.ratio(foundcrossing.size3)=abs(Area(3))/(abs(Area(3))+abs(Area(4)));%ratio between 1-crossing distance to 1-2 distance
									end
									%end of crossing checks
								end
							end
							foundcrossing_ratio_min=2;
							for ifoundcrossing=1:foundcrossing.size3
								if foundcrossing.ratio(ifoundcrossing)<foundcrossing_ratio_min
									foundcrossing_ratio_min=foundcrossing.ratio(ifoundcrossing);
									x_crack.sequence.merge(ipath,itip)=foundcrossing.ipath3(ifoundcrossing);
								end
							end
							
							if foundcrossing.size3>0
								x_crack.terminatedprop(ipath,itip)=1;
								if itip==1
									x_crack.center(iparticle+1,:,ipath)=x_crack.center(iparticle,:,ipath)+foundcrossing_ratio_min*zm.trajectory;
									x_crack.top(iparticle+1,:,ipath)=x_crack.center(iparticle+1,:,ipath);
									x_crack.bot(iparticle+1,:,ipath)=x_crack.center(iparticle+1,:,ipath);
								elseif itip==2
									x_crack.center(1,:,ipath)=x_crack.center(2,:,ipath)+foundcrossing_ratio_min*zm.trajectory;
									x_crack.top(1,:,ipath)=x_crack.center(1,:,ipath);
									x_crack.bot(1,:,ipath)=x_crack.center(1,:,ipath);
								end
							else
								%TDL start of addition for no crossing
								%x_crack.terminatedprop(ipath,itip)=1;
								foundcrossing_ratio_min=1;
								if itip==1
									x_crack.center(iparticle+1,:,ipath)=x_crack.center(iparticle,:,ipath)+foundcrossing_ratio_min*zm.trajectory;
									x_crack.top(iparticle+1,:,ipath)=x_crack.center(iparticle+1,:,ipath);
									x_crack.bot(iparticle+1,:,ipath)=x_crack.center(iparticle+1,:,ipath);
								elseif itip==2
									x_crack.center(1,:,ipath)=x_crack.center(2,:,ipath)+foundcrossing_ratio_min*zm.trajectory;
									x_crack.top(1,:,ipath)=x_crack.center(1,:,ipath);
									x_crack.bot(1,:,ipath)=x_crack.center(1,:,ipath);
								end
								%end of addition for no crossing
							end
							x_crack.terminatedprop(ipath,itip)=1;
						%end of CROSSING FINDER
						
						x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
					end
					if x_crack.terminatedprop(ipath,itip)==1
						continue;
					end
					%end of CLEAR EDGE EXTENSION
					
					%start of extension due to zero mass
						zm.trajectory=zeros(1,2);
						zm.ghostparticle=zeros(1,2);
						zm.angle=zeros(1,1);
						zm.distance=zeros(1,1);
						if x_crack.boxcalc.active(ipath,itip)==1
							for icornerpoint=1:4
								for io_natural=1:4
									io=CONNECT_crack.boxcalc(icornerpoint,io_natural,ipath,itip);
									if nmass_si(io,TheFieldSplit_boxcalc(io_natural,icornerpoint,itip,ipath))<0.001*m_sp(1);
										x_crack.boxcalc.zeromass(ipath,itip,icornerpoint)=x_crack.boxcalc.zeromass(ipath,itip,icornerpoint)+1;
									end
									%below: u'_i=A_ij*u_j
								end
							end
							
							if sum(x_crack.boxcalc.zeromass(ipath,itip,2:3))>0
								if itip==1
									iparticletip=x_crack.nparticles(ipath);
									iparticlebefore=x_crack.nparticles(ipath)-1;
								else%if itip==2
									iparticletip=1;
									iparticlebefore=2;
								end
								if x_crack.boxcalc.zeromass(ipath,itip,2)==x_crack.boxcalc.zeromass(ipath,itip,3)
									zm.trajectory=(x_crack.boxcalc.locs(2,:,ipath,itip)+x_crack.boxcalc.locs(3,:,ipath,itip))/2-x_crack.center(iparticletip,:,ipath);
								elseif x_crack.boxcalc.zeromass(ipath,itip,2)>x_crack.boxcalc.zeromass(ipath,itip,3)
									zm.trajectory=x_crack.boxcalc.locs(2,:,ipath,itip)-x_crack.center(iparticletip,:,ipath);
								else%if x_crack.boxcalc.zeromass(ipath,itip,2)<x_crack.boxcalc.zeromass(ipath,itip,3)
									zm.trajectory=x_crack.boxcalc.locs(3,:,ipath,itip)-x_crack.center(iparticletip,:,ipath);
								end
								zm.angle=reliableatan(zm.trajectory(1),zm.trajectory(2));
								zm.distance=sqrt(dot(zm.trajectory,zm.trajectory));
								zm.ghostparticle=x_crack.center(iparticletip,:,ipath)+zm.trajectory;
								
								%start EXTENDING AND MIGRATING
									if itip==1
										x_crack.center(iparticle+1,:,ipath)=zm.ghostparticle
										x_crack.top(iparticle+1,:,ipath)=x_crack.center(iparticle+1,:,ipath);
										x_crack.bot(iparticle+1,:,ipath)=x_crack.center(iparticle+1,:,ipath);
										x_crack.bridge.effectivespacing(iparticle,ipath)=(calcmag(x_crack.center(iparticle,:,ipath)-x_crack.center(iparticle+1,:,ipath))+calcmag(x_crack.center(iparticle,:,ipath)-x_crack.center(iparticle-1,:,ipath)))/2;
										x_crack.bridge.nodalenergy(iparticle,ipath)=x_crack.bridge.effectivespacing(iparticle,ipath)*t0_plane*x_crack.bridge.fractureenergy(iparticle,ipath);
										
										x_crack.cohesivepoint(iparticle+1,ipath)=1;
										x_crack.sequence.tipreg(ipath,itip)=1;

										x_crack_ghosttip(1,:)=zm.ghostparticle;
									elseif itip==2
										for iparticlemove=x_crack.nparticles(ipath):-1:1
											for idim=1:2
												x_crack.center(iparticlemove+1,idim,ipath)=x_crack.center(iparticlemove,idim,ipath);
												x_crack.top(iparticlemove+1,idim,ipath)=x_crack.top(iparticlemove,idim,ipath);
												x_crack.bot(iparticlemove+1,idim,ipath)=x_crack.bot(iparticlemove,idim,ipath);
												
												x_crack.force.top(iparticlemove+1,idim,ipath)=x_crack.force.top(iparticlemove,idim,ipath);
												x_crack.force.bot(iparticlemove+1,idim,ipath)=x_crack.force.bot(iparticlemove,idim,ipath);
												x_crack.bridge.base.deltax(iparticlemove+1,idim,ipath)=x_crack.bridge.base.deltax(iparticlemove,idim,ipath);
												x_crack.bridge.adjusted.deltax(iparticlemove+1,idim,ipath)=x_crack.bridge.adjusted.deltax(iparticlemove,idim,ipath);
												x_crack.bridge.firsttimedeltax(iparticlemove+1,idim,ipath)=x_crack.bridge.firsttimedeltax(iparticlemove,idim,ipath);
											end
											x_crack.bridge.completeratio(iparticlemove+1,ipath)=x_crack.bridge.completeratio(iparticlemove,ipath);
											x_crack.bridge.absforce(iparticlemove+1,ipath)=x_crack.bridge.absforce(iparticlemove,ipath);
											x_crack.bridge.isactive(iparticlemove+1,ipath)=x_crack.bridge.isactive(iparticlemove,ipath);
											x_crack.bridge.firsttimeactive(iparticlemove+1,ipath)=x_crack.bridge.firsttimeactive(iparticlemove,ipath);
											x_crack.bridge.adjusted.absdeltaxmax(iparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmax(iparticlemove,ipath);
											x_crack.bridge.base.absdeltax(iparticlemove+1,ipath)=x_crack.bridge.base.absdeltax(iparticlemove,ipath);
											x_crack.bridge.adjusted.absdeltax(iparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltax(iparticlemove,ipath);
											x_crack.bridge.adjusted.absdeltaxmaxi(iparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmaxi(iparticlemove,ipath);
											x_crack.bridge.kbase2(iparticlemove+1,ipath)=x_crack.bridge.kbase2(iparticlemove,ipath);
											x_crack.bridge.yieldforce2(iparticlemove+1,ipath)=x_crack.bridge.yieldforce2(iparticlemove,ipath);
											x_crack.bridge.deltai2(iparticlemove+1,ipath)=x_crack.bridge.deltai2(iparticlemove,ipath);
											x_crack.bridge.deltae2(iparticlemove+1,ipath)=x_crack.bridge.deltae2(iparticlemove,ipath);
											
											x_crack.bridge.failuresurface(iparticlemove+1,ipath)=x_crack.bridge.failuresurface(iparticlemove,ipath);
											x_crack.bridge.fractureenergy(iparticlemove+1,ipath)=x_crack.bridge.fractureenergy(iparticlemove,ipath);
											x_crack.bridge.strength(iparticlemove+1,ipath)=x_crack.bridge.strength(iparticlemove,ipath);
											x_crack.bridge.effectivespacing(iparticlemove+1,ipath)=x_crack.bridge.effectivespacing(iparticlemove,ipath);
											x_crack.bridge.nodalenergy(iparticlemove+1,ipath)=x_crack.bridge.nodalenergy(iparticlemove,ipath);
											
											x_crack.cohesivepoint(iparticlemove+1,ipath)=x_crack.cohesivepoint(iparticlemove,ipath);
											x_crack.tempaccel.tagged(iparticlemove+1,ipath)=x_crack.tempaccel.tagged(iparticlemove,ipath);
										end
										x_crack.center(1,:,ipath)=zm.ghostparticle;
										x_crack.top(1,:,ipath)=x_crack.center(1,:,ipath);
										x_crack.bot(1,:,ipath)=x_crack.center(1,:,ipath);
										x_crack.bridge.effectivespacing(2,ipath)=(calcmag(x_crack.center(2,:,ipath)-x_crack.center(3,:,ipath))+calcmag(x_crack.center(2,:,ipath)-x_crack.center(1,:,ipath)))/2;
										x_crack.bridge.nodalenergy(2,ipath)=x_crack.bridge.effectivespacing(2,ipath)*t0_plane*x_crack.bridge.fractureenergy(2,ipath);
										
										x_crack.cohesivepoint(1,ipath)=1;
										x_crack.tempaccel.tagged(1,ipath)=0;
										x_crack.sequence.tipreg(ipath,itip)=1;
										
										crackextension=x_crack.spacing;
										x_crack_ghosttip(1,1)=x_crack.center(2,1,ipath)+3*crackextension*cos(theta_crack);
										x_crack_ghosttip(1,2)=x_crack.center(2,2,ipath)+3*crackextension*sin(theta_crack);
										x_crack_ghosttip=zm.ghostparticle;
									end
								%end EXTENDING AND MIGRATING
								
								%start of CROSSING FINDER
									if itip==1
										x1(1,1)=x_crack.center(iparticle,1,ipath);
										x1(1,2)=x_crack.center(iparticle,2,ipath);
									elseif itip==2
										x1(1,1)=x_crack.center(2,1,ipath);
										x1(1,2)=x_crack.center(2,2,ipath);
									end
									x2=zm.ghostparticle;
									foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
									foundcrossing.iparticle3=zeros(1,200); %so not to clash with iparticle
									foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
									foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.
									for ipath2=1:x_crack.npaths
										for iparticle2=1:(x_crack.nparticles(ipath2)-1)
											if ipath2==ipath
												%iparticle: deals with the propagation, what's currently the particle as the itip
												%iparticle2: the loop for checking crack crossing
												if itip==1 && iparticle2>=iparticle-2
													continue;
												elseif itip==2 && iparticle2<=2
													continue;
												end
											end
											%start of crossing checks
											for dim=1:2
												x3(1,dim)=x_crack.center(iparticle2,dim,ipath2);
												x4(1,dim)=x_crack.center(iparticle2+1,dim,ipath2);
											end
											Area(1)=TriangleArea(x1,x2,x3);
											Area(2)=TriangleArea(x1,x2,x4);
											Area(3)=TriangleArea(x3,x4,x1);
											Area(4)=TriangleArea(x3,x4,x2);
											if (Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0) || (Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0)
												foundcrossing.size3=foundcrossing.size3+1;
												foundcrossing.ipath3(foundcrossing.size3)=ipath2;
												foundcrossing.iparticle3(foundcrossing.size3)=iparticle2;
												foundcrossing.ratio(foundcrossing.size3)=abs(Area(3))/(abs(Area(3))+abs(Area(4)));%ratio between 1-crossing distance to 1-2 distance
											end
											%end of crossing checks
										end
									end
									foundcrossing_ratio_min=2;
									for ifoundcrossing=1:foundcrossing.size3
										if foundcrossing.ratio(ifoundcrossing)<foundcrossing_ratio_min
											foundcrossing_ratio_min=foundcrossing.ratio(ifoundcrossing);
											x_crack.sequence.merge(ipath,itip)=foundcrossing.ipath3(ifoundcrossing);
										end
									end
									
									if foundcrossing.size3>0
										x_crack.terminatedprop(ipath,itip)=1;
										if itip==1
											x_crack.center(iparticle+1,:,ipath)=x_crack.center(iparticle,:,ipath)+foundcrossing_ratio_min*zm.trajectory;
											x_crack.top(iparticle+1,:,ipath)=x_crack.center(iparticle+1,:,ipath);
											x_crack.bot(iparticle+1,:,ipath)=x_crack.center(iparticle+1,:,ipath);
										elseif itip==2
											x_crack.center(1,:,ipath)=x_crack.center(2,:,ipath)+foundcrossing_ratio_min*zm.trajectory;
											x_crack.top(1,:,ipath)=x_crack.center(1,:,ipath);
											x_crack.bot(1,:,ipath)=x_crack.center(1,:,ipath);
										end
									else
										%TDL start of addition for no crossing
										%x_crack.terminatedprop(ipath,itip)=1;
										foundcrossing_ratio_min=0.5;
										if itip==1
											x_crack.center(iparticle+1,:,ipath)=x_crack.center(iparticle,:,ipath)+foundcrossing_ratio_min*zm.trajectory;
											x_crack.top(iparticle+1,:,ipath)=x_crack.center(iparticle+1,:,ipath);
											x_crack.bot(iparticle+1,:,ipath)=x_crack.center(iparticle+1,:,ipath);
										elseif itip==2
											x_crack.center(1,:,ipath)=x_crack.center(2,:,ipath)+foundcrossing_ratio_min*zm.trajectory;
											x_crack.top(1,:,ipath)=x_crack.center(1,:,ipath);
											x_crack.bot(1,:,ipath)=x_crack.center(1,:,ipath);
										end
										%end of addition for no crossing
									end
									x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
									x_crack.terminatedprop(ipath,itip)=1;
								%end of CROSSING FINDER
							end
						end
						
						%TDL plot boxes after here!
						%{
						plot(x_sp(:,1),x_sp(:,2),'o');
						hold on;
						grid on;
						axis([1.6,5.4,1.6,5.4]*200);
						set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
						set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
						for ipath=2:x_crack.npaths
							plot(x_crack.center(1:x_crack.nparticles(ipath),1,ipath),x_crack.center(1:x_crack.nparticles(ipath),2,ipath));
							for itip=1:2
							if x_crack.terminatedprop(ipath,itip)==0
							if x_crack.boxcalc.active(ipath,itip)==1
								plot(x_crack.boxcalc.locs(:,1,ipath,itip),x_crack.boxcalc.locs(:,2,ipath,itip));
							end
							end
							end
						end
						asdf(-pi);
						%}
						if x_crack.terminatedprop(ipath,itip)==1
							continue;
						end
					%end of extension due to zero mass
					
					
					
					for icornerpoint=1:4
						for io_natural=1:4
							io=CONNECT_crack.boxcalc(icornerpoint,io_natural,ipath,itip);
							x_crack.boxcalc.u_global(icornerpoint,:)=x_crack.boxcalc.u_global(icornerpoint,:)+u_si(io,:,TheFieldSplit_boxcalc(io_natural,icornerpoint,itip,ipath))*N_crack.boxcalc(1,io_natural,icornerpoint,ipath,itip);
							%below: u'_i=A_ij*u_j
						end
						for dim1=1:2
						for dim2=1:2
							x_crack.boxcalc.u_local(icornerpoint,dim1)=x_crack.boxcalc.u_local(icornerpoint,dim1)+A(dim1,dim2)*x_crack.boxcalc.u_global(icornerpoint,dim2);
						end
						end
						for idim=1:2
							i_d_natural_local=2*(icornerpoint-1)+idim;
							d_natural_local(i_d_natural_local,1)=x_crack.boxcalc.u_local(icornerpoint,idim);
						end
					end
					
					
					%start of 
					a=x_crack.boxcalc.length/2;
					b=x_crack.boxcalc.width/2;
					
					
					%strain calculation below
					1;
					xi=-1;
					eta=0;
					
					B=1/4*[(-1+eta)/a 0 (1-eta)/a 0 (1+eta)/a 0 (-1-eta)/a 0;
							0 (-1+xi)/b 0 (-1-xi)/b 0 (1+xi)/b 0 (1-xi)/b;
							(-1+xi)/b (-1+eta)/a (-1-xi)/b (1-eta)/a (1+xi)/b (1+eta)/a (1-xi)/b (-1-eta)/a];
					
					epsilon_tip_local=B*d_natural_local;
					
					dESP_local=zeros(2,2);
					dESP_global=zeros(2,2);
					
					dESP_local(1,1)=epsilon_tip_local(1);
					dESP_local(1,2)=epsilon_tip_local(3);
					dESP_local(2,1)=epsilon_tip_local(3);
					dESP_local(2,2)=epsilon_tip_local(2);
					
					%below: T_ij=A_qi*A_mj*T_qm, i=dim1,j=dim2,q=dim3,m=dim4
					for dim1=1:2
					for dim2=1:2
					for dim3=1:2
					for dim4=1:2
						dESP_global(dim1,dim2)=dESP_global(dim1,dim2)+A(dim3,dim1)*A(dim4,dim2)*dESP_local(dim3,dim4);
					end
					end
					end
					end
					%TDL new strain box calculator
					%{
					if t_time>2.5*dt
						dESP_global_dump(:,:,ipath)=dESP_global;
						x_crack_boxcalc_u_global_dump(:,:,ipath)=x_crack.boxcalc.u_global;
						x_crack_boxcalc_u_local_dump(:,:,ipath)=x_crack.boxcalc.u_local;
						1;
					end
					%}
					
					if debugprint2 || debugprint3
						fprintf('%s',['ipath=' int2txt(ipath) ', itip=' int2txt(itip) ', x=(' float2scitxt(5,x_crack.center(iparticle,1,ipath)) ' , ' float2scitxt(5,x_crack.center(iparticle,2,ipath)) ')' char(10)]);
					end
					
					if debugprint2
						fprintf('%s',['dESP_global=' char(10) '[ ' float2scitxt(5,dESP_global(1,1)) ' , ' float2scitxt(5,dESP_global(1,2)) ' ]' char(10) '[ ' float2scitxt(5,dESP_global(2,1)) ' , ' float2scitxt(5,dESP_global(2,2)) ' ]' char(10)]);
						fprintf('%s',['shrinkage_tip=' char(10) '[ ' float2scitxt(5,shrinkage_tip(1,1)) ' , ' float2scitxt(5,shrinkage_tip(1,2)) ' ]' char(10) '[ ' float2scitxt(5,shrinkage_tip(2,1)) ' , ' float2scitxt(5,shrinkage_tip(2,2)) ' ]' char(10)]);
						fprintf('%s',['=============================================' char(10) char(10)]);
						input_codegen('Press Enter!');
					end
					
					if debugprint3
						for icornerpoint=1:4
							fprintf('%s',['x_crack.boxcalc.locs(' int2txt(icornerpoint) ',:,' int2txt(ipath) ',' int2txt(itip) ')=' char(10) '[ ' float2scitxt(5,x_crack.boxcalc.locs(icornerpoint,1,ipath,itip)) ' , ' float2scitxt(5,x_crack.boxcalc.locs(icornerpoint,2,ipath,itip)) ' ]'  char(10)]);
						end
						fprintf('%s',[char(10)]);
						
						for icornerpoint=1:4
							fprintf('%s',['x_crack.boxcalc.u_global(' int2txt(icornerpoint) ',:)=' char(10) '[ ' float2scitxt(5,x_crack.boxcalc.u_global(icornerpoint,1)) ' , ' float2scitxt(5,x_crack.boxcalc.u_global(icornerpoint,2)) ' ]'  char(10)]);
						end
						fprintf('%s',[char(10)]);
						
						for icornerpoint=1:4
							fprintf('%s',['x_crack.boxcalc.u_local(' int2txt(icornerpoint) ',:)=' char(10) '[ ' float2scitxt(5,x_crack.boxcalc.u_local(icornerpoint,1)) ' , ' float2scitxt(5,x_crack.boxcalc.u_local(icornerpoint,2)) ' ]'  char(10)]);
						end
						fprintf('%s',[char(10)]);
					end
					
					%TDL conversion of dESP from true strain to log strain
					dESP_global_engtolog=strainconverter(dESP_global,1);
					dESP_global_truetolog=strainconverter(dESP_global,3);
					dESP_global=dESP_global_truetolog;
					
					
					if debugprint3
						fprintf('%s',['epsilon_total=' char(10) '[ ' float2scitxt(5,dESP_global(1,1)) ' , ' float2scitxt(5,dESP_global(1,2)) ' ]' char(10) '[ ' float2scitxt(5,dESP_global(2,1)) ' , ' float2scitxt(5,dESP_global(2,2)) ' ]' char(10)]);
						fprintf('%s',['epsilon_shrinkage=' char(10) '[ ' float2scitxt(5,shrinkage_tip(1,1)) ' , ' float2scitxt(5,shrinkage_tip(1,2)) ' ]' char(10) '[ ' float2scitxt(5,shrinkage_tip(2,1)) ' , ' float2scitxt(5,shrinkage_tip(2,2)) ' ]' char(10)]);
						fprintf('%s',['epsilon_total_engtolog=' char(10) '[ ' float2scitxt(5,dESP_global_engtolog(1,1)) ' , ' float2scitxt(5,dESP_global_engtolog(1,2)) ' ]' char(10) '[ ' float2scitxt(5,dESP_global_engtolog(2,1)) ' , ' float2scitxt(5,dESP_global_engtolog(2,2)) ' ]' char(10)]);
						fprintf('%s',['epsilon_total_truetolog=' char(10) '[ ' float2scitxt(5,dESP_global_truetolog(1,1)) ' , ' float2scitxt(5,dESP_global_truetolog(1,2)) ' ]' char(10) '[ ' float2scitxt(5,dESP_global_truetolog(2,1)) ' , ' float2scitxt(5,dESP_global_truetolog(2,2)) ' ]' char(10)]);
					end
					
					dESP_global=dESP_global-shrinkage_tip;
					
					if debugprint3
						fprintf('%s',['epsilon_elastoplastic=epsilon_total-epsilon_shrinkage']);
						fprintf('%s',['epsilon_elastoplastic=' char(10) '[ ' float2scitxt(5,dESP_global(1,1)) ' , ' float2scitxt(5,dESP_global(1,2)) ' ]' char(10) '[ ' float2scitxt(5,dESP_global(2,1)) ' , ' float2scitxt(5,dESP_global(2,2)) ' ]' char(10)]);
					end
					
					%propagation method: 1=EP acoustic tensor with box, 2=elastic with box
					if propagationmethod==1
						pltip.dESP=dESP_global;
						pltip.R=eye(2);
						pltip.Rback=eye(2);
						pltip.Q=[cos(pltip.angle.chosen) sin(pltip.angle.chosen); -sin(pltip.angle.chosen) cos(pltip.angle.chosen)];
						pltip.Qback=[cos(-pltip.angle.chosen) sin(-pltip.angle.chosen); -sin(-pltip.angle.chosen) cos(-pltip.angle.chosen)];
						pltip.RQ=pltip.R*pltip.Q;
						pltip.QbackRback=pltip.Qback*pltip.Rback;
						pltip.dESP=(pltip.RQ)*pltip.dESP*transpose(pltip.RQ);
						%[s_sp,e_pl,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax]=Wood_Schmidt17(dESP,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp);
						%tip_weakeningfactor=0.9;
						[pltip.s_sp,DUMMY1,DUMMY2,DUMMY3,DUMMY4,DUMMY5,DUMMY6,tip_surfacewithfmax,DUMMY8,pltip.AbeforeQ_rtl,~]= ...
							Wood_Schmidt17(tip_k,0,0,pltip.dESP,pltip.sigma_global_big,pltip.e_t_global_big,pltip.e_pl_global_big,pltip.alpha_in,pltip.xdirletter,pltip.ydirletter,pltip.zdirletter,pltip.xydirletter,pltip.yzdirletter,pltip.xzdirletter,ftl*(1-tip_weakeningfactor),ftr*(1-tip_weakeningfactor),ftt*(1-tip_weakeningfactor),fcl*(1-tip_weakeningfactor),fcr*(1-tip_weakeningfactor),fct*(1-tip_weakeningfactor),fvrt*(1-tip_weakeningfactor),fvrl*(1-tip_weakeningfactor),fvtl*(1-tip_weakeningfactor),Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl*(1-tip_weakeningfactor),Gfcl,Gftr*(1-tip_weakeningfactor),Gftt*(1-tip_weakeningfactor),Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,t_time,dt,pltip.spid,Debugging,pltip.thetacrackrtl,pltip.dudx_rtl);
						
						%DUMMY5 is alpha_hp 
						if sum(DUMMY5)>0
							1;
						end
						if sum(sum(alphahp))>0
							1;
						end
						lambdamin=inf;
						thetamin=NaN;
						lambda1=zeros(ntestedangle,1);
						lambda2=zeros(ntestedangle,1);
						theta=zeros(ntestedangle,1);
						theta_crack=zeros(1,1);
						n=zeros(2,1);
						h=zeros(2,2,ntestedangle);
						Qacoustic=zeros(2,2,ntestedangle);
						%AbeforeQ_tip=pltip.AbeforeQ_rtl; %no longer in use, we use orientationoffset interpolation now, as calculated in the for stacks below
						
						for idim1=1:2
						for idim2=1:2
						for idim3=1:2
						for idim4=1:2
						for idim5=1:2
						for idim6=1:2
						for idim7=1:2
						for idim8=1:2
							AbeforeQ_tip(idim1,idim2,idim3,idim4)=AbeforeQ_tip(idim1,idim2,idim3,idim4)+real(pltip.QbackRback(idim1,idim5)*pltip.QbackRback(idim2,idim6)*pltip.QbackRback(idim3,idim7)*pltip.QbackRback(idim4,idim8)*pltip.AbeforeQ_rtl(idim5,idim6,idim7,idim8));
						end
						end
						end
						end
						end
						end
						end
						end
						
						AbeforeQ_breaksignal=0;
						x_crack.propcounter(ipath,itip)=x_crack.propcounter(ipath,itip)+1;
						acousticdirection=(-1)^(x_crack.propcounter(ipath,itip)-1); %so it always starts counterclockwise
						acousticdirection=1;
						for itestedangle=1:ntestedangle
							%TDL switch direction of acoustic tensor evaluation here
							if acousticdirection>0
								theta(itestedangle)=(itestedangle)/ntestedangle*2*pi;
							else
								theta(itestedangle)=2*pi-(itestedangle-1)/ntestedangle*2*pi;
							end
							n(1)=cos(theta(itestedangle));
							n(2)=sin(theta(itestedangle));
							for idim1=1:2
							for idim2=1:2
							for idim3=1:2
							for idim4=1:2
								if isnan(AbeforeQ_tip(idim1,idim2,idim3,idim4))
									AbeforeQ_breaksignal=1;
								end
								Qacoustic(idim2,idim3,itestedangle)=Qacoustic(idim2,idim3,itestedangle)+n(idim1)*AbeforeQ_tip(idim1,idim2,idim3,idim4)*n(idim4);
							end
							end
							end
							end
							if AbeforeQ_breaksignal
								break;
							end
							[h_eig,lambda_eig]=eig(Qacoustic(:,:,itestedangle));
							h(:,:,itestedangle)=real(h_eig);
							lambda1(itestedangle)=real(lambda_eig(1,1));
							lambda2(itestedangle)=real(lambda_eig(2,2));
						end
						1;
						if AbeforeQ_breaksignal
							continue;
						end
						lambdamin=min([lambda1;lambda2]);
						if length(lambdamin)>1
							fprintf('%s',['length(lamdabmin)>1!' char(10)]);
							DUMMY=input_codegen('error 201004-1301 (this is bogus input)');
						end
						if lambdamin>=0
							theta_crack=NaN;
							propagationsignal=0;
						else
							%asdf(-pi);
							propagationsignal=1;
							localminima1index.sizes=0;
							localminima1index.values=zeros(1,ntestedangle);
							localminima2index.sizes=0;
							localminima2index.values=zeros(1,ntestedangle);
							for itestedangle=1:ntestedangle
								if lambda1(itestedangle)<0 && lambda1(itestedangle)<=lambda1(mod((itestedangle-1)-1,ntestedangle)+1) && lambda1(itestedangle)<=lambda1(mod((itestedangle+1)-1,ntestedangle)+1)
									localminima1index.sizes=localminima1index.sizes+1;
									localminima1index.values(localminima1index.sizes)=itestedangle;
								end
								if lambda2(itestedangle)<0 && lambda2(itestedangle)<=lambda2(mod((itestedangle-1)-1,ntestedangle)+1) && lambda2(itestedangle)<=lambda2(mod((itestedangle+1)-1,ntestedangle)+1)
									localminima2index.sizes=localminima2index.sizes+1;
									localminima2index.values(localminima2index.sizes)=itestedangle;
								end
							end
							nldudxhl.sizes=localminima1index.sizes+localminima2index.sizes;
							nldudxhl.values=zeros(1,2*ntestedangle);
							h_localminima.sizes=localminima1index.sizes+localminima2index.sizes;
							h_localminima.values=zeros(2,2*ntestedangle);
							if debugprint1
								fprintf('%s',['ipath=' int2txt(ipath) char(10)]);
								fprintf('%s',['itip=' int2txt(itip) char(10)]);
								fprintf('%s',['acousticdirection=' int2txt(acousticdirection) char(10)]);
								for idim1=1:2
								for idim2=1:2
									fprintf('%s',['dudx_tip(' int2txt(idim1) ',' int2txt(idim2) ')=' float2scitxt(5,dudx_tip(idim1,idim2)) char(10)]);
								end
								end
							end
							for ilocalminima=1:localminima1index.sizes
								n(1)=cos(theta(localminima1index.values(ilocalminima)));
								n(2)=sin(theta(localminima1index.values(ilocalminima)));
								nldudxhl.values(ilocalminima)=real(transpose(n)*dudx_tip*h(:,1,localminima1index.values(ilocalminima)));
								nldudxhl.sizes=ilocalminima;
								h_localminima.values(:,ilocalminima)=h(:,1,localminima1index.values(ilocalminima));
								h_localminima.sizes=ilocalminima;
								if debugprint1
									fprintf('%s',['ilocalminima=' int2txt(ilocalminima) char(10)]);
									fprintf('%s',['localminima1index.values(' int2txt(ilocalminima) ')=' int2txt(localminima1index.values(ilocalminima)) char(10)]);
									fprintf('%s',['theta(' int2txt(localminima1index.values(ilocalminima)) ')=' float2scitxt(5,theta(localminima1index.values(ilocalminima))) '=' float2scitxt(5,theta(localminima1index.values(ilocalminima))*180/pi) ' degs' char(10)]);
									for idim=1:2
										fprintf('%s',['n(' int2txt(idim) ')=' float2scitxt(5,n(idim)) char(10)]);
									end
									fprintf('%s',['nldudxhl.values(' int2txt(ilocalminima) ')=' float2scitxt(5,nldudxhl.values(ilocalminima)) char(10)]);
									for idim=1:2
										fprintf('%s',['h(' int2txt(idim) ',1,' int2txt(localminima1index.values(ilocalminima)) ')=' float2scitxt(5,h(idim,1,localminima1index.values(ilocalminima))) char(10)]);
									end
									for idim=1:2
										fprintf('%s',['h_localminima.values(' int2txt(idim) ',' int2txt(ilocalminima) ')=' float2scitxt(5,h_localminima.values(idim,ilocalminima)) char(10)]);
									end
								end
							end
							for ilocalminima=1:localminima2index.sizes
								n(1)=cos(theta(localminima2index.values(ilocalminima)));
								n(2)=sin(theta(localminima2index.values(ilocalminima)));
								nldudxhl.values(ilocalminima+localminima1index.sizes)=real(transpose(n)*dudx_tip*h(:,2,localminima2index.values(ilocalminima)));
								nldudxhl.sizes=ilocalminima+localminima1index.sizes;
								h_localminima.values(:,ilocalminima+localminima1index.sizes)=h(:,2,localminima2index.values(ilocalminima));
								h_localminima.sizes=ilocalminima+localminima1index.sizes;
								if debugprint1
									fprintf('%s',['ilocalminima=' int2txt(ilocalminima) char(10)]);
									fprintf('%s',['ilocalminima+localminima1index.sizes=' int2txt(ilocalminima+localminima1index.sizes) char(10)]);
									fprintf('%s',['localminima2index.values(' int2txt(ilocalminima) ')=' int2txt(localminima2index.values(ilocalminima)) char(10)]);
									fprintf('%s',['theta(' int2txt(localminima2index.values(ilocalminima)) ')=' float2scitxt(5,theta(localminima2index.values(ilocalminima))) '=' float2scitxt(5,theta(localminima2index.values(ilocalminima))*180/pi) ' degs' char(10)]);
									for idim=1:2
										fprintf('%s',['n(' int2txt(idim) ')=' float2scitxt(5,n(idim)) char(10)]);
									end
									fprintf('%s',['nldudxhl.values(' int2txt(ilocalminima+localminima1index.sizes) ')=' float2scitxt(5,nldudxhl.values(ilocalminima+localminima1index.sizes)) char(10)]);
									for idim=1:2
										fprintf('%s',['h(' int2txt(idim) ',2,' int2txt(localminima2index.values(ilocalminima)) ')=' float2scitxt(5,h(idim,2,localminima2index.values(ilocalminima))) char(10)]);
									end
									for idim=1:2
										fprintf('%s',['h_localminima.values(' int2txt(idim) ',' int2txt(ilocalminima+localminima1index.sizes) ')=' float2scitxt(5,h_localminima.values(idim,ilocalminima+localminima1index.sizes)) char(10)]);
									end
								end
							end
							for ilocalminima=1:localminima1index.sizes
								localminimaindex.values(ilocalminima)=localminima1index.values(ilocalminima);
								localminimaindex.sizes=ilocalminima;
							end
							for ilocalminima=1:localminima2index.sizes
								localminimaindex.values(ilocalminima+localminima1index.sizes)=localminima2index.values(ilocalminima);
								localminimaindex.sizes=localminima1index.sizes+ilocalminima;
							end
							FindMaxnldudxhl=FindMax(nldudxhl.values(1:nldudxhl.sizes));
							crackindex=localminimaindex.values(FindMaxnldudxhl);
							thetamin=theta(crackindex);
							h_crackdecision=zeros(2,1);
							h_crackdecision(:,1)=h_localminima.values(:,FindMaxnldudxhl);
							theta_crack=mod(thetamin+pi/2+pi/2,pi)+pi/2;
							if debugprint1
								for ilocalminimaindex=1:localminimaindex.sizes
									fprintf('%s',['localminimaindex.values(' int2txt(ilocalminimaindex) ')=' int2txt(localminimaindex.values(ilocalminimaindex)) char(10)]);
								end
								for ilocalminimaindex=1:localminimaindex.sizes
									fprintf('%s',['nldudxhl.values(' int2txt(ilocalminimaindex) ')=' float2scitxt(5,nldudxhl.values(ilocalminimaindex)) char(10)]);
								end
								fprintf('%s',['FindMaxnldudxhl=' int2txt(FindMaxnldudxhl) char(10)]);
								fprintf('%s',['crackindex=' int2txt(crackindex) char(10)]);
								fprintf('%s',['thetamin=theta(' int2txt(crackindex)  ')=' float2scitxt(5,thetamin) '=' float2scitxt(5,thetamin*180/pi) ' degs' char(10)]);
								fprintf('%s',['theta_crack=' float2scitxt(5,theta_crack) '=' float2scitxt(5,theta_crack*180/pi) ' degs' char(10)]);
								%TDL pause acoustic tensor evaluation result here
								input_codegen('press enter!');
							end
							1;
						end
						
						% end of criterion evaluation of crack propagation
						
						% propagation signal designates whether crack should propagate or not
					else%if propagationmethod==2
						epsilon_tip(1)=dESP_global(1,1);
						epsilon_tip(2)=dESP_global(2,2);
						epsilon_tip(3)=dESP_global(1,2);
						
						D=E/((1+nu)*(1-2*nu))*[1-nu nu 0;nu 1-nu 0;0 0 (1-2*nu)];
						
						s_tip_temp=D*epsilon_tip;
						
						for idim=1:3
							s_tip(ipath,idim,itip)=s_tip_temp(idim,1);
						end
						for idim=1:3
							s_tip_dump(2*(ipath-1)+itip,idim)=s_tip(ipath,idim,itip);
							s_tip_K1_dump(2*(ipath-1)+itip,idim)=s_tip_K1(ipath,idim,itip);
						end
						for idim=1:8
							d_tip_dump(2*(ipath-1)+itip,idim)=d_natural(idim,1);
							io_natural=ceil(idim/2);
							xydim=mod(idim-1,2)+1;
							d_LOC_tip_dump(2*(ipath-1)+itip,idim)=LOC(CONNECT_crack.center.values(iparticle,nio_designator(io_natural),ipath),xydim);;
						end
						for idim=1:2
							x_tip_dump(2*(ipath-1)+itip,idim)=x_crack.center(iparticle,idim,ipath);
						end
						s_tip_max=(s_tip(ipath,1,itip)+s_tip(ipath,2,itip))/2+sqrt( ((s_tip(ipath,1,itip)-s_tip(ipath,2,itip))/2)^2 + (s_tip(ipath,3,itip))^2 ); %calculate principal stress
						
						
						if debugprint5
							fprintf('%s',['elasticstrength =' float2scitxt(5,elasticstrength) char(10)]);
							input_codegen('press enter!');
						end
						
						if s_tip_max>k_dumpresult*elasticstrength
							dumpresult=1;
						end
						x_crack.tipcrackratio(ipath,itip)=s_tip_max/elasticstrength;
						x_crack.acctipcrackratio(ipath,itip)=max(x_crack.acctipcrackratio(ipath,itip),x_crack.tipcrackratio(ipath,itip));
						fprintf('%s',['ipath=' int2txt(ipath) ', itip=' int2txt(itip) ', s_tip_max=' float2scitxt(5,s_tip_max) ', elasticstrength=' float2scitxt(5,elasticstrength) ', s_tip_max/elasticstrength=' float2scitxt(5,s_tip_max/elasticstrength) char(10)]);
						if s_tip_max>elasticstrength
							propagationsignal=1;
							theta_crack=0.5*(pi-reliableatan((s_tip(ipath,1,itip)-s_tip(ipath,2,itip))/2,-s_tip(ipath,3,itip))); %direction of propagation, i.e. parallel to crack surface.
						end
						if debugprint3
							fprintf('%s',['s_tip_max=' float2scitxt(5,s_tip_max) char(10)]);
							fprintf('%s',['theta_crack=' float2scitxt(5,theta_crack) char(10)]);
							fprintf('%s',['crackforce=' float2scitxt(5,s_tip_max/elasticstrength) char(10)]);
							fprintf('%s',['=============================================' char(10) char(10)]);
							input_codegen('Press Enter!');
						end
					end
					if x_crack.terminatedprop(ipath,itip)==0 && propagationsignal==1 && denypropagation==0
						%TDL catch propagation
						dumpresult=1;
						if propagationmethod==1
							x_crack.bridge.failuresurface(iparticle,ipath)=tip_surfacewithfmax(1);
							%TDL fracture energy infinite switch 1
							if tip_surfacewithfmax(1)==1
								x_crack.bridge.fractureenergy(iparticle,ipath)=Gftr*fractureenergymultiplier;
								x_crack.bridge.strength(iparticle,ipath)=ftr*strengthfactor;
							elseif tip_surfacewithfmax(1)==3
								x_crack.bridge.fractureenergy(iparticle,ipath)=Gftt*fractureenergymultiplier;
								x_crack.bridge.strength(iparticle,ipath)=ftt*strengthfactor;
							elseif tip_surfacewithfmax(1)==5
								x_crack.bridge.fractureenergy(iparticle,ipath)=Gftl*fractureenergymultiplier;
								x_crack.bridge.strength(iparticle,ipath)=ftl*strengthfactor;
							else
								x_crack.bridge.fractureenergy(iparticle,ipath)=0;
								x_crack.bridge.strength(iparticle,ipath)=ftl*strengthfactor;
							end
							x_crack.bridge.yieldforce2(iparticle,ipath)=x_crack.bridge.strength(iparticle,ipath)*x_crack.spacing*t0_plane;
							baselength=x_crack.bridge.fractureenergy(iparticle,ipath)/x_crack.bridge.strength(iparticle,ipath);
							x_crack.bridge.deltae2(iparticle,ipath)=0.1/fractureenergymultiplier*baselength;
							x_crack.bridge.deltai2(iparticle,ipath)=(1-0.1/fractureenergymultiplier)*baselength;
						end
						
						%crackextension=x_crack.spacing;
						crackextension=x_crack.boxcalc.length/2;
						
						if itip==1
							deltax_previous=x_crack.center(iparticle,:,ipath)-x_crack.center(iparticle-1,:,ipath);
						elseif itip==2
							deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
						end
						theta_crack_trial(1)=theta_crack;
						theta_crack_trial(2)=mod(theta_crack+pi,2*pi); %two possibilities for crack angle, 
						if (deltax_previous(1,1,1)*cos(theta_crack_trial(1))+deltax_previous(1,2,1)*sin(theta_crack_trial(1)))>0 % cos of theta_crack_trial with current crack itip trajectory
							theta_crack=theta_crack_trial(1);
						else
							theta_crack=theta_crack_trial(2);
						end
						if itip==1
							%STRENGTH EXCEEDING PROPAGATION
							x_crack.center(iparticle+1,1,ipath)=x_crack.center(iparticle,1,ipath)+crackextension*cos(theta_crack);
							x_crack.center(iparticle+1,2,ipath)=x_crack.center(iparticle,2,ipath)+crackextension*sin(theta_crack);
							for idim=1:2
								x_crack.top(iparticle+1,idim,ipath)=x_crack.center(iparticle+1,idim,ipath);
								x_crack.bot(iparticle+1,idim,ipath)=x_crack.center(iparticle+1,idim,ipath);
							end
							x_crack.bridge.effectivespacing(iparticle,ipath)=(calcmag(x_crack.center(iparticle,:,ipath)-x_crack.center(iparticle+1,:,ipath))+calcmag(x_crack.center(iparticle,:,ipath)-x_crack.center(iparticle-1,:,ipath)))/2;
							x_crack.bridge.nodalenergy(iparticle,ipath)=x_crack.bridge.effectivespacing(iparticle,ipath)*t0_plane*x_crack.bridge.fractureenergy(iparticle,ipath);
							
							x_crack.cohesivepoint(iparticle+1,ipath)=1;
							x_crack.sequence.tipreg(ipath,itip)=1;

							crackextension=x_crack.spacing;
							x_crack_ghosttip(1,1)=x_crack.center(iparticle,1,ipath)+3*crackextension*cos(theta_crack);
							x_crack_ghosttip(1,2)=x_crack.center(iparticle,2,ipath)+3*crackextension*sin(theta_crack);
						elseif itip==2
							for iparticlemove=x_crack.nparticles(ipath):-1:1
								for idim=1:2
									x_crack.center(iparticlemove+1,idim,ipath)=x_crack.center(iparticlemove,idim,ipath);
									x_crack.top(iparticlemove+1,idim,ipath)=x_crack.top(iparticlemove,idim,ipath);
									x_crack.bot(iparticlemove+1,idim,ipath)=x_crack.bot(iparticlemove,idim,ipath);
									
									x_crack.force.top(iparticlemove+1,idim,ipath)=x_crack.force.top(iparticlemove,idim,ipath);
									x_crack.force.bot(iparticlemove+1,idim,ipath)=x_crack.force.bot(iparticlemove,idim,ipath);
									x_crack.bridge.base.deltax(iparticlemove+1,idim,ipath)=x_crack.bridge.base.deltax(iparticlemove,idim,ipath);
									x_crack.bridge.adjusted.deltax(iparticlemove+1,idim,ipath)=x_crack.bridge.adjusted.deltax(iparticlemove,idim,ipath);
									x_crack.bridge.firsttimedeltax(iparticlemove+1,idim,ipath)=x_crack.bridge.firsttimedeltax(iparticlemove,idim,ipath);
								end
								x_crack.bridge.completeratio(iparticlemove+1,ipath)=x_crack.bridge.completeratio(iparticlemove,ipath);
								x_crack.bridge.absforce(iparticlemove+1,ipath)=x_crack.bridge.absforce(iparticlemove,ipath);
								x_crack.bridge.isactive(iparticlemove+1,ipath)=x_crack.bridge.isactive(iparticlemove,ipath);
								x_crack.bridge.firsttimeactive(iparticlemove+1,ipath)=x_crack.bridge.firsttimeactive(iparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltaxmax(iparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmax(iparticlemove,ipath);
								x_crack.bridge.base.absdeltax(iparticlemove+1,ipath)=x_crack.bridge.base.absdeltax(iparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltax(iparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltax(iparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltaxmaxi(iparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmaxi(iparticlemove,ipath);
								x_crack.bridge.kbase2(iparticlemove+1,ipath)=x_crack.bridge.kbase2(iparticlemove,ipath);
								x_crack.bridge.yieldforce2(iparticlemove+1,ipath)=x_crack.bridge.yieldforce2(iparticlemove,ipath);
								x_crack.bridge.deltai2(iparticlemove+1,ipath)=x_crack.bridge.deltai2(iparticlemove,ipath);
								x_crack.cohesivepoint(iparticlemove+1,ipath)=x_crack.cohesivepoint(iparticlemove,ipath);
								x_crack.tempaccel.tagged(iparticlemove+1,ipath)=x_crack.tempaccel.tagged(iparticlemove,ipath);
							end
							x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+crackextension*cos(theta_crack);
							x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+crackextension*sin(theta_crack);
							for idim=1:2
								x_crack.top(1,idim,ipath)=x_crack.center(1,idim,ipath);
								x_crack.bot(1,idim,ipath)=x_crack.center(1,idim,ipath);
							end
							x_crack.bridge.effectivespacing(2,ipath)=(calcmag(x_crack.center(2,:,ipath)-x_crack.center(3,:,ipath))+calcmag(x_crack.center(2,:,ipath)-x_crack.center(1,:,ipath)))/2;
							x_crack.bridge.nodalenergy(2,ipath)=x_crack.bridge.effectivespacing(2,ipath)*t0_plane*x_crack.bridge.fractureenergy(2,ipath);
							
							x_crack.cohesivepoint(1,ipath)=1;
							x_crack.tempaccel.tagged(1,ipath)=0;
							x_crack.sequence.tipreg(ipath,itip)=1;
							
							crackextension=x_crack.spacing;
							x_crack_ghosttip(1,1)=x_crack.center(2,1,ipath)+3*crackextension*cos(theta_crack);
							x_crack_ghosttip(1,2)=x_crack.center(2,2,ipath)+3*crackextension*sin(theta_crack);
						end
						
						if itip==1
							x1(1,1)=x_crack.center(iparticle,1,ipath);
							x1(1,2)=x_crack.center(iparticle,2,ipath);
						elseif itip==2
							x1(1,1)=x_crack.center(2,1,ipath);
							x1(1,2)=x_crack.center(2,2,ipath);
						end
						x2(1,1)=x_crack_ghosttip(1,1);
						x2(1,2)=x_crack_ghosttip(1,2);
						
						foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
						foundcrossing.iparticle3=zeros(1,200); %so not to clash with iparticle
						foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
						foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.
						
						for ipath2=1:x_crack.npaths
							for iparticle2=1:(x_crack.nparticles(ipath2)-1)
								if ipath2==ipath
									%iparticle: deals with the propagation, what's currently the particle as the itip
									%iparticle2: the loop for checking crack crossing
									if itip==1 && iparticle2>=iparticle-2
										continue;
									elseif itip==2 && iparticle2<=2
										continue;
									end
								end
								%start of crossing checks
								for dim=1:2
									x3(1,dim)=x_crack.center(iparticle2,dim,ipath2);
									x4(1,dim)=x_crack.center(iparticle2+1,dim,ipath2);
								end
								Area(1)=TriangleArea(x1,x2,x3);
								Area(2)=TriangleArea(x1,x2,x4);
								Area(3)=TriangleArea(x3,x4,x1);
								Area(4)=TriangleArea(x3,x4,x2);
								if (Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0) || (Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0)
									foundcrossing.size3=foundcrossing.size3+1;
									foundcrossing.ipath3(foundcrossing.size3)=ipath2;
									foundcrossing.iparticle3(foundcrossing.size3)=iparticle2;
									foundcrossing.ratio(foundcrossing.size3)=abs(Area(3))/(abs(Area(3))+abs(Area(4)));%ratio between 1-crossing distance to 1-2 distance
								end
								%end of crossing checks
							end
						end
						foundcrossing_ratio_min=2;
						for ifoundcrossing=1:foundcrossing.size3
							if foundcrossing.ratio(ifoundcrossing)<foundcrossing_ratio_min
								foundcrossing_ratio_min=foundcrossing.ratio(ifoundcrossing);
								x_crack.sequence.merge(ipath,itip)=foundcrossing.ipath3(ifoundcrossing);
							end
						end
						if foundcrossing.size3>0
							x_crack.terminatedprop(ipath,itip)=1;
							%TDL slight extension for merging here
							if itip==1
								x_crack.center(iparticle+1,1,ipath)=x_crack.center(iparticle,1,ipath)+foundcrossing_ratio_min*3.1*crackextension*cos(theta_crack);
								x_crack.top(iparticle+1,1,ipath)=x_crack.center(iparticle+1,1,ipath);
								x_crack.bot(iparticle+1,1,ipath)=x_crack.center(iparticle+1,1,ipath);
								x_crack.center(iparticle+1,2,ipath)=x_crack.center(iparticle,2,ipath)+foundcrossing_ratio_min*3.1*crackextension*sin(theta_crack);
								x_crack.top(iparticle+1,2,ipath)=x_crack.center(iparticle+1,2,ipath);
								x_crack.bot(iparticle+1,2,ipath)=x_crack.center(iparticle+1,2,ipath);
							elseif itip==2
								x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+foundcrossing_ratio_min*3.1*crackextension*cos(theta_crack);
								x_crack.top(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.bot(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+foundcrossing_ratio_min*3.1*crackextension*sin(theta_crack);
								x_crack.top(1,2,ipath)=x_crack.center(1,2,ipath);
								x_crack.bot(1,2,ipath)=x_crack.center(1,2,ipath);
							end
						end
						x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
					end
				end
			end
		end
		
		%initiation starts below
		%bogus indent for below
			fprintf('%s',['marker #643b' char(10)]);
			if denyinitiation==0 && sum(justcracked)>0
				dumpresult=1;
				
				justcrackedlist=zeros(sum(justcracked),1);
				justcrackedcounter=0;
				for isp=1:spCount
					if justcracked(isp)
						justcrackedcounter=justcrackedcounter+1;
						justcrackedlist(justcrackedcounter)=isp;
					end
				end
				
				%justcrackedlist=CrackParticleClustering_nodes(LOC,1.5*le(1),justcrackedlist);
				fprintf('%s',['marker #702' char(10)]);
				%ntestedangle=size(Qacoustic{justcrackedlist{1}(1)},3);
				ntestedangle=36;
				fprintf('%s',['marker #703' char(10)]);
				theta=zeros(ntestedangle,1);
				fprintf('%s',['marker #704' char(10)]);
				errorntestedangle=36*1*1*1;
				error=zeros(1,errorntestedangle);
				
				x_justcrackedcenter=zeros(2,1);
				lowmassinitiationalert=0;
				for rsp=1:length(justcrackedlist)
					%TDL pause during initiation here
					1; %asdf(-pi);
					isp=justcrackedlist(rsp);	
					%justcrackedcounter=length(justcrackedlist{rsp});	
					mindistance=le(1)*NN(1);
					currentpos=0;
					for inn=1:NN(1)-1 %[D]TDL check for NN?
						if abs(le(1)*(inn-0.5)-x_sp(isp,1))<mindistance
							mindistance=abs(le(1)*(inn-0.5)-x_sp(isp,1));
							currentpos=le(1)*(inn-0.5);
						end
					end
					x_justcrackedcenter(1)=currentpos;
					
					mindistance=le(2)*NN(2);
					currentpos=0;
					for inn=1:NN(2)-1 %[D]TDL check for NN?
						if abs(le(1)*(inn-0.5)-x_sp(isp,2))<mindistance
							mindistance=abs(le(2)*(inn-0.5)-x_sp(isp,2));
							currentpos=le(2)*(inn-0.5);
						end
					end
					x_justcrackedcenter(2)=currentpos;
					%x_justcrackedcenter(1)=sum(LOC(justcrackedlist{rsp},1))/justcrackedcounter;
					%x_justcrackedcenter(2)=sum(LOC(justcrackedlist{rsp},2))/justcrackedcounter;
					%{
					for i=1:errorntestedangle
						theta(i)=(i-1)/36*1*1*1*pi;
						error(i)=0;
						for spc=1:justcrackedcounter
							error(i)=error(i)+(mod(thetacrack(justcrackedlist{rsp}(spc))-theta(i)+pi/2,pi)-pi/2)^2;
						end
					end
					%}
					avgnodalmass=0;
					avgnodalmasscounter=0;
					for io=1:niCount
						if abs(LOC(io,1)-x_justcrackedcenter(1))<0.75*le(1) && abs(LOC(io,2)-x_justcrackedcenter(2))<0.75*le(2)
							avgnodalmass=avgnodalmass+nmass_si_comb(io)/4;
							if debugprint4
								avgnodalmasscounter=avgnodalmasscounter+1;
								fprintf('%s',['avgnodalmasscounter=' int2txt(avgnodalmasscounter) char(10)]);
								fprintf('%s',['io=' int2txt(io) char(10)]);
								fprintf('%s',['LOC(' int2txt(io) ',:)=[' float2scitxt(5,LOC(io,1)) ',' float2scitxt(5,LOC(io,2)) ']' char(10)]);
								fprintf('%s',['nmass_si_comb(' int2txt(io) ')=' float2scitxt(5,nmass_si_comb(io)) char(10)]);
								fprintf('%s',['avgnodalmass=' float2scitxt(5,avgnodalmass) char(10)]);
							end
						end
					end
					if avgnodalmass<2*m_sp(1)
						lowmassinitiationalert=1;
					end
					thetajustcrackedcenter=thetacrack(isp);
					surfacewithfmaxcenter=surfacewithfmax(isp);
					%thetajustcrackedcenter=theta(FindMin(error));
					%considered=ones(x_crack.npaths,2);
					%distancelist=zeros(x_crack.npaths,2);
					%thetapropagationlist=zeros(x_crack.npaths,2);
					%n_nairncrack0=0;
					%n_nairncrack1=0;
					
					intheprevention=0;
					preventiondistance=1.25*le(1);
					preventionangle=pi/3;
					for ipath=1:x_crack.npaths;
						for spcrack=1:(x_crack.nparticles(ipath)-1)
							inthepreventionrange=0; %position only no care about orientation
							vector1a=[(x_justcrackedcenter(1)-x_crack.center(spcrack,1,ipath));(x_justcrackedcenter(2)-x_crack.center(spcrack,2,ipath))];
							vector1b=[(x_justcrackedcenter(1)-x_crack.center(spcrack+1,1,ipath));(x_justcrackedcenter(2)-x_crack.center(spcrack+1,2,ipath))];
							distance1a=sqrt(dot(vector1a,vector1a));
							distance1b=sqrt(dot(vector1b,vector1b));
							
							distance1a_old=sqrt((x_justcrackedcenter(1)-x_crack.center(spcrack,1,ipath))^2+(x_justcrackedcenter(2)-x_crack.center(spcrack,2,ipath))^2);
							distance1b_old=sqrt((x_justcrackedcenter(1)-x_crack.center(spcrack+1,1,ipath))^2+(x_justcrackedcenter(2)-x_crack.center(spcrack+1,2,ipath))^2);
							
							distance1=min([distance1a distance1b]);
							
							area2=abs(TriangleArea(x_justcrackedcenter,x_crack.center(spcrack,:,ipath),x_crack.center(spcrack+1,:,ipath)));
							
							inbetween2vector=[(x_crack.center(spcrack+1,1,ipath)-x_crack.center(spcrack,1,ipath));(x_crack.center(spcrack+1,2,ipath)-x_crack.center(spcrack,2,ipath))];
							
							inbetween2=sqrt(dot(inbetween2vector,inbetween2vector));
							
							inbetween2_old=sqrt((x_crack.center(spcrack+1,1,ipath)-x_crack.center(spcrack,1,ipath))^2+(x_crack.center(spcrack+1,2,ipath)-x_crack.center(spcrack,2,ipath))^2);
							distance2=area2/inbetween2;
							
							signcos1=dot(vector1a,inbetween2vector);
							signcos2=dot(vector1b,inbetween2vector);
							
							if signcos1*signcos2>0
								distance=distance1;
							else
								distance=distance2;
							end
							if distance<preventiondistance
								inthepreventionrange=1;
							end
							if spcrack==1 || spcrack==(x_crack.nparticles(ipath)-1)
								if spcrack==1
									index1=2;
									index2=1;
								else
									index1=x_crack.nparticles(ipath)-1;
									index2=x_crack.nparticles(ipath);
								end
								trajectory=x_crack.center(index2,:,ipath)-x_crack.center(index1,:,ipath);
								angle=reliableatan(trajectory(1),trajectory(2));
								prev_n1=[cos(angle) sin(angle)];
								prev_n2=[cos(angle+pi/2) sin(angle+pi/2)];
								prev_A=[prev_n1;prev_n2];
								x_crack_center_rotated=zeros(1,2);
								x_justcrackedcenter_rotated=zeros(1,2);
								for idim1=1:2
								for idim2=1:2
									x_crack_center_rotated(idim1)=x_crack_center_rotated(idim1)+prev_A(idim1,idim2)*x_crack.center(index2,idim2,ipath);
									x_justcrackedcenter_rotated(idim1)=x_justcrackedcenter_rotated(idim1)+prev_A(idim1,idim2)*x_justcrackedcenter(idim2);
								end
								end
								if abs(x_justcrackedcenter_rotated(1)-x_crack_center_rotated(1))<preventiondistance && abs(x_justcrackedcenter_rotated(2)-x_crack_center_rotated(2))<preventiondistance
									inthepreventionrange=1;
								end
							end
							if inthepreventionrange==1
								thetanairncrack=reliableatan(x_crack.center(spcrack+1,1,ipath)-x_crack.center(spcrack,1,ipath),x_crack.center(spcrack+1,2,ipath)-x_crack.center(spcrack,2,ipath));
								
								absdeltatheta=abs(mod(thetanairncrack-thetajustcrackedcenter+pi/2,pi)-pi/2);
								
								if absdeltatheta<preventionangle
									intheprevention=1;
								end
							end
							if intheprevention==1
								break;
							end
						end
						if intheprevention==1
							break;
						end
					end
					fprintf('%s',['isp=' int2txt(isp) char(10)]);
					fprintf('%s',['intheprevention=' int2txt(intheprevention) char(10)]);
					if debugprint4
						if lowmassinitiationalert==1
							fprintf('%s',['lowmassinitiationalert=' int2txt(lowmassinitiationalert) char(10)]);
							fprintf('%s',['avgnodalmass=' float2scitxt(5,avgnodalmass) char(10)]);
							fprintf('%s',['m_sp(1)=' float2scitxt(5,m_sp(1)) char(10)]);
							fprintf('%s',['x_justcrackedcenter=[' float2scitxt(5,x_justcrackedcenter(1)) ',' float2scitxt(5,x_justcrackedcenter(2)) ']' char(10)]);
							input_codegen('press enter to continue!');
						end
					end
					1;
					fprintf('%s',['lowmassinitiationalert=' int2txt(lowmassinitiationalert) char(10)]);
					if intheprevention==0 && lowmassinitiationalert==0
						thetainitiate=mod(thetajustcrackedcenter-pi,pi)+pi; %always pointing down, pi<theta<2*pi
						ipath=x_crack.npaths+1;
						x_crack.npaths=x_crack.npaths+1;
						fprintf('%s',['CasetoRun=' int2txt(CasetoRun) char(10)]);
						
						if sin(thetainitiate)==0 || cos(thetainitiate)==0
							multiplier=1;
						else
							multiplier=min([1/abs(cos(thetainitiate)) 1/abs(sin(thetainitiate))]);
						end
						multiplier=multiplier/2;
						%TDL under construction
						%growing the crack one by one
						%step 0: define center as x_crack.center(2,:,ipath) (temporary, will change on step 3) at x_justrackedcenter
						%step 1: grow to +1/3 multiplier as x_crack.center(3,:,ipath)
						%step 2: grow the +2/3 multipler as x_crack.center(4,:,ipath)
						%step 3: move back x_crack.center(2,:,ipath) to -1/3 multipler, by first assigning -1/3 multiplier to particle #1, then migrating
						%step 4: grow to -2/3 multiplier x_crack.center(1,:,ipath)
						%thus, migration is only needed when step 3 ends with crack itip termination and step 4 doesn't go
						
						%start of step 0
							x_crack.cohesivepath(ipath)=1;
							x_crack.nparticles(ipath)=1;
							x_crack.center(2,1,ipath)=x_justcrackedcenter(1); 
							x_crack.center(2,2,ipath)=x_justcrackedcenter(2); 
							x_crack.cohesivepoint(2,ipath)=1;
						%end of step 0

						%start of step 1
							x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
							initcut.expansion=1/3*multiplier*le(1); %assuming le(1)=le(2);
							x_crack.center(3,1,ipath)=x_crack.center(2,1,ipath)+initcut.expansion*cos(thetainitiate); 
							x_crack.center(3,2,ipath)=x_crack.center(2,2,ipath)+initcut.expansion*sin(thetainitiate); 
							x_crack.cohesivepoint(3,ipath)=1; %first we assume it's not terminated
							x1=x_crack.center(2,:,ipath);
							x2=x_crack.center(3,:,ipath);
							
							%below tries to check potential crossings with all other existing cracks
							initcut.firstevaluation=1;
							initcut.actuallycut=0;
							%the two above are actually redundant, since even though they serve different functions we can still just use one and repurpose for the other necessity, however for better readability we use both anyway.
							
							for ipath2=1:x_crack.npaths-1 %maximum npath is the newly initiated crack, thus -1 so it doesn't compare to itself
							for iparticle=1:x_crack.nparticles(ipath2)-1 %this -1 is because if we have n particles, we have n-1 spans.
								x3=x_crack.center(iparticle,:,ipath2);
								x4=x_crack.center(iparticle+1,:,ipath2);
								[initcut.CrossDir,initcut.RelativeLocation]=FindCrossing(x1,x2,x3,x4);
								if initcut.CrossDir~=0
									initcut.actuallycut=1;	
									%if this is the first evaluation (initcut.firstevaluation==1, or simply initcut.firstevaluation) or current value (initcut.RelativeLocation) is less than current minimum value (initcut.RelativeLocationMin), then we take the current value as the new minimum.
									if initcut.firstevaluation || initcut.RelativeLocation<initcut.RelativeLocationMin
										initcut.RelativeLocationMin=initcut.RelativeLocation;
									end
									initcut.firstevaluation=0;
								end
							end
							end
							
							%if a cut is detected, we terminate and go no further
							if initcut.actuallycut
								x_crack.center(3,1,ipath)=x_crack.center(2,1,ipath)+initcut.RelativeLocationMin*initcut.expansion*cos(thetainitiate); %assuming le(1)=le(2);
								x_crack.center(3,2,ipath)=x_crack.center(2,2,ipath)+initcut.RelativeLocationMin*initcut.expansion*sin(thetainitiate); %assuming le(1)=le(2);
								x_crack.terminatedprop(ipath,1)=1; %ipath, itip (1 or 2), we terminate 1st itip
								x_crack.cohesivepoint(3,ipath)=0;
							%else
								%we move to step 2
							end
						%end of step 1
						
						%start of step 2
						if initcut.actuallycut==0 %(if no cut is detected)
							%first we assume it's not terminated
							x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
							initcut.expansion=2/3*multiplier*le(1); %assuming le(1)=le(2);
							x_crack.center(4,1,ipath)=x_crack.center(3,1,ipath)+initcut.expansion*cos(thetainitiate); %assuming le(1)=le(2), also assuming no cut, crack not terminated
							x_crack.center(4,2,ipath)=x_crack.center(3,2,ipath)+initcut.expansion*sin(thetainitiate);
							x_crack.cohesivepoint(4,ipath)=1; %again, assuming crack isn't terminated and cohesivepoint still goes
							x1=x_crack.center(3,:,ipath);
							x2=x_crack.center(4,:,ipath);
							
							%below tries to check potential crossings with all other existing cracks (besides itself of course)
							initcut.firstevaluation=1;
							initcut.actuallycut=0;
							%again, both are actually redundant, can get away with using only one, but for better readibility I keep both of them
							
							for ipath2=1:x_crack.npaths-1
							for iparticle=1:x_crack.nparticles(ipath2)-1
								x3=x_crack.center(iparticle,:,ipath2);
								x4=x_crack.center(iparticle+1,:,ipath2);
								[initcut.CrossDir,initcut.RelativeLocation]=FindCrossing(x1,x2,x3,x4);
								if initcut.CrossDir~=0
									initcut.actuallycut=1;
									if initcut.firstevaluation || initcut.RelativeLocation<initcut.RelativeLocationMin
										initcut.RelativeLocationMin=initcut.RelativeLocation;
									end
									initcut.firstevaluation=0;
								end	
							end
							end
						end
						
						%if a cut is detected, we terminate
						if initcut.actuallycut
							x_crack.center(4,1,ipath)=x_crack.center(3,1,ipath)+initcut.RelativeLocationMin*initcut.expansion*cos(thetainitiate); %assuming le(1)=le(2);
							x_crack.center(4,2,ipath)=x_crack.center(3,2,ipath)+initcut.RelativeLocationMin*initcut.expansion*sin(thetainitiate);
							x_crack.terminatedprop(ipath,1)=1; %itip #1, for the maximum particle number
							x_crack.cohesivepoint(4,ipath)=0;
						%else
							%then no overrides, we've already defined everything beforehand
						end
						%end of step 2
						
						%start of step 3
							%first, assume it's not terminated. also we first assign to number 1 temporarily, as we'll migrate it to 2 later
							%x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1; %we still assume 3 particles, we just borrow number 1. if turns out we dont need it, we migrate everything of 2 3 4 to 1 2 3.
							initcut.expansion=1/3*multiplier*le(1); %assuming le(1)=le(2);
							x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)-initcut.expansion*cos(thetainitiate); 
							x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)-initcut.expansion*sin(thetainitiate);
							x_crack.cohesivepoint(1,ipath)=1; %first we assume it's not terminated
							x1=x_crack.center(2,:,ipath);
							x2=x_crack.center(1,:,ipath);

							%below tries to check potential crossings with all other existing cracks, except itself of course
							initcut.firstevaluation=1;
							initcut.actuallycut=0;
							%again, the two above are redundant. they serve different functions, but just using actually cut can actually serve both needs. however I'm keeping both for better readability.
							
							for ipath2=1:x_crack.npaths-1
							for iparticle=1:x_crack.nparticles(ipath2)-1
								x3=x_crack.center(iparticle,:,ipath2);
								x4=x_crack.center(iparticle+1,:,ipath2);
								[initcut.CrossDir,initcut.RelativeLocation]=FindCrossing(x1,x2,x3,x4);
								if initcut.CrossDir~=0
									initcut.actuallycut=1;
									if initcut.firstevaluation || initcut.RelativeLocation<initcut.RelativeLocationMin
										initcut.RelativeLocationMin=initcut.RelativeLocation;
									end
									initcut.firstevaluation=0;
								end
							end
							end
							
							%if cut detected, extend only up to the cut
							if initcut.actuallycut
								x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)-initcut.RelativeLocationMin*initcut.expansion*cos(thetainitiate);
								x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)-initcut.RelativeLocationMin*initcut.expansion*sin(thetainitiate);
								x_crack.terminatedprop(ipath,2)=1; %tip #2 (crack particle number 1)
								x_crack.cohesivepoint(1,ipath)=0;
							end
								
							%assigning 1 back to 2
								x_crack.center(2,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.center(2,2,ipath)=x_crack.center(1,2,ipath);
								x_crack.cohesivepoint(2,ipath)=x_crack.cohesivepoint(1,ipath);
							%end of assigning 1 back to 2
							
							%below migrates 2 3 4 to 1 2 3 if cut is detected
							if initcut.actuallycut
								for iparticlemove=1:x_crack.nparticles(ipath)
									x_crack.center(iparticlemove,1,ipath)=x_crack.center(iparticlemove+1,1,ipath);
									x_crack.center(iparticlemove,2,ipath)=x_crack.center(iparticlemove+1,2,ipath);
									x_crack.cohesivepoint(iparticlemove,ipath)=x_crack.cohesivepoint(iparticlemove+1,ipath);
								end
								x_crack.center(x_crack.nparticles(ipath)+1,1,ipath)=0;
								x_crack.center(x_crack.nparticles(ipath)+1,2,ipath)=0;
								x_crack.cohesivepoint(x_crack.nparticles(ipath)+1,ipath)=0;
							end
						%end of step 3
						
						%start of step 4
							if initcut.actuallycut==0
								x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
								initcut.expansion=2/3*multiplier*le(1); %assuming le(1)=le(2);
								x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)-initcut.expansion*cos(thetainitiate);
								x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)-initcut.expansion*sin(thetainitiate);
								x_crack.cohesivepoint(1,ipath)=1;
								x1=x_crack.center(2,:,ipath);
								x2=x_crack.center(1,:,ipath);
								
								%below tries ot check potential crossings with all other existing cracks (besides itself of course)
								initcut.firstevaluation=1;
								initcut.actuallycut=0;
								%again, both are actually redundant, can get away with using only one, but for better readibility I keep both of them
									
								for ipath2=1:x_crack.npaths-1
								for iparticle=1:x_crack.nparticles(ipath2)-1
									x3=x_crack.center(iparticle,:,ipath2);
									x4=x_crack.center(iparticle+1,:,ipath2);
									[initcut.CrossDir,initcut.RelativeLocation]=FindCrossing(x1,x2,x3,x4);
									if initcut.CrossDir~=0
										initcut.actuallycut=1;
										if initcut.firstevaluation || initcut.RelativeLocation<initcut.RelativeLocationMin
											initcut.RelativeLocationMin=initcut.RelativeLocation;
										end
										initcut.firstevaluation=0;
									end
								end
								end
								%if a cut is detected, we terminate
								if initcut.actuallycut
									x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)-initcut.RelativeLocationMin*initcut.expansion*cos(thetainitiate); 
									x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)-initcut.RelativeLocationMin*initcut.expansion*sin(thetainitiate);
									x_crack.terminatedprop(ipath,2)=1;
									x_crack.cohesivepoint(1,ipath)=0;
								end	
							end
						%end of step 4
						
						%start of calculating cohesion parameters
							initiatedspacing=0;
							for iparticle=1:x_crack.nparticles(ipath)
								if iparticle==1
									initiatedspacing=sqrt(dot(x_crack.center(1,:,ipath)-x_crack.center(2,:,ipath),x_crack.center(1,:,ipath)-x_crack.center(2,:,ipath)));
								elseif iparticle==x_crack.nparticles(ipath)
									initiatedspacing=sqrt(dot(x_crack.center(x_crack.nparticles(ipath),:,ipath)-x_crack.center(x_crack.nparticles(ipath)-1,:,ipath),x_crack.center(x_crack.nparticles(ipath),:,ipath)-x_crack.center(x_crack.nparticles(ipath)-1,:,ipath)))
								else
									initiatedspacing=0.5*(sqrt(dot(x_crack.center(iparticle,:,ipath)-x_crack.center(iparticle+1,:,ipath),x_crack.center(iparticle,:,ipath)-x_crack.center(iparticle+1,:,ipath)))+sqrt(dot(x_crack.center(iparticle,:,ipath)-x_crack.center(iparticle-1,:,ipath),x_crack.center(iparticle,:,ipath)-x_crack.center(iparticle-1,:,ipath))));
								end
								%TDL fracture energy infinite switch 2
								if propagationmethod==1
									x_crack.bridge.failuresurface(iparticle,ipath)=tip_surfacewithfmax(1);
									if surfacewithfmaxcenter==1
										x_crack.bridge.fractureenergy(iparticle,ipath)=Gftr*fractureenergymultiplier;
										x_crack.bridge.strength(iparticle,ipath)=ftr*strengthfactor;
									elseif surfacewithfmaxcenter==3
										x_crack.bridge.fractureenergy(iparticle,ipath)=Gftt*fractureenergymultiplier;
										x_crack.bridge.strength(iparticle,ipath)=ftt*strengthfactor;
									elseif surfacewithfmaxcenter==5
										x_crack.bridge.fractureenergy(iparticle,ipath)=Gftl*fractureenergymultiplier;
										x_crack.bridge.strength(iparticle,ipath)=ftl*strengthfactor;
									else
										x_crack.bridge.fractureenergy(iparticle,ipath)=0;
										x_crack.bridge.strength(iparticle,ipath)=ftl*strengthfactor;
									end
									x_crack.bridge.yieldforce2(iparticle,ipath)=x_crack.bridge.strength(iparticle,ipath)*initiatedspacing*t0_plane;
									baselength=x_crack.bridge.fractureenergy(iparticle,ipath)/x_crack.bridge.strength(iparticle,ipath);
									x_crack.bridge.deltae2(iparticle,ipath)=0.1/fractureenergymultiplier*baselength;
									x_crack.bridge.deltai2(iparticle,ipath)=(1-0.1/fractureenergymultiplier)*baselength;
								end
								
								%{
								fprintf('%s',['iparticle=' int2txt(iparticle) ', ipath=' int2txt(ipath) char(10)]);
								fprintf('%s',['initiatedspacing=' float2scitxt(5,initiatedspacing) char(10)]);
								fprintf('%s',['le(1)=' float2scitxt(5,le(1)) char(10)]);
								fprintf('%s',['multiplier=' float2scitxt(5,multiplier) char(10)]);
								fprintf('%s',['x_crack.bridge.yieldforce2(iparticle,ipath)=' float2scitxt(5,x_crack.bridge.yieldforce2(iparticle,ipath)) char(10)]);
								fprintf('%s',['baselength=' float2scitxt(5,baselength) char(10)]);
								fprintf('%s',['x_crack.bridge.deltae2(iparticle,ipath)=' float2scitxt(5,x_crack.bridge.deltae2(iparticle,ipath)) char(10)]);
								fprintf('%s',['x_crack.bridge.deltai2(iparticle,ipath)=' float2scitxt(5,x_crack.bridge.deltai2(iparticle,ipath)) char(10)]);
								input_codegen('press enter!');
								%}
							end
						%end of calculating cohesion parameters
						
						%{
						x_crack.center(1,1,ipath)=x_justcrackedcenter(1)-1*multiplier*le(1)*cos(thetainitiate); %assuming le(1)=le(2);
						x_crack.center(1,2,ipath)=x_justcrackedcenter(2)-1*multiplier*le(1)*sin(thetainitiate);
						x_crack.center(2,1,ipath)=x_justcrackedcenter(1)-1/3*multiplier*le(1)*cos(thetainitiate);
						x_crack.center(2,2,ipath)=x_justcrackedcenter(2)-1/3*multiplier*le(1)*sin(thetainitiate);
						x_crack.center(3,1,ipath)=x_justcrackedcenter(1)+1/3*multiplier*le(1)*cos(thetainitiate);
						x_crack.center(3,2,ipath)=x_justcrackedcenter(2)+1/3*multiplier*le(1)*sin(thetainitiate);
						x_crack.center(4,1,ipath)=x_justcrackedcenter(1)+1*multiplier*le(1)*cos(thetainitiate);
						x_crack.center(4,2,ipath)=x_justcrackedcenter(2)+1*multiplier*le(1)*sin(thetainitiate);
						x_crack.cohesivepath(ipath)=1;
						x_crack.cohesivepoint(1,ipath)=1;
						x_crack.cohesivepoint(2,ipath)=1;
						x_crack.cohesivepoint(3,ipath)=1;
						x_crack.cohesivepoint(4,ipath)=1;
						%}
							
						%fprintf('%s',['>>line 8967: size(x_crackcenter' int2txt(ipath) '},1)=' int2txt(x_crack.nparticles(ipath)) char(10)]);
						%fprintf('%s',['>>line 8968: size(x_cracktop{' int2txt(ipath) '},1)=' int2txt(size(x_cracktop{ipath},1)) char(10)]);
						%{
						for i=1:size(x_cracktop{ipath},1)
							for j=1:size(x_cracktop{ipath},2)
								%fprintf('%s',['>>line 8973: x_cracktop{' int2txt(ipath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_cracktop{ipath}(i,j)) char(10)]);
							end
						end
						for i=1:size(x_crackbot{ipath},1)
							for j=1:size(x_crackbot{ipath},2)
								%fprintf('%s',['>>line 8980: x_crackbot{' int2txt(ipath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackbot{ipath}(i,j)) char(10)]);
							end
						end
						for i=1:size(x_crackcenter{ipath},1)
							for j=1:size(x_crackcenter{ipath},2)
								%fprintf('%s',['>>line 8987: x_crackcenter{' int2txt(ipath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackcenter{ipath}(i,j)) char(10)]);
							end
						end
						%}
						for i=1:x_crack.nparticles(ipath)
							for j=1:2
								%fprintf('%s',['>>line 8973: x_crackcenter{' int2txt(ipath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackcenter{ipath}(i,j)) char(10)]);
								x_crack.top(i,j,ipath)=x_crack.center(i,j,ipath);
								x_crack.bot(i,j,ipath)=x_crack.center(i,j,ipath);
							end
						end
						%shit below
						%x_cracktop{ipath}=x_crackcenter{ipath};
						%x_crackbot{ipath}=x_crackcenter{ipath};
						%shit above
					end
					%soundplay
					1;
				end
			end
			%{
			if x_crack.npaths>=3
				for ipath=1:x_crack.npaths
					for iparticle=1:x_crack.nparticles(ipath)
						fprintf('%s',['x_crack.center(' int2txt(iparticle) ',:,' int2txt(ipath) ')=[' float2scitxt(5,x_crack.center(iparticle,1,ipath)) ' ' float2scitxt(5,x_crack.center(iparticle,2,ipath)) ']' char(10)]);
					end
				end
			end
			%}
		%bogus indent for above	
		1;
			
		for ipath=1:x_crack.npaths
		for itip=1:2
			if x_crack.terminatedprop(ipath,itip)==0
				x_crack.boxcalc.active(ipath,itip)=1;
			else
				x_crack.boxcalc.active(ipath,itip)=0;
			end
		end
		end
		
		fprintf('%s',['x_crack.npaths=' int2txt(x_crack.npaths) char(10)]);
		fprintf('%s',['sum(x_crack.nparticles)-x_crack.npaths=' int2txt(sum(x_crack.nparticles)-x_crack.npaths) char(10)]);
		%CasetoRun==221 || CasetoRun==222 || CasetoRun==225
		%CasetoRun==221 || CasetoRun==222 || CasetoRun==225
		%CasetoRun==221 || CasetoRun==222 || CasetoRun==225
		%CasetoRun==221 || CasetoRun==222 || CasetoRun==225
		%CasetoRun==221 || CasetoRun==222 || CasetoRun==225
		%CasetoRun==221 || CasetoRun==222 || CasetoRun==225
%TDL end editing in fhdjsfklsdahfhdjksa.m
	elseif CasetoRun==199
		%crack propagation of 199
		% of 163 but with acoustic tensor
		%node centric propagation
		%no gauss propagation
		
		%new declarations start here
		propagationsignal=zeros(1,1);
		ntestedangle=36;
		AbeforeQ_tip=zeros(2,2,2,2); %only one 4th order tensor, recycled for every tip calculated
		dudx_tip=zeros(2,2);
		nldudxhl.values=zeros(1,2*ntestedangle);
		nldudxhl.sizes=zeros(1,1);
		h_localminima.sizes=zeros(1,1);
		h_localminima.values=zeros(2,2*ntestedangle);
		localminima1index.values=zeros(1,ntestedangle);
		localminima1index.sizes=zeros(1,1);
		localminima2index.values=zeros(1,ntestedangle);
		localminima2index.sizes=zeros(1,1);
		localminimaindex.values=zeros(1,2*ntestedangle);
		localminimaindex.sizes=zeros(1,1);
		h_crackdecision=zeros(2,1);
		FindMaxnldudxhl=zeros(1,1);
		crackindex=zeros(1,1);
		thetamin=zeros(1,1);
		theta_crack=zeros(1,1);
		%new declarations end here
		[AbeforeQ_si,AbeforeQ_si_active]=Interpolate_AbeforeQ(AbeforeQ,NODES,nodeCount,CONNECT,N,spCount,m_sp,TheFieldSplit,CasetoRun,fieldnumber);
		no=niCount;
		%s_tip(ipath,dim,itip);
		s_tip=zeros(x_crack.npaths,3,2);
		s_tip_K1=zeros(x_crack.npaths,3,2); %ncrackpaths; dimension (x and y); which tip
		deltax_previous=zeros(1,2,1);
		theta_crack_trial=zeros(1,2);
		deltatheta_crack=zeros(1,2);
		s_tip_dump=zeros(2*x_crack.npaths,3);
		d_tip_dump=zeros(2*x_crack.npaths,8);
		d_LOC_tip_dump=zeros(2*x_crack.npaths,8);
		s_tip_K1_dump=zeros(2*x_crack.npaths,3);
		u_tip_dump=zeros(2*x_crack.npaths,8);
		x_tip_dump=zeros(2*x_crack.npaths,2);
		r_propdirweighted_dump=zeros(2*x_crack.npaths,2);
		K1_maxradius=3*le(1);
		K1_estimate=zeros(1,2);
		K1_distance=zeros(1,2);
		r_propdirweighted=zeros(x_crack.npaths,2,2); %crackpath num, dimension, which tip
		sigma_maxprinc_magnitude=0;
		r_propdircompliment=zeros(1,2);
		a_transform=zeros(2,2);
		s_tip_tensor=zeros(2,2);
		s_tip_tensor_transformed=zeros(2,2);
		LOC_avg=zeros(1,2);
		nio_designator=zeros(1,4);
		d_natural=zeros(8,1);
		delta_x=zeros(1,2);
		epsilon_tip=zeros(3,1);
		x_crack_ghosttip=zeros(1,2);
		x1=zeros(1,2);
		x2=zeros(1,2);
		x3=zeros(1,2);
		x4=zeros(1,2);
		Area=zeros(1,4);
		foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
		foundcrossing.icrackparticle3=zeros(1,200); %so not to clash with iparticle
		foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
		foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.
		%nio_designator(1): in the natural coordinates, node 1 associates with which nio?
		%nio_designator(2): in the natural coordinates, node 2 associates with which nio?
		%nio_designator(3): in the natural coordinates, node 3 associates with which nio?
		%nio_designator(4): in the natural coordinates, node 4 associates with which nio?
		
		io_natural_cross_before=0;
		io_natural_cross_after=0;
		io_natural_sides=zeros(1,4);
		
		
		%r_propdirweighted=zeros(1,2); %dimension only
		%allowpropagation=1;
		for tip=1:2
			%tip=1: particle of highest index
			%tip=2: particle of lowest index
			for ipath=1:x_crack.npaths
				if x_crack.terminatedprop(ipath,tip)==0
					if tip==1
						icrackparticle=x_crack.nparticles(ipath);
					elseif tip==2
						icrackparticle=1;
					end
					LOC_avg=zeros(1,2);
					for nio=1:4
						io=CONNECT_crack.center.values(icrackparticle,nio,ipath);
						for dim=1:2
							LOC_avg(1,dim)=LOC_avg(1,dim)+LOC(io,dim);
						end
					end
					for dim=1:2
						LOC_avg(1,dim)=LOC_avg(1,dim)/4;
					end
					for nio=1:4
						io=CONNECT_crack.center.values(icrackparticle,nio,ipath);
						if LOC(io,1)<LOC_avg(1,1)
							if LOC(io,2)<LOC_avg(1,2)
								nio_designator(1)=nio;
							elseif LOC(io,2)>LOC_avg(1,2) %can just write else, but this way it's more readable. also equal is not possible, so I left it out
								nio_designator(4)=nio;
							end
						elseif LOC(io,1)>LOC_avg(1,1) %same drill, trying to improve readability
							if LOC(io,2)<LOC_avg(1,2)
								nio_designator(2)=nio;
							elseif LOC(io,2)>LOC_avg(1,2)
								nio_designator(3)=nio;
							end
						end
					end
					%allowpropagation=1;
					tip_crackability=0;
					AbeforeQ_tip=zeros(2,2,2,2);
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						tip_crackability=tip_crackability+uncrackable_si_comb(io)*N_crack.center(1,nio_outside,icrackparticle,ipath);
						if AbeforeQ_si_active(io,1)==1
							for dim1=1:2
							for dim2=1:2
							for dim3=1:2
							for dim4=1:2
								AbeforeQ_tip(dim1,dim2,dim3,dim4)=AbeforeQ_tip(dim1,dim2,dim3,dim4)+AbeforeQ_si(dim1,dim2,dim3,dim4,io,1)*N_crack.center(1,nio_outside,icrackparticle,ipath);
							end
							end
							end
							end
						end
						dudx_tip=dudx_tip+u_si(io,:,1)'*dN_crack.center(:,nio_outside,icrackparticle,ipath)';
						%the way is inspired form the following:
						%L_sp{spid} = L_sp{spid} + (nvelo_si(npid,:,TheFieldSplit(j,spid))'*dN{spid}(:,j)');
					end
					x_crack.Efactor(ipath,tip)=0;
					x_crack.mEfactor(ipath,tip)=0;
					x_crack.mass(ipath,tip)=0;
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						if CasetoRun==174
							x_crack.mEfactor(ipath,tip)=x_crack.mEfactor(ipath,tip)+N_crack.center(1,nio_outside,icrackparticle,ipath)*mEfactor_si(io,1);
							x_crack.mass(ipath,tip)=x_crack.mass(ipath,tip)+N_crack.center(1,nio_outside,icrackparticle,ipath)*nmass_si(io,1);
						end
						for dim=1:2
							index=2*(io_natural-1)+dim;
							if io_natural_sides(io_natural)==2
								d_natural(index,1)=u_si(io,dim,TheFieldSplit_cracktop{ipath}(nio_outside,icrackparticle));
							elseif io_natural_sides(io_natural)==3
								d_natural(index,1)=u_si(io,dim,TheFieldSplit_crackbot{ipath}(nio_outside,icrackparticle));
							else
								d_natural(index,1)=u_si_comb(io,dim);
							end
						end
						%if uncrackable_si_comb(io)>0.25
						if tip_crackability>0.125
							x_crack.terminatedprop(ipath,tip)=1;
							break;
						elseif sum(nmass_si(io,:))<=0
							%allowpropagation=0;
							x_crack.terminatedprop(ipath,tip)=1;
							x_crack.openedgetip(ipath,tip)=1;
							if tip==1
								deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
								x_crack.cohesivepoint(icrackparticle,ipath)=0;
							elseif tip==2
								deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
								x_crack.cohesivepoint(1,ipath)=0;
							end
							if tip==1
								%CLEAR EDGE EXTENSION
								%might need idim=1:2 loop, but don't touch if still works OK?
								%did it anyway
								
								% no shift here, just adding to the list
								for idim=1:2
									x_crack.center(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle,idim,ipath)+deltax_previous(idim);
									x_crack.top(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
									x_crack.bot(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
								end
							elseif tip==2
								% shift here
								
								%shift loop below:
								for icrackparticlemove=x_crack.nparticles(ipath):-1:1
									for idim=1:2
										x_crack.center(icrackparticlemove+1,idim,ipath)=x_crack.center(icrackparticlemove,idim,ipath);
										x_crack.top(icrackparticlemove+1,idim,ipath)=x_crack.top(icrackparticlemove,idim,ipath);
										x_crack.bot(icrackparticlemove+1,idim,ipath)=x_crack.bot(icrackparticlemove,idim,ipath);
										
										
										x_crack.force.top(icrackparticlemove+1,idim,ipath)=x_crack.force.top(icrackparticlemove,idim,ipath);
										x_crack.force.bot(icrackparticlemove+1,idim,ipath)=x_crack.force.bot(icrackparticlemove,idim,ipath);
										x_crack.bridge.base.deltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.base.deltax(icrackparticlemove,idim,ipath);
										x_crack.bridge.adjusted.deltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.adjusted.deltax(icrackparticlemove,idim,ipath);
										x_crack.bridge.firsttimedeltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.firsttimedeltax(icrackparticlemove,idim,ipath);
										%(icrackparticlemove+1,idim,ipath)
										%(icrackparticlemove,idim,ipath)
										%=
									end
									x_crack.bridge.absforce(icrackparticlemove+1,ipath)=x_crack.bridge.absforce(icrackparticlemove,ipath);
									x_crack.bridge.isactive(icrackparticlemove+1,ipath)=x_crack.bridge.isactive(icrackparticlemove,ipath);
									x_crack.bridge.firsttimeactive(icrackparticlemove+1,ipath)=x_crack.bridge.firsttimeactive(icrackparticlemove,ipath);
									x_crack.bridge.adjusted.absdeltaxmax(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmax(icrackparticlemove,ipath);
									x_crack.bridge.base.absdeltax(icrackparticlemove+1,ipath)=x_crack.bridge.base.absdeltax(icrackparticlemove,ipath);
									x_crack.bridge.adjusted.absdeltax(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltax(icrackparticlemove,ipath);
									x_crack.bridge.adjusted.absdeltaxmaxi(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmaxi(icrackparticlemove,ipath);
									x_crack.bridge.kbase2(icrackparticlemove+1,ipath)=x_crack.bridge.kbase2(icrackparticlemove,ipath);
									x_crack.bridge.yieldforce2(icrackparticlemove+1,ipath)=x_crack.bridge.yieldforce2(icrackparticlemove,ipath);
									x_crack.bridge.deltai2(icrackparticlemove+1,ipath)=x_crack.bridge.deltai2(icrackparticlemove,ipath);
									x_crack.cohesivepoint(icrackparticlemove+1,ipath)=x_crack.cohesivepoint(icrackparticlemove,ipath);
								end
								
								%adding to the list here:
								for idim=1:2
									x_crack.center(1,idim,ipath)=x_crack.center(2,idim,ipath)+deltax_previous(idim);
									x_crack.top(1,idim,ipath)=x_crack.center(1,idim,ipath);
									x_crack.bot(1,idim,ipath)=x_crack.center(1,idim,ipath);
								end
							end
							x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
							break;
						end
					end
					% start of criterion evaluation of crack propagation
					propagationsignal=0;

					lambdamin=inf;
					thetamin=NaN;
					lambda1=zeros(ntestedangle,1);
					lambda2=zeros(ntestedangle,1);
					theta=zeros(ntestedangle,1);
					theta_crack=zeros(1,1);
					n=zeros(2,1);
					h=zeros(2,2,ntestedangle);
					Qacoustic=zeros(2,2,ntestedangle);
					for itestedangle=1:ntestedangle
						theta(itestedangle)=(itestedangle)/ntestedangle*2*pi;
						n(1)=cos(theta(itestedangle));
						n(2)=sin(theta(itestedangle));
						for idim1=1:2
						for idim2=1:2
						for idim3=1:2
						for idim4=1:2
							Qacoustic(idim2,idim3,itestedangle)=Qacoustic(idim2,idim3,itestedangle)+n(idim1)*AbeforeQ_tip(idim1,idim2,idim3,idim4)*n(idim4);
						end
						end
						end
						end
						[h_eig,lambda_eig]=eig(Qacoustic(:,:,itestedangle));
						h(:,:,itestedangle)=real(h_eig);
						lambda1(itestedangle)=real(lambda_eig(1,1));
						lambda2(itestedangle)=real(lambda_eig(2,2));
					end
					lambdamin=min([lambda1;lambda2]);
					if length(lambdamin)>1
						fprintf('%s',['length(lamdabmin)>1!' char(10)]);
						DUMMY=input_codegen('error 201004-1301 (this is bogus input)');
					end
					if lambdamin>=0
						theta_crack=NaN;
						propagationsignal=0;
					else
						propagationsignal=1;
						localminima1index.sizes=0;
						localminima1index.values=zeros(1,ntestedangle);
						localminima2index.sizes=0;
						localminima2index.values=zeros(1,ntestedangle);
						for itestedangle=1:ntestedangle
							if lambda1(itestedangle)<0 && lambda1(itestedangle)<=lambda1(mod((itestedangle-1)-1,ntestedangle)+1) && lambda1(i)<=lambda1(mod((itestedangle+1)-1,ntestedangle)+1)
								localminima1index.sizes=localminima1index.sizes+1;
								localminima1index.values(localminima1index.sizes)=itestedangle;
							end
							if lambda2(itestedangle)<0 && lambda2(itestedangle)<=lambda2(mod((itestedangle-1)-1,ntestedangle)+1) && lambda2(itestedangle)<=lambda2(mod((itestedangle+1)-1,ntestedangle)+1)
								localminima2index.sizes=localminima2index.sizes+1;
								localminima2index.values(localminima2index.sizes)=itestedangle;
							end
						end
						nldudxhl.sizes=localminima1index.sizes+localminima2index.sizes;
						nldudxhl.values=zeros(1,2*ntestedangle);
						h_localminima.sizes=localminima1index.sizes+localminima2index.sizes;
						h_localminima.values=zeros(2,2*ntestedangle);
						for ilocalminima=1:localminima1index.sizes
							n(1)=cos(theta(localminima1index.values(ilocalminima)));
							n(2)=sin(theta(localminima1index.values(ilocalminima)));
							nldudxhl.values(ilocalminima)=real(transpose(n)*dudx_tip*h(:,1,localminima1index.values(ilocalminima)));
							nldudxhl.sizes=ilocalminima;
							h_localminima.values(:,ilocalminima)=h(:,1,localminima1index.values(ilocalminima));
							h_localminima.sizes=ilocalminima;
						end
						for ilocalminima=1:localminima2index.sizes
							n(1)=cos(theta(localminima2index.values(ilocalminima)));
							n(2)=sin(theta(localminima2index.values(ilocalminima)));
							nldudxhl.values(ilocalminima+localminima1index.sizes)=real(transpose(n)*dudx_tip*h(:,2,localminima2index.values(ilocalminima)));
							nldudxhl.sizes=ilocalminima+localminima1index.sizes;
							h_localminima.values(:,ilocalminima+localminima1index.sizes)=h(:,2,localminima2index.values(ilocalminima));
							h_localminima.sizes=ilocalminima+localminima1index.sizes;
						end
						for ilocalminima=1:localminima1index.sizes
							localminimaindex.values(ilocalminima)=localminima1index.values(ilocalminima);
							localminimaindex.sizes=ilocalminima;
						end
						for ilocalminima=1:localminima2index.sizes
							localminimaindex.values(ilocalminima+localminima1index.sizes)=localminima2index.values(ilocalminima);
							localminimaindex.sizes=localminima1index.sizes+ilocalminima;
						end
						FindMaxnldudxhl=FindMax(nldudxhl.values(1:nldudxhl.sizes));
						crackindex=localminimaindex.values(FindMaxnldudxhl);
						thetamin=theta(crackindex);
						h_crackdecision=zeros(2,1);
						h_crackdecision(:,1)=h_localminima.values(:,FindMaxnldudxhl);
						theta_crack=mod(thetamin+pi/2+pi/2,pi)+pi/2;
					end
					% end of criterion evaluation of crack propagation
					% propagation signal designates whether crack should propagate or not
					if x_crack.terminatedprop(ipath,tip)==0 && propagationsignal==1
						crackextension=x_crack.spacing;
						if tip==1
							deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
						elseif tip==2
							deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
						end
						theta_crack_trial(1)=theta_crack;
						theta_crack_trial(2)=mod(theta_crack+pi,2*pi); %two possibilities for crack angle, 
						if (deltax_previous(1,1,1)*cos(theta_crack_trial(1))+deltax_previous(1,2,1)*sin(theta_crack_trial(1)))>0 % cos of theta_crack_trial with current crack tip trajectory
							theta_crack=theta_crack_trial(1);
						else
							theta_crack=theta_crack_trial(2);
						end
						if tip==1
							%STRENGTH EXCEEDING PROPAGATION
							x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+crackextension*cos(theta_crack);
							x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+crackextension*sin(theta_crack);
							for idim=1:2
								x_crack.top(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
								x_crack.bot(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
							end
							x_crack.cohesivepoint(icrackparticle+1,ipath)=1;
							x_crack.sequence.tipreg(ipath,tip)=1;

							x_crack_ghosttip(1,1)=x_crack.center(icrackparticle,1,ipath)+3*crackextension*cos(theta_crack);
							x_crack_ghosttip(1,2)=x_crack.center(icrackparticle,2,ipath)+3*crackextension*sin(theta_crack);
						elseif tip==2
							for icrackparticlemove=x_crack.nparticles(ipath):-1:1
								for idim=1:2
									x_crack.center(icrackparticlemove+1,idim,ipath)=x_crack.center(icrackparticlemove,idim,ipath);
									x_crack.top(icrackparticlemove+1,idim,ipath)=x_crack.top(icrackparticlemove,idim,ipath);
									x_crack.bot(icrackparticlemove+1,idim,ipath)=x_crack.bot(icrackparticlemove,idim,ipath);
									
									x_crack.force.top(icrackparticlemove+1,idim,ipath)=x_crack.force.top(icrackparticlemove,idim,ipath);
									x_crack.force.bot(icrackparticlemove+1,idim,ipath)=x_crack.force.bot(icrackparticlemove,idim,ipath);
									x_crack.bridge.base.deltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.base.deltax(icrackparticlemove,idim,ipath);
									x_crack.bridge.adjusted.deltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.adjusted.deltax(icrackparticlemove,idim,ipath);
									x_crack.bridge.firsttimedeltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.firsttimedeltax(icrackparticlemove,idim,ipath);
								end
								x_crack.bridge.absforce(icrackparticlemove+1,ipath)=x_crack.bridge.absforce(icrackparticlemove,ipath);
								x_crack.bridge.isactive(icrackparticlemove+1,ipath)=x_crack.bridge.isactive(icrackparticlemove,ipath);
								x_crack.bridge.firsttimeactive(icrackparticlemove+1,ipath)=x_crack.bridge.firsttimeactive(icrackparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltaxmax(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmax(icrackparticlemove,ipath);
								x_crack.bridge.base.absdeltax(icrackparticlemove+1,ipath)=x_crack.bridge.base.absdeltax(icrackparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltax(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltax(icrackparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltaxmaxi(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmaxi(icrackparticlemove,ipath);
								x_crack.bridge.kbase2(icrackparticlemove+1,ipath)=x_crack.bridge.kbase2(icrackparticlemove,ipath);
								x_crack.bridge.yieldforce2(icrackparticlemove+1,ipath)=x_crack.bridge.yieldforce2(icrackparticlemove,ipath);
								x_crack.bridge.deltai2(icrackparticlemove+1,ipath)=x_crack.bridge.deltai2(icrackparticlemove,ipath);
								x_crack.cohesivepoint(icrackparticlemove+1,ipath)=x_crack.cohesivepoint(icrackparticlemove,ipath);
							end
							x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+crackextension*cos(theta_crack);
							x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+crackextension*sin(theta_crack);
							for idim=1:2
								x_crack.top(1,idim,ipath)=x_crack.center(1,idim,ipath);
								x_crack.bot(1,idim,ipath)=x_crack.center(1,idim,ipath);
							end
							x_crack.cohesivepoint(1,ipath)=1;
							x_crack.sequence.tipreg(ipath,tip)=1;
							
							x_crack_ghosttip(1,1)=x_crack.center(2,1,ipath)+3*crackextension*cos(theta_crack);
							x_crack_ghosttip(1,2)=x_crack.center(2,2,ipath)+3*crackextension*sin(theta_crack);
						end
						if tip==1
							x1(1,1)=x_crack.center(icrackparticle,1,ipath);
							x1(1,2)=x_crack.center(icrackparticle,2,ipath);
						elseif tip==2
							x1(1,1)=x_crack.center(2,1,ipath);
							x1(1,2)=x_crack.center(2,2,ipath);
						end
						x2(1,1)=x_crack_ghosttip(1,1);
						x2(1,2)=x_crack_ghosttip(1,2);

						foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
						foundcrossing.icrackparticle3=zeros(1,200); %so not to clash with iparticle
						foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
						foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.
						
						for ipath2=1:x_crack.npaths
							for icrackparticle2=1:(x_crack.nparticles(ipath2)-1)
								if ipath2==ipath
									%icrackparticle: deals with the propagation, what's currently the particle as the tip
									%icrackparticle2: the loop for checking crack crossing
									if tip==1 && icrackparticle2>=icrackparticle-2
										continue;
									elseif tip==2 && icrackparticle2<=2
										continue;
									end
								end
								%start of crossing checks
								for dim=1:2
									x3(1,dim)=x_crack.center(icrackparticle2,dim,ipath2);
									x4(1,dim)=x_crack.center(icrackparticle2+1,dim,ipath2);
								end
								Area(1)=TriangleArea(x1,x2,x3);
								Area(2)=TriangleArea(x1,x2,x4);
								Area(3)=TriangleArea(x3,x4,x1);
								Area(4)=TriangleArea(x3,x4,x2);
								if (Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0) || (Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0)
									foundcrossing.size3=foundcrossing.size3+1;
									foundcrossing.ipath3(foundcrossing.size3)=ipath2;
									foundcrossing.icrackparticle3(foundcrossing.size3)=icrackparticle2;
									foundcrossing.ratio(foundcrossing.size3)=abs(Area(3))/(abs(Area(3))+abs(Area(4)));%ratio between 1-crossing distance to 1-2 distance
								end
								%end of crossing checks
							end
						end
						foundcrossing_ratio_min=2;
						for ifoundcrossing=1:foundcrossing.size3
							if foundcrossing.ratio(ifoundcrossing)<foundcrossing_ratio_min
								foundcrossing_ratio_min=foundcrossing.ratio(ifoundcrossing);
								x_crack.sequence.merge(ipath,tip)=foundcrossing.ipath3(ifoundcrossing);
							end
						end
						if foundcrossing.size3>0
							x_crack.terminatedprop(ipath,tip)=1;
							if tip==1
								x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+foundcrossing_ratio_min*3.1*crackextension*cos(theta_crack);
								x_crack.top(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.bot(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+foundcrossing_ratio_min*3.1*crackextension*sin(theta_crack);
								x_crack.top(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
								x_crack.bot(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
							elseif tip==2
								x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+foundcrossing_ratio_min*3.1*crackextension*cos(theta_crack);
								x_crack.top(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.bot(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+foundcrossing_ratio_min*3.1*crackextension*sin(theta_crack);
								x_crack.top(1,2,ipath)=x_crack.center(1,2,ipath);
								x_crack.bot(1,2,ipath)=x_crack.center(1,2,ipath);
							end
						end
						x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
					end
				end
			end
		end
		
		%{	
		%initiation starts below
		justcrackednodes=zeros(1,no);
		crackanglenodes=zeros(1,no);
		nfield=fieldnumber;
		mi_base=m_sp(1)*4;
		%elasticstrength=0.25; %define custom streel strength initiation here
		% steel strength already defined in propagation "subroutine"
		sigmamaxprincmaxperfy=0; %max of all nodes
		elasticstrength=elasticstrengthbase;
		if CasetoRun==186 || CasetoRun==193 || CasetoRun==194 || CasetoRun==192 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195
			%initiation denied
			elasticstrength=1e99;
			elasticstrengthbase=1e99;
		end
		for io=1:no
			if uncrackable_si(io,1)>0.125
				continue;
			end
			if CasetoRun==174
				if nmass_si(io,1)>0
					elasticstrength=elasticstrengthbase*(mEfactor_si(io,1)/nmass_si(io,1));
				else
					elasticstrength=elasticstrengthbase;
				end
			end
			%elasticstrength=elasticstrengthbase; %turned off for now
			
			for ifield=1:1
				sigmamaxprinc=(s_si(io,1,ifield)+s_si(io,2,ifield))/2+sqrt(((s_si(io,1,ifield)-s_si(io,2,ifield))/2)^2+(s_si(io,3,ifield))^2);
				sigmamaxprincmaxperfy=max(sigmamaxprincmaxperfy,sigmamaxprinc/elasticstrength);
				if sigmamaxprinc>k_dumpresult*elasticstrength
					dumpresult=1;
				end
				if nmass_si(io,1)>=0.125*mi_base && sigmamaxprinc>elasticstrength %nmass treshold so crack doesnt initiate in thin air
					justcrackednodes(io)=1;
					crackanglenodes(io)=0.5*(pi-reliableatan((s_si(io,1,ifield)-s_si(io,2,ifield))/2,-s_si(io,3,ifield)));
				end
			end
		end
		fprintf('%s',['marker #643b' char(10)]);
		if sum(justcrackednodes)>0
			justcrackedlist=zeros(sum(justcrackednodes),1);
			justcrackedcounter=0;
			for io=1:no
				if justcrackednodes(io)
					justcrackedcounter=justcrackedcounter+1;
					justcrackedlist(justcrackedcounter)=io;
				end
			end
			
			%justcrackedlist=CrackParticleClustering_nodes(LOC,1.5*le(1),justcrackedlist);
			fprintf('%s',['marker #702' char(10)]);
			%ntestedangle=size(Qacoustic{justcrackedlist{1}(1)},3);
			ntestedangle=36;
			fprintf('%s',['marker #703' char(10)]);
			theta=zeros(ntestedangle,1);
			fprintf('%s',['marker #704' char(10)]);
			errorntestedangle=36*1*1*1;
			error=zeros(1,errorntestedangle);
			
			x_justcrackedcenter=zeros(2,1);
			for iro=1:length(justcrackedlist)
				%justcrackedcounter=length(justcrackedlist{iro});	
				x_justcrackedcenter(1)=LOC(justcrackedlist(iro),1);
				x_justcrackedcenter(2)=LOC(justcrackedlist(iro),2);
				%x_justcrackedcenter(1)=sum(LOC(justcrackedlist{iro},1))/justcrackedcounter;
				%x_justcrackedcenter(2)=sum(LOC(justcrackedlist{iro},2))/justcrackedcounter;
				%{
				for i=1:errorntestedangle
					theta(i)=(i-1)/36*1*1*1*pi;
					error(i)=0;
					for spc=1:justcrackedcounter
						error(i)=error(i)+(mod(thetacrack(justcrackedlist{iro}(spc))-theta(i)+pi/2,pi)-pi/2)^2;
					end
				end
				%}
				thetajustcrackedcenter=crackanglenodes(justcrackedlist(iro));
				%thetajustcrackedcenter=theta(FindMin(error));
				%considered=ones(x_crack.npaths,2);
				%distancelist=zeros(x_crack.npaths,2);
				%thetapropagationlist=zeros(x_crack.npaths,2);
				%n_nairncrack0=0;
				%n_nairncrack1=0;
				
				intheprevention=0;
				preventiondistance=1.5*le(1);
				preventionangle=pi/4;
				for icrackpath=1:x_crack.npaths;
					for spcrack=1:(x_crack.nparticles(icrackpath)-1)
						vector1a=[(x_justcrackedcenter(1)-x_crack.center(spcrack,1,icrackpath));(x_justcrackedcenter(2)-x_crack.center(spcrack,2,icrackpath))];
						vector1b=[(x_justcrackedcenter(1)-x_crack.center(spcrack+1,1,icrackpath));(x_justcrackedcenter(2)-x_crack.center(spcrack+1,2,icrackpath))];
						distance1a=sqrt(dot(vector1a,vector1a));
						distance1b=sqrt(dot(vector1b,vector1b));
						
						distance1a_old=sqrt((x_justcrackedcenter(1)-x_crack.center(spcrack,1,icrackpath))^2+(x_justcrackedcenter(2)-x_crack.center(spcrack,2,icrackpath))^2);
						distance1b_old=sqrt((x_justcrackedcenter(1)-x_crack.center(spcrack+1,1,icrackpath))^2+(x_justcrackedcenter(2)-x_crack.center(spcrack+1,2,icrackpath))^2);
						
						distance1=min([distance1a distance1b]);
						
						area2=abs(TriangleArea(x_justcrackedcenter,x_crack.center(spcrack,:,icrackpath),x_crack.center(spcrack+1,:,icrackpath)));
						
						inbetween2vector=[(x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath));(x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath))];
						
						inbetween2=sqrt(dot(inbetween2vector,inbetween2vector));
						
						inbetween2_old=sqrt((x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath))^2+(x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath))^2);
						distance2=area2/inbetween2;
						
						signcos1=dot(vector1a,inbetween2vector);
						signcos2=dot(vector1b,inbetween2vector);
						
						if signcos1*signcos2>0
							distance=distance1;
						else
							distance=distance2;
						end
						
						if distance<preventiondistance
							thetanairncrack=reliableatan(x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath),x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath));
							
							absdeltatheta=abs(mod(thetanairncrack-thetajustcrackedcenter+pi/2,pi)-pi/2);
							
							if absdeltatheta<preventionangle
								intheprevention=1;
							end
						end
						if intheprevention==1
							break;
						end
					end
					if intheprevention==1
						break;
					end
				end
				if intheprevention==0
					thetainitiate=mod(thetajustcrackedcenter-pi,pi)+pi; %always pointing down, pi<theta<2*pi
					icrackpath=x_crack.npaths+1;
					x_crack.npaths=x_crack.npaths+1;
					if CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==194
						x_crack.nparticles(icrackpath)=3;
						x_crack.center(3,2,icrackpath)=x_justcrackedcenter(2)+le(1)/2*sin(thetainitiate); %assuming le(1)=le(2);
						x_crack.center(3,1,icrackpath)=x_justcrackedcenter(1)+le(1)/2*cos(thetainitiate);
						x_crack.center(1,2,icrackpath)=x_justcrackedcenter(2)-le(1)/2*sin(thetainitiate);
						x_crack.center(1,1,icrackpath)=x_justcrackedcenter(1)-le(1)/2*cos(thetainitiate);
						x_crack.center(2,2,icrackpath)=x_justcrackedcenter(2);
						x_crack.center(2,1,icrackpath)=x_justcrackedcenter(1);
						x_crack.cohesivepath(icrackpath)=1;
						x_crack.cohesivepoint(1,icrackpath)=1;
						x_crack.cohesivepoint(2,icrackpath)=1;
						x_crack.cohesivepoint(3,icrackpath)=1;
					else
						x_crack.nparticles(icrackpath)=2;
						x_crack.center(2,2,icrackpath)=x_justcrackedcenter(2)+le(1)/2*sin(thetainitiate); %assuming le(1)=le(2);
						x_crack.center(2,1,icrackpath)=x_justcrackedcenter(1)+le(1)/2*cos(thetainitiate);
						x_crack.center(1,2,icrackpath)=x_justcrackedcenter(2)-le(1)/2*sin(thetainitiate);
						x_crack.center(1,1,icrackpath)=x_justcrackedcenter(1)-le(1)/2*cos(thetainitiate);
					end
					%fprintf('%s',['>>line 8967: size(x_crackcenter' int2txt(icrackpath) '},1)=' int2txt(x_crack.nparticles(icrackpath)) char(10)]);
					%fprintf('%s',['>>line 8968: size(x_cracktop{' int2txt(icrackpath) '},1)=' int2txt(size(x_cracktop{icrackpath},1)) char(10)]);
					%{
					for i=1:size(x_cracktop{icrackpath},1)
						for j=1:size(x_cracktop{icrackpath},2)
							%fprintf('%s',['>>line 8973: x_cracktop{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_cracktop{icrackpath}(i,j)) char(10)]);
						end
					end
					for i=1:size(x_crackbot{icrackpath},1)
						for j=1:size(x_crackbot{icrackpath},2)
							%fprintf('%s',['>>line 8980: x_crackbot{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackbot{icrackpath}(i,j)) char(10)]);
						end
					end
					for i=1:size(x_crackcenter{icrackpath},1)
						for j=1:size(x_crackcenter{icrackpath},2)
							%fprintf('%s',['>>line 8987: x_crackcenter{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackcenter{icrackpath}(i,j)) char(10)]);
						end
					end
					%}
					for i=1:x_crack.nparticles(icrackpath)
						for j=1:2
							%fprintf('%s',['>>line 8973: x_crackcenter{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackcenter{icrackpath}(i,j)) char(10)]);
							x_crack.top(i,j,icrackpath)=x_crack.center(i,j,icrackpath);
							x_crack.bot(i,j,icrackpath)=x_crack.center(i,j,icrackpath);
						end
					end
					%shit below
					%x_cracktop{icrackpath}=x_crackcenter{icrackpath};
					%x_crackbot{icrackpath}=x_crackcenter{icrackpath};
					%shit above
				end
				%soundplay
				1;
			end
		end
		%}
	elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==194
		%crack propagation of 163
		% of 139 with initiation
		%node centric propagation
		%no gauss propagation
		no=niCount;
		%s_tip(ipath,dim,itip);
		s_tip=zeros(x_crack.npaths,3,2);
		s_tip_K1=zeros(x_crack.npaths,3,2); %ncrackpaths; dimension (x and y); which tip
		deltax_previous=zeros(1,2,1);
		theta_crack_trial=zeros(1,2);
		deltatheta_crack=zeros(1,2);
		s_tip_dump=zeros(2*x_crack.npaths,3);
		d_tip_dump=zeros(2*x_crack.npaths,8);
		d_LOC_tip_dump=zeros(2*x_crack.npaths,8);
		s_tip_K1_dump=zeros(2*x_crack.npaths,3);
		u_tip_dump=zeros(2*x_crack.npaths,8);
		x_tip_dump=zeros(2*x_crack.npaths,2);
		r_propdirweighted_dump=zeros(2*x_crack.npaths,2);
		K1_maxradius=3*le(1);
		K1_estimate=zeros(1,2);
		K1_distance=zeros(1,2);
		r_propdirweighted=zeros(x_crack.npaths,2,2); %crackpath num, dimension, which tip
		sigma_maxprinc_magnitude=0;
		r_propdircompliment=zeros(1,2);
		a_transform=zeros(2,2);
		s_tip_tensor=zeros(2,2);
		s_tip_tensor_transformed=zeros(2,2);
		LOC_avg=zeros(1,2);
		nio_designator=zeros(1,4);
		d_natural=zeros(8,1);
		delta_x=zeros(1,2);
		epsilon_tip=zeros(3,1);
		x_crack_ghosttip=zeros(1,2);
		x1=zeros(1,2);
		x2=zeros(1,2);
		x3=zeros(1,2);
		x4=zeros(1,2);
		Area=zeros(1,4);
		foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
		foundcrossing.icrackparticle3=zeros(1,200); %so not to clash with iparticle
		foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
		foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.
		%nio_designator(1): in the natural coordinates, node 1 associates with which nio?
		%nio_designator(2): in the natural coordinates, node 2 associates with which nio?
		%nio_designator(3): in the natural coordinates, node 3 associates with which nio?
		%nio_designator(4): in the natural coordinates, node 4 associates with which nio?
		
		io_natural_cross_before=0;
		io_natural_cross_after=0;
		io_natural_sides=zeros(1,4);
		
		elasticstrength=0.0125; %to stop coder whining
		if CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==194
			elasticstrength=0.0125;
			k_dumpresult=0.99;
		elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==183 || CasetoRun==184
			elasticstrength=1e10; %cracking denied
			k_dumpresult=0.99;
		elseif CasetoRun==185
			elasticstrength=0.0125; %cracking denied
			k_dumpresult=0.99;
		elseif CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==194
			elasticstrength=25;
			k_dumpresult=0.9;
		end
		elasticstrengthbase=elasticstrength;
		
		%r_propdirweighted=zeros(1,2); %dimension only
		%allowpropagation=1;
		for tip=1:2
			%tip=1: particle of highest index
			%tip=2: particle of lowerst index
			for ipath=1:x_crack.npaths
				if x_crack.terminatedprop(ipath,tip)==0
					if tip==1
						icrackparticle=x_crack.nparticles(ipath);
					elseif tip==2
						icrackparticle=1;
					end
					LOC_avg=zeros(1,2);
					for nio=1:4
						io=CONNECT_crack.center.values(icrackparticle,nio,ipath);
						for dim=1:2
							LOC_avg(1,dim)=LOC_avg(1,dim)+LOC(io,dim);
						end
					end
					for dim=1:2
						LOC_avg(1,dim)=LOC_avg(1,dim)/4;
					end
					for nio=1:4
						io=CONNECT_crack.center.values(icrackparticle,nio,ipath);
						if LOC(io,1)<LOC_avg(1,1)
							if LOC(io,2)<LOC_avg(1,2)
								nio_designator(1)=nio;
							elseif LOC(io,2)>LOC_avg(1,2) %can just write else, but this way it's more readable. also equal is not possible, so I left it out
								nio_designator(4)=nio;
							end
						elseif LOC(io,1)>LOC_avg(1,1) %same drill, trying to improve readability
							if LOC(io,2)<LOC_avg(1,2)
								nio_designator(2)=nio;
							elseif LOC(io,2)>LOC_avg(1,2)
								nio_designator(3)=nio;
							end
						end
					end
					%allowpropagation=1;
					tip_crackability=0;
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						tip_crackability=tip_crackability+uncrackable_si_comb(io)*N_crack.center(1,nio_outside,icrackparticle,ipath);
					end
					%finding where the crack cuts the cell
					for itrial=1:x_crack.nparticles(ipath)-1
						io_natural_cross_before=0;
						io_natural_cross_after=0;
						io_natural_sides=zeros(1,4);
						if tip==1
							x1(1,1)=x_crack.center(icrackparticle-(itrial-1),1,ipath);
							x1(1,2)=x_crack.center(icrackparticle-(itrial-1),2,ipath);
							x2(1,1)=x_crack.center(icrackparticle-itrial,1,ipath);
							x2(1,2)=x_crack.center(icrackparticle-itrial,2,ipath);
						elseif tip==2
							x1(1,1)=x_crack.center(1+(itrial-1),1,ipath);
							x1(1,2)=x_crack.center(1+(itrial-1),2,ipath);
							x2(1,1)=x_crack.center(1+itrial,1,ipath);
							x2(1,2)=x_crack.center(1+itrial,2,ipath);
						end
											
						for io_natural=1:4
							nio_outside=nio_designator(io_natural);
							io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
							x3(1,1)=LOC(io,1);
							x3(1,2)=LOC(io,2);
							nio_outside=nio_designator(mod(io_natural+1-1,4)+1);
							io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
							x4(1,1)=LOC(io,1);
							x4(1,2)=LOC(io,2);
							Area(1)=TriangleArea(x1,x2,x3);
							Area(2)=TriangleArea(x1,x2,x4);
							Area(3)=TriangleArea(x3,x4,x1);
							Area(4)=TriangleArea(x3,x4,x2);
							if (Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0) || (Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0)
								%before and before-1: top(2) for tip==1, bottom(3) for tip==2
								%after and after+1: bottom(3) for tip==1, top(2) for tip==1
								io_natural_cross_before=io_natural;
								if tip==1
									io_natural_sides(io_natural_cross_before)=2;
									io_natural_sides(mod(io_natural_cross_before-1-1,4)+1)=2;
								elseif tip==2
									io_natural_sides(io_natural_cross_before)=3;
									io_natural_sides(mod(io_natural_cross_before-1-1,4)+1)=3;
								end
								
								io_natural_cross_after=mod(io_natural+1-1,4)+1;
								if tip==1
									io_natural_sides(io_natural_cross_after)=3;							
									io_natural_sides(mod(io_natural_cross_after+1-1,4)+1)=3;
								elseif tip==2
									io_natural_sides(io_natural_cross_after)=2;
									io_natural_sides(mod(io_natural_cross_after+1-1,4)+1)=2;
								end
								break;
							end
						end
						if io_natural_cross_before>0
							break;
						end
					end
					x_crack.Efactor(ipath,tip)=0;
					x_crack.mEfactor(ipath,tip)=0;
					x_crack.mass(ipath,tip)=0;
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						if CasetoRun==174
							x_crack.mEfactor(ipath,tip)=x_crack.mEfactor(ipath,tip)+N_crack.center(1,nio_outside,icrackparticle,ipath)*mEfactor_si(io,1);
							x_crack.mass(ipath,tip)=x_crack.mass(ipath,tip)+N_crack.center(1,nio_outside,icrackparticle,ipath)*nmass_si(io,1);
						end
						for dim=1:2
							index=2*(io_natural-1)+dim;
							if io_natural_sides(io_natural)==2
								d_natural(index,1)=u_si(io,dim,TheFieldSplit_cracktop{ipath}(nio_outside,icrackparticle));
							elseif io_natural_sides(io_natural)==3
								d_natural(index,1)=u_si(io,dim,TheFieldSplit_crackbot{ipath}(nio_outside,icrackparticle));
							else
								d_natural(index,1)=u_si_comb(io,dim);
							end
						end
						%if uncrackable_si_comb(io)>0.25
						if tip_crackability>0.125
							x_crack.terminatedprop(ipath,tip)=1;
							break;
						elseif sum(nmass_si(io,:))<=0
							%allowpropagation=0;
							x_crack.terminatedprop(ipath,tip)=1;
							x_crack.openedgetip(ipath,tip)=1;
							if tip==1
								deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
								x_crack.cohesivepoint(icrackparticle,ipath)=0;
							elseif tip==2
								deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
								x_crack.cohesivepoint(1,ipath)=0;
							end
							if tip==1
								%CLEAR EDGE EXTENSION
								%might need idim=1:2 loop, but don't touch if still works OK?
								%did it anyway
								
								% no shift here, just adding to the list
								for idim=1:2
									x_crack.center(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle,idim,ipath)+deltax_previous(idim);
									x_crack.top(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
									x_crack.bot(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
								end
							elseif tip==2
								% shift here
								
								%shift loop below:
								for icrackparticlemove=x_crack.nparticles(ipath):-1:1
									for idim=1:2
										x_crack.center(icrackparticlemove+1,idim,ipath)=x_crack.center(icrackparticlemove,idim,ipath);
										x_crack.top(icrackparticlemove+1,idim,ipath)=x_crack.top(icrackparticlemove,idim,ipath);
										x_crack.bot(icrackparticlemove+1,idim,ipath)=x_crack.bot(icrackparticlemove,idim,ipath);
										
										
										x_crack.force.top(icrackparticlemove+1,idim,ipath)=x_crack.force.top(icrackparticlemove,idim,ipath);
										x_crack.force.bot(icrackparticlemove+1,idim,ipath)=x_crack.force.bot(icrackparticlemove,idim,ipath);
										x_crack.bridge.base.deltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.base.deltax(icrackparticlemove,idim,ipath);
										x_crack.bridge.adjusted.deltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.adjusted.deltax(icrackparticlemove,idim,ipath);
										x_crack.bridge.firsttimedeltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.firsttimedeltax(icrackparticlemove,idim,ipath);
										%(icrackparticlemove+1,idim,ipath)
										%(icrackparticlemove,idim,ipath)
										%=
									end
									x_crack.bridge.absforce(icrackparticlemove+1,ipath)=x_crack.bridge.absforce(icrackparticlemove,ipath);
									x_crack.bridge.isactive(icrackparticlemove+1,ipath)=x_crack.bridge.isactive(icrackparticlemove,ipath);
									x_crack.bridge.firsttimeactive(icrackparticlemove+1,ipath)=x_crack.bridge.firsttimeactive(icrackparticlemove,ipath);
									x_crack.bridge.adjusted.absdeltaxmax(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmax(icrackparticlemove,ipath);
									x_crack.bridge.base.absdeltax(icrackparticlemove+1,ipath)=x_crack.bridge.base.absdeltax(icrackparticlemove,ipath);
									x_crack.bridge.adjusted.absdeltax(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltax(icrackparticlemove,ipath);
									x_crack.bridge.adjusted.absdeltaxmaxi(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmaxi(icrackparticlemove,ipath);
									x_crack.bridge.kbase2(icrackparticlemove+1,ipath)=x_crack.bridge.kbase2(icrackparticlemove,ipath);
									x_crack.bridge.yieldforce2(icrackparticlemove+1,ipath)=x_crack.bridge.yieldforce2(icrackparticlemove,ipath);
									x_crack.bridge.deltai2(icrackparticlemove+1,ipath)=x_crack.bridge.deltai2(icrackparticlemove,ipath);
									x_crack.cohesivepoint(icrackparticlemove+1,ipath)=x_crack.cohesivepoint(icrackparticlemove,ipath);
								end
								
								%adding to the list here:
								for idim=1:2
									x_crack.center(1,idim,ipath)=x_crack.center(2,idim,ipath)+deltax_previous(idim);
									x_crack.top(1,idim,ipath)=x_crack.center(1,idim,ipath);
									x_crack.bot(1,idim,ipath)=x_crack.center(1,idim,ipath);
								end
							end
							x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
							break;
							
						end
					end
					
					if CasetoRun==174
						if x_crack.mass(ipath,tip)>0 && x_crack.mEfactor(ipath,tip)>0
							x_crack.Efactor(ipath,tip)=x_crack.mEfactor(ipath,tip)/x_crack.mass(ipath,tip);
							fprintf('%s',['ipath=' int2txt(ipath) '; tip=' int2txt(tip) '; x_crack.Efactor(ipath,tip)=' float2scitxt(5,x_crack.Efactor(ipath,tip)) char(10)]);
							1;
						else
							fprintf('%s',['ipath=' int2txt(ipath) '; tip=' int2txt(tip) '; x_crack.Efactor(ipath,tip)=default (1)' char(10)]);
							x_crack.Efactor(ipath,tip)=1;
						end
						elasticstrength=elasticstrengthbase*x_crack.Efactor(ipath,tip);
						%elasticstrength=elasticstrengthbase; %turned off for now
					end
					
					a=le(1)/2;
					b=le(2)/2;
					
					for dim=1:2
						delta_x(dim)=x_crack.center(icrackparticle,dim,ipath)-LOC_avg(1,dim);
					end
					
					xi=delta_x(1)/a;
					eta=delta_x(2)/b;
					
					B=1/4*[(-1+eta)/a 0 (1-eta)/a 0 (1+eta)/a 0 (-1-eta)/a 0;
							0 (-1+xi)/b 0 (-1-xi)/b 0 (1+xi)/b 0 (1-xi)/b;
							(-1+xi)/b (-1+eta)/a (-1-xi)/b (1-eta)/a (1+xi)/b (1+eta)/a (1-xi)/b (-1-eta)/a];
					
					epsilon_tip=B*d_natural;
					%tempmarker5

					D=E/((1+nu)*(1-2*nu))*[1-nu nu 0;nu 1-nu 0;0 0 (1-2*nu)];
					
					s_tip_temp=D*epsilon_tip;
					
					for idim=1:3
						s_tip(ipath,idim,tip)=s_tip_temp(idim,1);
					end
					for idim=1:3
						s_tip_dump(2*(ipath-1)+tip,idim)=s_tip(ipath,idim,tip);
						s_tip_K1_dump(2*(ipath-1)+tip,idim)=s_tip_K1(ipath,idim,tip);
					end
					for idim=1:8
						d_tip_dump(2*(ipath-1)+tip,idim)=d_natural(idim,1);
						io_natural=ceil(idim/2);
						xydim=mod(idim-1,2)+1;
						d_LOC_tip_dump(2*(ipath-1)+tip,idim)=LOC(CONNECT_crack.center.values(icrackparticle,nio_designator(io_natural),ipath),xydim);;
					end
					for idim=1:2
						x_tip_dump(2*(ipath-1)+tip,idim)=x_crack.center(icrackparticle,idim,ipath);
					end
					s_tip_max=(s_tip(ipath,1,tip)+s_tip(ipath,2,tip))/2+sqrt( ((s_tip(ipath,1,tip)-s_tip(ipath,2,tip))/2)^2 + (s_tip(ipath,3,tip))^2 ); %calculate principal stress
					
					if s_tip_max>k_dumpresult*elasticstrength
						dumpresult=1;
					end
					x_crack.tipcrackratio(ipath,tip)=s_tip_max/elasticstrength;
					x_crack.acctipcrackratio(ipath,tip)=max(x_crack.acctipcrackratio(ipath,tip),x_crack.tipcrackratio(ipath,tip));
					if x_crack.terminatedprop(ipath,tip)==0 && s_tip_max>elasticstrength
					%if s_tip_max>elasticstrength
						if ipath==1 && x_crack.nparticles(ipath)>=10
							1;
						end
						theta_crack=0.5*(pi-reliableatan((s_tip(ipath,1,tip)-s_tip(ipath,2,tip))/2,-s_tip(ipath,3,tip)));
						if CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==194
							crackextension=x_crack.spacing;
						else
							crackextension=le(1)/2;
						end
						if tip==1
							deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
						elseif tip==2
							deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
						end
						%theta_previous=reliableatan(deltax_previous(1,1,1),deltax_previous(1,2,1));
						theta_crack_trial(1)=theta_crack;
						theta_crack_trial(2)=mod(theta_crack+pi,2*pi); %two possibilities for crack angle, 
						if (deltax_previous(1,1,1)*cos(theta_crack_trial(1))+deltax_previous(1,2,1)*sin(theta_crack_trial(1)))>0 % cos of theta_crack_trial with current crack tip trajectory
							theta_crack=theta_crack_trial(1);
						else
							theta_crack=theta_crack_trial(2);
						end
						if tip==1
							%STRENGTH EXCEEDING PROPAGATION
							x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+crackextension*cos(theta_crack);
							x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+crackextension*sin(theta_crack);
							for idim=1:2
								x_crack.top(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
								x_crack.bot(icrackparticle+1,idim,ipath)=x_crack.center(icrackparticle+1,idim,ipath);
							end
							x_crack.cohesivepoint(icrackparticle+1,ipath)=1;
							x_crack.sequence.tipreg(ipath,tip)=1;

							x_crack_ghosttip(1,1)=x_crack.center(icrackparticle,1,ipath)+3*crackextension*cos(theta_crack);
							x_crack_ghosttip(1,2)=x_crack.center(icrackparticle,2,ipath)+3*crackextension*sin(theta_crack);
						elseif tip==2
							for icrackparticlemove=x_crack.nparticles(ipath):-1:1
								for idim=1:2
									x_crack.center(icrackparticlemove+1,idim,ipath)=x_crack.center(icrackparticlemove,idim,ipath);
									x_crack.top(icrackparticlemove+1,idim,ipath)=x_crack.top(icrackparticlemove,idim,ipath);
									x_crack.bot(icrackparticlemove+1,idim,ipath)=x_crack.bot(icrackparticlemove,idim,ipath);
									
									x_crack.force.top(icrackparticlemove+1,idim,ipath)=x_crack.force.top(icrackparticlemove,idim,ipath);
									x_crack.force.bot(icrackparticlemove+1,idim,ipath)=x_crack.force.bot(icrackparticlemove,idim,ipath);
									x_crack.bridge.base.deltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.base.deltax(icrackparticlemove,idim,ipath);
									x_crack.bridge.adjusted.deltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.adjusted.deltax(icrackparticlemove,idim,ipath);
									x_crack.bridge.firsttimedeltax(icrackparticlemove+1,idim,ipath)=x_crack.bridge.firsttimedeltax(icrackparticlemove,idim,ipath);
								end
								x_crack.bridge.absforce(icrackparticlemove+1,ipath)=x_crack.bridge.absforce(icrackparticlemove,ipath);
								x_crack.bridge.isactive(icrackparticlemove+1,ipath)=x_crack.bridge.isactive(icrackparticlemove,ipath);
								x_crack.bridge.firsttimeactive(icrackparticlemove+1,ipath)=x_crack.bridge.firsttimeactive(icrackparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltaxmax(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmax(icrackparticlemove,ipath);
								x_crack.bridge.base.absdeltax(icrackparticlemove+1,ipath)=x_crack.bridge.base.absdeltax(icrackparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltax(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltax(icrackparticlemove,ipath);
								x_crack.bridge.adjusted.absdeltaxmaxi(icrackparticlemove+1,ipath)=x_crack.bridge.adjusted.absdeltaxmaxi(icrackparticlemove,ipath);
								x_crack.bridge.kbase2(icrackparticlemove+1,ipath)=x_crack.bridge.kbase2(icrackparticlemove,ipath);
								x_crack.bridge.yieldforce2(icrackparticlemove+1,ipath)=x_crack.bridge.yieldforce2(icrackparticlemove,ipath);
								x_crack.bridge.deltai2(icrackparticlemove+1,ipath)=x_crack.bridge.deltai2(icrackparticlemove,ipath);
								x_crack.cohesivepoint(icrackparticlemove+1,ipath)=x_crack.cohesivepoint(icrackparticlemove,ipath);
							end
							x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+crackextension*cos(theta_crack);
							x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+crackextension*sin(theta_crack);
							for idim=1:2
								x_crack.top(1,idim,ipath)=x_crack.center(1,idim,ipath);
								x_crack.bot(1,idim,ipath)=x_crack.center(1,idim,ipath);
							end
							x_crack.cohesivepoint(1,ipath)=1;
							x_crack.sequence.tipreg(ipath,tip)=1;
							
							x_crack_ghosttip(1,1)=x_crack.center(2,1,ipath)+3*crackextension*cos(theta_crack);
							x_crack_ghosttip(1,2)=x_crack.center(2,2,ipath)+3*crackextension*sin(theta_crack);
						end
						if tip==1
							x1(1,1)=x_crack.center(icrackparticle,1,ipath);
							x1(1,2)=x_crack.center(icrackparticle,2,ipath);
						elseif tip==2
							x1(1,1)=x_crack.center(2,1,ipath);
							x1(1,2)=x_crack.center(2,2,ipath);
						end
						x2(1,1)=x_crack_ghosttip(1,1);
						x2(1,2)=x_crack_ghosttip(1,2);

						foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
						foundcrossing.icrackparticle3=zeros(1,200); %so not to clash with iparticle
						foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
						foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.
						
						for ipath2=1:x_crack.npaths
							for icrackparticle2=1:(x_crack.nparticles(ipath2)-1)
								if ipath2==ipath
									%icrackparticle: deals with the propagation, what's currently the particle as the tip
									%icrackparticle2: the loop for checking crack crossing
									if tip==1 && icrackparticle2>=icrackparticle-2
										continue;
									elseif tip==2 && icrackparticle2<=2
										continue;
									end
								end
								%start of crossing checks
								for dim=1:2
									x3(1,dim)=x_crack.center(icrackparticle2,dim,ipath2);
									x4(1,dim)=x_crack.center(icrackparticle2+1,dim,ipath2);
								end
								Area(1)=TriangleArea(x1,x2,x3);
								Area(2)=TriangleArea(x1,x2,x4);
								Area(3)=TriangleArea(x3,x4,x1);
								Area(4)=TriangleArea(x3,x4,x2);
								if (Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0) || (Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0)
									foundcrossing.size3=foundcrossing.size3+1;
									foundcrossing.ipath3(foundcrossing.size3)=ipath2;
									foundcrossing.icrackparticle3(foundcrossing.size3)=icrackparticle2;
									foundcrossing.ratio(foundcrossing.size3)=abs(Area(3))/(abs(Area(3))+abs(Area(4)));%ratio between 1-crossing distance to 1-2 distance
								end
								%end of crossing checks
							end
						end
						foundcrossing_ratio_min=2;
						for ifoundcrossing=1:foundcrossing.size3
							if foundcrossing.ratio(ifoundcrossing)<foundcrossing_ratio_min
								foundcrossing_ratio_min=foundcrossing.ratio(ifoundcrossing);
								x_crack.sequence.merge(ipath,tip)=foundcrossing.ipath3(ifoundcrossing);
							end
						end
						if foundcrossing.size3>0
							x_crack.terminatedprop(ipath,tip)=1;
							if tip==1
								x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+foundcrossing_ratio_min*3.1*crackextension*cos(theta_crack);
								x_crack.top(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.bot(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+foundcrossing_ratio_min*3.1*crackextension*sin(theta_crack);
								x_crack.top(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
								x_crack.bot(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
							elseif tip==2
								x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+foundcrossing_ratio_min*3.1*crackextension*cos(theta_crack);
								x_crack.top(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.bot(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+foundcrossing_ratio_min*3.1*crackextension*sin(theta_crack);
								x_crack.top(1,2,ipath)=x_crack.center(1,2,ipath);
								x_crack.bot(1,2,ipath)=x_crack.center(1,2,ipath);
							end
						end
						x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
					end
				end
			end
		end
		
		
		%initiation starts below
		justcrackednodes=zeros(1,no);
		crackanglenodes=zeros(1,no);
		nfield=fieldnumber;
		mi_base=m_sp(1)*4;
		%elasticstrength=0.25; %define custom streel strength initiation here
		% steel strength already defined in propagation "subroutine"
		sigmamaxprincmaxperfy=0; %max of all nodes
		elasticstrength=elasticstrengthbase;
		if CasetoRun==186 || CasetoRun==193 || CasetoRun==194 || CasetoRun==192 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195
			%initiation denied
			elasticstrength=1e99;
			elasticstrengthbase=1e99;
		end
		for io=1:no
			if uncrackable_si(io,1)>0.125
				continue;
			end
			if CasetoRun==174
				if nmass_si(io,1)>0
					elasticstrength=elasticstrengthbase*(mEfactor_si(io,1)/nmass_si(io,1));
				else
					elasticstrength=elasticstrengthbase;
				end
			end
			%elasticstrength=elasticstrengthbase; %turned off for now
			
			for ifield=1:1
				sigmamaxprinc=(s_si(io,1,ifield)+s_si(io,2,ifield))/2+sqrt(((s_si(io,1,ifield)-s_si(io,2,ifield))/2)^2+(s_si(io,3,ifield))^2);
				sigmamaxprincmaxperfy=max(sigmamaxprincmaxperfy,sigmamaxprinc/elasticstrength);
				if sigmamaxprinc>k_dumpresult*elasticstrength
					dumpresult=1;
				end
				if nmass_si(io,1)>=0.125*mi_base && sigmamaxprinc>elasticstrength %nmass treshold so crack doesnt initiate in thin air
					justcrackednodes(io)=1;
					crackanglenodes(io)=0.5*(pi-reliableatan((s_si(io,1,ifield)-s_si(io,2,ifield))/2,-s_si(io,3,ifield)));
				end
			end
		end
		fprintf('%s',['marker #643b' char(10)]);
		if sum(justcrackednodes)>0
			justcrackedlist=zeros(sum(justcrackednodes),1);
			justcrackedcounter=0;
			for io=1:no
				if justcrackednodes(io)
					justcrackedcounter=justcrackedcounter+1;
					justcrackedlist(justcrackedcounter)=io;
				end
			end
			
			%justcrackedlist=CrackParticleClustering_nodes(LOC,1.5*le(1),justcrackedlist);
			fprintf('%s',['marker #702' char(10)]);
			%ntestedangle=size(Qacoustic{justcrackedlist{1}(1)},3);
			ntestedangle=36;
			fprintf('%s',['marker #703' char(10)]);
			theta=zeros(ntestedangle,1);
			fprintf('%s',['marker #704' char(10)]);
			errorntestedangle=36*1*1*1;
			error=zeros(1,errorntestedangle);
			
			x_justcrackedcenter=zeros(2,1);
			for iro=1:length(justcrackedlist)
				%justcrackedcounter=length(justcrackedlist{iro});	
				x_justcrackedcenter(1)=LOC(justcrackedlist(iro),1);
				x_justcrackedcenter(2)=LOC(justcrackedlist(iro),2);
				%x_justcrackedcenter(1)=sum(LOC(justcrackedlist{iro},1))/justcrackedcounter;
				%x_justcrackedcenter(2)=sum(LOC(justcrackedlist{iro},2))/justcrackedcounter;
				%{
				for i=1:errorntestedangle
					theta(i)=(i-1)/36*1*1*1*pi;
					error(i)=0;
					for spc=1:justcrackedcounter
						error(i)=error(i)+(mod(thetacrack(justcrackedlist{iro}(spc))-theta(i)+pi/2,pi)-pi/2)^2;
					end
				end
				%}
				thetajustcrackedcenter=crackanglenodes(justcrackedlist(iro));
				%thetajustcrackedcenter=theta(FindMin(error));
				%considered=ones(x_crack.npaths,2);
				%distancelist=zeros(x_crack.npaths,2);
				%thetapropagationlist=zeros(x_crack.npaths,2);
				%n_nairncrack0=0;
				%n_nairncrack1=0;
				
				intheprevention=0;
				preventiondistance=1.5*le(1);
				preventionangle=pi/4;
				for icrackpath=1:x_crack.npaths;
					for spcrack=1:(x_crack.nparticles(icrackpath)-1)
						vector1a=[(x_justcrackedcenter(1)-x_crack.center(spcrack,1,icrackpath));(x_justcrackedcenter(2)-x_crack.center(spcrack,2,icrackpath))];
						vector1b=[(x_justcrackedcenter(1)-x_crack.center(spcrack+1,1,icrackpath));(x_justcrackedcenter(2)-x_crack.center(spcrack+1,2,icrackpath))];
						distance1a=sqrt(dot(vector1a,vector1a));
						distance1b=sqrt(dot(vector1b,vector1b));
						
						distance1a_old=sqrt((x_justcrackedcenter(1)-x_crack.center(spcrack,1,icrackpath))^2+(x_justcrackedcenter(2)-x_crack.center(spcrack,2,icrackpath))^2);
						distance1b_old=sqrt((x_justcrackedcenter(1)-x_crack.center(spcrack+1,1,icrackpath))^2+(x_justcrackedcenter(2)-x_crack.center(spcrack+1,2,icrackpath))^2);
						
						distance1=min([distance1a distance1b]);
						
						area2=abs(TriangleArea(x_justcrackedcenter,x_crack.center(spcrack,:,icrackpath),x_crack.center(spcrack+1,:,icrackpath)));
						
						inbetween2vector=[(x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath));(x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath))];
						
						inbetween2=sqrt(dot(inbetween2vector,inbetween2vector));
						
						inbetween2_old=sqrt((x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath))^2+(x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath))^2);
						distance2=area2/inbetween2;
						
						signcos1=dot(vector1a,inbetween2vector);
						signcos2=dot(vector1b,inbetween2vector);
						
						if signcos1*signcos2>0
							distance=distance1;
						else
							distance=distance2;
						end
						
						if distance<preventiondistance
							thetanairncrack=reliableatan(x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath),x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath));
							
							absdeltatheta=abs(mod(thetanairncrack-thetajustcrackedcenter+pi/2,pi)-pi/2);
							
							if absdeltatheta<preventionangle
								intheprevention=1;
							end
						end
						if intheprevention==1
							break;
						end
					end
					if intheprevention==1
						break;
					end
				end
				if intheprevention==0
					thetainitiate=mod(thetajustcrackedcenter-pi,pi)+pi; %always pointing down, pi<theta<2*pi
					icrackpath=x_crack.npaths+1;
					x_crack.npaths=x_crack.npaths+1;
					if CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==194
						x_crack.nparticles(icrackpath)=3;
						x_crack.center(3,2,icrackpath)=x_justcrackedcenter(2)+le(1)/2*sin(thetainitiate); %assuming le(1)=le(2);
						x_crack.center(3,1,icrackpath)=x_justcrackedcenter(1)+le(1)/2*cos(thetainitiate);
						x_crack.center(1,2,icrackpath)=x_justcrackedcenter(2)-le(1)/2*sin(thetainitiate);
						x_crack.center(1,1,icrackpath)=x_justcrackedcenter(1)-le(1)/2*cos(thetainitiate);
						x_crack.center(2,2,icrackpath)=x_justcrackedcenter(2);
						x_crack.center(2,1,icrackpath)=x_justcrackedcenter(1);
						x_crack.cohesivepath(icrackpath)=1;
						x_crack.cohesivepoint(1,icrackpath)=1;
						x_crack.cohesivepoint(2,icrackpath)=1;
						x_crack.cohesivepoint(3,icrackpath)=1;
					else
						x_crack.nparticles(icrackpath)=2;
						x_crack.center(2,2,icrackpath)=x_justcrackedcenter(2)+le(1)/2*sin(thetainitiate); %assuming le(1)=le(2);
						x_crack.center(2,1,icrackpath)=x_justcrackedcenter(1)+le(1)/2*cos(thetainitiate);
						x_crack.center(1,2,icrackpath)=x_justcrackedcenter(2)-le(1)/2*sin(thetainitiate);
						x_crack.center(1,1,icrackpath)=x_justcrackedcenter(1)-le(1)/2*cos(thetainitiate);
					end
					%fprintf('%s',['>>line 8967: size(x_crackcenter' int2txt(icrackpath) '},1)=' int2txt(x_crack.nparticles(icrackpath)) char(10)]);
					%fprintf('%s',['>>line 8968: size(x_cracktop{' int2txt(icrackpath) '},1)=' int2txt(size(x_cracktop{icrackpath},1)) char(10)]);
					%{
					for i=1:size(x_cracktop{icrackpath},1)
						for j=1:size(x_cracktop{icrackpath},2)
							%fprintf('%s',['>>line 8973: x_cracktop{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_cracktop{icrackpath}(i,j)) char(10)]);
						end
					end
					for i=1:size(x_crackbot{icrackpath},1)
						for j=1:size(x_crackbot{icrackpath},2)
							%fprintf('%s',['>>line 8980: x_crackbot{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackbot{icrackpath}(i,j)) char(10)]);
						end
					end
					for i=1:size(x_crackcenter{icrackpath},1)
						for j=1:size(x_crackcenter{icrackpath},2)
							%fprintf('%s',['>>line 8987: x_crackcenter{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackcenter{icrackpath}(i,j)) char(10)]);
						end
					end
					%}
					for i=1:x_crack.nparticles(icrackpath)
						for j=1:2
							%fprintf('%s',['>>line 8973: x_crackcenter{' int2txt(icrackpath) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackcenter{icrackpath}(i,j)) char(10)]);
							x_crack.top(i,j,icrackpath)=x_crack.center(i,j,icrackpath);
							x_crack.bot(i,j,icrackpath)=x_crack.center(i,j,icrackpath);
						end
					end
					%shit below
					%x_cracktop{icrackpath}=x_crackcenter{icrackpath};
					%x_crackbot{icrackpath}=x_crackcenter{icrackpath};
					%shit above
				end
				%soundplay
				1;
			end
		end
	elseif CasetoRun==151 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==139 || CasetoRun==118 || CasetoRun==173
		%crack propagation of 139
		%propagation denied for this
		%node centric propagation
		%no gauss propagation
		%currently propagation only
		no=niCount;
		%s_tip(ipath,dim,itip);
		s_tip=zeros(x_crack.npaths,3,2);
		s_tip_K1=zeros(x_crack.npaths,3,2); %ncrackpaths; dimension (x and y); which tip
		deltax_previous=zeros(1,2,1);
		theta_crack_trial=zeros(1,2);
		deltatheta_crack=zeros(1,2);
		s_tip_dump=zeros(2*x_crack.npaths,3);
		d_tip_dump=zeros(2*x_crack.npaths,8);
		d_LOC_tip_dump=zeros(2*x_crack.npaths,8);
		s_tip_K1_dump=zeros(2*x_crack.npaths,3);
		u_tip_dump=zeros(2*x_crack.npaths,8);
		x_tip_dump=zeros(2*x_crack.npaths,2);
		r_propdirweighted_dump=zeros(2*x_crack.npaths,2);
		K1_maxradius=3*le(1);
		K1_estimate=zeros(1,2);
		K1_distance=zeros(1,2);
		r_propdirweighted=zeros(x_crack.npaths,2,2); %crackpath num, dimension, which tip
		sigma_maxprinc_magnitude=0;
		r_propdircompliment=zeros(1,2);
		a_transform=zeros(2,2);
		s_tip_tensor=zeros(2,2);
		s_tip_tensor_transformed=zeros(2,2);
		LOC_avg=zeros(1,2);
		nio_designator=zeros(1,4);
		d_natural=zeros(8,1);
		delta_x=zeros(1,2);
		epsilon_tip=zeros(3,1);
		x_crack_ghosttip=zeros(1,2);
		x1=zeros(1,2);
		x2=zeros(1,2);
		x3=zeros(1,2);
		x4=zeros(1,2);
		Area=zeros(1,4);
		foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
		foundcrossing.icrackparticle3=zeros(1,200); %so not to clash with iparticle
		foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
		foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.
		%nio_designator(1): in the natural coordinates, node 1 associates with which nio?
		%nio_designator(2): in the natural coordinates, node 2 associates with which nio?
		%nio_designator(3): in the natural coordinates, node 3 associates with which nio?
		%nio_designator(4): in the natural coordinates, node 4 associates with which nio?
		
		io_natural_cross_before=0;
		io_natural_cross_after=0;
		io_natural_sides=zeros(1,4);
		sigmamaxprincmaxperfy=0;
		
		%r_propdirweighted=zeros(1,2); %dimension only
		%allowpropagation=1;
		for tip=1:2
			%tip=1: particle of highest index
			%tip=2: particle of lowerst index
			for ipath=1:x_crack.npaths
				if x_crack.terminatedprop(ipath,tip)==0
					if tip==1
						icrackparticle=x_crack.nparticles(ipath);
					elseif tip==2
						icrackparticle=1;
					end
					LOC_avg=zeros(1,2);
					for nio=1:4
						io=CONNECT_crack.center.values(icrackparticle,nio,ipath);
						for dim=1:2
							LOC_avg(1,dim)=LOC_avg(1,dim)+LOC(io,dim);
						end
					end
					for dim=1:2
						LOC_avg(1,dim)=LOC_avg(1,dim)/4;
					end
					for nio=1:4
						io=CONNECT_crack.center.values(icrackparticle,nio,ipath);
						if LOC(io,1)<LOC_avg(1,1)
							if LOC(io,2)<LOC_avg(1,2)
								nio_designator(1)=nio;
							elseif LOC(io,2)>LOC_avg(1,2) %can just write else, but this way it's more readable. also equal is not possible, so I left it out
								nio_designator(4)=nio;
							end
						elseif LOC(io,1)>LOC_avg(1,1) %same drill, trying to improve readability
							if LOC(io,2)<LOC_avg(1,2)
								nio_designator(2)=nio;
							elseif LOC(io,2)>LOC_avg(1,2)
								nio_designator(3)=nio;
							end
						end
					end
					%allowpropagation=1;
					tip_crackability=0;
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						tip_crackability=tip_crackability+uncrackable_si_comb(io)*N_crack.center(1,nio_outside,icrackparticle,ipath);
					end
					%finding where the crack cuts the cell
					for itrial=1:x_crack.nparticles(ipath)-1
						io_natural_cross_before=0;
						io_natural_cross_after=0;
						io_natural_sides=zeros(1,4);
						if tip==1
							x1(1,1)=x_crack.center(icrackparticle-(itrial-1),1,ipath);
							x1(1,2)=x_crack.center(icrackparticle-(itrial-1),2,ipath);
							x2(1,1)=x_crack.center(icrackparticle-itrial,1,ipath);
							x2(1,2)=x_crack.center(icrackparticle-itrial,2,ipath);
						elseif tip==2
							x1(1,1)=x_crack.center(1+(itrial-1),1,ipath);
							x1(1,2)=x_crack.center(1+(itrial-1),2,ipath);
							x2(1,1)=x_crack.center(1+itrial,1,ipath);
							x2(1,2)=x_crack.center(1+itrial,2,ipath);
						end
											
						for io_natural=1:4
							nio_outside=nio_designator(io_natural);
							io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
							x3(1,1)=LOC(io,1);
							x3(1,2)=LOC(io,2);
							nio_outside=nio_designator(mod(io_natural+1-1,4)+1);
							io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
							x4(1,1)=LOC(io,1);
							x4(1,2)=LOC(io,2);
							Area(1)=TriangleArea(x1,x2,x3);
							Area(2)=TriangleArea(x1,x2,x4);
							Area(3)=TriangleArea(x3,x4,x1);
							Area(4)=TriangleArea(x3,x4,x2);
							if (Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0) || (Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0)
								%before and before-1: top(2) for tip==1, bottom(3) for tip==2
								%after and after+1: bottom(3) for tip==1, top(2) for tip==1
								io_natural_cross_before=io_natural;
								if tip==1
									io_natural_sides(io_natural_cross_before)=2;
									io_natural_sides(mod(io_natural_cross_before-1-1,4)+1)=2;
								elseif tip==2
									io_natural_sides(io_natural_cross_before)=3;
									io_natural_sides(mod(io_natural_cross_before-1-1,4)+1)=3;
								end
								
								io_natural_cross_after=mod(io_natural+1-1,4)+1;
								if tip==1
									io_natural_sides(io_natural_cross_after)=3;							
									io_natural_sides(mod(io_natural_cross_after+1-1,4)+1)=3;
								elseif tip==2
									io_natural_sides(io_natural_cross_after)=2;
									io_natural_sides(mod(io_natural_cross_after+1-1,4)+1)=2;
								end
								break;
							end
						end
						if io_natural_cross_before>0
							break;
						end
					end
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						for dim=1:2
							index=2*(io_natural-1)+dim;
							if io_natural_sides(io_natural)==2
								d_natural(index,1)=u_si(io,dim,TheFieldSplit_cracktop{ipath}(nio_outside,icrackparticle));
							elseif io_natural_sides(io_natural)==3
								d_natural(index,1)=u_si(io,dim,TheFieldSplit_crackbot{ipath}(nio_outside,icrackparticle));
							else
								d_natural(index,1)=u_si_comb(io,dim);
							end
						end
						%if uncrackable_si_comb(io)>0.25
						if tip_crackability>0.125
							x_crack.terminatedprop(ipath,tip)=1;
							break;
						elseif sum(nmass_si(io,:))<=0
							%allowpropagation=0;
							x_crack.terminatedprop(ipath,tip)=1;
							if tip==1
								deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
							elseif tip==2
								deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
							end							
							if tip==1
								x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+deltax_previous(1);
								x_crack.top(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.bot(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+deltax_previous(2);
								x_crack.top(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
								x_crack.bot(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
							elseif tip==2
								for icrackparticlemove=x_crack.nparticles(ipath):-1:1
									for dim=1:2
										x_crack.center(icrackparticlemove+1,dim,ipath)=x_crack.center(icrackparticlemove,dim,ipath);
										x_crack.top(icrackparticlemove+1,dim,ipath)=x_crack.top(icrackparticlemove,dim,ipath);
										x_crack.bot(icrackparticlemove+1,dim,ipath)=x_crack.bot(icrackparticlemove,dim,ipath);
									end
								end
								x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+deltax_previous(1);
								x_crack.top(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.bot(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+deltax_previous(2);
								x_crack.top(1,2,ipath)=x_crack.center(1,2,ipath);
								x_crack.bot(1,2,ipath)=x_crack.center(1,2,ipath);
							end
							x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
							break;
						end
					end
					
					a=le(1)/2;
					b=le(2)/2;
					
					for dim=1:2
						delta_x(dim)=x_crack.center(icrackparticle,dim,ipath)-LOC_avg(1,dim);
					end
					
					xi=delta_x(1)/a;
					eta=delta_x(2)/b;
					
					B=1/4*[(-1+eta)/a 0 (1-eta)/a 0 (1+eta)/a 0 (-1-eta)/a 0;
							0 (-1+xi)/b 0 (-1-xi)/b 0 (1+xi)/b 0 (1-xi)/b;
							(-1+xi)/b (-1+eta)/a (-1-xi)/b (1-eta)/a (1+xi)/b (1+eta)/a (1-xi)/b (-1-eta)/a];
					
					epsilon_tip=B*d_natural;
					%tempmarker5

					D=E/((1+nu)*(1-2*nu))*[1-nu nu 0;nu 1-nu 0;0 0 (1-2*nu)];
					
					s_tip_temp=D*epsilon_tip;
					
					for dim=1:3
						s_tip(ipath,dim,tip)=s_tip_temp(dim,1);
					end
					for dim=1:3
						s_tip_dump(2*(ipath-1)+tip,dim)=s_tip(ipath,dim,tip);
						s_tip_K1_dump(2*(ipath-1)+tip,dim)=s_tip_K1(ipath,dim,tip);
					end
					for dim=1:8
						d_tip_dump(2*(ipath-1)+tip,dim)=d_natural(dim,1);
						io_natural=ceil(dim/2);
						xydim=mod(dim-1,2)+1;
						d_LOC_tip_dump(2*(ipath-1)+tip,dim)=LOC(CONNECT_crack.center.values(icrackparticle,nio_designator(io_natural),ipath),xydim);;
					end
					for dim=1:2
						x_tip_dump(2*(ipath-1)+tip,dim)=x_crack.center(icrackparticle,dim,ipath);
					end
					s_tip_max=(s_tip(ipath,1,tip)+s_tip(ipath,2,tip))/2+sqrt( ((s_tip(ipath,1,tip)-s_tip(ipath,2,tip))/2)^2 + (s_tip(ipath,3,tip))^2 ); %calculate principal stress
					
					elasticstrength=0.125; %to stop coder whining
					if CasetoRun==139 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
						elasticstrength=0.125;
						k_dumpresult=0.999;
					elseif CasetoRun==136
						elasticstrength=0.00125;
						k_dumpresult=0.999;
					elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165
						elasticstrength=0.0125;
						k_dumpresult=0.995;
					elseif CasetoRun==184
						elasticstrength=1e10; %cracking denied
						k_dumpresult=0.99;
					elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
						elasticstrength=999999999;
						k_dumpresult=0.995;
					elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
						elasticstrength=0.25;
						k_dumpresult=0.7;
					end
					if s_tip_max>k_dumpresult*elasticstrength
						dumpresult=1;
					end
					x_crack.tipcrackratio(ipath,tip)=s_tip_max/elasticstrength;
					sigmamaxprincmaxperfy=max(sigmamaxprincmaxperfy,s_tip_max/elasticstrength);
					if x_crack.terminatedprop(ipath,tip)==0 && s_tip_max>elasticstrength
					%if s_tip_max>elasticstrength
						if ipath==1 && x_crack.nparticles(ipath)>=10
							1;
						end
						theta_crack=0.5*(pi-reliableatan((s_tip(ipath,1,tip)-s_tip(ipath,2,tip))/2,-s_tip(ipath,3,tip)));
						crackextension=le(1)/2;
						if tip==1
							deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
						elseif tip==2
							deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
						end
						%theta_previous=reliableatan(deltax_previous(1,1,1),deltax_previous(1,2,1));
						theta_crack_trial(1)=theta_crack;
						theta_crack_trial(2)=mod(theta_crack+pi,2*pi); %two possibilities for crack angle, 
						if (deltax_previous(1,1,1)*cos(theta_crack_trial(1))+deltax_previous(1,2,1)*sin(theta_crack_trial(1)))>0 % cos of theta_crack_trial with current crack tip trajectory
							theta_crack=theta_crack_trial(1);
						else
							theta_crack=theta_crack_trial(2);
						end
						if tip==1
							x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+crackextension*cos(theta_crack);
							x_crack.top(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
							x_crack.bot(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
							x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+crackextension*sin(theta_crack);
							x_crack.top(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
							x_crack.bot(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
							x_crack_ghosttip(1,1)=x_crack.center(icrackparticle,1,ipath)+3*crackextension*cos(theta_crack);
							x_crack_ghosttip(1,2)=x_crack.center(icrackparticle,2,ipath)+3*crackextension*sin(theta_crack);
						elseif tip==2
							for icrackparticlemove=x_crack.nparticles(ipath):-1:1
								for dim=1:2
									x_crack.center(icrackparticlemove+1,dim,ipath)=x_crack.center(icrackparticlemove,dim,ipath);
									x_crack.top(icrackparticlemove+1,dim,ipath)=x_crack.top(icrackparticlemove,dim,ipath);
									x_crack.bot(icrackparticlemove+1,dim,ipath)=x_crack.bot(icrackparticlemove,dim,ipath);
								end
							end
							x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+crackextension*cos(theta_crack);
							x_crack.top(1,1,ipath)=x_crack.center(1,1,ipath);
							x_crack.bot(1,1,ipath)=x_crack.center(1,1,ipath);
							x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+crackextension*sin(theta_crack);
							x_crack.top(1,2,ipath)=x_crack.center(1,2,ipath);
							x_crack.bot(1,2,ipath)=x_crack.center(1,2,ipath);
							x_crack_ghosttip(1,1)=x_crack.center(2,1,ipath)+3*crackextension*cos(theta_crack);
							x_crack_ghosttip(1,2)=x_crack.center(2,2,ipath)+3*crackextension*sin(theta_crack);
						end
						if tip==1
							x1(1,1)=x_crack.center(icrackparticle,1,ipath);
							x1(1,2)=x_crack.center(icrackparticle,2,ipath);
						elseif tip==2
							x1(1,1)=x_crack.center(2,1,ipath);
							x1(1,2)=x_crack.center(2,2,ipath);
						end
						x2(1,1)=x_crack_ghosttip(1,1);
						x2(1,2)=x_crack_ghosttip(1,2);

						foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
						foundcrossing.icrackparticle3=zeros(1,200); %so not to clash with iparticle
						foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
						foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.

						for ipath2=1:x_crack.npaths
							for icrackparticle2=1:(x_crack.nparticles(ipath2)-1)
								if ipath2==ipath
									%icrackparticle: deals with the propagation, what's currently the particle as the tip
									%icrackparticle2: the loop for checking crack crossing
									if tip==1 && icrackparticle2>=icrackparticle-2
										continue;
									elseif tip==2 && icrackparticle2<=2
										continue;
									end
								end
								%start of crossing checks
								for dim=1:2
									x3(1,dim)=x_crack.center(icrackparticle2,dim,ipath2);
									x4(1,dim)=x_crack.center(icrackparticle2+1,dim,ipath2);
								end
								Area(1)=TriangleArea(x1,x2,x3);
								Area(2)=TriangleArea(x1,x2,x4);
								Area(3)=TriangleArea(x3,x4,x1);
								Area(4)=TriangleArea(x3,x4,x2);
								if (Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0) || (Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0)
									foundcrossing.size3=foundcrossing.size3+1;
									foundcrossing.ipath3(foundcrossing.size3)=ipath2;
									foundcrossing.icrackparticle3(foundcrossing.size3)=icrackparticle2;
									foundcrossing.ratio(foundcrossing.size3)=abs(Area(3))/(abs(Area(3))+abs(Area(4)));%ratio between 1-crossing distance to 1-2 distance
								end
								%end of crossing checks
							end
						end
						foundcrossing_ratio_min=2;
						for ifoundcrossing=1:foundcrossing.size3
							if foundcrossing.ratio(ifoundcrossing)<foundcrossing_ratio_min
								foundcrossing_ratio_min=foundcrossing.ratio(ifoundcrossing);
							end
						end
						if foundcrossing.size3>0
							x_crack.terminatedprop(ipath,tip)=1;
							if tip==1
								x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+foundcrossing_ratio_min*3.1*crackextension*cos(theta_crack);
								x_crack.top(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.bot(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+foundcrossing_ratio_min*3.1*crackextension*sin(theta_crack);
								x_crack.top(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
								x_crack.bot(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
							elseif tip==2
								x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+foundcrossing_ratio_min*3.1*crackextension*cos(theta_crack);
								x_crack.top(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.bot(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+foundcrossing_ratio_min*3.1*crackextension*sin(theta_crack);
								x_crack.top(1,2,ipath)=x_crack.center(1,2,ipath);
								x_crack.bot(1,2,ipath)=x_crack.center(1,2,ipath);
							end
						end
						x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
					end
				end
			end
		end
	elseif CasetoRun==124
		%crack propagation of 124
		%propagation denied for this
		%node centric propagation
		%no gauss propagation
		%currently propagation only
		no=niCount;
		%s_tip(ipath,dim,itip);
		s_tip=zeros(x_crack.npaths,3,2);
		s_tip_K1=zeros(x_crack.npaths,3,2); %ncrackpaths; dimension (x and y); which tip
		deltax_previous=zeros(1,2,1);
		theta_crack_trial=zeros(1,2);
		deltatheta_crack=zeros(1,2);
		s_tip_dump=zeros(2*x_crack.npaths,3);
		d_tip_dump=zeros(2*x_crack.npaths,8);
		d_LOC_tip_dump=zeros(2*x_crack.npaths,8);
		s_tip_K1_dump=zeros(2*x_crack.npaths,3);
		u_tip_dump=zeros(2*x_crack.npaths,8);
		x_tip_dump=zeros(2*x_crack.npaths,2);
		r_propdirweighted_dump=zeros(2*x_crack.npaths,2);
		K1_maxradius=3*le(1);
		K1_estimate=zeros(1,2);
		K1_distance=zeros(1,2);
		r_propdirweighted=zeros(x_crack.npaths,2,2); %crackpath num, dimension, which tip
		sigma_maxprinc_magnitude=0;
		r_propdircompliment=zeros(1,2);
		a_transform=zeros(2,2);
		s_tip_tensor=zeros(2,2);
		s_tip_tensor_transformed=zeros(2,2);
		LOC_avg=zeros(1,2);
		nio_designator=zeros(1,4);
		d_natural=zeros(8,1);
		delta_x=zeros(1,2);
		epsilon_tip=zeros(3,1);
		x_crack_ghosttip=zeros(1,2);
		x1=zeros(1,2);
		x2=zeros(1,2);
		x3=zeros(1,2);
		x4=zeros(1,2);
		Area=zeros(1,4);
		foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
		foundcrossing.icrackparticle3=zeros(1,200); %so not to clash with iparticle
		foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
		foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.
		%nio_designator(1): in the natural coordinates, node 1 associates with which nio?
		%nio_designator(2): in the natural coordinates, node 2 associates with which nio?
		%nio_designator(3): in the natural coordinates, node 3 associates with which nio?
		%nio_designator(4): in the natural coordinates, node 4 associates with which nio?
		
		io_natural_cross_before=0;
		io_natural_cross_after=0;
		io_natural_sides=zeros(1,4);
		
		%r_propdirweighted=zeros(1,2); %dimension only
		%allowpropagation=1;
		for tip=1:2
			%tip=1: particle of highest index
			%tip=2: particle of lowerst index
			for ipath=1:x_crack.npaths
				if x_crack.terminatedprop(ipath,tip)==0
					if tip==1
						icrackparticle=x_crack.nparticles(ipath);
					elseif tip==2
						icrackparticle=1;
					end
					LOC_avg=zeros(1,2);
					for nio=1:4
						io=CONNECT_crack.center.values(icrackparticle,nio,ipath);
						for dim=1:2
							LOC_avg(1,dim)=LOC_avg(1,dim)+LOC(io,dim);
						end
					end
					for dim=1:2
						LOC_avg(1,dim)=LOC_avg(1,dim)/4;
					end
					for nio=1:4
						io=CONNECT_crack.center.values(icrackparticle,nio,ipath);
						if LOC(io,1)<LOC_avg(1,1)
							if LOC(io,2)<LOC_avg(1,2)
								nio_designator(1)=nio;
							elseif LOC(io,2)>LOC_avg(1,2) %can just write else, but this way it's more readable. also equal is not possible, so I left it out
								nio_designator(4)=nio;
							end
						elseif LOC(io,1)>LOC_avg(1,1) %same drill, trying to improve readability
							if LOC(io,2)<LOC_avg(1,2)
								nio_designator(2)=nio;
							elseif LOC(io,2)>LOC_avg(1,2)
								nio_designator(3)=nio;
							end
						end
					end
					%allowpropagation=1;
					tip_crackability=0;
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						tip_crackability=tip_crackability+uncrackable_si_comb(io)*N_crack.center(1,nio_outside,icrackparticle,ipath);
					end
					%finding where the crack cuts the cell
					for itrial=1:x_crack.nparticles(ipath)-1
						io_natural_cross_before=0;
						io_natural_cross_after=0;
						io_natural_sides=zeros(1,4);
						if tip==1
							x1(1,1)=x_crack.center(icrackparticle-(itrial-1),1,ipath);
							x1(1,2)=x_crack.center(icrackparticle-(itrial-1),2,ipath);
							x2(1,1)=x_crack.center(icrackparticle-itrial,1,ipath);
							x2(1,2)=x_crack.center(icrackparticle-itrial,2,ipath);
						elseif tip==2
							x1(1,1)=x_crack.center(1+(itrial-1),1,ipath);
							x1(1,2)=x_crack.center(1+(itrial-1),2,ipath);
							x2(1,1)=x_crack.center(1+itrial,1,ipath);
							x2(1,2)=x_crack.center(1+itrial,2,ipath);
						end
											
						for io_natural=1:4
							nio_outside=nio_designator(io_natural);
							io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
							x3(1,1)=LOC(io,1);
							x3(1,2)=LOC(io,2);
							nio_outside=nio_designator(mod(io_natural+1-1,4)+1);
							io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
							x4(1,1)=LOC(io,1);
							x4(1,2)=LOC(io,2);
							Area(1)=TriangleArea(x1,x2,x3);
							Area(2)=TriangleArea(x1,x2,x4);
							Area(3)=TriangleArea(x3,x4,x1);
							Area(4)=TriangleArea(x3,x4,x2);
							if (Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0) || (Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0)
								%before and before-1: top(2) for tip==1, bottom(3) for tip==2
								%after and after+1: bottom(3) for tip==1, top(2) for tip==1
								io_natural_cross_before=io_natural;
								if tip==1
									io_natural_sides(io_natural_cross_before)=2;
									io_natural_sides(mod(io_natural_cross_before-1-1,4)+1)=2;
								elseif tip==2
									io_natural_sides(io_natural_cross_before)=3;
									io_natural_sides(mod(io_natural_cross_before-1-1,4)+1)=3;
								end
								
								io_natural_cross_after=mod(io_natural+1-1,4)+1;
								if tip==1
									io_natural_sides(io_natural_cross_after)=3;							
									io_natural_sides(mod(io_natural_cross_after+1-1,4)+1)=3;
								elseif tip==2
									io_natural_sides(io_natural_cross_after)=2;
									io_natural_sides(mod(io_natural_cross_after+1-1,4)+1)=2;
								end
								break;
							end
						end
						if io_natural_cross_before>0
							break;
						end
					end
					for io_natural=1:4
						nio_outside=nio_designator(io_natural);
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						for dim=1:2
							index=2*(io_natural-1)+dim;
							if io_natural_sides(io_natural)==2
								d_natural(index,1)=u_si(io,dim,TheFieldSplit_cracktop{ipath}(nio_outside,icrackparticle));
							elseif io_natural_sides(io_natural)==3
								d_natural(index,1)=u_si(io,dim,TheFieldSplit_crackbot{ipath}(nio_outside,icrackparticle));
							else
								d_natural(index,1)=u_si_comb(io,dim);
							end
						end
						%if uncrackable_si_comb(io)>0.25
						if tip_crackability>0.125
							x_crack.terminatedprop(ipath,tip)=1;
							break;
						elseif sum(nmass_si(io,:))<=0
							%allowpropagation=0;
							x_crack.terminatedprop(ipath,tip)=1;
							if tip==1
								deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
							elseif tip==2
								deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
							end							
							if tip==1
								x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+deltax_previous(1);
								x_crack.top(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.bot(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+deltax_previous(2);
								x_crack.top(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
								x_crack.bot(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
							elseif tip==2
								for icrackparticlemove=x_crack.nparticles(ipath):-1:1
									for dim=1:2
										x_crack.center(icrackparticlemove+1,dim,ipath)=x_crack.center(icrackparticlemove,dim,ipath);
										x_crack.top(icrackparticlemove+1,dim,ipath)=x_crack.top(icrackparticlemove,dim,ipath);
										x_crack.bot(icrackparticlemove+1,dim,ipath)=x_crack.bot(icrackparticlemove,dim,ipath);
									end
								end
								x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+deltax_previous(1);
								x_crack.top(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.bot(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+deltax_previous(2);
								x_crack.top(1,2,ipath)=x_crack.center(1,2,ipath);
								x_crack.bot(1,2,ipath)=x_crack.center(1,2,ipath);
							end
							x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
							break;
						end
					end
					
					a=le(1)/2;
					b=le(2)/2;
					
					for dim=1:2
						delta_x(dim)=x_crack.center(icrackparticle,dim,ipath)-LOC_avg(1,dim);
					end
					
					xi=delta_x(1)/a;
					eta=delta_x(2)/b;
					
					B=1/4*[(-1+eta)/a 0 (1-eta)/a 0 (1+eta)/a 0 (-1-eta)/a 0;
							0 (-1+xi)/b 0 (-1-xi)/b 0 (1+xi)/b 0 (1-xi)/b;
							(-1+xi)/b (-1+eta)/a (-1-xi)/b (1-eta)/a (1+xi)/b (1+eta)/a (1-xi)/b (-1-eta)/a];
					
					epsilon_tip=B*d_natural;
					%tempmarker5
					EWStatus_tip=0;
					LWStatus_tip=0;
					for nio=1:4
						io=CONNECT_crack.center.values(icrackparticle,nio_outside,ipath);
						EWStatus_tip=EWStatus_tip+EW_si_comb(io)*N_crack.center(1,nio,icrackparticle,ipath);
						LWStatus_tip=LWStatus_tip+LW_si_comb(io)*N_crack.center(1,nio,icrackparticle,ipath);
					end
					E_LW=E;
					E_EW=40/1200*E;
					elasticstrength_LW=0.125;
					elasticstrength_EW=sqrt(E_EW/E_LW)*elasticstrength_LW;
					E_tip=(E_EW*EWStatus_tip+E_LW*LWStatus_tip)/(EWStatus_tip+LWStatus_tip);
					elasticstrength=(elasticstrength_EW*EWStatus_tip+elasticstrength_LW*LWStatus_tip)/(EWStatus_tip+LWStatus_tip);
					
					D=E_tip/((1+nu)*(1-2*nu))*[1-nu nu 0;nu 1-nu 0;0 0 (1-2*nu)];
					
					s_tip_temp=D*epsilon_tip;
					
					for dim=1:3
						s_tip(ipath,dim,tip)=s_tip_temp(dim,1);
					end
					for dim=1:3
						s_tip_dump(2*(ipath-1)+tip,dim)=s_tip(ipath,dim,tip);
						s_tip_K1_dump(2*(ipath-1)+tip,dim)=s_tip_K1(ipath,dim,tip);
					end
					for dim=1:8
						d_tip_dump(2*(ipath-1)+tip,dim)=d_natural(dim,1);
						io_natural=ceil(dim/2);
						xydim=mod(dim-1,2)+1;
						d_LOC_tip_dump(2*(ipath-1)+tip,dim)=LOC(CONNECT_crack.center.values(icrackparticle,nio_designator(io_natural),ipath),xydim);;
					end
					for dim=1:2
						x_tip_dump(2*(ipath-1)+tip,dim)=x_crack.center(icrackparticle,dim,ipath);
					end
					s_tip_max=(s_tip(ipath,1,tip)+s_tip(ipath,2,tip))/2+sqrt( ((s_tip(ipath,1,tip)-s_tip(ipath,2,tip))/2)^2 + (s_tip(ipath,3,tip))^2 ); %calculate principal stress
					
					%elasticstrength=0.125; %to stop coder whining
					k_dumpresult=0.99;
					
					if s_tip_max>k_dumpresult*elasticstrength
						dumpresult=1;
					end
					x_crack.tipcrackratio(ipath,tip)=s_tip_max/elasticstrength;
					if x_crack.terminatedprop(ipath,tip)==0 && s_tip_max>elasticstrength
					%if s_tip_max>elasticstrength
						if ipath==1 && x_crack.nparticles(ipath)>=10
							1;
						end
						theta_crack=0.5*(pi-reliableatan((s_tip(ipath,1,tip)-s_tip(ipath,2,tip))/2,-s_tip(ipath,3,tip)));
						crackextension=le(1)/2;
						if tip==1
							deltax_previous=x_crack.center(icrackparticle,:,ipath)-x_crack.center(icrackparticle-1,:,ipath);
						elseif tip==2
							deltax_previous=x_crack.center(1,:,ipath)-x_crack.center(1+1,:,ipath);
						end
						%theta_previous=reliableatan(deltax_previous(1,1,1),deltax_previous(1,2,1));
						theta_crack_trial(1)=theta_crack;
						theta_crack_trial(2)=mod(theta_crack+pi,2*pi); %two possibilities for crack angle, 
						if (deltax_previous(1,1,1)*cos(theta_crack_trial(1))+deltax_previous(1,2,1)*sin(theta_crack_trial(1)))>0 % cos of theta_crack_trial with current crack tip trajectory
							theta_crack=theta_crack_trial(1);
						else
							theta_crack=theta_crack_trial(2);
						end
						if tip==1
							x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+crackextension*cos(theta_crack);
							x_crack.top(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
							x_crack.bot(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
							x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+crackextension*sin(theta_crack);
							x_crack.top(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
							x_crack.bot(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
							x_crack_ghosttip(1,1)=x_crack.center(icrackparticle,1,ipath)+3*crackextension*cos(theta_crack);
							x_crack_ghosttip(1,2)=x_crack.center(icrackparticle,2,ipath)+3*crackextension*sin(theta_crack);
						elseif tip==2
							for icrackparticlemove=x_crack.nparticles(ipath):-1:1
								for dim=1:2
									x_crack.center(icrackparticlemove+1,dim,ipath)=x_crack.center(icrackparticlemove,dim,ipath);
									x_crack.top(icrackparticlemove+1,dim,ipath)=x_crack.top(icrackparticlemove,dim,ipath);
									x_crack.bot(icrackparticlemove+1,dim,ipath)=x_crack.bot(icrackparticlemove,dim,ipath);
								end
							end
							x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+crackextension*cos(theta_crack);
							x_crack.top(1,1,ipath)=x_crack.center(1,1,ipath);
							x_crack.bot(1,1,ipath)=x_crack.center(1,1,ipath);
							x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+crackextension*sin(theta_crack);
							x_crack.top(1,2,ipath)=x_crack.center(1,2,ipath);
							x_crack.bot(1,2,ipath)=x_crack.center(1,2,ipath);
							x_crack_ghosttip(1,1)=x_crack.center(2,1,ipath)+3*crackextension*cos(theta_crack);
							x_crack_ghosttip(1,2)=x_crack.center(2,2,ipath)+3*crackextension*sin(theta_crack);
						end
						if tip==1
							x1(1,1)=x_crack.center(icrackparticle,1,ipath);
							x1(1,2)=x_crack.center(icrackparticle,2,ipath);
						elseif tip==2
							x1(1,1)=x_crack.center(2,1,ipath);
							x1(1,2)=x_crack.center(2,2,ipath);
						end
						x2(1,1)=x_crack_ghosttip(1,1);
						x2(1,2)=x_crack_ghosttip(1,2);

						foundcrossing.ipath3=zeros(1,200); %so not clash with ipath
						foundcrossing.icrackparticle3=zeros(1,200); %so not to clash with iparticle
						foundcrossing.ratio=zeros(1,200); %at which point where crossing happens?
						foundcrossing.size3=zeros(1,1); %how many found? %again size3 so to not clash with regular size, perhaps.

						for ipath2=1:x_crack.npaths
							for icrackparticle2=1:(x_crack.nparticles(ipath2)-1)
								if ipath2==ipath
									%icrackparticle: deals with the propagation, what's currently the particle as the tip
									%icrackparticle2: the loop for checking crack crossing
									if tip==1 && icrackparticle2>=icrackparticle-2
										continue;
									elseif tip==2 && icrackparticle2<=2
										continue;
									end
								end
								%start of crossing checks
								for dim=1:2
									x3(1,dim)=x_crack.center(icrackparticle2,dim,ipath2);
									x4(1,dim)=x_crack.center(icrackparticle2+1,dim,ipath2);
								end
								Area(1)=TriangleArea(x1,x2,x3);
								Area(2)=TriangleArea(x1,x2,x4);
								Area(3)=TriangleArea(x3,x4,x1);
								Area(4)=TriangleArea(x3,x4,x2);
								if (Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0) || (Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0)
									foundcrossing.size3=foundcrossing.size3+1;
									foundcrossing.ipath3(foundcrossing.size3)=ipath2;
									foundcrossing.icrackparticle3(foundcrossing.size3)=icrackparticle2;
									foundcrossing.ratio(foundcrossing.size3)=abs(Area(3))/(abs(Area(3))+abs(Area(4)));%ratio between 1-crossing distance to 1-2 distance
								end
								%end of crossing checks
							end
						end
						foundcrossing_ratio_min=2;
						for ifoundcrossing=1:foundcrossing.size3
							if foundcrossing.ratio(ifoundcrossing)<foundcrossing_ratio_min
								foundcrossing_ratio_min=foundcrossing.ratio(ifoundcrossing);
							end
						end
						if foundcrossing.size3>0
							x_crack.terminatedprop(ipath,tip)=1;
							if tip==1
								x_crack.center(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle,1,ipath)+foundcrossing_ratio_min*3.1*crackextension*cos(theta_crack);
								x_crack.top(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.bot(icrackparticle+1,1,ipath)=x_crack.center(icrackparticle+1,1,ipath);
								x_crack.center(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle,2,ipath)+foundcrossing_ratio_min*3.1*crackextension*sin(theta_crack);
								x_crack.top(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
								x_crack.bot(icrackparticle+1,2,ipath)=x_crack.center(icrackparticle+1,2,ipath);
							elseif tip==2
								x_crack.center(1,1,ipath)=x_crack.center(2,1,ipath)+foundcrossing_ratio_min*3.1*crackextension*cos(theta_crack);
								x_crack.top(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.bot(1,1,ipath)=x_crack.center(1,1,ipath);
								x_crack.center(1,2,ipath)=x_crack.center(2,2,ipath)+foundcrossing_ratio_min*3.1*crackextension*sin(theta_crack);
								x_crack.top(1,2,ipath)=x_crack.center(1,2,ipath);
								x_crack.bot(1,2,ipath)=x_crack.center(1,2,ipath);
							end
						end
						x_crack.nparticles(ipath)=x_crack.nparticles(ipath)+1;
					end
				end
			end
		end
	elseif CasetoRun==-1 %118 originally uses this
		%crack propagation of 118
		if CloseEnough(t_time,0.001377337324502874186735179584673,1e-5,2)
			1;
		end
		fprintf('%s',['marker #643' char(10)]);
		if sum(justcracked)>0
			justcrackedlist=zeros(sum(justcracked),1);
			justcrackedcounter=0;
			for sp=1:spCount
				if justcracked(sp)
					justcrackedcounter=justcrackedcounter+1;
					justcrackedlist(justcrackedcounter)=sp;
				end
			end
			
			justcrackedlist=CrackParticleClustering(x_sp,le(1),justcrackedlist);
			ntestedangle=size(Qacoustic{justcrackedlist{1}(1)},3);
			theta=zeros(ntestedangle,1);
			errorntestedangle=36*1*1*1;
			error=zeros(1,errorntestedangle);
			
			for crackgroup=1:length(justcrackedlist)
				justcrackedcounter=length(justcrackedlist{crackgroup});	
				x_justcrackedcenter=zeros(2,1);
				x_justcrackedcenter(1)=sum(x_sp(justcrackedlist{crackgroup},1))/justcrackedcounter;
				x_justcrackedcenter(2)=sum(x_sp(justcrackedlist{crackgroup},2))/justcrackedcounter;
				for i=1:errorntestedangle
					theta(i)=(i-1)/36*1*1*1*pi;
					error(i)=0;
					for spc=1:justcrackedcounter
						error(i)=error(i)+(mod(thetacrack(justcrackedlist{crackgroup}(spc))-theta(i)+pi/2,pi)-pi/2)^2;
					end
				end
				thetajustcrackedcenter=theta(FindMin(error));
				considered=ones(x_crack.npaths,2);
				distancelist=zeros(x_crack.npaths,2);
				thetapropagationlist=zeros(x_crack.npaths,2);
				n_nairncrack0=0;
				n_nairncrack1=0;
				for icrackpath=x_crack.npaths:-1:1
					for whichtip=1:2
						if whichtip==1
							n_nairncrack1=x_crack.nparticles(icrackpath);
							n_nairncrack0=n_nairncrack1-1;
						elseif whichtip==2
							n_nairncrack1=1;
							n_nairncrack0=2;
						else
							fprintf('%s',['whichtip error! 1904151959' char(10)]);
							pause;
							1;
						end
						
						x_cracktip=x_crack.center(n_nairncrack1,:,icrackpath);
						thetatocrackcenter=reliableatan(x_justcrackedcenter(1)-x_cracktip(1),x_justcrackedcenter(2)-x_cracktip(2));
						theta_prev=reliableatan(x_crack.center(n_nairncrack1,1,icrackpath)-x_crack.center(n_nairncrack0,1,icrackpath),x_crack.center(n_nairncrack1,2,icrackpath)-x_crack.center(n_nairncrack0,2,icrackpath));
						deltatheta_tocrackvsprev=mod(thetatocrackcenter-theta_prev+pi,2*pi)-pi;
						if abs(deltatheta_tocrackvsprev)>pi
							fprintf('%s',['deltatheta_tocrackvsprev error! 1904112048' char(10)]);
							pause;
							1;
						end
						if abs(deltatheta_tocrackvsprev)>pi/2
							considered(icrackpath,whichtip)=0;
							distancelist(icrackpath,whichtip)=inf;
							continue;
						end
						propagationlength=sqrt((x_crack.center(n_nairncrack1,1,icrackpath)-x_justcrackedcenter(1))^2+(x_crack.center(n_nairncrack1,2,icrackpath)-x_justcrackedcenter(2))^2);
						if propagationlength>1.5*le(1)
							considered(icrackpath,whichtip)=0;
							distancelist(icrackpath,whichtip)=inf;
							continue;
						end
						distancelist(icrackpath,whichtip)=propagationlength;
						for i=1:36*1*1*1
							theta(i)=(i-1)/36*1*1*1*2*pi;
							error(i)=(mod(thetajustcrackedcenter-theta(i)+pi/2,pi)-pi/2)^2+(mod(thetatocrackcenter-theta(i)+pi,2*pi)-pi)^2;
						end
						theta_crackpropagation=theta(FindMin(error));
						theta_crackpropagation=mod(theta_crackpropagation-theta_prev+pi,2*pi)+theta_prev-pi;
						thetapropagationlist(icrackpath,whichtip)=theta_crackpropagation;
					end
				end
				if sum(sum(considered))>0
					ncrackandwhichtip=FindMinMatrix(distancelist);
					icrackpath_outloop=ncrackandwhichtip(1);
					whichtip=ncrackandwhichtip(2);
					if whichtip==1
						n_nairncrack1=x_crack.nparticles(icrackpath_outloop);
					else
						n_nairncrack1=1;
					end
					propagationlength=distancelist(icrackpath_outloop,whichtip);
					theta_crackpropagation=thetapropagationlist(icrackpath_outloop,whichtip);
					idealpropagationlength=le(1)/4; %assuming lp(1)==lp(2)
					%propagationlengthreductionfactor=max([1 round(propagationlength/idealpropagationlength)]);
					propagationlengthreductionfactor=1;
					if whichtip==1
						x_crack.nparticles(icrackpath_outloop)=x_crack.nparticles(icrackpath_outloop)+propagationlengthreductionfactor;
						for i=1:propagationlengthreductionfactor
							x_crack.center(n_nairncrack1+i,:,icrackpath_outloop)=[x_crack.center(n_nairncrack1,1,icrackpath_outloop)+i/propagationlengthreductionfactor*propagationlength*cos(theta_crackpropagation) x_crack.center(n_nairncrack1,2,icrackpath_outloop)+i/propagationlengthreductionfactor*propagationlength*sin(theta_crackpropagation)];
							x_crack.top(n_nairncrack1+i,:,icrackpath_outloop)=x_crack.center(n_nairncrack1+i,:,icrackpath_outloop);
							x_crack.bot(n_nairncrack1+i,:,icrackpath_outloop)=x_crack.center(n_nairncrack1+i,:,icrackpath_outloop);
						end
					elseif whichtip==2
						for i=x_crack.nparticles(icrackpath_outloop):-1:1
							x_crack.center(i+propagationlengthreductionfactor,:,icrackpath_outloop)=x_crack.center(i,:,icrackpath_outloop);
							x_crack.top(i+propagationlengthreductionfactor,:,icrackpath_outloop)=x_crack.top(i,:,icrackpath_outloop);
							x_crack.bot(i+propagationlengthreductionfactor,:,icrackpath_outloop)=x_crack.bot(i,:,icrackpath_outloop);
						end
						x_crack.nparticles(icrackpath_outloop)=x_crack.nparticles(icrackpath_outloop)+propagationlengthreductionfactor;
						n_nairncrack1=n_nairncrack1+propagationlengthreductionfactor;
						for i=1:propagationlengthreductionfactor
							x_crack.center(n_nairncrack1-i,:,icrackpath_outloop)=[x_crack.center(n_nairncrack1,1,icrackpath_outloop)+i/propagationlengthreductionfactor*propagationlength*cos(theta_crackpropagation) x_crack.center(n_nairncrack1,2,icrackpath_outloop)+i/propagationlengthreductionfactor*propagationlength*sin(theta_crackpropagation)];
							x_crack.top(n_nairncrack1-i,:,icrackpath_outloop)=x_crack.center(n_nairncrack1-i,:,icrackpath_outloop);
							x_crack.bot(n_nairncrack1-i,:,icrackpath_outloop)=x_crack.center(n_nairncrack1-i,:,icrackpath_outloop);
						end
					else
						fprintf('%s',['which tip error! 1904151909' char(10)]);
						pause;
						1;
					end
				else
					intheprevention=0;
					preventiondistance=0.075*le_base;
					preventionangle=pi/4;
					for icrackpath=1:x_crack.npaths;
						for spcrack=1:(x_crack.nparticles(icrackpath)-1)
							vector1a=[(x_justcrackedcenter(1)-x_crack.center(spcrack,1,icrackpath));(x_justcrackedcenter(2)-x_crack.center(spcrack,2,icrackpath))];
							vector1b=[(x_justcrackedcenter(1)-x_crack.center(spcrack+1,1,icrackpath));(x_justcrackedcenter(2)-x_crack.center(spcrack+1,2,icrackpath))];
							distance1a=sqrt(dot(vector1a,vector1a));
							distance1b=sqrt(dot(vector1b,vector1b));
							
							distance1a_old=sqrt((x_justcrackedcenter(1)-x_crack.center(spcrack,1,icrackpath))^2+(x_justcrackedcenter(2)-x_crack.center(spcrack,2,icrackpath))^2);
							distance1b_old=sqrt((x_justcrackedcenter(1)-x_crack.center(spcrack+1,1,icrackpath))^2+(x_justcrackedcenter(2)-x_crack.center(spcrack+1,2,icrackpath))^2);
							
							distance1=min([distance1a distance1b]);
							
							area2=abs(TriangleArea(x_justcrackedcenter,x_crack.center(spcrack,:,icrackpath),x_crack.center(spcrack+1,:,icrackpath)));
							
							inbetween2vector=[(x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath));(x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath))];
							
							inbetween2=sqrt(dot(inbetween2vector,inbetween2vector));
							
							inbetween2_old=sqrt((x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath))^2+(x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath))^2);
							distance2=area2/inbetween2;
							
							signcos1=dot(vector1a,inbetween2vector);
							signcos2=dot(vector1b,inbetween2vector);
							
							if signcos1*signcos2>0
								distance=distance1;
							else
								distance=distance2;
							end
							
							if distance<preventiondistance
								thetanairncrack=reliableatan(x_crack.center(spcrack+1,1,icrackpath)-x_crack.center(spcrack,1,icrackpath),x_crack.center(spcrack+1,2,icrackpath)-x_crack.center(spcrack,2,icrackpath));
								
								absdeltatheta=abs(mod(thetanairncrack-thetajustcrackedcenter+pi/2,pi)-pi/2);
								
								if absdeltatheta<preventionangle
									intheprevention=1;
								end
							end
							if intheprevention==1
								break;
							end
						end
						if intheprevention==1
							break;
						end
					end
					if intheprevention==0
						thetainitiate=mod(thetajustcrackedcenter-pi,pi)+pi; %always pointing down, pi<theta<2*pi
						icrackpath_outloop=x_crack.npaths+1;
						x_crack.npaths=x_crack.npaths+1;
						x_crack.nparticles(icrackpath_outloop)=2;
						x_crack.center(2,2,icrackpath_outloop)=x_justcrackedcenter(2)+le(1)/2/2*sin(thetainitiate); %assuming le(1)=le(2);
						x_crack.center(2,1,icrackpath_outloop)=x_justcrackedcenter(1)+le(1)/2/2*cos(thetainitiate);
						x_crack.center(1,2,icrackpath_outloop)=x_justcrackedcenter(2)-le(1)/2/2*sin(thetainitiate);
						x_crack.center(1,1,icrackpath_outloop)=x_justcrackedcenter(1)-le(1)/2/2*cos(thetainitiate);
						%fprintf('%s',['>>line 8967: size(x_crackcenter' int2txt(icrackpath_outloop) '},1)=' int2txt(x_crack.nparticles(icrackpath_outloop)) char(10)]);
						%fprintf('%s',['>>line 8968: size(x_cracktop{' int2txt(icrackpath_outloop) '},1)=' int2txt(size(x_cracktop{icrackpath_outloop},1)) char(10)]);
						%{
						for i=1:size(x_cracktop{icrackpath_outloop},1)
							for j=1:size(x_cracktop{icrackpath_outloop},2)
								%fprintf('%s',['>>line 8973: x_cracktop{' int2txt(icrackpath_outloop) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_cracktop{icrackpath_outloop}(i,j)) char(10)]);
							end
						end
						for i=1:size(x_crackbot{icrackpath_outloop},1)
							for j=1:size(x_crackbot{icrackpath_outloop},2)
								%fprintf('%s',['>>line 8980: x_crackbot{' int2txt(icrackpath_outloop) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackbot{icrackpath_outloop}(i,j)) char(10)]);
							end
						end
						for i=1:size(x_crackcenter{icrackpath_outloop},1)
							for j=1:size(x_crackcenter{icrackpath_outloop},2)
								%fprintf('%s',['>>line 8987: x_crackcenter{' int2txt(icrackpath_outloop) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackcenter{icrackpath_outloop}(i,j)) char(10)]);
							end
						end
						%}
						for i=1:x_crack.nparticles(icrackpath_outloop)
							for j=1:2
								%fprintf('%s',['>>line 8973: x_crackcenter{' int2txt(icrackpath_outloop) '}(' int2txt(i) ',' int2txt(j) ')=' float2txt(5,x_crackcenter{icrackpath_outloop}(i,j)) char(10)]);
								x_crack.top(i,j,icrackpath_outloop)=x_crack.center(i,j,icrackpath_outloop);
								x_crack.bot(i,j,icrackpath_outloop)=x_crack.center(i,j,icrackpath_outloop);
							end
						end
						%shit below
						%x_cracktop{icrackpath_outloop}=x_crackcenter{icrackpath_outloop};
						%x_crackbot{icrackpath_outloop}=x_crackcenter{icrackpath_outloop};
						%shit above
					end
					%soundplay
					1;
				end
				%{
				%switchable1
				soundplay;
				%}
				%switchable1
				1; %pause multi average and propagate here
			end
			
		end
		fprintf('%s',['marker #644' char(10)]);
	elseif CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 %average and propagate
		if sum(justcracked)>0
			justcrackedlist=zeros(sum(justcracked),1);
			justcrackedcounter=0;
			for sp=1:spCount
				if justcracked(sp)
					justcrackedcounter=justcrackedcounter+1;
					justcrackedlist(justcrackedcounter)=sp;
				end
			end
			justcrackedlist=CrackParticleClustering(x_sp,le(1),justcrackedlist);
			ntestedangle=size(Qacoustic{justcrackedlist{1}(1)},3);
			theta=zeros(ntestedangle,1);
			errorntestedangle=36*1*1*1;
			error=zeros(1,errorntestedangle)
			
			AbeforeQ=zeros(2,2,2,2,spCount);
			% grouping just done
			for crackgroup=1:length(justcrackedlist)
				justcrackedcounter=length(justcrackedlist{crackgroup});
				for nspcracked=1:justcrackedcounter;
					for i=1:2
					for j=1:2
					for k=1:2
					for l=1:2
					for p=1:2
					for q=1:2
					for m=1:2
					for nn=1:2
						AbeforeQ(i,j,k,l,justcrackedlist{crackgroup}(nspcracked))=AbeforeQ(i,j,k,l,justcrackedlist{crackgroup}(nspcracked))+QbackRback(i,p,justcrackedlist{crackgroup}(nspcracked))*QbackRback(j,q,justcrackedlist{crackgroup}(nspcracked))*QbackRback(k,m,justcrackedlist{crackgroup}(nspcracked))*QbackRback(l,nn,justcrackedlist{crackgroup}(nspcracked))*AbeforeQ_rtl(p,q,m,nn,justcrackedlist{crackgroup}(nspcracked));
					end
					end
					end
					end
					end
					end
					end
					end
					Qacoustic{justcrackedlist{crackgroup}(nspcracked)}=zeros(size(Qacoustic{justcrackedlist{crackgroup}(nspcracked)}));
					for itestedangle=1:ntestedangle
						theta(itestedangle)=itestedangle/ntestedangle*2*pi;
						n(1)=cos(theta(itestedangle));
						n(2)=sin(theta(itestedangle));
						for m=1:2
						for nn=1:2
						for o=1:2
						for p=1:2
							Qacoustic{justcrackedlist{crackgroup}(nspcracked)}(nn,o,itestedangle)=Qacoustic{justcrackedlist{crackgroup}(nspcracked)}(nn,o,itestedangle)+n(m)*AbeforeQ(m,nn,o,p,justcrackedlist{crackgroup}(nspcracked))*n(p);
						end
						end
						end
						end
					end
				end
				x_justcrackedcenter=zeros(2,1);
				x_justcrackedcenter(1)=sum(x_sp(justcrackedlist{crackgroup},1))/justcrackedcounter;
				x_justcrackedcenter(2)=sum(x_sp(justcrackedlist{crackgroup},2))/justcrackedcounter;
				if CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 %case 80 uses Q average
					%ntestedangle=size(Qacoustic{justcrackedlist{crackgroup}(1)},3);
					lambda1_avg=zeros(ntestedangle,1);
					lambda2_avg=zeros(ntestedangle,1);
					%theta=zeros(ntestedangle,1);
					%n=zeros(2,1);
					h_avg=zeros(2,2,ntestedangle); %1st index: direction; 2nd index: which lambda; 3rd index: which
					%{
					for i=1:justcrackedcounter
						for j=1:ntestedangle
							Qacoustic{justcrackedlist{crackgroup}(i)}(:,:,j)=(QbackRback(:,:,justcrackedlist{crackgroup}(i)))*Qacoustic{justcrackedlist{crackgroup}(i)}(:,:,j)*transpose(QbackRback(:,:,justcrackedlist{crackgroup}(i)));
						end
					end
					%}
					Qacoustic_avg=zeros(2,2,ntestedangle);
					dudx_avg=zeros(2,2);
					for i=1:justcrackedcounter
						if i==1
							Qacoustic_avg=Qacoustic{justcrackedlist{crackgroup}(i)};
							dudx_avg=[dudx_sp(justcrackedlist{crackgroup}(i),1) dudx_sp(justcrackedlist{crackgroup}(i),2);dudx_sp(justcrackedlist{crackgroup}(i),3) dudx_sp(justcrackedlist{crackgroup}(i),4)];
							%h_avg=h{justcrackedlist{crackgroup}(i)};
						else
							Qacoustic_avg=Qacoustic_avg+Qacoustic{justcrackedlist{crackgroup}(i)};
							dudx_avg=dudx_avg+[dudx_sp(justcrackedlist{crackgroup}(i),1) dudx_sp(justcrackedlist{crackgroup}(i),2);dudx_sp(justcrackedlist{crackgroup}(i),3) dudx_sp(justcrackedlist{crackgroup}(i),4)];
							%h_avg=h_avg+h{justcrackedlist{crackgroup}(i)};
						end
					end
					Qacoustic_avg=Qacoustic_avg/justcrackedcounter;
					dudx_avg=dudx_avg/justcrackedcounter;
					%h_avg=h_avg/justcrackedcounter;
					for i=1:ntestedangle
						theta(i)=i/ntestedangle*2*pi;
						n(1)=cos(theta(i));
						n(2)=sin(theta(i));
						[h_eig,lambda_eig]=eig(Qacoustic_avg(:,:,i));
						h_avg(:,:,i)=real(h_eig);
						lambda1_avg(i)=real(lambda_eig(1,1));
						lambda2_avg(i)=real(lambda_eig(2,2));
					end
					lambdamin=min([lambda1_avg;lambda2_avg]);
					if length(lambdamin)>1
						fprintf('%s',['length(lamdabmin)>1!' char(10)]);
						pause;
						1;
					end
					lambdaminlessthanzero=1; % switcher for making sure the averaged acoustic tensor still has less than zero eigen value(s). firstly assumed that it is, unless proven otherwise below.
					if lambdamin>0
						fprintf('%s',['Warning, lamdamin>0 on avg(Q)!' char(10)]);
						fprintf('%s',['Ditching average acoustic tensor, switching to individual acoustic tensor' char(10)]);
						lambdaminlessthanzero=0;
						%pause;
						1;
					end
					if lambdaminlessthanzero==1
						localminima1index=zeros(1,0);
						localminima2index=zeros(1,0);
						for i=1:ntestedangle
							if lambda1_avg(i)<0 && lambda1_avg(i)<=lambda1_avg(mod((i-1)-1,ntestedangle)+1) && lambda1_avg(i)<=lambda1_avg(mod((i+1)-1,ntestedangle)+1)
							%if lambda1_avg(i)<=lambda1_avg(mod((i-1)-1,ntestedangle)+1) && lambda1_avg(i)<=lambda1_avg(mod((i+1)-1,ntestedangle)+1)
								localminima1index=[localminima1index i];
							end
							if lambda2_avg(i)<0 && lambda2_avg(i)<=lambda2_avg(mod((i-1)-1,ntestedangle)+1) && lambda2_avg(i)<=lambda2_avg(mod((i+1)-1,ntestedangle)+1)
							%if lambda2_avg(i)<=lambda2_avg(mod((i-1)-1,ntestedangle)+1) && lambda2_avg(i)<=lambda2_avg(mod((i+1)-1,ntestedangle)+1)
								localminima2index=[localminima2index i];
							end
						end
						nldudxhl=zeros(length(localminima1index)+length(localminima2index),1);
						h_localminima=zeros(2,length(localminima1index)+length(localminima2index));
						for i=1:length(localminima1index)
							n(1)=cos(theta(localminima1index(i)));
							n(2)=sin(theta(localminima1index(i)));
							nldudxhl(i)=transpose(n)*dudx_avg*h_avg(:,1,localminima1index(i));
							h_localminima(:,i)=h_avg(:,1,localminima1index(i));
						end
						for i=1:length(localminima2index)
							n(1)=cos(theta(localminima2index(i)));
							n(2)=sin(theta(localminima2index(i)));
							nldudxhl(i+length(localminima1index))=transpose(n)*dudx_avg*h_avg(:,2,localminima2index(i));
							h_localminima(:,i+length(localminima1index))=h_avg(:,2,localminima2index(i));
						end
						localminimaindex=[localminima1index localminima2index];
						FindMaxnldudxhl=FindMax(nldudxhl); %I put FindMax(nldudxhl) to a variable FindMaxnldudxhl as I need to call it twice. Better to save the result rather than calling the function twice.
						crackindex=localminimaindex(FindMaxnldudxhl);
						thetamin=theta(crackindex);
						thetacrack_avg=mod(thetamin+pi/2+pi/2,pi)-pi/2;
						1; %pause average Q calculation
						for i=1:justcrackedcounter
							thetacrack(justcrackedlist{crackgroup}(i))=thetacrack_avg;
							thetacrackrtl(justcrackedlist{crackgroup}(i))=thetacrack_avg-reliableatan(RQ(1,1,justcrackedlist{crackgroup}(i)),RQ(1,2,justcrackedlist{crackgroup}(i)));
						end
						thetajustcrackedcenter=thetacrack_avg;
						1;
					else
						for i=1:errorntestedangle
							theta(i)=(i-1)/36*1*1*1*pi;
							error(i)=0;
							for spc=1:justcrackedcounter
								error(i)=error(i)+(mod(thetacrack(justcrackedlist{crackgroup}(spc))-theta(i)+pi/2,pi)-pi/2)^2;
							end
						end
						thetajustcrackedcenter=theta(FindMin(error));
						1;
					end
				else
					for i=1:errorntestedangle
						theta(i)=(i-1)/36*1*1*1*pi;
						error(i)=0;
						for spc=1:justcrackedcounter
							error(i)=error(i)+(mod(thetacrack(justcrackedlist{crackgroup}(spc))-theta(i)+pi/2,pi)-pi/2)^2;
						end
					end
					thetajustcrackedcenter=theta(FindMin(error));
				end
				if CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110
					considered=ones(length(x_crack),2);
					distancelist=zeros(length(x_crack),2);
					thetapropagationlist=zeros(length(x_crack),2);
					n_nairncrack0=0;
					n_nairncrack1=0;
					for icrackpath=length(x_crack):-1:1
						for whichtip=1:2
							if whichtip==1
								n_nairncrack1=size(x_crack{icrackpath},1);
								n_nairncrack0=n_nairncrack1-1;
							elseif whichtip==2
								n_nairncrack1=1;
								n_nairncrack0=2;
							else
								fprintf('%s',['whichtip error! 1904151959' char(10)]);
								pause;
								1;
							end
							x_cracktip=x_crack{icrackpath}(n_nairncrack1,:);
							thetatocrackcenter=reliableatan(x_justcrackedcenter(1)-x_cracktip(1),x_justcrackedcenter(2)-x_cracktip(2));
							theta_prev=reliableatan(x_crack{icrackpath}(n_nairncrack1,1)-x_crack{icrackpath}(n_nairncrack0,1),x_crack{icrackpath}(n_nairncrack1,2)-x_crack{icrackpath}(n_nairncrack0,2));
							deltatheta_tocrackvsprev=mod(thetatocrackcenter-theta_prev+pi,2*pi)-pi;
							if abs(deltatheta_tocrackvsprev)>pi
								fprintf('%s',['deltatheta_tocrackvsprev error! 1904112048' char(10)]);
								pause;
								1;
							end
							if abs(deltatheta_tocrackvsprev)>pi/2
								considered(icrackpath,whichtip)=0;
								distancelist(icrackpath,whichtip)=inf;
								continue;
							end
							propagationlength=sqrt((x_crack{icrackpath}(n_nairncrack1,1)-x_justcrackedcenter(1))^2+(x_crack{icrackpath}(n_nairncrack1,2)-x_justcrackedcenter(2))^2);
							if propagationlength>1.5*le(1)
								considered(icrackpath,whichtip)=0;
								distancelist(icrackpath,whichtip)=inf;
								continue;
							end
							distancelist(icrackpath,whichtip)=propagationlength;
							for i=1:36*1*1*1
								theta(i)=(i-1)/36*1*1*1*2*pi;
								error(i)=(mod(thetajustcrackedcenter-theta(i)+pi/2,pi)-pi/2)^2+(mod(thetatocrackcenter-theta(i)+pi,2*pi)-pi)^2;
							end
							theta_crackpropagation=theta(FindMin(error));
							theta_crackpropagation=mod(theta_crackpropagation-theta_prev+pi,2*pi)+theta_prev-pi;
							thetapropagationlist(icrackpath,whichtip)=theta_crackpropagation;
						end
					end
					if sum(sum(considered))>0
						ncrackandwhichtip=FindMinMatrix(distancelist);
						icrackpath_outloop=ncrackandwhichtip(1);
						whichtip=ncrackandwhichtip(2);
						if whichtip==1
							n_nairncrack1=size(x_crack{icrackpath_outloop},1);
						else
							n_nairncrack1=1;
						end
						propagationlength=distancelist(icrackpath_outloop,whichtip);
						theta_crackpropagation=thetapropagationlist(icrackpath_outloop,whichtip);
						idealpropagationlength=le(1)/4; %assuming lp(1)==lp(2)
						%propagationlengthreductionfactor=max([1 round(propagationlength/idealpropagationlength)]);
						propagationlengthreductionfactor=1;
						if whichtip==1
							for i=1:propagationlengthreductionfactor
								x_crack{icrackpath_outloop}(n_nairncrack1+i,:)=[x_crack{icrackpath_outloop}(n_nairncrack1,1)+i/propagationlengthreductionfactor*propagationlength*cos(theta_crackpropagation) x_crack{icrackpath_outloop}(n_nairncrack1,2)+i/propagationlengthreductionfactor*propagationlength*sin(theta_crackpropagation)];
								x_cracktop{icrackpath_outloop}(n_nairncrack1+i,:)=x_crack{icrackpath_outloop}(n_nairncrack1+i,:);
								x_crackbot{icrackpath_outloop}(n_nairncrack1+i,:)=x_crack{icrackpath_outloop}(n_nairncrack1+i,:);
							end
						elseif whichtip==2
							for i=size(x_crack{icrackpath_outloop},1):-1:1
								x_crack{icrackpath_outloop}(i+propagationlengthreductionfactor,:)=x_crack{icrackpath_outloop}(i,:);
								x_cracktop{icrackpath_outloop}(i+propagationlengthreductionfactor,:)=x_cracktop{icrackpath_outloop}(i,:);
								x_crackbot{icrackpath_outloop}(i+propagationlengthreductionfactor,:)=x_crackbot{icrackpath_outloop}(i,:);
							end
							n_nairncrack1=n_nairncrack1+propagationlengthreductionfactor;
							for i=1:propagationlengthreductionfactor
								x_crack{icrackpath_outloop}(n_nairncrack1-i,:)=[x_crack{icrackpath_outloop}(n_nairncrack1,1)+i/propagationlengthreductionfactor*propagationlength*cos(theta_crackpropagation) x_crack{icrackpath_outloop}(n_nairncrack1,2)+i/propagationlengthreductionfactor*propagationlength*sin(theta_crackpropagation)];
								x_cracktop{icrackpath_outloop}(n_nairncrack1-i,:)=x_crack{icrackpath_outloop}(n_nairncrack1-i,:);
								x_crackbot{icrackpath_outloop}(n_nairncrack1-i,:)=x_crack{icrackpath_outloop}(n_nairncrack1-i,:);

							end
						else
							fprintf('%s',['which tip error! 1904151909' char(10)]);
							pause
							1;
						end
					else
						intheprevention=0;
						preventiondistance=le(1)/2;
						preventionangle=pi/4;
						for icrackpath=1:length(x_crack);
							for spcrack=1:(size(x_crack{icrackpath},1)-1)
								vector1a=[(x_justcrackedcenter(1)-x_crack{icrackpath}(spcrack,1));(x_justcrackedcenter(2)-x_crack{icrackpath}(spcrack,2))];
								vector1b=[(x_justcrackedcenter(1)-x_crack{icrackpath}(spcrack+1,1));(x_justcrackedcenter(2)-x_crack{icrackpath}(spcrack+1,2))];
								distance1a=sqrt(dot(vector1a,vector1a));
								distance1b=sqrt(dot(vector1b,vector1b));
								
								distance1a_old=sqrt((x_justcrackedcenter(1)-x_crack{icrackpath}(spcrack,1))^2+(x_justcrackedcenter(2)-x_crack{icrackpath}(spcrack,2))^2);
								distance1b_old=sqrt((x_justcrackedcenter(1)-x_crack{icrackpath}(spcrack+1,1))^2+(x_justcrackedcenter(2)-x_crack{icrackpath}(spcrack+1,2))^2);
								
								distance1=min([distance1a distance1b]);
								
								area2=abs(TriangleArea(x_justcrackedcenter,x_crack{icrackpath}(spcrack,:),x_crack{icrackpath}(spcrack+1,:)));
								
								inbetween2vector=[(x_crack{icrackpath}(spcrack+1,1)-x_crack{icrackpath}(spcrack,1));(x_crack{icrackpath}(spcrack+1,2)-x_crack{icrackpath}(spcrack,2))];
								
								inbetween2=sqrt(dot(inbetween2vector,inbetween2vector));
								
								inbetween2_old=sqrt((x_crack{icrackpath}(spcrack+1,1)-x_crack{icrackpath}(spcrack,1))^2+(x_crack{icrackpath}(spcrack+1,2)-x_crack{icrackpath}(spcrack,2))^2);
								distance2=area2/inbetween2;
								
								signcos1=dot(vector1a,inbetween2vector);
								signcos2=dot(vector1b,inbetween2vector);
								
								if signcos1*signcos2>0
									distance=distance1;
								else
									distance=distance2;
								end
								
								if distance<preventiondistance
									thetanairncrack=reliableatan(x_crack{icrackpath}(spcrack+1,1)-x_crack{icrackpath}(spcrack,1),x_crack{icrackpath}(spcrack+1,2)-x_crack{icrackpath}(spcrack,2));
									
									absdeltatheta=abs(mod(thetanairncrack-thetajustcrackedcenter+pi/2,pi)-pi/2);
									
									if absdeltatheta<preventionangle
										intheprevention=1;
									end
								end
								if intheprevention==1
									break;
								end
							end
							if intheprevention==1
								break;
							end
						end
						if intheprevention==0
							thetainitiate=mod(thetajustcrackedcenter-pi,pi)+pi; %always pointing down, pi<theta<2*pi
							icrackpath_outloop=length(x_crack)+1;
							x_crack{icrackpath_outloop}(2,2)=x_justcrackedcenter(2)+le(1)/2/2*sin(thetainitiate); %assuming le(1)=le(2);
							x_crack{icrackpath_outloop}(2,1)=x_justcrackedcenter(1)+le(1)/2/2*cos(thetainitiate);
							x_crack{icrackpath_outloop}(1,2)=x_justcrackedcenter(2)-le(1)/2/2*sin(thetainitiate);
							x_crack{icrackpath_outloop}(1,1)=x_justcrackedcenter(1)-le(1)/2/2*cos(thetainitiate);
							x_cracktop{icrackpath_outloop}=x_crack{icrackpath_outloop};
							x_crackbot{icrackpath_outloop}=x_crack{icrackpath_outloop};
						end
						%soundplay
						1;
					end
					%{
					%switchable1
					soundplay;
					%}
					%switchable1
					1; %pause multi average and propagate here
				else
					n_nairncrack=size(x_crack,1);
					x_cracktip=x_crack(n_nairncrack,:);
					thetatocrackcenter=reliableatan(x_justcrackedcenter(1)-x_cracktip(1),x_justcrackedcenter(2)-x_cracktip(2));
					theta_prev=reliableatan(x_crack(n_nairncrack,1)-x_crack(n_nairncrack-1,1),x_crack(n_nairncrack,2)-x_crack(n_nairncrack-1,2));
					propagationlength=sqrt((x_crack(n_nairncrack,1)-x_justcrackedcenter(1))^2+(x_crack(n_nairncrack,2)-x_justcrackedcenter(2))^2);
					idealpropagationlength=le(1)/4; %assuming lp(1)==lp(2)
					propagationlengthreductionfactor=max([1 round(propagationlength/idealpropagationlength)]);
					for i=1:36*1*1*1
						theta(i)=(i-1)/36*1*1*1*2*pi;
						error(i)=(mod(thetajustcrackedcenter-theta(i)+pi/2,pi)-pi/2)^2+(mod(thetatocrackcenter-theta(i)+pi,2*pi)-pi)^2;
					end
					theta_crackpropagation=theta(FindMin(error));
					theta_crackpropagation=mod(theta_crackpropagation-theta_prev+pi,2*pi)+theta_prev-pi;
					for i=1:propagationlengthreductionfactor
						x_crack.center(n_nairncrack+i,:,1)=[x_crack(n_nairncrack,1)+i/propagationlengthreductionfactor*propagationlength*cos(theta_crackpropagation) x_crack(n_nairncrack,2)+i/propagationlengthreductionfactor*propagationlength*sin(theta_crackpropagation)];
						x_crack.top(n_nairncrack+i,:,1)=x_crack(n_nairncrack+i,:);
						x_crack.bot(n_nairncrack+i,:,1)=x_crack(n_nairncrack+i,:);
					end
					1; %pause average and propagate here
				end
			end
			% grouping effect stops
		end
	elseif CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120
		%start function for calculating J integral
		K_sp=0.5*(p_sp.*(v_ssp_out(:,1).^2 + v_ssp_out(:,2).^2));
		n_tip=size(x_crack{1},1);
		x_tip=x_crack{1}(n_tip,:);
		ni_Jcenter=FindMax(Nmatrix_cracktop{1}(:,n_tip));
		if length(x_crack)>1
			fprintf('%s',['too many icrackpath! 1905132233' char(10)]);
			pause
			1;
		end
		if mod(refinementfactor,2)==0
		else
			fprintf('%s',['refinement factor has to be even! 1905132234' char(10)]);
			pause
			1;
		end
		expansion=0.5*refinementfactor;
		n_pointperside=2*expansion+1;
		
		%listing surrounding nodes in counter-clockwise order
		ni_list{4}(n_pointperside)=0;
		ni_list{3}(n_pointperside)=0;
		ni_list{2}(n_pointperside)=0;
		ni_list{1}(n_pointperside)=0;
		%ni_list index: 1 = left, 2 = bottom, 3 = right, 4 = top
		
		for i=1:n_pointperside
			ni_list{1}(i)=ni_Jcenter-expansion+expansion*NN(1)-(i-1)*NN(1);
			ni_list{2}(i)=ni_Jcenter-expansion*NN(1)-expansion+(i-1);
			ni_list{3}(i)=ni_Jcenter+expansion-expansion*NN(1)+(i-1)*NN(1);
			ni_list{4}(i)=ni_Jcenter+expansion*NN(1)+expansion-(i-1);
		end
		
		
		for toporbot=1:2
			sidebreaksignal=0;
			for crackline=(n_tip-1):-1:1
				for side=1:4
					for sideline=1:(length(ni_list{side})-1)
						if side==3 && sideline==2 && crackline==2
							1;
						end
						x1=LOC(ni_list{side}(sideline),:);
						x2=LOC(ni_list{side}(sideline+1),:);
						if toporbot==1
							x3=x_cracktop{1}(crackline,:);
							x4=x_cracktop{1}(crackline+1,:);
							[CrossDir,RelativeLocation]=FindCrossing(x1,x2,x3,x4);
						elseif toporbot==2
							x3=x_crackbot{1}(crackline,:);
							x4=x_crackbot{1}(crackline+1,:);
							[CrossDir,RelativeLocation]=FindCrossing(x1,x2,x3,x4);
						end
						if CrossDir>0
							sidebreaksignal=1;
							break;
						end
					end
					if sidebreaksignal==1
						break;
					end
				end
				if sidebreaksignal==1
					break;
				end
			end
			if toporbot==1
				crackline_top=crackline;
				side_top=side;
				sideline_top=sideline;
				CrossDir_top=CrossDir;
				RelativeLocation_top=RelativeLocation;
			elseif toporbot==2
				crackline_bot=crackline;
				side_bot=side;
				sideline_bot=sideline;
				CrossDir_bot=CrossDir;
				RelativeLocation_bot=RelativeLocation;
			end
		end
		nfield=3;
		nNodes=size(CONNECTpn,1);
		M_ni=zeros(nNodes,nfield);
		MW_ni=zeros(nNodes,nfield);
		Mdudx_ni=zeros(nNodes,4,nfield);
		Ms_ni=zeros(nNodes,3,nfield);
		MK_ni=zeros(nNodes,nfield);
		
		%{
		for npid=1:nNodes
			for nsp=1:size(TheFieldSplitBase3_old{ni},1)
				sp=CONNECTpn(ni,nsp);
				if N{sp}()==0 || m_sp(sp)==0
					continue
				end
				M_ni(npid,TheFieldSplitBase3_old(npid,sp))            = M_ni(npid,TheFieldSplitBase3_old(npid,sp)) + m_sp(sp)*N{sp}(j);
				MW_ni(npid,TheFieldSplitBase3_old(npid,sp))            = MW_ni(npid,TheFieldSplitBase3_old(npid,sp)) + (m_sp(sp)*W_sp(sp))*N{sp}(j);
				Mdudx_ni(npid,:,TheFieldSplitBase3_old(npid,sp))            = Mdudx_ni(npid,:,TheFieldSplitBase3_old(npid,sp)) + (m_sp(sp)*dudx_sp(sp,:))*N{sp}(j);
				Ms_ni(npid,:,TheFieldSplitBase3_old(npid,sp))            = Ms_ni(npid,:,TheFieldSplitBase3_old(npid,sp)) + (m_sp(sp)*s_sp(sp,:))*N{sp}(j);
				MK_ni(npid,TheFieldSplitBase3_old(npid,sp))            = MK_ni(npid,TheFieldSplitBase3_old(npid,sp)) + (m_sp(sp)*K_sp(sp))*N{sp}(j);
			end
		end
		%}
		for sp=1:spCount
			for j=1:NODES(sp)
				npid                           = CONNECT{sp}(j);
				if N{sp}(j)==0 || m_sp(sp)==0
					continue
				end
				M_ni(npid,TheFieldSplitBase3{sp}(j,1))            = M_ni(npid,TheFieldSplitBase3{sp}(j,1)) + m_sp(sp)*N{sp}(j);
				MW_ni(npid,TheFieldSplitBase3{sp}(j,1))            = MW_ni(npid,TheFieldSplitBase3{sp}(j,1)) + (m_sp(sp)*W_sp(sp))*N{sp}(j);
				Mdudx_ni(npid,:,TheFieldSplitBase3{sp}(j,1))            = Mdudx_ni(npid,:,TheFieldSplitBase3{sp}(j,1)) + (m_sp(sp)*dudx_sp(sp,:))*N{sp}(j);
				Ms_ni(npid,:,TheFieldSplitBase3{sp}(j,1))            = Ms_ni(npid,:,TheFieldSplitBase3{sp}(j,1)) + (m_sp(sp)*s_sp(sp,:))*N{sp}(j);
				MK_ni(npid,TheFieldSplitBase3{sp}(j,1))            = MK_ni(npid,TheFieldSplitBase3{sp}(j,1)) + (m_sp(sp)*K_sp(sp))*N{sp}(j);
			end 
		end
		
		sidegap=mod(side_bot-side_top,4);
		J1=0;
		J2=0;
		hoopstress=[];
		hooptheta=[];
		hoopindex=0;
		dudx_ni_before=zeros(1,4);
		dudx_ni_after=zeros(1,4);
		s_ni_before=zeros(1,3);
		s_ni_after=zeros(1,3);
		n=zeros(2,1);
		for relativeside=0:4-sidegap
			side=mod(side_bot-1+relativeside,4)+1;
			startsidenode=1;
			endsidenode=(2*expansion)+1;
			if relativeside==0
				startsidenode=sideline_bot;
			elseif relativeside==4-sidegap
				endsidenode=sideline_top+1;
			end
			for sideline=startsidenode:endsidenode-1
				nodebefore=ni_list{side}(sideline);
				nodeafter=ni_list{side}(sideline+1);
				if relativeside==0 || relativeside==1
					sumsequence=1:2:3;
				elseif relativeside==(4-sidegap) || relativeside==(4-sidegap-1)
					sumsequence=1:2;
				else
					sumsequence=1:3;
				end
				M_before=sum(M_ni(nodebefore,sumsequence));
				if M_before==0
					W_ni_before=0;
					dudx_ni_before(1:4)=0;
					s_ni_before(1:3)=0;
					K_ni_before=0;
				else
					W_ni_before=sum(MW_ni(nodebefore,sumsequence))/M_before;
					K_ni_before=sum(MK_ni(nodebefore,:))/M_before;
					for index=1:4
						dudx_ni_before(index)=sum(Mdudx_ni(nodebefore,index,sumsequence))/M_before;
					end
					for index=1:3
						s_ni_before(index)=sum(Ms_ni(nodebefore,index,sumsequence))/M_before;
					end
				end
				M_after=sum(M_ni(nodeafter,sumsequence));
				if M_after==0
					W_ni_after=0;
					dudx_ni_after(1:4)=0;
					s_ni_after(1:3)=0;
					K_ni_after=0;
				else
					W_ni_after=sum(MW_ni(nodeafter,sumsequence))/M_after;
					K_ni_after=sum(MK_ni(nodeafter,:))/M_after;
					for index=1:4
						dudx_ni_after(index)=sum(Mdudx_ni(nodeafter,index,sumsequence))/M_after;
					end
					for index=1:3
						s_ni_after(index)=sum(Ms_ni(nodeafter,index,sumsequence))/M_after;
					end
				end
				if relativeside==0 && sideline==startsidenode
					hoopindex=hoopindex+1;
					currentnode=nodebefore;
					hooptheta=VectorInsertion(hooptheta,hoopindex,reliableatan(LOC(currentnode,1)-x_crack{1}(n_tip,1),LOC(currentnode,2)-x_crack{1}(n_tip,2)));
					Q=[cos(hooptheta(hoopindex)) sin(hooptheta(hoopindex));-sin(hooptheta(hoopindex)) cos(hooptheta(hoopindex))];
					oldsigma=[s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)];
					newsigma=Q*oldsigma*transpose(Q);
					hoopstress=VectorInsertion(hoopstress,hoopindex,newsigma(2,2));
				end
				
				hoopindex=hoopindex+1;
				currentnode=nodeafter;
				hooptheta=VectorInsertion(hooptheta,hoopindex,reliableatan(LOC(currentnode,1)-x_crack{1}(n_tip,1),LOC(currentnode,2)-x_crack{1}(n_tip,2)));
				Q=[cos(hooptheta(hoopindex)) sin(hooptheta(hoopindex));-sin(hooptheta(hoopindex)) cos(hooptheta(hoopindex))];
				oldsigma=[s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)];
				newsigma=Q*oldsigma*transpose(Q);
				hoopstress=VectorInsertion(hoopstress,hoopindex,newsigma(2,2));
				
				if side==1
					n(1,1)=-1;
					n(2,1)=0;
				elseif side==2
					n(1,1)=0;
					n(2,1)=-1;
				elseif side==3
					n(1,1)=1;
					n(2,1)=0;
				elseif side==4
					n(1,1)=0;
					n(2,1)=1;
				end
				
				F1before=(W_ni_before+K_ni_before)*n(1)-dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(1);dudx_ni_before(3)]);
				F2before=(W_ni_before+K_ni_before)*n(2)-dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(2);dudx_ni_before(4)]);
				
				F1after=(W_ni_after+K_ni_after)*n(1)-dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(1);dudx_ni_after(3)]);
				F2after=(W_ni_after+K_ni_after)*n(2)-dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(2);dudx_ni_after(4)]);
				
				
				%The following is just for debugging purposes:
				%{
				W_ni_before_track(side,sideline)=W_ni_before;
				W_ni_after_track(side,sideline)=W_ni_after;
				W_ni_track(side,sideline)=(W_ni_before+W_ni_after)/2;
				
				K_ni_before_track(side,sideline)=K_ni_before;
				K_ni_after_track(side,sideline)=K_ni_after;
				K_ni_track(side,sideline)=(K_ni_before+K_ni_after)/2;
				
				n1(side,sideline)=n(1);
				n2(side,sideline)=n(2);
				
				indot1_before_track(side,sideline)=dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(1);dudx_ni_before(3)]);
				indot1_after_track(side,sideline)=dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(1);dudx_ni_after(3)]);
				indot1_track(side,sideline)=(indot1_before_track(side,sideline)+indot1_after_track(side,sideline))/2;
				
				s_ni_1_before_track(side,sideline)=s_ni_before(1);
				s_ni_2_before_track(side,sideline)=s_ni_before(2);
				s_ni_3_before_track(side,sideline)=s_ni_before(3);
				
				s_ni_1_after_track(side,sideline)=s_ni_after(1);
				s_ni_2_after_track(side,sideline)=s_ni_after(2);
				s_ni_3_after_track(side,sideline)=s_ni_after(3);
				
				dudx_ni_1_before_track(side,sideline)=dudx_ni_before(1);
				dudx_ni_2_before_track(side,sideline)=dudx_ni_before(2);
				dudx_ni_3_before_track(side,sideline)=dudx_ni_before(3);
				dudx_ni_4_before_track(side,sideline)=dudx_ni_before(4);
				
				dudx_ni_1_after_track(side,sideline)=dudx_ni_after(1);
				dudx_ni_2_after_track(side,sideline)=dudx_ni_after(2);
				dudx_ni_3_after_track(side,sideline)=dudx_ni_after(3);
				dudx_ni_4_after_track(side,sideline)=dudx_ni_after(4);
				
				dudx_ni_1_avg_track(side,sideline)=(dudx_ni_before(1)+dudx_ni_after(1))/2;
				dudx_ni_2_avg_track(side,sideline)=(dudx_ni_before(2)+dudx_ni_after(2))/2;
				dudx_ni_3_avg_track(side,sideline)=(dudx_ni_before(3)+dudx_ni_after(3))/2;
				dudx_ni_4_avg_track(side,sideline)=(dudx_ni_before(4)+dudx_ni_after(4))/2;
				
				s_ni_1_avg(side,sideline)=(s_ni_1_before_track(side,sideline)+s_ni_1_after_track(side,sideline))/2;
				s_ni_2_avg(side,sideline)=(s_ni_2_before_track(side,sideline)+s_ni_2_after_track(side,sideline))/2;
				s_ni_3_avg(side,sideline)=(s_ni_3_before_track(side,sideline)+s_ni_3_after_track(side,sideline))/2;
				
				indot2_before_track(side,sideline)=dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(2);dudx_ni_before(4)]);
				indot2_after_track(side,sideline)=dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(2);dudx_ni_after(4)]);
				indot2_track(side,sideline)=(indot2_before_track(side,sideline)+indot2_after_track(side,sideline))/2;
				
				W_ni_contributionto1(side,sideline)=W_ni_track(side,sideline)*n1(side,sideline);
				W_ni_contributionto2(side,sideline)=W_ni_track(side,sideline)*n2(side,sideline);
				
				K_ni_contributionto1(side,sideline)=K_ni_track(side,sideline)*n1(side,sideline);
				K_ni_contributionto2(side,sideline)=K_ni_track(side,sideline)*n2(side,sideline);
				%}
				
				
				if relativeside==0 && sideline==startsidenode
					F1before=F1before*(1-RelativeLocation_bot)+F1after*(RelativeLocation_bot);
					F2before=F2before*(1-RelativeLocation_bot)+F2after*(RelativeLocation_bot);
					deltai=(1-RelativeLocation_bot)*le(1); %assuming square grid
				elseif relativeside==4-sidegap && sideline==endsidenode-1
					F1after=F1before*(1-RelativeLocation_top)+F1after*(RelativeLocation_top);
					F2after=F2before*(1-RelativeLocation_top)+F2after*(RelativeLocation_top);
					deltai=RelativeLocation_top*le(1); %assuming square grid
				end
				
				%The following is just for debugging purposes:
				%{				
				F1before_store(side,sideline)=F1before;
				F2before_store(side,sideline)=F2before;
				F1after_store(side,sideline)=F1after;
				F2after_store(side,sideline)=F2after;
				%}
				
				J1=J1+(F1before+F1after)/2*deltai;
				J2=J2+(F2before+F2after)/2*deltai;
			end
		end
		deltax_crack=x_crack{1}(n_tip,1)-x_crack{1}(n_tip-1,1);
		deltay_crack=x_crack{1}(n_tip,2)-x_crack{1}(n_tip-1,2);
		
		
		thetacold=reliableatan(deltax_crack,deltay_crack);
		%thetac=reliableatan(J1,J2);
		%thetac=thetacold;
		%thetac=thetamin;
		maxhoopstresssofar=[];
		for i=1:length(hooptheta)
			deltathetac=mod((hooptheta(i)-thetacold)+pi,2*pi)-pi;
			if deltathetac<-pi/2 || deltathetac>pi/2
				continue;
			end
			if length(maxhoopstresssofar)==0
				maxhoopstresssofar=hoopstress(i);
				maxhoopstressnumsofar=i;
			else
				if hoopstress(i)>maxhoopstresssofar
					maxhoopstresssofar=hoopstress(i);
					maxhoopstressnumsofar=i;
				end
			end
		end
		thetac=hooptheta(maxhoopstressnumsofar);
		if CasetoRun==116 || CasetoRun==117 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==120 || CasetoRun==121
			thetac=0;
		end
		deltathetac=mod((thetac-thetacold)+pi,2*pi)-pi;
		newcrackdistance=sqrt(deltax_crack^2+deltay_crack^2);
		G=J1*cos(thetac)+J2*sin(thetac);
		%disp(['G=' num2str(G) ', thetac=' num2str(thetac*180/3.1415926536) ' degrees']);
	else
		%start function for calculating J integral
		K_sp=0.5*(p_sp.*(v_ssp_out(:,1).^2 + v_ssp_out(:,2).^2));
		n_tip=size(x_crack,1);
		x_tip=x_crack(n_tip,:);
		ni_Jcenter=FindMax(Nmatrix_crack(:,n_tip));
		if CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77
			for moveJcenterrepeate=0:999999
				if LOC(ni_Jcenter,2)>50-expansion*le(2)
					ni_Jcenter=ni_Jcenter-NN(1);
				elseif LOC(ni_Jcenter,2)<10+expansion*le(2)
					ni_Jcenter=ni_Jcenter+NN(1);
					expansion=2;
				elseif CasetoRun==69
					expansion=2;
				else
					expansion=2;
				end
				if CasetoRun==71
				else
					break;
					1;
				end
			end
		elseif CasetoRun==72
			for moveJcenterrepeate=0:999999
				if LOC(ni_Jcenter,2)>40-expansion*le(2)
					ni_Jcenter=ni_Jcenter-NN(1);
				elseif LOC(ni_Jcenter,2)<10+expansion*le(2)
					ni_Jcenter=ni_Jcenter+NN(1);
				else
					break;
					1;
				end
			end
		end
		
		n_pointperside=2*expansion+1;
		
		%listing surrounding nodes in counter-clockwise order
		ni_list{4}(n_pointperside)=0;
		ni_list{3}(n_pointperside)=0;
		ni_list{2}(n_pointperside)=0;
		ni_list{1}(n_pointperside)=0;
		%ni_list index: 1 = left, 2 = bottom, 3 = right, 4 = top
		
		for i=1:n_pointperside
			ni_list{1}(i)=ni_Jcenter-expansion+expansion*NN(1)-(i-1)*NN(1);
			ni_list{2}(i)=ni_Jcenter-expansion*NN(1)-expansion+(i-1);
			ni_list{3}(i)=ni_Jcenter+expansion-expansion*NN(1)+(i-1)*NN(1);
			ni_list{4}(i)=ni_Jcenter+expansion*NN(1)+expansion-(i-1);
		end
		
		
		for toporbot=1:2
			sidebreaksignal=0;
			for crackline=(n_tip-1):-1:1
				for side=1:4
					for sideline=1:(length(ni_list{side})-1)
						if side==3 && sideline==2 && crackline==2
							1;
						end
						x1=LOC(ni_list{side}(sideline),:);
						x2=LOC(ni_list{side}(sideline+1),:);
						if toporbot==1
							x3=x_cracktop(crackline,:);
							x4=x_cracktop(crackline+1,:);
							[CrossDir,RelativeLocation]=FindCrossing(x1,x2,x3,x4);
						elseif toporbot==2
							x3=x_crackbot(crackline,:);
							x4=x_crackbot(crackline+1,:);
							[CrossDir,RelativeLocation]=FindCrossing(x1,x2,x3,x4);
						end
						if CrossDir>0
							sidebreaksignal=1;
							break;
						end
					end
					if sidebreaksignal==1
						break;
					end
				end
				if sidebreaksignal==1
					break;
				end
			end
			if toporbot==1
				crackline_top=crackline;
				side_top=side;
				sideline_top=sideline;
				CrossDir_top=CrossDir;
				RelativeLocation_top=RelativeLocation;
			elseif toporbot==2
				crackline_bot=crackline;
				side_bot=side;
				sideline_bot=sideline;
				CrossDir_bot=CrossDir;
				RelativeLocation_bot=RelativeLocation;
			end
		end
		nNodes=size(CONNECTpn,1);
		M_ni=zeros(nNodes,3);
		MW_ni=zeros(nNodes,3);
		Mdudx_ni=zeros(nNodes,4,3);
		Ms_ni=zeros(nNodes,3,3);
		MK_ni=zeros(nNodes,3);
		for field=1:size(Nmatrix,3)
			M_ni(:,field)=Nmatrix(:,:,field)*m_sp;
			MW_ni(:,field)=Nmatrix(:,:,field)*(m_sp.*W_sp);
			Mdudx_ni(:,:,field)=Nmatrix(:,:,field)*(m_sp.*dudx_sp);
			Ms_ni(:,:,field)=Nmatrix(:,:,field)*(m_sp.*s_sp);
			MK_ni(:,:,field)=Nmatrix(:,:,field)*(m_sp.*K_sp);
		end
		sidegap=mod(side_bot-side_top,4);
		J1=0;
		J2=0;
		hoopstress=[];
		hooptheta=[];
		hoopindex=0;
		dudx_ni_before=zeros(1,4);
		dudx_ni_after=zeros(1,4);
		s_ni_before=zeros(1,3);
		s_ni_after=zeros(1,3);
		for relativeside=0:4-sidegap
			side=mod(side_bot-1+relativeside,4)+1;
			startsidenode=1;
			endsidenode=(2*expansion)+1;
			if relativeside==0
				startsidenode=sideline_bot;
			elseif relativeside==4-sidegap
				endsidenode=sideline_top+1;
			end
			for sideline=startsidenode:endsidenode-1
				nodebefore=ni_list{side}(sideline);
				nodeafter=ni_list{side}(sideline+1);
				if relativeside==0 || relativeside==1
					sumsequence=1:2:3;
				elseif relativeside==(4-sidegap) || relativeside==(4-sidegap-1)
					sumsequence=1:2;
				else
					sumsequence=1:3;
				end
				M_before=sum(M_ni(nodebefore,sumsequence));
				if M_before==0
					W_ni_before=0;
					dudx_ni_before(1:4)=0;
					s_ni_before(1:3)=0;
					K_ni_before=0;
				else
					W_ni_before=sum(MW_ni(nodebefore,sumsequence))/M_before;
					K_ni_before=sum(MK_ni(nodebefore,:))/M_before;
					for index=1:4
						dudx_ni_before(index)=sum(Mdudx_ni(nodebefore,index,sumsequence))/M_before;
					end
					for index=1:3
						s_ni_before(index)=sum(Ms_ni(nodebefore,index,sumsequence))/M_before;
					end
				end
				
				M_after=sum(M_ni(nodeafter,sumsequence));
				if M_after==0
					W_ni_after=0;
					dudx_ni_after(1:4)=0;
					s_ni_after(1:3)=0;
					K_ni_after=0;
				else
					W_ni_after=sum(MW_ni(nodeafter,sumsequence))/M_after;
					K_ni_after=sum(MK_ni(nodeafter,:))/M_after;
					for index=1:4
						if side==1 && sideline==1 && index==2
							1;
						end
						dudx_ni_after(index)=sum(Mdudx_ni(nodeafter,index,sumsequence))/M_after;
					end
					for index=1:3
						s_ni_after(index)=sum(Ms_ni(nodeafter,index,sumsequence))/M_after;
					end
				end
				if relativeside==0 && sideline==startsidenode
					hoopindex=hoopindex+1;
					currentnode=nodebefore;
					hooptheta=VectorInsertion(hooptheta,hoopindex,reliableatan(LOC(currentnode,1)-x_crack(n_tip,1),LOC(currentnode,2)-x_crack(n_tip,2)));
					Q=[cos(hooptheta(hoopindex)) sin(hooptheta(hoopindex));-sin(hooptheta(hoopindex)) cos(hooptheta(hoopindex))];
					oldsigma=[s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)];
					newsigma=Q*oldsigma*transpose(Q);
					hoopstress=VectorInsertion(hoopstress,hoopindex,newsigma(2,2));
				end
				
				hoopindex=hoopindex+1;
				currentnode=nodeafter;
				hooptheta=VectorInsertion(hooptheta,hoopindex,reliableatan(LOC(currentnode,1)-x_crack(n_tip,1),LOC(currentnode,2)-x_crack(n_tip,2)));
				Q=[cos(hooptheta(hoopindex)) sin(hooptheta(hoopindex));-sin(hooptheta(hoopindex)) cos(hooptheta(hoopindex))];
				oldsigma=[s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)];
				newsigma=Q*oldsigma*transpose(Q);
				hoopstress=VectorInsertion(hoopstress,hoopindex,newsigma(2,2));
				
				if side==1
					n(1,1)=-1;
					n(2,1)=0;
				elseif side==2
					n(1,1)=0;
					n(2,1)=-1;
				elseif side==3
					n(1,1)=1;
					n(2,1)=0;
				elseif side==4
					n(1,1)=0;
					n(2,1)=1;
				end
				
				F1before=(W_ni_before+K_ni_before)*n(1)-dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(1);dudx_ni_before(3)]);
				F2before=(W_ni_before+K_ni_before)*n(2)-dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(2);dudx_ni_before(4)]);
				
				F1after=(W_ni_after+K_ni_after)*n(1)-dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(1);dudx_ni_after(3)]);
				F2after=(W_ni_after+K_ni_after)*n(2)-dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(2);dudx_ni_after(4)]);
				%{
				W_ni_before_track(side,sideline)=W_ni_before;
				W_ni_after_track(side,sideline)=W_ni_after;
				W_ni_track(side,sideline)=(W_ni_before+W_ni_after)/2;
				
				K_ni_before_track(side,sideline)=K_ni_before;
				K_ni_after_track(side,sideline)=K_ni_after;
				K_ni_track(side,sideline)=(K_ni_before+K_ni_after)/2;
				
				n1(side,sideline)=n(1);
				n2(side,sideline)=n(2);
				
				indot1_before_track(side,sideline)=dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(1);dudx_ni_before(3)]);
				indot1_after_track(side,sideline)=dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(1);dudx_ni_after(3)]);
				indot1_track(side,sideline)=(indot1_before_track(side,sideline)+indot1_after_track(side,sideline))/2;
				
				s_ni_1_before_track(side,sideline)=s_ni_before(1);
				s_ni_2_before_track(side,sideline)=s_ni_before(2);
				s_ni_3_before_track(side,sideline)=s_ni_before(3);
				
				s_ni_1_after_track(side,sideline)=s_ni_after(1);
				s_ni_2_after_track(side,sideline)=s_ni_after(2);
				s_ni_3_after_track(side,sideline)=s_ni_after(3);
				
				dudx_ni_1_before_track(side,sideline)=dudx_ni_before(1);
				dudx_ni_2_before_track(side,sideline)=dudx_ni_before(2);
				dudx_ni_3_before_track(side,sideline)=dudx_ni_before(3);
				dudx_ni_4_before_track(side,sideline)=dudx_ni_before(4);
				
				dudx_ni_1_after_track(side,sideline)=dudx_ni_after(1);
				dudx_ni_2_after_track(side,sideline)=dudx_ni_after(2);
				dudx_ni_3_after_track(side,sideline)=dudx_ni_after(3);
				dudx_ni_4_after_track(side,sideline)=dudx_ni_after(4);
				
				dudx_ni_1_avg_track(side,sideline)=(dudx_ni_before(1)+dudx_ni_after(1))/2;
				dudx_ni_2_avg_track(side,sideline)=(dudx_ni_before(2)+dudx_ni_after(2))/2;
				dudx_ni_3_avg_track(side,sideline)=(dudx_ni_before(3)+dudx_ni_after(3))/2;
				dudx_ni_4_avg_track(side,sideline)=(dudx_ni_before(4)+dudx_ni_after(4))/2;
				
				s_ni_1_avg(side,sideline)=(s_ni_1_before_track(side,sideline)+s_ni_1_after_track(side,sideline))/2;
				s_ni_2_avg(side,sideline)=(s_ni_2_before_track(side,sideline)+s_ni_2_after_track(side,sideline))/2;
				s_ni_3_avg(side,sideline)=(s_ni_3_before_track(side,sideline)+s_ni_3_after_track(side,sideline))/2;
				
				indot2_before_track(side,sideline)=dot([s_ni_before(1) s_ni_before(3);s_ni_before(3) s_ni_before(2)]*n,[dudx_ni_before(2);dudx_ni_before(4)]);
				indot2_after_track(side,sideline)=dot([s_ni_after(1) s_ni_after(3);s_ni_after(3) s_ni_after(2)]*n,[dudx_ni_after(2);dudx_ni_after(4)]);
				indot2_track(side,sideline)=(indot2_before_track(side,sideline)+indot2_after_track(side,sideline))/2;
				
				W_ni_contributionto1(side,sideline)=W_ni_track(side,sideline)*n1(side,sideline);
				W_ni_contributionto2(side,sideline)=W_ni_track(side,sideline)*n2(side,sideline);
				
				K_ni_contributionto1(side,sideline)=K_ni_track(side,sideline)*n1(side,sideline);
				K_ni_contributionto2(side,sideline)=K_ni_track(side,sideline)*n2(side,sideline);
				%}
				if relativeside==0 && sideline==startsidenode
					F1before=F1before*(1-RelativeLocation_bot)+F1after*(RelativeLocation_bot);
					F2before=F2before*(1-RelativeLocation_bot)+F2after*(RelativeLocation_bot);
					deltai=(1-RelativeLocation_bot)*le(1); %assuming square grid
				elseif relativeside==4-sidegap && sideline==endsidenode-1
					F1after=F1before*(1-RelativeLocation_top)+F1after*(RelativeLocation_top);
					F2after=F2before*(1-RelativeLocation_top)+F2after*(RelativeLocation_top);
					deltai=RelativeLocation_top*le(1); %assuming square grid
				end
				J1=J1+(F1before+F1after)/2*deltai;
				J2=J2+(F2before+F2after)/2*deltai;
			end
		
		end
		deltax_crack=x_crack(n_tip,1)-x_crack(n_tip-1,1);
		deltay_crack=x_crack(n_tip,2)-x_crack(n_tip-1,2);
		%{
		nx_cell=ceil(x_crack(n_tip,1)/le(1));
		ny_cell=ceil(x_crack(n_tip,2)/le(2));
		ni_bl=nx_cell+(ny_cell-1)*NN(1);
		ni_br=ni_bl+1;
		ni_tl=ni_bl+NN(1);
		ni_tr=ni_tl+1;
		x_factor=(x_crack(n_tip,1)-LOC(ni_bl,1))/(LOC(ni_br,1)-LOC(ni_bl,1));
		y_factor=(x_crack(n_tip,2)-LOC(ni_bl,2))/(LOC(ni_tl,2)-LOC(ni_bl,2));
		
		
		M_ni_all=M_ni(:,1)+M_ni(:,2)+M_ni(:,3);
		Ms_ni_all=Ms_ni(:,:,1)+Ms_ni(:,:,2)+Ms_ni(:,:,3);
		
		s_ni_bl=Ms_ni_all(ni_bl,:)/M_ni_all(ni_bl);
		s_ni_br=Ms_ni_all(ni_br,:)/M_ni_all(ni_br);
		s_ni_tl=Ms_ni_all(ni_tl,:)/M_ni_all(ni_tl);
		s_ni_tr=Ms_ni_all(ni_tr,:)/M_ni_all(ni_tr);
		
		s_ni_tip=(s_ni_bl*(1-x_factor)+s_ni_br*x_factor)*(1-y_factor)+(s_ni_tl*(1-x_factor)+s_ni_tr*x_factor)*y_factor;
		
		thetaprinc=1/2*atan(2*s_ni_tip(1,3)/(s_ni_tip(1,1)-s_ni_tip(1,2)));
		s_ni_tip_first=(s_ni_tip(1,1)+s_ni_tip(1,2))/2+(s_ni_tip(1,1)-s_ni_tip(1,2))/2*cos(2*thetaprinc)+s_ni_tip(1,3)*sin(2*thetaprinc);
		s_ni_tip_second=(s_ni_tip(1,1)+s_ni_tip(1,2))/2-(s_ni_tip(1,1)-s_ni_tip(1,2))/2*cos(2*thetaprinc)-s_ni_tip(1,3)*sin(2*thetaprinc);
		
		if s_ni_tip_first>s_ni_tip_second
			thetamin=thetaprinc+pi/2;
		else
			thetamin=thetaprinc;
		end
		
		thetamin=mod(thetamin+pi/2,pi)-pi/2;
		%}
		thetacold=reliableatan(deltax_crack,deltay_crack);
		%thetac=reliableatan(J1,J2);
		%thetac=thetacold;
		%thetac=thetamin;
		maxhoopstresssofar=[];
		for i=1:length(hooptheta)
			deltathetac=mod((hooptheta(i)-thetacold)+pi,2*pi)-pi;
			if deltathetac<-pi/2 || deltathetac>pi/2
				continue;
			end
			if length(maxhoopstresssofar)==0
				maxhoopstresssofar=hoopstress(i);
				maxhoopstressnumsofar=i;
			else
				if hoopstress(i)>maxhoopstresssofar
					maxhoopstresssofar=hoopstress(i);
					maxhoopstressnumsofar=i;
				end
			end
		end
		thetac=hooptheta(maxhoopstressnumsofar);
		deltathetac=mod((thetac-thetacold)+pi,2*pi)-pi;
		newcrackdistance=sqrt(deltax_crack^2+deltay_crack^2);
		G=J1*cos(thetac)+J2*sin(thetac);
		fprintf('%s',['G=' float2txt(5,G) ', thetac=' float2txt(5,thetac*180/3.1415926536) ' degrees' char(10)]);
		if CasetoRun==64 || CasetoRun==65 || CasetoRun==70 || CasetoRun==66 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72
			Gcnow=0.14;
			if CasetoRun==68
				Gcnow=0.5;
			end
			if G>Gcnow && deltathetac<pi && deltathetac>-pi
				newx_crack=x_crack(n_tip,:)+newcrackdistance*[cos(thetac) sin(thetac)]
				x_crack=[x_crack;newx_crack]
				x_cracktop=[x_cracktop;newx_crack];
				x_crackbot=[x_crackbot;newx_crack];
				1;
			end
		end
	end
	%{
	disp('intersection found!')
	disp(['crackline=' num2str(crackline) ' out of ' num2str(n_tip-1)]);
	disp(['side=' num2str(side)]);
	disp(['sideline=' num2str(sideline) ' out of ' num2str(length(ni_list{side})-1)]);
	disp(['CrossDir=' num2str(CrossDir)]);
	disp(['RelativeLocation=' num2str(RelativeLocation)]);
	AbsoluteLocation=LOC(ni_list{side}(sideline),:)+LOC(ni_list{side}(sideline+1),:)*RelativeLocation;
	disp(['Absolute Coordinate = (' num2str(AbsoluteLocation,1) ',' num2str(AbsoluteLocation,2) ')']);
	
	pause
	1;
	%}
	
	%end function for calculating J
	
	energy.kinetic.value=0;
	energy.strain.value=0;
	for ip=1:spCount
		energy.kinetic.value=energy.kinetic.value+0.5*m_sp(ip)*(v_ssp_out(ip,1)^2+v_ssp_out(ip,2)^2);
		energy.strain.value=energy.strain.value+sse_sp(ip)*A_sp(ip)*t_sp(ip);
	end
	
	
	%% Update the topology of particles
	%if CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
	%else
	[r1_sp,r2_sp] = Update_topology(spCount,F_sp,r1_sp,r10_sp,r2_sp,r20_sp);
	r1_sp=real(r1_sp);
	r2_sp=real(r2_sp);
	%end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [thecell, thenodes, cellcentralcoordinates, cellnodescoordinates]=identifycellsandnodes_reg(x_sp,LOC,LOCC,outputrequest)
	LOCX=[0:1:NN(1)]*le(1);
	LOCY=[0:1:NN(2)]*le(2);
	xindex=0;
	yindex=0;
	for i=1:length(LOCX)
		if x_sp(1)<LOCX(i)
			xindex=i-1;
			break;
		end
	end
	for i=1:length(LOCY)
		if x_sp(2)<LOCY(i)
			yindex=i-1;
			break;
		end
	end
	if outputrequest(1)==1
		thecell=(yindex-1)*(length(LOCX)-1)+xindex;
	end
	if outputrequest(2)==1
		thenodes=zeros(1,4);
		thenodes(1)=(yindex-1)*(length(LOCX))+xindex;
		thenodes(2)=thenodes(1)+1;
		thenodes(3)=thenodes(1)+length(LOCX);
		thenodes(4)=thenodes(3)+1;
	end
	if outputrequest(3)==1
		cellcentralcoordinates=zeros(size(LOCC(thecell,:)));
		cellcentralcoordinates(1,:)=LOCC(thecell,:);
	end
	if outputrequest(4)==1
		cellnodescoordinates=zeros(4,size(LOC(thenodes(i),:),2));
		for i=1:4
			cellnodescoordinates(i,:)=LOC(thenodes(i),:);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [thecell, thenodes, cellcentralcoordinates, cellnodescoordinates]=identifycellsandnodes(x_sp,LOCX,LOCY,LOC,LOCC,outputrequest)
	xindex=0;
	yindex=0;
	for i=1:length(LOCX)
		if x_sp(1)<LOCX(i)
			xindex=i-1;
			break;
		end
	end
	for i=1:length(LOCY)
		if x_sp(2)<LOCY(i)
			yindex=i-1;
			break;
		end
	end
	if outputrequest(1)==1
		thecell=(yindex-1)*(length(LOCX)-1)+xindex;
	end
	if outputrequest(2)==1
		thenodes=zeros(1,4);
		thenodes(1)=(yindex-1)*(length(LOCX))+xindex;
		thenodes(2)=thenodes(1)+1;
		thenodes(3)=thenodes(1)+length(LOCX);
		thenodes(4)=thenodes(3)+1;
	end
	if outputrequest(3)==1
		cellcentralcoordinates=zeros(1,size(LOCC(thecell,:),2));
		cellcentralcoordinates(1,:)=LOCC(thecell,:);
	end
	if outputrequest(4)==1
		cellnodescoordinates=zeros(4,size(LOC(thenodes(i),:),2));
		for i=1:4
			cellnodescoordinates(i,:)=LOC(thenodes(i),:);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit,Nmatrix,dNxmatrix,dNymatrix,Nmatrixtop,Nmatrixbot,NmatrixAll] = SplitField(spSizes,LOC,x_sp,CONNECT,CONNECTpn,x_crack_centeronly,CONNECT_crack,CONNECTpn_crack,Nmatrix,dNxmatrix,dNymatrix,t_time)
	NmatrixAll=Nmatrix;
	Nmatrixtop=zeros(size(NmatrixAll));
	Nmatrixbot=zeros(size(NmatrixAll));
	Nmatrix(1,1,3)=0;
	dNxmatrix(1,1,3)=0;
	dNymatrix(1,1,3)=0;
	TheFieldSplit=cell(1,lengthCONNECT);
	for sp=1:lengthCONNECT
		TheFieldSplit{sp}=zeros(1,spSizes(sp));
	end
	%for SuspectedNodeCounter=1:length(CONNECTpn_crack)
	Area=zeros(4,1);
	for sp=1:length(CONNECT)
		for ni=1:length(CONNECT{sp})
			Field2Counter=0;
			Field3Counter=0;
			for crack_p_counter=1:(size(x_crack_centeronly,1)-1)
				i=CONNECT{sp}(ni);
				x1=x_sp(sp,:);
				x2=LOC(i,:);
				x3=x_crack_centeronly(crack_p_counter,:);
				x4=x_crack_centeronly(crack_p_counter+1,:);
				Area(1)=TriangleArea(x1,x2,x3);
				Area(2)=TriangleArea(x1,x2,x4);
				Area(3)=TriangleArea(x3,x4,x1);
				Area(4)=TriangleArea(x3,x4,x2);
				if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
					%{
					if sp==220 && ni==8 && CloseEnough(x1(1),58.740308582876274101636226987466,1e-5,2)
						1;
						plot(x1(1),x1(2),'o','DisplayName','particle')
						hold on
						plot(x2(1),x2(2),'o','DisplayName','node')
						plot(x3(1),x3(2),'o','DisplayName','crackbefore')
						plot(x4(1),x4(2),'o','DisplayName','crackafter')
						legend show
						hold off
						1;
					end
					%}
					Field2Counter=Field2Counter+1;
				elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
					%{
					if sp==220 && ni==8 && CloseEnough(x1(1),58.740308582876274101636226987466,1e-5,2)
						1;
						plot(x1(1),x1(2),'o','DisplayName','particle')
						hold on
						plot(x2(1),x2(2),'o','DisplayName','node')
						plot(x3(1),x3(2),'o','DisplayName','crackbefore')
						plot(x4(1),x4(2),'o','DisplayName','crackafter')
						legend show
						hold off
						1;
					end
					%}
					Field3Counter=Field3Counter+1;
				end
			end
			if Field2Counter>0 && Field3Counter>0
				%{
				try
					asdf(-pi);
				catch exc
					disp('Field Split Error!');
					getReport(exc,'extended');
					pause;
					1;
				end
				%}
				1;
				Field23Min=min([Field2Counter Field3Counter]);
				Field2Counter=Field2Counter-Field23Min;
				Field3Counter=Field3Counter-Field23Min;
				1;
			end
			if mod(Field2Counter,2)>0
				TheFieldSplit{sp}(ni)=2;
				Nmatrix(i,sp,2)=Nmatrix(i,sp,1);
				Nmatrix(i,sp,1)=0;
				dNxmatrix(i,sp,2)=dNxmatrix(i,sp,1);
				dNxmatrix(i,sp,1)=0;
				dNymatrix(i,sp,2)=dNymatrix(i,sp,1);
				dNymatrix(i,sp,1)=0;
			elseif mod(Field3Counter,2)>0
				TheFieldSplit{sp}(ni)=3;
				Nmatrix(i,sp,3)=Nmatrix(i,sp,1);
				Nmatrix(i,sp,1)=0;
				dNxmatrix(i,sp,3)=dNxmatrix(i,sp,1);
				dNxmatrix(i,sp,1)=0;
				dNymatrix(i,sp,3)=dNymatrix(i,sp,1);
				dNymatrix(i,sp,1)=0;
			end
		end
	end
	for i=1:size(CONNECTpn,1)
		niSize=size(CONNECTpn,2); %size of list of sp for a certain ni
		for nsp=1:size(CONNECTpn,2)
			if CONNECTpn(i,nsp)<1
				niSize=nsp-1;
				break;
			end
		end
		TheFieldSplit_ni=zeros(1,niSize) %A row of TheFieldSplit for a certain ni
		for nsp=1:niSize
			nni=0;
			sp=CONNECTpn(i,nsp);
			for nni=1:length(CONNECT{sp});
				if CONNECT{sp}(nni)==i;
					break;
				end
			end
			TheFieldSplit_ni(1,nsp)=TheFieldSplit{sp}(nni);
		end
		if CloseEnough(t_time,0.25291484448446682753441905333602,1e-5,2) && i==613 %temporary for debugging
			1;
		end
		nodalfieldlist=sort(unique(TheFieldSplit_ni));
		newfieldrevision=1;
		if length(nodalfieldlist)==2
			if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
				newfieldrevision=3;
			elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
				newfieldrevision=2;
			end
		elseif length(nodalfieldlist)==3
			fprintf('%s',['Field split error, ignoring 1904092154' char(10)]);
			pause
			1;
		end
		if newfieldrevision>1
			for sp=1:length(CONNECT)
				if TheFieldSplit{sp}(nni)==1
					TheFieldSplit{sp}(nni)=newfieldrevision;
					Nmatrix(i,sp,newfieldrevision)=Nmatrix(i,sp,1);
					Nmatrix(i,sp,1)=0;
					dNxmatrix(i,sp,newfieldrevision)=dNxmatrix(i,sp,1);
					dNxmatrix(i,sp,1)=0;
					dNymatrix(i,sp,newfieldrevision)=dNymatrix(i,sp,1);
					dNymatrix(i,sp,1)=0;
				end
			end
		end
	end
	for sp=1:length(CONNECT)
		niSize=size(CONNECTpn,2); %size of list of sp for a certain ni
		for nsp=1:size(CONNECTpn,2)
			if CONNECTpn(i,nsp)<1
				niSize=nsp-1;
				break;
			end
		end
		TheFieldSplit_ni=zeros(1,niSize) %A row of TheFieldSplit for a certain ni
		for nsp=1:niSize
			nni=0;
			sp=CONNECTpn(i,nsp);
			for nni=1:length(CONNECT{sp});
				if CONNECT{sp}(nni)==i;
					break;
				end
			end
			TheFieldSplit_ni(1,nsp)=TheFieldSplit{sp}(nni);
		end
		if max(TheFieldSplit_ni)==2
			Nmatrixtop(:,sp)=NmatrixAll(:,sp);
		elseif max(TheFieldSplit_ni)==3
			Nmatrixbot(:,sp)=NmatrixAll(:,sp);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit,Nmatrix,dNxmatrix,dNymatrix,NmatrixAll] = SplitFieldMulti(spSizes,LOC,x_sp,CONNECT,CONNECTpn,x_crackcenter,CONNECT_crack,CONNECTpn_crack,Nmatrix,dNxmatrix,dNymatrix,t_time)
	NmatrixAll=Nmatrix;
	numberofcrackpaths=length(x_crackcenter);
	numberoffields=3^numberofcrackpaths;
	if numberoffields>1
		Nmatrix(1,1,numberoffields)=0;
		dNxmatrix(1,1,numberoffields)=0;
		dNymatrix(1,1,numberoffields)=0;
	end
	TheFieldSplit=cell(1,lengthCONNECT);
	for sp=1:lengthCONNECT
		TheFieldSplit{sp}=zeros(1,spSizes(sp));
	end
	TheFieldSplitBase3=cell(1,lengthCONNECT);
	for sp=1:lengthCONNECT
		TheFieldSplitBase3{sp}=zeros(spSizes(sp),numberofcrackpaths);
	end
	
	%for SuspectedNodeCounter=1:length(CONNECTpn_crack)
	Area=zeros(4,1);
	for icrackpath=1:numberofcrackpaths %not to get confused with numberofcrackpaths, icrackpath is the moving number, from 1 to numberofcrackpaths
		for sp=1:length(CONNECT)
			for ni=1:length(CONNECT{sp})
				Field2Counter=0;
				Field3Counter=0;
				for crack_p_counter=1:(size(x_crackcenter{icrackpath},1)-1)
					i=CONNECT{sp}(ni);
					x1=x_sp(sp,:);
					x2=LOC(i,:);
					x3=x_crackcenter{icrackpath}(crack_p_counter,:);
					x4=x_crackcenter{icrackpath}(crack_p_counter+1,:);
					Area(1)=TriangleArea(x1,x2,x3);
					Area(2)=TriangleArea(x1,x2,x4);
					Area(3)=TriangleArea(x3,x4,x1);
					Area(4)=TriangleArea(x3,x4,x2);
					if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
						Field2Counter=Field2Counter+1;
					elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
						%{
						if sp==220 && ni==8 && CloseEnough(x1(1),58.740308582876274101636226987466,1e-5,2)
							1;
							plot(x1(1),x1(2),'o','DisplayName','particle')
							hold on
							plot(x2(1),x2(2),'o','DisplayName','node')
							plot(x3(1),x3(2),'o','DisplayName','crackbefore')
							plot(x4(1),x4(2),'o','DisplayName','crackafter')
							legend show
							hold off
							1;
						end
						%}
						Field3Counter=Field3Counter+1;
					end
				end
				if Field2Counter>0 && Field3Counter>0
					%{
					try
						asdf(-pi);
					catch exc
						disp('Field Split Error!');
						getReport(exc,'extended');
						pause;
						1;
					end
					%}
					1;
					Field23Min=min([Field2Counter Field3Counter]);
					Field2Counter=Field2Counter-Field23Min;
					Field3Counter=Field3Counter-Field23Min;
					1;
				end
				if mod(Field2Counter,2)>0
				%{
					TheFieldSplit(i,sp)=2*icrackpath;
					Nmatrix(i,sp,2*icrackpath)=Nmatrix(i,sp,1);
					Nmatrix(i,sp,1)=0;
					dNxmatrix(i,sp,2*icrackpath)=dNxmatrix(i,sp,1);
					dNxmatrix(i,sp,1)=0;
					dNymatrix(i,sp,2*icrackpath)=dNymatrix(i,sp,1);
					dNymatrix(i,sp,1)=0;
				%}
					TheFieldSplitBase3{sp}(ni,icrackpath)=2;
				elseif mod(Field3Counter,2)>0
				%{
					TheFieldSplit(i,sp)=2*icrackpath+1;
					Nmatrix(i,sp,2*icrackpath+1)=Nmatrix(i,sp,1);
					Nmatrix(i,sp,1)=0;
					dNxmatrix(i,sp,2*icrackpath+1)=dNxmatrix(i,sp,1);
					dNxmatrix(i,sp,1)=0;
					dNymatrix(i,sp,2*icrackpath+1)=dNymatrix(i,sp,1);
					dNymatrix(i,sp,1)=0;
				%}
					TheFieldSplitBase3{sp}(ni,icrackpath)=3;
				end
			end
		end
		
		for i=1:size(CONNECTpn,1)
			CONNECTpnLength=0;
			for j=1:size(CONNECTpn,2);
				if CONNECTpn(i,j)>0
					CONNECTpnLength=CONNECTpnLength+1;
				else
					break;
				end
			end
			nodalfieldlist=sort(unique(TheFieldSplitBase3(i,CONNECTpn(i,1:CONNECTpnLength),icrackpath)));
			newfieldrevision=1;
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			elseif length(nodalfieldlist)==3
				fprintf('%s',['Field split error! (code 1904012104)' char(10)]);
				pause
				1;
			end
			if newfieldrevision>1
				for nsp=1:CONNECTpnLength
					if TheFieldSplitBase3(i,CONNECTpn(i,nsp),icrackpath)==1
						TheFieldSplitBase3(i,CONNECTpn(i,nsp),icrackpath)=newfieldrevision;
					end
				end
			end
		end

		%{
		for i=1:size(CONNECTpn,1)
			nodalfieldlist=sort(unique(TheFieldSplit(i,:)));
			newfieldrevision=1;
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			elseif length(nodalfieldlist)==3
				disp('Field split error, ignoring')
				%pause
				1;
			end
			if newfieldrevision>1
				for sp=1:length(CONNECT)
					if TheFieldSplit(i,sp)==1
						TheFieldSplit(i,sp)=newfieldrevision;
						Nmatrix(i,sp,newfieldrevision)=Nmatrix(i,sp,1);
						Nmatrix(i,sp,1)=0;
						dNxmatrix(i,sp,newfieldrevision)=dNxmatrix(i,sp,1);
						dNxmatrix(i,sp,1)=0;
						dNymatrix(i,sp,newfieldrevision)=dNymatrix(i,sp,1);
						dNymatrix(i,sp,1)=0;
					end
				end
			end
		end
		%}
	end
	for i=1:size(TheFieldSplitBase3,1)
		for sp=1:size(TheFieldSplitBase3,2)
			TheFieldSplit(i,sp)=BaseNtoDec(TheFieldSplitBase3(i,sp,:),1,3);
		end
	end
	for i=1:size(TheFieldSplit,1)
		for sp=1:size(TheFieldSplit,2)
			if TheFieldSplit(i,sp)==1
			else
				if TheFieldSplit(i,sp)==9
					1;
				end
				Nmatrix(i,sp,TheFieldSplit(i,sp))=Nmatrix(i,sp,1);
				Nmatrix(i,sp,1)=0;
				
				dNxmatrix(i,sp,TheFieldSplit(i,sp))=dNxmatrix(i,sp,1);
				dNxmatrix(i,sp,1)=0;
				
				dNymatrix(i,sp,TheFieldSplit(i,sp))=dNymatrix(i,sp,1);
				dNymatrix(i,sp,1)=0;
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit] = SplitFieldMultiOptimized(LOC,x_sp,CONNECT,CONNECTpn,x_crackcenter,t_time,le)
	numberofcrackpaths=length(x_crackcenter);
	numberoffields=3^numberofcrackpaths;
	trajectory1=0;
	trajectory2=0;

	TheFieldSplit=ones(size(CONNECTpn,1),length(CONNECT));
	TheFieldSplitBase3_old=ones(size(CONNECTpn,1),length(CONNECT),numberofcrackpaths);
	%SplitSourceSplitBase3=zeros(size(CONNECTpn,1),length(CONNECT),numberofcrackpaths);
	
	Area=zeros(4,1);
	for icrackpath=1:numberofcrackpaths %not to get confused with numberofcrackpaths, icrackpath is the moving number, from 1 to numberofcrackpaths
		for sp=1:length(CONNECT)
			for ni=1:length(CONNECT{sp})
				Field2Counter=0;
				Field3Counter=0;
				for crack_p_counter=1:(size(x_crackcenter{icrackpath},1)-1)
					i=CONNECT{sp}(ni);
					x1=x_sp(sp,:);
					x2=LOC(i,:);
					x3=x_crackcenter{icrackpath}(crack_p_counter,:);
					x4=x_crackcenter{icrackpath}(crack_p_counter+1,:);
					Area(1)=TriangleArea(x1,x2,x3);
					Area(2)=TriangleArea(x1,x2,x4);
					Area(3)=TriangleArea(x3,x4,x1);
					Area(4)=TriangleArea(x3,x4,x2);
					if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
						Field2Counter=Field2Counter+1;
					elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
						Field3Counter=Field3Counter+1;
					end
				end
				if Field2Counter>0 && Field3Counter>0
					Field23Min=min([Field2Counter Field3Counter]);
					Field2Counter=Field2Counter-Field23Min;
					Field3Counter=Field3Counter-Field23Min;
				end
				if mod(Field2Counter,2)>0
					TheFieldSplitBase3_old(i,sp,icrackpath)=2;
					%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
				elseif mod(Field3Counter,2)>0
					TheFieldSplitBase3_old(i,sp,icrackpath)=3;
					%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
				end
			end
		end
		
		for i=1:size(CONNECTpn,1)
			CONNECTpnLength=0;
			for j=1:size(CONNECTpn,2);
				if CONNECTpn(i,j)>0
					CONNECTpnLength=CONNECTpnLength+1;
				else
					break;
				end
			end
			nodalfieldlist=sort(unique(TheFieldSplitBase3_old(i,CONNECTpn(i,1:CONNECTpnLength),icrackpath)));
			newfieldrevision=1;
			if length(nodalfieldlist)==3
				fprintf('%s',['Field split error, applying fix! (code 1904012106)' char(10)]);
				%pause
				1;
				problematicnsp=[];
				for nsp=1:CONNECTpnLength
					if TheFieldSplitBase3_old(i,CONNECTpn(i,nsp),icrackpath)>1
						problematicnsp=[problematicnsp nsp];
					end
				end
				TheFieldSplitBase3_old=TheFieldSplitBase3_old;
				for fixmode=1:3
					% extending the crack
					%fixmode=1: x_crackcenter{npid}(size(x_crackcenter{npid},1),:) extension by le(1)
					%fixmode=2: x_crackcenter{npid}(0,:) extension by le(1)
					%fixmode=3: both extensions
					if fixmode==1
						x_crack_modified=x_crackcenter{icrackpath};
						cracksize=size(x_crack_modified,1);
						trajectory=reliableatan(x_crackcenter{icrackpath}(cracksize,1)-x_crackcenter{icrackpath}(cracksize-1,1),x_crackcenter{icrackpath}(cracksize,2)-x_crackcenter{icrackpath}(cracksize-1,2));
						x_crack_modified(cracksize,1)=x_crackcenter{icrackpath}(cracksize,1)+le(1)*cos(trajectory);
						x_crack_modified(cracksize,2)=x_crackcenter{icrackpath}(cracksize,2)+le(1)*sin(trajectory);
					elseif fixmode==2
						x_crack_modified=x_crackcenter{icrackpath};
						cracksize=size(x_crack_modified,1);
						trajectory=reliableatan(x_crackcenter{icrackpath}(1,1)-x_crackcenter{icrackpath}(2,1),x_crackcenter{icrackpath}(1,2)-x_crackcenter{icrackpath}(2,2));
						x_crack_modified(1,1)=x_crackcenter{icrackpath}(1,1)+le(1)*cos(trajectory);
						x_crack_modified(1,2)=x_crackcenter{icrackpath}(1,2)+le(1)*sin(trajectory);
					elseif fixmode==3
						x_crack_modified=x_crackcenter{icrackpath};
						cracksize=size(x_crack_modified,1);
						trajectory1=reliableatan(x_crackcenter{icrackpath}(cracksize,1)-x_crackcenter{icrackpath}(cracksize-1,1),x_crackcenter{icrackpath}(cracksize,2)-x_crackcenter{icrackpath}(cracksize-1,2));
						x_crack_modified(cracksize,1)=x_crackcenter{icrackpath}(cracksize,1)+le(1)*cos(trajectory1);
						x_crack_modified(cracksize,2)=x_crackcenter{icrackpath}(cracksize,2)+le(1)*sin(trajectory1);
						trajectory2=reliableatan(x_crackcenter{icrackpath}(1,1)-x_crackcenter{icrackpath}(2,1),x_crackcenter{icrackpath}(1,2)-x_crackcenter{icrackpath}(2,2));
						x_crack_modified(1,1)=x_crackcenter{icrackpath}(1,1)+le(1)*cos(trajectory2);
						x_crack_modified(1,2)=x_crackcenter{icrackpath}(1,2)+le(1)*sin(trajectory2);
					end
					% extending the crack finished
					
					% revising bad mapping
					for nsp=1:length(problematicnsp)
						Field2Counter=0;
						Field3Counter=0;
						sp=CONNECTpn(i,problematicnsp(nsp));
						TheFieldSplitBase3_old(i,sp,icrackpath)=1;
						for crack_p_counter=1:(size(x_crack_modified,1)-1)
							x1=x_sp(sp,:);
							x2=LOC(i,:);
							x3=x_crack_modified(crack_p_counter,:);
							x4=x_crack_modified(crack_p_counter+1,:);
							Area(1)=TriangleArea(x1,x2,x3);
							Area(2)=TriangleArea(x1,x2,x4);
							Area(3)=TriangleArea(x3,x4,x1);
							Area(4)=TriangleArea(x3,x4,x2);
							if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
								Field2Counter=Field2Counter+1;
								%close gcf;
								%plot(LOC(i,1),LOC(i,2),'o','DisplayName','Node');
								%hold on
								%plot(x_sp(sp,1),x_sp(sp,2),'o','DisplayName','Particle');
								%plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
								%plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
								%daspect([1 1 1]);
								%legend show
								%title(['above, particle=' num2str(sp) ', node=' num2str(i)]);
								%1;
							elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
								Field3Counter=Field3Counter+1;
								%close gcf;
								%plot(LOC(i,1),LOC(i,2),'o','DisplayName','Node');
								%hold on
								%plot(x_sp(sp,1),x_sp(sp,2),'o','DisplayName','Particle');
								%plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
								%plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
								%daspect([1 1 1]);
								%legend show
								%title(['below, particle=' num2str(sp) ', node=' num2str(i)]);
								%1;
							end
						end
						if Field2Counter>0 && Field3Counter>0
							Field23Min=min([Field2Counter Field3Counter]);
							Field2Counter=Field2Counter-Field23Min;
							Field3Counter=Field3Counter-Field23Min;
						end
						if mod(Field2Counter,2)>0
							TheFieldSplitBase3_old(i,sp,icrackpath)=2;
							%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
						elseif mod(Field3Counter,2)>0
							TheFieldSplitBase3_old(i,sp,icrackpath)=3;
							%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
						end
					end
					% mapping revision done

					% checking if revision is successful
					nodalfieldlist=sort(unique(TheFieldSplitBase3_old(i,CONNECTpn(i,1:CONNECTpnLength),icrackpath)));
					if length(nodalfieldlist)==3
						fprintf('%s',['fix attempt number ' int2txt(fixmode) ' failed' char(10)]);
						TheFieldSplitBase3_old=TheFieldSplitBase3_old;
						if fixmode==3
							fprintf('%s',['code 1904172033' char(10)]);
							pause
							1;
						end
					elseif length(nodalfieldlist)==2
						fprintf('%s',['fix attempt number ' int2txt(fixmode) ' successful' char(10)]);
						break;
					elseif length(nodalfieldlist)==1
						fprintf('%s',['fix attempt number ' int2txt(fixmode) ' broke separation (code 1904172022)' char(10)]);
						pause
						1;
					end
					% done checking if revision is successful
				end	
			end
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			end
			if newfieldrevision>1
				for nsp=1:CONNECTpnLength
					if TheFieldSplitBase3_old(i,CONNECTpn(i,nsp),icrackpath)==1
						TheFieldSplitBase3_old(i,CONNECTpn(i,nsp),icrackpath)=newfieldrevision;
					end
				end
			end
		end
	end
	for i=1:size(TheFieldSplitBase3_old,1)
		for sp=1:size(TheFieldSplitBase3_old,2)
			TheFieldSplit(i,sp)=BaseNtoDec(TheFieldSplitBase3_old(i,sp,:),1,3);
		end
	end
	%{
	UniqueFields=unique(TheFieldSplit);
	for i=length(UniqueFields):-1:1
		UniqueFieldsInv(UniqueFields(i))=i;
	end
	for i=1:size(TheFieldSplitBase3_old,1)
		for sp=1:size(TheFieldSplitBase3_old,2)
			TheFieldSplit(i,sp)=UniqueFieldsInv(TheFieldSplit(i,sp));
			if TheFieldSplit(i,sp)==0
				disp('FieldSplitZero! 1904151633');
			end
		end
	end
	%}
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplitBase3_ni,TheFieldSplitBase3_sp,spSizes] = SplitFieldMultiOptimized2(LOC,x_sp,CONNECT,CONNECTpn,x_crack,t_time,le)
	trajectory=0;
	numberofcrackpaths=x_crack.npaths;
	numberoffields=3^numberofcrackpaths;
	
	%TheFieldSplit=ones(size(CONNECTpn,1),length(CONNECT)); %<-- doesnt seem necessary
	%fprintf('%s',['amarker #186' char(10)]);
	%TheFieldSplitBase3_ni=zeros(size(CONNECTpn,1),length(CONNECT),numberofcrackpaths);
	%TheFieldSplitBase3_ni=ones(size(CONNECTpn,1),length(CONNECT),numberofcrackpaths); %<-- shit's right here???
	%SplitSourceSplitBase3=zeros(length(CONNECTpn),length(CONNECT),numberofcrackpaths);
	
	%new TheFieldSplitBase3_ni structure: {ni}(nsp,icrackpath) ni: number of nodes; nsp: the connected particles only based on CONNECTpn, icrackpath: the crack number
	niCount=length(CONNECTpn.nrparticles);
	spCount=length(CONNECT);
	niSizes=CONNECTpn.nrparticles;
	spSizes=zeros(1,spCount);
	for sp=1:spCount
		spSizes(sp)=length(CONNECT{sp});
	end
	maxspSizes=max(spSizes);
	maxniSizes=max(niSizes);
	TheFieldSplitBase3_ni=zeros(niCount,maxniSizes,numberofcrackpaths);
	TheFieldSplitBase3_sp=zeros(maxspSizes,spCount,numberofcrackpaths);
	%TheFieldSplitBase3_sp=cell(1,spCount);
	%{
	maxspSize=max(spSizes);
	for sp=1:spCount
		TheFieldSplitBase3_sp{sp}=zeros(length(CONNECT{sp}),numberofcrackpaths);
		%TheFieldSplitBase3_sp{sp}=zeros(maxspSize,numberofcrackpaths);
		%TheFieldSplitBase3_sp{sp}=zeros(spSizes(sp),numberofcrackpaths);
	end
	TheFieldSplitBase3_sp{1}(1,1)=1; %algorithm test
	%}
	Area=zeros(4,1);%fprintf('%s',['amarker #189' char(10)]);
	LOC_CONNECT=cell(1,spCount);
	for sp=1:spCount
		LOC_CONNECT{sp}=LOC(CONNECT{sp},:);
	end
	for icrackpath=1:numberofcrackpaths %not to get confused with numberofcrackpaths, icrackpath is the moving number, from 1 to numberofcrackpaths
	%{
	%switchable1 
		try
			parfor sp=1:length(CONNECT)
				TheFieldSplitBase3_ni(:,sp,icrackpath)=SplitFieldMultiOptimized2_parforred(LOC_CONNECT{sp},x_sp(sp,:),CONNECT{sp},niCount,x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath),t_time);
			end
		catch
		%}
		%switchable1
			
			%TDL investigate TheFieldSplitBase3_ni bug
			parfor ni=1:niCount
			%for ni=1:niCount
				%TheFieldSplitBase3_ni(ni (all nodes),nsp (particle numbers attached to the nodes),icrackpath)
				TheFieldSplitBase3_ni(ni,:,icrackpath)=SplitFieldMultiOptimized2_parforred_ni(x_sp,x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath),t_time,niSizes(ni),CONNECTpn.values(ni,1:CONNECTpn.nrparticles(ni)),LOC(ni,:),maxniSizes);
				1;
			end
			%{
			parfor sp=1:spCount
				%TheFieldSplitBase3_sp{sp}(:,icrackpath)=SplitFieldMultiOptimized2_parforred_sp(x_sp(sp,:),x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath),t_time,spSizes(sp),CONNECT{sp},LOC);
				TheFieldSplitBase3_sp(:,sp,icrackpath)=SplitFieldMultiOptimized2_parforred_sp(x_sp(sp,:),x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath),t_time,spSizes(sp),CONNECT{sp},LOC,maxspSizes);
			end
			%}
			
			%{
			%switchable1
		end
		%}
		%switchable1
		for i=1:niCount
			%{
			CONNECTpnLength=0;
			for j=1:CONNECTpnLength;
				if CONNECTpn(i,j)>0
					CONNECTpnLength=CONNECTpnLength+1;
				else
					break;
				end
			end
			%}
			nodalfieldlist=sort(unique(transpose(TheFieldSplitBase3_ni(i,1:niSizes(i),icrackpath))));
			newfieldrevision=1;
			if length(nodalfieldlist)==3
				fprintf('%s',['Field split error, applying fix! (code 1904012106)' char(10)]);
				%pause
				1;
				problematicnsp=zeros(1,maxniSizes);
				coder.varsize('problematicnsp');
				problematicnsp=zeros(1,0);
				for nsp=1:niSizes(i)
					if TheFieldSplitBase3_ni(i,nsp,icrackpath)>1
						problematicnsp=[problematicnsp nsp];
					end
				end
				TheFieldSplitBase3_old_i=TheFieldSplitBase3_ni(i,:,icrackpath);
				for fixmode=1:3
					% extending the crack
					%fixmode=1: x_crack.center{npid}(size(x_crack{npid},1),:) extension by le(1)
					%fixmode=2: x_crack{npid}(0,:) extension by le(1)
					%fixmode=3: both extensions
					x_crack_modified=x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath);
					cracksize=size(x_crack_modified,1);
					if fixmode==1
						trajectory=reliableatan(x_crack.center(cracksize,1,icrackpath)-x_crack.center(cracksize-1,1,icrackpath),x_crack.center(cracksize,2,icrackpath)-x_crack.center(cracksize-1,2,icrackpath));
						x_crack_modified(cracksize,1)=x_crack.center(cracksize,1,icrackpath)+2*le(1)*cos(trajectory);
						x_crack_modified(cracksize,2)=x_crack.center(cracksize,2,icrackpath)+2*le(1)*sin(trajectory);
					elseif fixmode==2
						trajectory=reliableatan(x_crack.center(1,1,icrackpath)-x_crack.center(2,1,icrackpath),x_crack.center(1,2,icrackpath)-x_crack.center(2,2,icrackpath));
						x_crack_modified(1,1)=x_crack.center(1,1,icrackpath)+2*le(1)*cos(trajectory);
						x_crack_modified(1,2)=x_crack.center(1,2,icrackpath)+2*le(1)*sin(trajectory);
					elseif fixmode==3
						trajectory1=reliableatan(x_crack.center(cracksize,1,icrackpath)-x_crack.center(cracksize-1,1,icrackpath),x_crack.center(cracksize,2,icrackpath)-x_crack.center(cracksize-1,2,icrackpath));
						x_crack_modified(cracksize,1)=x_crack.center(cracksize,1,icrackpath)+2*le(1)*cos(trajectory1);
						x_crack_modified(cracksize,2)=x_crack.center(cracksize,2,icrackpath)+2*le(1)*sin(trajectory1);
						trajectory2=reliableatan(x_crack.center(1,1,icrackpath)-x_crack.center(2,1,icrackpath),x_crack.center(1,2,icrackpath)-x_crack.center(2,2,icrackpath));
						x_crack_modified(1,1)=x_crack.center(1,1,icrackpath)+2*le(1)*cos(trajectory2);
						x_crack_modified(1,2)=x_crack.center(1,2,icrackpath)+2*le(1)*sin(trajectory2);
					end
					% extending the crack finished
					%{
					close gcf;
					plot(LOC(i,1),LOC(i,2),'+','DisplayName','Node');
					hold on
					for nsp=1:niSizes(i)
						sp=CONNECTpn(i,nsp);
						if TheFieldSplitBase3_ni{i}(nsp,icrackpath)==1
							plot(x_sp(sp,1),x_sp(sp,2),'x','Color','Red','HandleVisibility','Off');
						elseif TheFieldSplitBase3_ni{i}(nsp,icrackpath)==2
							plot(x_sp(sp,1),x_sp(sp,2),'x','Color','Green','HandleVisibility','Off');
						elseif TheFieldSplitBase3_ni{i}(nsp,icrackpath)==3
							plot(x_sp(sp,1),x_sp(sp,2),'x','Color','Blue','HandleVisibility','Off');
						end
					end
					plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
					daspect([1 1 1]);
					legend show
					title(['above, particle=' num2str(sp) ', node=' num2str(i)]);
					1;
					%}
					% revising bad mapping
					for nsp_problematic=1:length(problematicnsp)
						Field2Counter=0;
						Field3Counter=0;
						nsp=problematicnsp(nsp_problematic);
						sp=CONNECTpn.values(i,nsp);
						TheFieldSplitBase3_ni(i,nsp,icrackpath)=1;
						for crack_p_counter=1:(size(x_crack_modified,1)-1)
							x1=x_sp(sp,:);
							x2=LOC(i,:);
							x3=x_crack_modified(crack_p_counter,:);
							x4=x_crack_modified(crack_p_counter+1,:);
							Area(1)=TriangleArea(x1,x2,x3);
							Area(2)=TriangleArea(x1,x2,x4);
							Area(3)=TriangleArea(x3,x4,x1);
							Area(4)=TriangleArea(x3,x4,x2);
							if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
								Field2Counter=Field2Counter+1;
								%{
								close gcf;
								plot(LOC(i,1),LOC(i,2),'+','DisplayName','Node');
								hold on
								plot(x_sp(sp,1),x_sp(sp,2),'x','DisplayName','Particle');
								plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
								plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
								daspect([1 1 1]);
								legend show
								title(['above, particle=' num2str(sp) ', node=' num2str(i)]);
								1;
								%}
							elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
								Field3Counter=Field3Counter+1;
								%{
								close gcf;
								plot(LOC(i,1),LOC(i,2),'+','DisplayName','Node');
								hold on
								plot(x_sp(sp,1),x_sp(sp,2),'x','DisplayName','Particle');
								plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
								plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
								daspect([1 1 1]);
								legend show
								title(['below, particle=' num2str(sp) ', node=' num2str(i)]);
								1;
								%}
							end
						end
						if Field2Counter>0 && Field3Counter>0
							Field23Min=min([Field2Counter Field3Counter]);
							Field2Counter=Field2Counter-Field23Min;
							Field3Counter=Field3Counter-Field23Min;
						end
						if mod(Field2Counter,2)>0
							TheFieldSplitBase3_ni(i,nsp,icrackpath)=2;
							%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
						elseif mod(Field3Counter,2)>0
							TheFieldSplitBase3_ni(i,nsp,icrackpath)=3;
							%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
						end
					end
					% mapping revision done
					
					% checking if revision is successful
					nodalfieldlist=zeros(4,1);
					coder.varsize('nodalfieldlist');
					nodalfieldlist=sort(unique(transpose(TheFieldSplitBase3_ni(i,1:niSizes(i),icrackpath))));
					if length(nodalfieldlist)==3
						fprintf('%s',['fix attempt number ' int2txt(fixmode) ' failed' char(10)]);
						TheFieldSplitBase3_ni(i,:,icrackpath)=TheFieldSplitBase3_old_i;
						if fixmode==3
							fprintf('%s',['code 1904172033' char(10)]);
							pause
							1;
						end
					elseif length(nodalfieldlist)==2
						fprintf('%s',['fix attempt number ' int2txt(fixmode) ' successful' char(10)]);
						break;
					elseif length(nodalfieldlist)==1
						fprintf('%s',['fix attempt number ' int2txt(fixmode) ' broke separation (code 1904172022)' char(10)]);
						pause
						1;
					end
					% done checking if revision is successful
				end
			end
			%{
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			end
			if newfieldrevision>1
				for nsp=1:niSizes(i)
					if TheFieldSplitBase3_ni(i,nsp,icrackpath)==1
						TheFieldSplitBase3_ni(i,nsp,icrackpath)=newfieldrevision;
					end
				end
			end
			%}
		end
	end
	
	nroCounter=zeros(1,spCount);
	for io=1:niCount %io: moving number (i) of n(o)de
		for nrsp=1:niSizes(io)
			sp=CONNECTpn.values(io,nrsp);
			nroCounter(sp)=nroCounter(sp)+1;
			for j=1:numberofcrackpaths
				TheFieldSplitBase3_sp(nroCounter(sp),sp,j)=TheFieldSplitBase3_ni(io,nrsp,j);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplitBase3_sp_boxcalc] = SplitFieldMultiOptimized2_boxcalc(LOC,CONNECT,CONNECTpn,x_crack,t_time,le)
	%CONNECT aka CONNECT_crack.boxcalc
		%no .values as they're all 4, so values already in CONNECT_crack.boxcalc itself
	%CONNECTpn aka CONNECTpn_crack.boxcalc
		%there's a .values with the sizes (.nrparticles), since the array size can be anything.
	%nocount=nicount, no count is the more temporary call
	trajectory=0;
	numberofcrackpaths=x_crack.npaths;
	numberoffields=3^numberofcrackpaths;
	
	noCount=size(CONNECTpn.nrparticles,2);
	noSizes=CONNECTpn.nrparticles;
	maxnoSizes=CONNECTpn.maxnrparticles;
	TheFieldSplitBase3_ni_boxcalc=ones(noCount,maxnoSizes,2,numberofcrackpaths,numberofcrackpaths); %node number, relevant particle number, tip number, crackpath number, the tenary digits (length=number of crackpaths);
	TheFieldSplitBase3_sp_boxcalc=ones(4,4,2,numberofcrackpaths,numberofcrackpaths); %relevant node number (always 4, since MPM mapping), spCount (which is 4 for a box), particle number, tip number, crackpath number, the tenary digits (length=number of crackpaths);
	
	%for the loop layers below:
	%itip: which path
	%ipath2: which crack path
	%ipath: for the tenary digits
	x_sp_hack=zeros(4,2);
	
	for ipath2=1:numberofcrackpaths
	for itip=1:2
	if x_crack.boxcalc.active(ipath2,itip)==1
		Area=zeros(4,1);%fprintf('%s',['amarker #189' char(10)]);
		if itip==1
			ihackparticle=x_crack.nparticles(ipath2);
		else%if itip==2, but cant bcs coder will whine
			ihackparticle=1;
		end
		for icorner=1:4
			x_sp_hack(icorner,:)=0.999*x_crack.center(ihackparticle,:,ipath2)+0.001*x_crack.boxcalc.locs(icorner,:,ipath2,itip);
		end
		for ipath=1:numberofcrackpaths %not to get confused with numberofcrackpaths, ipath is the moving number, from 1 to numberofcrackpaths
			parfor io=1:noCount
				%the default method takes x_sp, which in this case is x_crack.boxcalc.locs(:,:,ipath2,itip). however we're implementing a hack, that is we take the position of crack tip as reference. the hacked x_sp is called x_sp_hack. 
				
				TheFieldSplitBase3_ni_boxcalc(io,:,itip,ipath2,ipath)=SplitFieldMultiOptimized2_parforred_ni(x_sp_hack,x_crack.center(1:x_crack.nparticles(ipath),:,ipath),t_time,noSizes(itip,io,ipath2),CONNECTpn.values(io,1:CONNECTpn.nrparticles(itip,io,ipath2),itip,ipath2),LOC(io,:),maxnoSizes);
			end
			for io=1:noCount
				nodalfieldlist=sort(unique(transpose(TheFieldSplitBase3_ni_boxcalc(io,1:noSizes(itip,io,ipath2),itip,ipath2,ipath))));
				newfieldrevision=1;
				if length(nodalfieldlist)==3
					fprintf('%s',['Field split error, applying fix! (code 1904012106)' char(10)]);
					1;
					problematicirsp=zeros(1,maxnoSizes);
					coder.varsize('problematicirsp');
					problematicirsp=zeros(1,0);
					for irsp=1:noSizes(itip,io,ipath2)
						if TheFieldSplitBase3_ni_boxcalc(io,irsp,itip,ipath2,ipath)>1
							problematicirsp=[problematicirsp irsp];
						end
					end
					TheFieldSplitBase3_old_i=TheFieldSplitBase3_ni_boxcalc(io,:,itip,ipath2,ipath);
					for fixmode=1:3
						% extending the crack
						%fixmode=1: x_crack.center{npid}(size(x_crack{npid},1),:) extension by le(1)
						%fixmode=2: x_crack{npid}(0,:) extension by le(1)
						%fixmode=3: both extensions
						x_crack_modified=x_crack.center(1:x_crack.nparticles(ipath),:,ipath);
						cracksize=size(x_crack_modified,1);
						if fixmode==1
							trajectory=reliableatan(x_crack.center(cracksize,1,ipath)-x_crack.center(cracksize-1,1,ipath),x_crack.center(cracksize,2,ipath)-x_crack.center(cracksize-1,2,ipath));
							x_crack_modified(cracksize,1)=x_crack.center(cracksize,1,ipath)+2*le(1)*cos(trajectory);
							x_crack_modified(cracksize,2)=x_crack.center(cracksize,2,ipath)+2*le(1)*sin(trajectory);
						elseif fixmode==2
							trajectory=reliableatan(x_crack.center(1,1,ipath)-x_crack.center(2,1,ipath),x_crack.center(1,2,ipath)-x_crack.center(2,2,ipath));
							x_crack_modified(1,1)=x_crack.center(1,1,ipath)+2*le(1)*cos(trajectory);
							x_crack_modified(1,2)=x_crack.center(1,2,ipath)+2*le(1)*sin(trajectory);
						elseif fixmode==3
							trajectory1=reliableatan(x_crack.center(cracksize,1,ipath)-x_crack.center(cracksize-1,1,ipath),x_crack.center(cracksize,2,ipath)-x_crack.center(cracksize-1,2,ipath));
							x_crack_modified(cracksize,1)=x_crack.center(cracksize,1,ipath)+2*le(1)*cos(trajectory1);
							x_crack_modified(cracksize,2)=x_crack.center(cracksize,2,ipath)+2*le(1)*sin(trajectory1);
							trajectory2=reliableatan(x_crack.center(1,1,ipath)-x_crack.center(2,1,ipath),x_crack.center(1,2,ipath)-x_crack.center(2,2,ipath));
							x_crack_modified(1,1)=x_crack.center(1,1,ipath)+2*le(1)*cos(trajectory2);
							x_crack_modified(1,2)=x_crack.center(1,2,ipath)+2*le(1)*sin(trajectory2);
						end
						% extending the crack finished
						% revising bad mapping
						for irsp_problematic=1:length(problematicirsp)
							Field2Counter=0;
							Field3Counter=0;
							irsp=problematicirsp(irsp_problematic);
							icorner=CONNECTpn.values(io,irsp,itip,ipath2);
							TheFieldSplitBase3_ni_boxcalc(io,irsp,itip,ipath2,ipath)=1;
							for crack_p_counter=1:(size(x_crack_modified,1)-1)
								%x1=x_crack.boxcalc.locs(icorner,:,ipath2,itip); %this is normal version, the hacked version is used below
								x1=x_sp_hack(icorner,:);
								x2=LOC(io,:);
								x3=x_crack_modified(crack_p_counter,:);
								x4=x_crack_modified(crack_p_counter+1,:);
								Area(1)=TriangleArea(x1,x2,x3);
								Area(2)=TriangleArea(x1,x2,x4);
								Area(3)=TriangleArea(x3,x4,x1);
								Area(4)=TriangleArea(x3,x4,x2);
								if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
									Field2Counter=Field2Counter+1;
								elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
									Field3Counter=Field3Counter+1;
								end
							end
							if Field2Counter>0 && Field3Counter>0
								Field23Min=min([Field2Counter Field3Counter]);
								Field2Counter=Field2Counter-Field23Min;
								Field3Counter=Field3Counter-Field23Min;
							end
							if mod(Field2Counter,2)>0
								TheFieldSplitBase3_ni_boxcalc(io,irsp,itip,ipath2,ipath)=2;
							elseif mod(Field3Counter,2)>0
								TheFieldSplitBase3_ni_boxcalc(io,irsp,itip,ipath2,ipath)=3;
							end
						end
						% mapping revision done
						
						% checking if revision is successful
						nodalfieldlist=zeros(4,1);
						coder.varsize('nodalfieldlist');
						nodalfieldlist=sort(unique(transpose(TheFieldSplitBase3_ni_boxcalc(io,1:noSizes(itip,io,ipath2),itip,ipath2,ipath))));
						if length(nodalfieldlist)==3
							fprintf('%s',['fix attempt number ' int2txt(fixmode) ' failed' char(10)]);
							TheFieldSplitBase3_ni_boxcalc(io,:,itip,ipath2,ipath)=TheFieldSplitBase3_old_i;
							if fixmode==3
								fprintf('%s',['code 1904172033' char(10)]);
								pause
								1;
							end
						elseif length(nodalfieldlist)==2
							fprintf('%s',['fix attempt number ' int2txt(fixmode) ' successful' char(10)]);
							break;
						elseif length(nodalfieldlist)==1
							fprintf('%s',['fix attempt number ' int2txt(fixmode) ' broke separation (code 1904172022)' char(10)]);
							pause
							1;
						end
						% done checking if revision is successful
					end
				end
			end
		end
		
		iro=zeros(1,1);
		for io=1:noCount %io: moving number (i) of n(o)de
			for nrsp=1:noSizes(itip,io,ipath2)
				icorner=CONNECTpn.values(io,nrsp,itip,ipath2);
				for iro_seek=1:4
					if CONNECT(icorner,iro_seek,ipath2,itip)==io
						iro=iro_seek;
						break;
					end
				end
				for ipath=1:numberofcrackpaths
					TheFieldSplitBase3_sp_boxcalc(iro,icorner,itip,ipath2,ipath)=TheFieldSplitBase3_ni_boxcalc(io,nrsp,itip,ipath2,ipath);
				end
			end
		end
	end
	end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplitBase3] = SplitFieldMultiOptimized2_parforred_sp(x_sp,x_crack,t_time,spSizes,CONNECT,LOC,maxspSizes)
	Area=zeros(1,4);
	TheFieldSplitBase3=ones(max(spSizes),1,1);
	x1=x_sp;
	for nni=1:spSizes
		ni=CONNECT(nni);
		Field2Counter=0;
		Field3Counter=0;
		x2=LOC(ni,:);
		for crack_p_counter=1:(size(x_crack,1)-1)
			x3=x_crack(crack_p_counter,:);
			x4=x_crack(crack_p_counter+1,:);
			Area(1)=TriangleArea(x1,x2,x3);
			Area(2)=TriangleArea(x1,x2,x4);
			Area(3)=TriangleArea(x3,x4,x1);
			Area(4)=TriangleArea(x3,x4,x2);
			if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
				Field2Counter=Field2Counter+1;
			elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
				Field3Counter=Field3Counter+1;
			end
		end
		if Field2Counter>0 && Field3Counter>0
			Field23Min=min([Field2Counter Field3Counter]);
			Field2Counter=Field2Counter-Field23Min;
			Field3Counter=Field3Counter-Field23Min;
		end
		if mod(Field2Counter,2)>0
			TheFieldSplitBase3(nni,1,1)=2;
			%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
		elseif mod(Field3Counter,2)>0
			TheFieldSplitBase3(nni,1,1)=3;
			%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
		end
	end
	for nni=spSizes+1:maxspSizes
		TheFieldSplitBase3(nni,1,1)=0;
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplitBase3_old] = SplitFieldMultiOptimized2_parforred(x_sp,x_crack,t_time,niSizes,CONNECTpn,LOC)
	Area=zeros(1,4);
	TheFieldSplitBase3_old=ones(niSizes,1);
	for nsp=1:niSizes
		sp=CONNECTpn(1,nsp);
		Field2Counter=0;
		Field3Counter=0;
		x1=x_sp(sp,:); %particle position
		x2=LOC(1,:); %node position
		for crack_p_counter=1:(size(x_crack,1)-1)
			x3=x_crack(crack_p_counter,:);
			x4=x_crack(crack_p_counter+1,:);
			Area(1)=TriangleArea(x1,x2,x3);
			Area(2)=TriangleArea(x1,x2,x4);
			Area(3)=TriangleArea(x3,x4,x1);
			Area(4)=TriangleArea(x3,x4,x2);
			if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
				Field2Counter=Field2Counter+1;
			elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
				Field3Counter=Field3Counter+1;
			end
		end
		if Field2Counter>0 && Field3Counter>0
			Field23Min=min([Field2Counter Field3Counter]);
			Field2Counter=Field2Counter-Field23Min;
			Field3Counter=Field3Counter-Field23Min;
		end
		if mod(Field2Counter,2)>0
			TheFieldSplitBase3_old(nsp,1)=2;
			%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
		elseif mod(Field3Counter,2)>0
			TheFieldSplitBase3_old(nsp,1)=3;
			%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplitBase3_ni] = SplitFieldMultiOptimized2_parforred_ni(x_sp,x_crack,t_time,niSizes,CONNECTpn,LOC,maxniSizes)
	Area=zeros(1,4);
	TheFieldSplitBase3_ni=ones(maxniSizes,1,1);
	for nsp=1:niSizes
		sp=CONNECTpn(1,nsp);
		Field2Counter=0;
		Field3Counter=0;
		x1=x_sp(sp,:); %particle position
		x2=LOC(1,:); %node position
		for crack_p_counter=1:(size(x_crack,1)-1)
			x3=x_crack(crack_p_counter,:);
			x4=x_crack(crack_p_counter+1,:);
			Area(1)=TriangleArea(x1,x2,x3);
			Area(2)=TriangleArea(x1,x2,x4);
			Area(3)=TriangleArea(x3,x4,x1);
			Area(4)=TriangleArea(x3,x4,x2);
			if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
				Field2Counter=Field2Counter+1;
			elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
				Field3Counter=Field3Counter+1;
			end
		end
		if Field2Counter>0 && Field3Counter>0
			Field23Min=min([Field2Counter Field3Counter]);
			Field2Counter=Field2Counter-Field23Min;
			Field3Counter=Field3Counter-Field23Min;
		end
		if mod(Field2Counter,2)>0
			TheFieldSplitBase3_ni(nsp,1,1)=2;
			%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
		elseif mod(Field3Counter,2)>0
			TheFieldSplitBase3_ni(nsp,1,1)=3;
			%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
		end
	end
	for nsp=niSizes+1:maxniSizes
		TheFieldSplitBase3_ni(nsp,1,1)=0;
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit,Nmatrix,dNxmatrix,dNymatrix,NmatrixAll] = SplitFieldMulti_crack(LOC,x_sp,CONNECT,CONNECTpn,x_crack,CONNECT_crack,CONNECTpn_crack,Nmatrix,dNxmatrix,dNymatrix,t_time,currentcrackpathnum,cracktoporbot)
	%fill in cracktoporbot=1 for crack, cracktoporbot=2 for top, and cracktoporbot=3 for bot
	NmatrixAll=Nmatrix;
	numberofcrackpaths=length(x_crack);
	numberoffields=3^numberofcrackpaths;
	if numberoffields>1
		Nmatrix(1,1,numberoffields)=0;
		dNxmatrix(1,1,numberoffields)=0;
		dNymatrix(1,1,numberoffields)=0;
	end
	TheFieldSplit=ones(size(CONNECTpn,1),length(CONNECT));
	TheFieldSplitBase3_old=ones(size(CONNECTpn,1),length(CONNECT),numberofcrackpaths);
	
	%for SuspectedNodeCounter=1:length(CONNECTpn_crack)
	Area=zeros(4,1);
	for icrackpath=1:numberofcrackpaths %not to get confused with numberofcrackpaths, icrackpath is the moving number, from 1 to numberofcrackpaths
		for sp=1:length(CONNECT)
			for ni=1:length(CONNECT{sp})
				if icrackpath==currentcrackpathnum
					i=CONNECT{sp}(ni);
					TheFieldSplitBase3_old(i,sp,icrackpath)=cracktoporbot;
				else
					Field2Counter=0;
					Field3Counter=0;
					for crack_p_counter=1:(size(x_crack{icrackpath},1)-1)
						i=CONNECT{sp}(ni);
						x1=x_sp(sp,:);
						x2=LOC(i,:);
						x3=x_crack{icrackpath}(crack_p_counter,:);
						x4=x_crack{icrackpath}(crack_p_counter+1,:);
						Area(1)=TriangleArea(x1,x2,x3);
						Area(2)=TriangleArea(x1,x2,x4);
						Area(3)=TriangleArea(x3,x4,x1);
						Area(4)=TriangleArea(x3,x4,x2);
						if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
							Field2Counter=Field2Counter+1;
						elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
							%{
							if sp==220 && ni==8 && CloseEnough(x1(1),58.740308582876274101636226987466,1e-5,2)
								1;
								plot(x1(1),x1(2),'o','DisplayName','particle')
								hold on
								plot(x2(1),x2(2),'o','DisplayName','node')
								plot(x3(1),x3(2),'o','DisplayName','crackbefore')
								plot(x4(1),x4(2),'o','DisplayName','crackafter')
								legend show
								hold off
								1;
							end
							%}
							Field3Counter=Field3Counter+1;
						end
					end
					if Field2Counter>0 && Field3Counter>0
						%{
						try
							asdf(-pi);
						catch exc
							disp('Field Split Error!');
							getReport(exc,'extended');
							pause;
							1;
						end
						%}
						1;
						Field23Min=min([Field2Counter Field3Counter]);
						Field2Counter=Field2Counter-Field23Min;
						Field3Counter=Field3Counter-Field23Min;
						1;
					end
					if mod(Field2Counter,2)>0
					%{
						TheFieldSplit(i,sp)=2*icrackpath;
						Nmatrix(i,sp,2*icrackpath)=Nmatrix(i,sp,1);
						Nmatrix(i,sp,1)=0;
						dNxmatrix(i,sp,2*icrackpath)=dNxmatrix(i,sp,1);
						dNxmatrix(i,sp,1)=0;
						dNymatrix(i,sp,2*icrackpath)=dNymatrix(i,sp,1);
						dNymatrix(i,sp,1)=0;
					%}
						TheFieldSplitBase3_old(i,sp,icrackpath)=2;
					elseif mod(Field3Counter,2)>0
					%{
						TheFieldSplit(i,sp)=2*icrackpath+1;
						Nmatrix(i,sp,2*icrackpath+1)=Nmatrix(i,sp,1);
						Nmatrix(i,sp,1)=0;
						dNxmatrix(i,sp,2*icrackpath+1)=dNxmatrix(i,sp,1);
						dNxmatrix(i,sp,1)=0;
						dNymatrix(i,sp,2*icrackpath+1)=dNymatrix(i,sp,1);
						dNymatrix(i,sp,1)=0;
					%}
						TheFieldSplitBase3_old(i,sp,icrackpath)=3;
					end
				end
			end
		end
		
		for i=1:size(CONNECTpn,1)
			CONNECTpnLength=0;
			for j=1:size(CONNECTpn,2);
				if CONNECTpn(i,j)>0
					CONNECTpnLength=CONNECTpnLength+1;
				else
					break;
				end
			end

			nodalfieldlist=sort(unique(TheFieldSplitBase3_old(i,CONNECTpn(i,1:CONNECTpnLength),icrackpath)));
			newfieldrevision=1;
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			elseif length(nodalfieldlist)==3
				fprintf('%s',['Field split error! (code 1904012104)' char(10)]);
				pause
				1;
			end
			if newfieldrevision>1
				for nsp=1:CONNECTpnLength
					if TheFieldSplitBase3_old(i,CONNECTpn(i,nsp),icrackpath)==1
						TheFieldSplitBase3_old(i,CONNECTpn(i,nsp),icrackpath)=newfieldrevision;
					end
				end
			end
		end

		%{
		for i=1:size(CONNECTpn,1)
			nodalfieldlist=sort(unique(TheFieldSplit(i,:)));
			newfieldrevision=1;
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			elseif length(nodalfieldlist)==3
				disp('Field split error, ignoring')
				%pause
				1;
			end
			if newfieldrevision>1
				for sp=1:length(CONNECT)
					if TheFieldSplit(i,sp)==1
						TheFieldSplit(i,sp)=newfieldrevision;
						Nmatrix(i,sp,newfieldrevision)=Nmatrix(i,sp,1);
						Nmatrix(i,sp,1)=0;
						dNxmatrix(i,sp,newfieldrevision)=dNxmatrix(i,sp,1);
						dNxmatrix(i,sp,1)=0;
						dNymatrix(i,sp,newfieldrevision)=dNymatrix(i,sp,1);
						dNymatrix(i,sp,1)=0;
					end
				end
			end
		end
		%}
	end
	for i=1:size(TheFieldSplitBase3_old,1)
		for sp=1:size(TheFieldSplitBase3_old,2)
			TheFieldSplit(i,sp)=BaseNtoDec(TheFieldSplitBase3_old(i,sp,:),1,3);
		end
	end
	for i=1:size(TheFieldSplit,1)
		for sp=1:size(TheFieldSplit,2)
			if TheFieldSplit(i,sp)==1
			else
				if TheFieldSplit(i,sp)==9
					1;
				end
				Nmatrix(i,sp,TheFieldSplit(i,sp))=Nmatrix(i,sp,1);
				Nmatrix(i,sp,1)=0;
				
				dNxmatrix(i,sp,TheFieldSplit(i,sp))=dNxmatrix(i,sp,1);
				dNxmatrix(i,sp,1)=0;
				
				dNymatrix(i,sp,TheFieldSplit(i,sp))=dNymatrix(i,sp,1);
				dNymatrix(i,sp,1)=0;
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit] = SplitFieldMulti_crackoptimized(LOC,x_sp,CONNECT,CONNECTpn,x_crack,currentcrackpathnum,cracktoporbot)
	%fill in cracktoporbot=1 for crack, cracktoporbot=2 for top, and cracktoporbot=3 for bot
	
	numberofcrackpaths=length(x_crack);
	numberoffields=3^numberofcrackpaths;
	
	TheFieldSplit=ones(size(CONNECTpn,1),length(CONNECT));
	TheFieldSplitBase3_old=ones(size(CONNECTpn,1),length(CONNECT),numberofcrackpaths);
	
	Area=zeros(4,1);
	for icrackpath=1:numberofcrackpaths %not to get confused with numberofcrackpaths, icrackpath is the moving number, from 1 to numberofcrackpaths
		for sp=1:length(CONNECT)
			for ni=1:length(CONNECT{sp})
				if icrackpath==currentcrackpathnum
					i=CONNECT{sp}(ni);
					TheFieldSplitBase3_old(i,sp,icrackpath)=cracktoporbot;
				else
					Field2Counter=0;
					Field3Counter=0;
					for crack_p_counter=1:(size(x_crack{icrackpath},1)-1)
						i=CONNECT{sp}(ni);
						x1=x_sp(sp,:);
						x2=LOC(i,:);
						x3=x_crack{icrackpath}(crack_p_counter,:);
						x4=x_crack{icrackpath}(crack_p_counter+1,:);
						Area(1)=TriangleArea(x1,x2,x3);
						Area(2)=TriangleArea(x1,x2,x4);
						Area(3)=TriangleArea(x3,x4,x1);
						Area(4)=TriangleArea(x3,x4,x2);
						if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
							Field2Counter=Field2Counter+1;
						elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
							Field3Counter=Field3Counter+1;
						end
					end
					if Field2Counter>0 && Field3Counter>0
						1;
						Field23Min=min([Field2Counter Field3Counter]);
						Field2Counter=Field2Counter-Field23Min;
						Field3Counter=Field3Counter-Field23Min;
						1;
					end
					if mod(Field2Counter,2)>0
						TheFieldSplitBase3_old(i,sp,icrackpath)=2;
					elseif mod(Field3Counter,2)>0
						TheFieldSplitBase3_old(i,sp,icrackpath)=3;
					end
				end
			end
		end
		
		for i=1:size(CONNECTpn,1)
			CONNECTpnLength=0;
			for j=1:size(CONNECTpn,2);
				if CONNECTpn(i,j)>0
					CONNECTpnLength=CONNECTpnLength+1;
				else
					break;
				end
			end
			nodalfieldlist=sort(unique(TheFieldSplitBase3_old(i,CONNECTpn(i,1:CONNECTpnLength),icrackpath)));
			newfieldrevision=1;
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			elseif length(nodalfieldlist)==3
				fprintf('%s',['Field split error! (code 1904012105)' char(10)]);
				pause
				1;
			end
			if newfieldrevision>1
				for nsp=1:CONNECTpnLength
					if TheFieldSplitBase3_old(i,CONNECTpn(i,nsp),icrackpath)==1
						TheFieldSplitBase3_old(i,CONNECTpn(i,nsp),icrackpath)=newfieldrevision;
					end
				end
			end
		end
	end
	for i=1:size(TheFieldSplitBase3_old,1)
		for sp=1:size(TheFieldSplitBase3_old,2)
			TheFieldSplit(i,sp)=BaseNtoDec(TheFieldSplitBase3_old(i,sp,:),1,3);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplitBase3_old] = SplitFieldMulti_crackoptimized2(LOC,x_sp,CONNECT,CONNECTpn,x_crack,currentcrackpathnum,cracktoporbot,le)
	%fill in cracktoporbot=1 for crack, cracktoporbot=2 for top, and cracktoporbot=3 for bot
	
	numberofcrackpaths=x_crack.npaths;
	numberoffields=3^numberofcrackpaths;
	
	TheFieldSplit=ones(size(CONNECTpn,1),length(CONNECT));
	TheFieldSplitBase3_old=ones(size(CONNECTpn,1),length(CONNECT),numberofcrackpaths);
	
	Area=zeros(4,1);
	for icrackpath=1:numberofcrackpaths %not to get confused with numberofcrackpaths, icrackpath is the moving number, from 1 to numberofcrackpaths
		for sp=1:length(CONNECT)
			for ni=1:length(CONNECT{sp})
				i=CONNECT{sp}(ni);
				if icrackpath==currentcrackpathnum
					TheFieldSplitBase3_old(i,sp,icrackpath)=cracktoporbot;
				else
					Field2Counter=0;
					Field3Counter=0;
					for crack_p_counter=1:(x_crack.nparticles(icrackpath)-1)
						x1=x_sp(sp,:);
						x2=LOC(i,:);
						x3=x_crack.center(crack_p_counter,:,icrackpath);
						x4=x_crack.center(crack_p_counter+1,:,icrackpath);
						Area(1)=TriangleArea(x1,x2,x3);
						Area(2)=TriangleArea(x1,x2,x4);
						Area(3)=TriangleArea(x3,x4,x1);
						Area(4)=TriangleArea(x3,x4,x2);
						if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
							Field2Counter=Field2Counter+1;
						elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
							Field3Counter=Field3Counter+1;
						end
					end
					if Field2Counter>0 && Field3Counter>0
						1;
						Field23Min=min([Field2Counter Field3Counter]);
						Field2Counter=Field2Counter-Field23Min;
						Field3Counter=Field3Counter-Field23Min;
						1;
					end
					if mod(Field2Counter,2)>0
						TheFieldSplitBase3_old(i,sp,icrackpath)=2;
					elseif mod(Field3Counter,2)>0
						TheFieldSplitBase3_old(i,sp,icrackpath)=3;
					end
				end
			end
		end
		
		for i=1:size(CONNECTpn,1)
			CONNECTpnLength=0;
			for j=1:size(CONNECTpn,2);
				if CONNECTpn(i,j)>0
					CONNECTpnLength=CONNECTpnLength+1;
				else
					break;
				end
			end
			nodalfieldlist=sort(unique(TheFieldSplitBase3_old(i,CONNECTpn(i,1:CONNECTpnLength),icrackpath)));
			newfieldrevision=1;
			if length(nodalfieldlist)==3
				fprintf('%s',['Field split error, applying fix! (code 1904012106)' char(10)]);
				%pause
				1;
				problematicnsp=zeros(1,0);
				for nsp=1:CONNECTpnLength
					if TheFieldSplitBase3_old(i,CONNECTpn(i,nsp),icrackpath)>1
						problematicnsp=[problematicnsp nsp];
					end
				end
				TheFieldSplitBase3_old=TheFieldSplitBase3_old;
				x_crack_modified=x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath);
				for fixmode=1:3
					% extending the crack
					%fixmode=1: x_crack.center(x_crack.nparticles(npid),:,npid) extension by le(1)
					%fixmode=2: x_crack(0,:,npid) extension by le(1)
					%fixmode=3: both extensions
					if fixmode==1
						x_crack_modified=x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath);
						cracksize=size(x_crack_modified,1);
						trajectory=reliableatan(x_crack.center(cracksize,1,icrackpath)-x_crack.center(cracksize-1,1,icrackpath),x_crack.center(cracksize,2,icrackpath)-x_crack.center(cracksize-1,2,icrackpath));
						x_crack_modified(cracksize,1)=x_crack.center(cracksize,1,icrackpath)+le(1)*cos(trajectory);
						x_crack_modified(cracksize,2)=x_crack.center(cracksize,2,icrackpath)+le(1)*sin(trajectory);
					elseif fixmode==2
						x_crack_modified=x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath);
						cracksize=size(x_crack_modified,1);
						trajectory=reliableatan(x_crack.center(1,1,icrackpath)-x_crack.center(2,1,icrackpath),x_crack.center(1,2,icrackpath)-x_crack.center(2,2,icrackpath));
						x_crack_modified(1,1)=x_crack.center(1,1,icrackpath)+le(1)*cos(trajectory);
						x_crack_modified(1,2)=x_crack.center(1,2,icrackpath)+le(1)*sin(trajectory);
					elseif fixmode==3
						x_crack_modified=x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath);
						cracksize=size(x_crack_modified,1);
						trajectory1=reliableatan(x_crack.center(cracksize,1,icrackpath)-x_crack.center(cracksize-1,1,icrackpath),x_crack.center(cracksize,2,icrackpath)-x_crack.center(cracksize-1,2,icrackpath));
						x_crack_modified(cracksize,1)=x_crack.center(cracksize,1,icrackpath)+le(1)*cos(trajectory1);
						x_crack_modified(cracksize,2)=x_crack.center(cracksize,2,icrackpath)+le(1)*sin(trajectory1);
						trajectory2=reliableatan(x_crack.center(1,1,icrackpath)-x_crack.center(2,1,icrackpath),x_crack.center(1,2,icrackpath)-x_crack.center(2,2,icrackpath));
						x_crack_modified(1,1)=x_crack.center(1,1,icrackpath)+le(1)*cos(trajectory2);
						x_crack_modified(1,2)=x_crack.center(1,2,icrackpath)+le(1)*sin(trajectory2);
					end
					% extending the crack finished
					
					% revising bad mapping
					for nsp=1:length(problematicnsp)
						Field2Counter=0;
						Field3Counter=0;
						sp=CONNECTpn(i,problematicnsp(nsp));
						TheFieldSplitBase3_old(i,sp,icrackpath)=1;
						for crack_p_counter=1:(size(x_crack_modified,1)-1)
							x1=x_sp(sp,:);
							x2=LOC(i,:);
							x3=x_crack_modified(crack_p_counter,:);
							x4=x_crack_modified(crack_p_counter+1,:);
							Area(1)=TriangleArea(x1,x2,x3);
							Area(2)=TriangleArea(x1,x2,x4);
							Area(3)=TriangleArea(x3,x4,x1);
							Area(4)=TriangleArea(x3,x4,x2);
							if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
								Field2Counter=Field2Counter+1;
								%close gcf;
								%plot(LOC(i,1),LOC(i,2),'o','DisplayName','Node');
								%hold on
								%plot(x_sp(sp,1),x_sp(sp,2),'o','DisplayName','Particle');
								%plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
								%plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
								%daspect([1 1 1]);
								%legend show
								%title(['above, particle=' num2str(sp) ', node=' num2str(i)]);
								%1;
							elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
								Field3Counter=Field3Counter+1;
								%close gcf;
								%plot(LOC(i,1),LOC(i,2),'o','DisplayName','Node');
								%hold on
								%plot(x_sp(sp,1),x_sp(sp,2),'o','DisplayName','Particle');
								%plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
								%plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
								%daspect([1 1 1]);
								%legend show
								%title(['below, particle=' num2str(sp) ', node=' num2str(i)]);
								%1;
							end
						end
						if Field2Counter>0 && Field3Counter>0
							Field23Min=min([Field2Counter Field3Counter]);
							Field2Counter=Field2Counter-Field23Min;
							Field3Counter=Field3Counter-Field23Min;
						end
						if mod(Field2Counter,2)>0
							TheFieldSplitBase3_old(i,sp,icrackpath)=2;
							%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
						elseif mod(Field3Counter,2)>0
							TheFieldSplitBase3_old(i,sp,icrackpath)=3;
							%SplitSourceSplitBase3(i,sp,icrackpath)=crack_p_counter;
						end
					end
					% mapping revision done

					% checking if revision is successful
					nodalfieldlist=sort(unique(TheFieldSplitBase3_old(i,CONNECTpn(i,1:CONNECTpnLength),icrackpath)));
					if length(nodalfieldlist)==3
						fprintf('%s',['fix attempt number ' int2txt(fixmode) ' failed' char(10)]);
						TheFieldSplitBase3_old=TheFieldSplitBase3_old;
						if fixmode==3
							fprintf('%s',['code 1904172033' char(10)]);
							pause
							1;
						end
					elseif length(nodalfieldlist)==2
						fprintf('%s',['fix attempt number ' int2txt(fixmode) ' successful' char(10)]);
						break;
					elseif length(nodalfieldlist)==1
						fprintf('%s',['fix attempt number ' int2txt(fixmode) ' broke separation (code 1904172022)' char(10)]);
						pause
						1;
					end
					% done checking if revision is successful
				end	
			end
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			end
			if newfieldrevision>1
				for nsp=1:CONNECTpnLength
					if TheFieldSplitBase3_old(i,CONNECTpn(i,nsp),icrackpath)==1
						TheFieldSplitBase3_old(i,CONNECTpn(i,nsp),icrackpath)=newfieldrevision;
					end
				end
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplitBase3_sp] = SplitFieldMulti_crackoptimized2_nocell(LOC,x_sp,CONNECT_crack_topbot,CONNECTpn_crack_topbot,x_crack,currentcrackpathnum,cracktoporbot,le)
	%fill in cracktoporbot=1 for crack, cracktoporbot=2 for top, and cracktoporbot=3 for bot
	%currentcrackpathnum: for the crack particles, for the positions
	%icrackpath: for the crack lines, for the separation
	irsp_outloop=1; %basically irsp but different to stop coder whining
	
	spSizes=CONNECT_crack_topbot.nrnodes(currentcrackpathnum,:);
	noCount=size(CONNECTpn_crack_topbot.values,1);
	spCount=x_crack.nparticles(currentcrackpathnum);
	maxspSizes=max(spSizes);
	numberofcrackpaths=x_crack.npaths;
	numberoffields=3^numberofcrackpaths;
	
	%TheFieldSplit=ones(maxspSizes,x_crack.nparticles(currentcrackpathnum));
	TheFieldSplitBase3_sp=ones(maxspSizes,x_crack.nparticles(currentcrackpathnum),numberofcrackpaths);
	TheFieldSplitBase3_ni=ones(noCount,CONNECTpn_crack_topbot.maxnrparticles,numberofcrackpaths);
	x_sp=zeros(1,2);
	deltax=zeros(1,2);
	
	Area=zeros(4,1);
	for icrackpath=1:numberofcrackpaths %not to get confused with numberofcrackpaths, icrackpath is the moving number, from 1 to numberofcrackpaths
		for io=1:noCount
			for irsp=1:CONNECTpn_crack_topbot.nrparticles(currentcrackpathnum,io)
				sp=CONNECTpn_crack_topbot.values(io,irsp,currentcrackpathnum);
				if icrackpath==currentcrackpathnum
					pathbefore=zeros(1,2);
					pathafter=zeros(1,2);
					if sp>1 %for before
						deltax=x_crack.center(sp,:,currentcrackpathnum)-x_crack.center(sp-1,:,currentcrackpathnum);
						pathbefore=deltax/sqrt(dot(deltax,deltax));
					end
					if sp<x_crack.nparticles(currentcrackpathnum)
						deltax=x_crack.center(sp+1,:,currentcrackpathnum)-x_crack.center(sp,:,currentcrackpathnum);
						pathafter=deltax/sqrt(dot(deltax,deltax));
					end
					pathsummed=pathbefore+pathafter;
					pathangleaverage=reliableatan(pathsummed(1),pathsummed(2));
					if cracktoporbot==2
						pathangledrift=pathangleaverage+pi/2;
					elseif cracktoporbot==3
						pathangledrift=pathangleaverage-pi/2;
					else
						pathangledrift=pathangleaverage;
					end
					x_sp=x_crack.center(sp,:,currentcrackpathnum)+(le(1)/10000)*[cos(pathangledrift) sin(pathangledrift)];
				elseif cracktoporbot==2
					x_sp=x_crack.top(sp,:,currentcrackpathnum);
				elseif cracktoporbot==3
					x_sp=x_crack.bot(sp,:,currentcrackpathnum);
				else
					x_sp=x_crack.center(sp,:,currentcrackpathnum);
				end
				Field2Counter=0;
				Field3Counter=0;
				for crack_p_counter=1:(x_crack.nparticles(icrackpath)-1)
					x1=x_sp;
					x2=LOC(io,:);
					x3=x_crack.center(crack_p_counter,:,icrackpath);
					x4=x_crack.center(crack_p_counter+1,:,icrackpath);
					Area(1)=TriangleArea(x1,x2,x3);
					Area(2)=TriangleArea(x1,x2,x4);
					Area(3)=TriangleArea(x3,x4,x1);
					Area(4)=TriangleArea(x3,x4,x2);
					if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
						Field2Counter=Field2Counter+1;
					elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
						Field3Counter=Field3Counter+1;
					end
				end
				if Field2Counter>0 && Field3Counter>0
					1;
					Field23Min=min([Field2Counter Field3Counter]);
					Field2Counter=Field2Counter-Field23Min;
					Field3Counter=Field3Counter-Field23Min;
					1;
				end
				if mod(Field2Counter,2)>0
					TheFieldSplitBase3_ni(io,irsp,icrackpath)=2;
				elseif mod(Field3Counter,2)>0
					TheFieldSplitBase3_ni(io,irsp,icrackpath)=3;
				end
				%{
				if sp==5 && cracktoporbot==2
					io
					TheFieldSplitBase3_ni(io,irsp,icrackpath)
					LOC(io,:)
					1;
				end
				%}
			end
		end
		
		for io=1:noCount
			%for irsp=1:CONNECTpn_crack_topbot.nrparticles(icrack,io,icrackpath)
			nodalfieldlist=sort(unique(TheFieldSplitBase3_ni(io,1:CONNECTpn_crack_topbot.nrparticles(currentcrackpathnum,io),icrackpath)));
			newfieldrevision=1;
			if length(nodalfieldlist)==3
				fprintf('%s',['Field split error, applying fix! (code 1904012106)' char(10)]);
				%pause
				1;
				problematicnsp=zeros(1,CONNECTpn_crack_topbot.maxnrparticles);
				coder.varsize('problematicnsp');
				problematicnsp=zeros(1,0);
				for irsp=1:CONNECTpn_crack_topbot.nrparticles(currentcrackpathnum,io);
					if TheFieldSplitBase3_ni(io,irsp,icrackpath)>1
						problematicnsp=[problematicnsp irsp];
					end
				end
				TheFieldSplitBase3_old_io=TheFieldSplitBase3_ni(io,:,icrackpath);
				x_crack_modified=x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath);
				for fixmode=1:3
					% extending the crack
					%fixmode=1: x_crack.center(x_crack.nparticles(npid),:,npid) extension by le(1)
					%fixmode=2: x_crack(0,:,npid) extension by le(1)
					%fixmode=3: both extensions
					if fixmode==1
						x_crack_modified=x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath);
						cracksize=size(x_crack_modified,1);
						trajectory=reliableatan(x_crack.center(cracksize,1,icrackpath)-x_crack.center(cracksize-1,1,icrackpath),x_crack.center(cracksize,2,icrackpath)-x_crack.center(cracksize-1,2,icrackpath));
						x_crack_modified(cracksize,1)=x_crack.center(cracksize,1,icrackpath)+2*le(1)*cos(trajectory);
						x_crack_modified(cracksize,2)=x_crack.center(cracksize,2,icrackpath)+2*le(1)*sin(trajectory);
					elseif fixmode==2
						x_crack_modified=x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath);
						cracksize=size(x_crack_modified,1);
						trajectory=reliableatan(x_crack.center(1,1,icrackpath)-x_crack.center(2,1,icrackpath),x_crack.center(1,2,icrackpath)-x_crack.center(2,2,icrackpath));
						x_crack_modified(1,1)=x_crack.center(1,1,icrackpath)+2*le(1)*cos(trajectory);
						x_crack_modified(1,2)=x_crack.center(1,2,icrackpath)+2*le(1)*sin(trajectory);
					elseif fixmode==3
						x_crack_modified=x_crack.center(1:x_crack.nparticles(icrackpath),:,icrackpath);
						cracksize=size(x_crack_modified,1);
						trajectory1=reliableatan(x_crack.center(cracksize,1,icrackpath)-x_crack.center(cracksize-1,1,icrackpath),x_crack.center(cracksize,2,icrackpath)-x_crack.center(cracksize-1,2,icrackpath));
						x_crack_modified(cracksize,1)=x_crack.center(cracksize,1,icrackpath)+2*le(1)*cos(trajectory1);
						x_crack_modified(cracksize,2)=x_crack.center(cracksize,2,icrackpath)+2*le(1)*sin(trajectory1);
						trajectory2=reliableatan(x_crack.center(1,1,icrackpath)-x_crack.center(2,1,icrackpath),x_crack.center(1,2,icrackpath)-x_crack.center(2,2,icrackpath));
						x_crack_modified(1,1)=x_crack.center(1,1,icrackpath)+2*le(1)*cos(trajectory2);
						x_crack_modified(1,2)=x_crack.center(1,2,icrackpath)+2*le(1)*sin(trajectory2);
					end
					% extending the crack finished
					
					% revising bad mapping
					for iproblematicnsp=1:length(problematicnsp)
						Field2Counter=0;
						Field3Counter=0;
						irsp_outloop=problematicnsp(iproblematicnsp);
						sp=CONNECTpn_crack_topbot.values(io,problematicnsp(iproblematicnsp),currentcrackpathnum);
						if icrackpath==currentcrackpathnum
							pathbefore=zeros(1,2);
							pathafter=zeros(1,2);
							if sp>1 %for before
								deltax=x_crack.center(sp,:,currentcrackpathnum)-x_crack.center(sp-1,:,currentcrackpathnum);
								pathbefore=deltax/sqrt(dot(deltax,deltax));
							end
							if sp<x_crack.nparticles(currentcrackpathnum)
								deltax=x_crack.center(sp+1,:,currentcrackpathnum)-x_crack.center(sp,:,currentcrackpathnum);
								pathafter=deltax/sqrt(dot(deltax,deltax));
							end
							pathsummed=pathbefore+pathafter;
							pathangleaverage=reliableatan(pathsummed(1),pathsummed(2));
							if cracktoporbot==2
								pathangledrift=pathangleaverage+pi/2;
							elseif cracktoporbot==3
								pathangledrift=pathangleaverage-pi/2;
							else
								pathangledrift=pathangleaverage;
							end
							x_sp=x_crack.center(sp,:,currentcrackpathnum)+(le(1)/10000)*[cos(pathangledrift) sin(pathangledrift)];
						elseif cracktoporbot==2
							x_sp=x_crack.top(sp,:,currentcrackpathnum);
						elseif cracktoporbot==3
							x_sp=x_crack.bot(sp,:,currentcrackpathnum);
						else
							x_sp=x_crack.center(sp,:,currentcrackpathnum);
						end
						TheFieldSplitBase3_ni(io,irsp_outloop,icrackpath)=1;
						for crack_p_counter=1:(size(x_crack_modified,1)-1)
							x1=x_sp;
							x2=LOC(io,:);
							x3=x_crack_modified(crack_p_counter,:);
							x4=x_crack_modified(crack_p_counter+1,:);
							Area(1)=TriangleArea(x1,x2,x3);
							Area(2)=TriangleArea(x1,x2,x4);
							Area(3)=TriangleArea(x3,x4,x1);
							Area(4)=TriangleArea(x3,x4,x2);
							if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
								Field2Counter=Field2Counter+1;
								%close gcf;
								%plot(LOC(io,1),LOC(io,2),'o','DisplayName','Node');
								%hold on
								%plot(x_sp(sp,1),x_sp(sp,2),'o','DisplayName','Particle');
								%plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
								%plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
								%daspect([1 1 1]);
								%legend show
								%title(['above, particle=' num2str(sp) ', node=' num2str(io)]);
								%1;
							elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
								Field3Counter=Field3Counter+1;
								%close gcf;
								%plot(LOC(io,1),LOC(io,2),'o','DisplayName','Node');
								%hold on
								%plot(x_sp(sp,1),x_sp(sp,2),'o','DisplayName','Particle');
								%plot(x_crack_modified(:,1),x_crack_modified(:,2),'-','DisplayName','Crack Whole');
								%plot(x_crack_modified(crack_p_counter:crack_p_counter+1,1),x_crack_modified(crack_p_counter:crack_p_counter+1,2),'-o','DisplayName','Crack Interest');
								%daspect([1 1 1]);
								%legend show
								%title(['below, particle=' num2str(sp) ', node=' num2str(io)]);
								%1;
							end
						end
						if Field2Counter>0 && Field3Counter>0
							Field23Min=min([Field2Counter Field3Counter]);
							Field2Counter=Field2Counter-Field23Min;
							Field3Counter=Field3Counter-Field23Min;
						end
						if mod(Field2Counter,2)>0
							TheFieldSplitBase3_ni(io,irsp_outloop,icrackpath)=2;
							%SplitSourceSplitBase3(io,sp,icrackpath)=crack_p_counter;
						elseif mod(Field3Counter,2)>0
							TheFieldSplitBase3_ni(io,irsp_outloop,icrackpath)=3;
							%SplitSourceSplitBase3(io,sp,icrackpath)=crack_p_counter;
						end
					end
					% mapping revision done
					
					% checking if revision is successful
					nodalfieldlist=sort(unique(TheFieldSplitBase3_ni(io,1:CONNECTpn_crack_topbot.nrparticles(currentcrackpathnum,io),icrackpath)));
					if length(nodalfieldlist)==3
						fprintf('%s',['fix attempt number ' int2txt(fixmode) ' failed' char(10)]);
						TheFieldSplitBase3_ni(irsp_outloop,:,icrackpath)=TheFieldSplitBase3_old_io;
						if fixmode==3
							fprintf('%s',['code 1904172033' char(10)]);
							pause
							1;
						end
					elseif length(nodalfieldlist)==2
						fprintf('%s',['fix attempt number ' int2txt(fixmode) ' successful' char(10)]);
						break;
					elseif length(nodalfieldlist)==1
						fprintf('%s',['fix attempt number ' int2txt(fixmode) ' broke separation (code 1904172022)' char(10)]);
						pause;
						1;
					end
					% done checking if revision is successful
				end	
			end
			%{
			if length(nodalfieldlist)==2
				if nodalfieldlist(1)==1 && nodalfieldlist(2)==2
					newfieldrevision=3;
				elseif nodalfieldlist(1)==1 && nodalfieldlist(2)==3
					newfieldrevision=2;
				end
			end
			if newfieldrevision>1
				for irsp=1:CONNECTpn_crack_topbot.nrparticles(currentcrackpathnum,io)
					if TheFieldSplitBase3_ni(io,irsp,icrackpath)==1
						TheFieldSplitBase3_ni(io,irsp,icrackpath)=newfieldrevision;
					end
				end
			end
			%}
		end
	end
	%nroCounter=zeros(1,spCount);
	iro=1;
	for io=1:noCount %io: moving number (i) of n(o)de
		for nrsp=1:CONNECTpn_crack_topbot.nrparticles(currentcrackpathnum,io);
			sp=CONNECTpn_crack_topbot.values(io,nrsp,currentcrackpathnum);
			for iro_seek=1:4
				if CONNECT_crack_topbot.values(sp,iro_seek,currentcrackpathnum)==io
					iro=iro_seek;
					break;
				end
			end
			%nroCounter(sp)=nroCounter(sp)+1;
			for j=1:numberofcrackpaths
				TheFieldSplitBase3_sp(iro,sp,j)=TheFieldSplitBase3_ni(io,nrsp,j);
			end
		end
	end
	1;
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function DecOut=BaseNtoDec(inputarray,startnum,endnum)
	DecOut=startnum;
	inputarraylength=length(inputarray);
	for i=inputarraylength:-1:1
		DecOut=DecOut+(inputarray(i)-startnum)*(endnum+1-startnum)^(inputarraylength-i);
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [CrossDir,RelativeLocation]=FindCrossing(x1,x2,x3,x4)
	%CrossDir=0:no crossing; 1:cross from above; 2:cross from below
	CrossDir=0;
	RelativeLocation=0;
	Area=zeros(1,4);
	Area(1)=TriangleArea(x1,x2,x3);
	Area(2)=TriangleArea(x1,x2,x4);
	Area(3)=TriangleArea(x3,x4,x1);
	Area(4)=TriangleArea(x3,x4,x2);
	if Area(1)<0 && Area(2)>=0 && Area(3)>=0 && Area(4)<0
		CrossDir=1;
		RelativeLocation=Area(3)/(Area(3)-Area(4));
	elseif Area(1)>=0 && Area(2)<0 && Area(3)<0 && Area(4)>=0
		CrossDir=2;
		RelativeLocation=Area(3)/(Area(3)-Area(4));
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function Area = TriangleArea(x1,x2,x3)
	Area=x1(1)*(x2(2)-x3(2))+x2(1)*(x3(2)-x1(2))+x3(1)*(x1(2)-x2(2));
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [nmass_si,nmomentum_si,niforce_si,neforce_si,traction_si,pforce_si,ncforce_si,L_si]=Interpolate_Particle_To_Grid_WithPredeterminedVelocity2(NODES,nodeCount,CONNECT,le,N,dN,spCount,b_sp,A_sp,t_sp,ptraction_sp,v_ssp,s_sp,m_sp,pforce_sp,Nmatrix,dNxmatrix,dNymatrix,ncforce_cracktop,ncforce_crackbot,Nmatrix_cracktop,Nmatrix_crackbot,TheFieldSplit,CasetoRun,CONNECTpn)
	%% Interpolation from particle to grid task
	% Node variables
	fieldnumber=size(Nmatrix,3);
	nmass_si=zeros(size(Nmatrix,1),fieldnumber);
	nmomentum_si=zeros(size(Nmatrix,1),2,fieldnumber);
	for field=fieldnumber:-1:1
		nmass_si(:,field)                = Nmatrix(:,:,field)*m_sp;                         % Nodal Mass
		nmomentum_si(:,1,field)       = Nmatrix(:,:,field)*(m_sp.*v_ssp(:,1));           % Nodal Momentum in X direction
		nmomentum_si(:,2,field)       = Nmatrix(:,:,field)*(m_sp.*v_ssp(:,2));           % Nodal Momentum in Y direction
	end
	niforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal Internal force
	neforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal External force
	traction_si             = zeros(nodeCount,2,fieldnumber);                   % Nodal Traction
	pforce_si               = zeros(nodeCount,2,fieldnumber);                   % Nodal Extra Particle force
	L_si                    = zeros(nodeCount,2,2,fieldnumber);
	pforce_si               = zeros(nodeCount,2,fieldnumber);                   % Nodal traction
	SSPtophalf_sp           = zeros(spCount,2);
	SSPbothalf_sp           = zeros(spCount,2);

	ncforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal crack force

	if CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 %multicrack nodal force deactivated for now
	else
		ncforce_si(:,:,2)    = Nmatrix_cracktop*ncforce_cracktop;
		ncforce_si(:,:,3)    = Nmatrix_crackbot*ncforce_crackbot;
	end

	%{
	ncforce_si(:,1,2)    = Nmatrix_cracktop*ncforce_cracktop(:,1);
	ncforce_si(:,2,2)    = Nmatrix_cracktop*ncforce_cracktop(:,2);
	ncforce_si(:,1,3)    = Nmatrix_crackbot*ncforce_crackbot(:,1);
	ncforce_si(:,2,3)    = Nmatrix_crackbot*ncforce_crackbot(:,2);
	%}

	for i=1:nodeCount
		niSize=size(CONNECTpn,2); %size of list of sp for a certain ni
		for nsp=1:size(CONNECTpn,2)
			if CONNECTpn(i,nsp)<1
				niSize=nsp-1;
				break;
			end
		end
		TheFieldSplit_ni=zeros(1,niSize) %A row of TheFieldSplit for a certain ni
		for nsp=1:niSize
			nni=0;
			sp=CONNECTpn(i,nsp);
			for nni=1:length(CONNECT{sp});
				if CONNECT{sp}(nni)==i;
					break;
				end
			end
			TheFieldSplit_ni(1,nsp)=TheFieldSplit{sp}(nni);
		end
		if unique(TheFieldSplit_ni(1,:))==1
			ncforce_si(i,:,1)=ncforce_si(i,:,2)+ncforce_si(i,:,3);
			ncforce_si(i,:,2)=[0 0];
			ncforce_si(i,:,3)=[0 0];
		end
	end

	for sp=1:spCount %originally parfor
		SSPtophalf_sp(sp,:)=[s_sp(sp,1) s_sp(sp,3)];
		SSPbothalf_sp(sp,:)=[s_sp(sp,3) s_sp(sp,2)];
	end

	for field=1:fieldnumber
		niforce_si(:,1,field)        = -((dNxmatrix(:,:,field)*(A_sp.*t_sp.*SSPtophalf_sp(:,1)))+(dNymatrix(:,:,field)*(A_sp.*t_sp.*SSPtophalf_sp(:,2)))) ;%- 0.07*v_ssp(sp,:); %damping
		niforce_si(:,2,field)        = -((dNxmatrix(:,:,field)*(A_sp.*t_sp.*SSPbothalf_sp(:,1)))+(dNymatrix(:,:,field)*(A_sp.*t_sp.*SSPbothalf_sp(:,2)))) ;%- 0.07*v_ssp(sp,:); %damping
	end

	for field=1:fieldnumber
		L_si(:,1,1,field)=dNxmatrix(:,:,field)*v_ssp(:,1);
		L_si(:,1,2,field)=dNymatrix(:,:,field)*v_ssp(:,1);
		L_si(:,2,1,field)=dNxmatrix(:,:,field)*v_ssp(:,2);
		L_si(:,2,2,field)=dNymatrix(:,:,field)*v_ssp(:,2);

		neforce_si(:,1,field)         = Nmatrix(:,:,field)*(b_sp(:,1).*m_sp);
		neforce_si(:,2,field)         = Nmatrix(:,:,field)*(b_sp(:,2).*m_sp);
		pforce_si(:,1,field)       = Nmatrix(:,:,field)*pforce_sp(:,1);
		pforce_si(:,2,field)       = Nmatrix(:,:,field)*pforce_sp(:,2);

		traction_si(:,1,field)       = Nmatrix(:,:,field)*(A_sp.*t_sp.*ptraction_sp(:,1)/le(2));
		traction_si(:,2,field)       = Nmatrix(:,:,field)*(A_sp.*t_sp.*ptraction_sp(:,2)/le(1)); 

	end

	%{
	 for sp=1:spCount
	 % Build stress tensor
	 %SSP = [s_sp(sp,1) s_sp(sp,3);s_sp(sp,3) s_sp(sp,2)];
	 
	 for j=1:NODES(sp)
		 npid                           = CONNECT{sp}(j);
		 
			  if N{sp}(j)==0
			 continue
			  end
		 
	 % Mass bn m 
	 %nmass_si(npid)            = nmass_si(npid) + m_sp(sp)*N{sp}(j);
	 
	 % Momentumlp(1,1)lp(1,1)lp(1,1)
	 %nmomentum_si(npid,:)      = nmomentum_si(npid,:) + m_sp(sp)*v_ssp(sp,:)*N{sp}(j);
	 
	 % Internal forces
	 %niforce_si(npid,:)        = niforce_si(npid,:) - (A_sp(sp)*t_sp(sp)*SSP*dN{sp}(:,j))' ;%- 0.07*v_ssp(sp,:); %damping
	%{
	 if niforce_si(npid,1)~=0
		 disp(['niforce_si(' num2str(npid) ',:)=[' num2str(niforce_si(npid,1)) ',' num2str(niforce_si(npid,2)) '];sp=' num2str(sp) ';npid=' num2str(npid) ';N{' num2str(sp) '}(j)=' num2str(N{sp}(j)) ';A_sp(' num2str(sp) ')=' num2str(A_sp(sp)) ';SSP=[' num2str(SSP(1,1)) ' ' num2str(SSP(1,2)) ';' num2str(SSP(2,1)) ' ' num2str(SSP(2,2)) '];dN{' num2str(sp) '}(:,' num2str(j) ')=[' num2str(dN{sp}(1,j)) ' ' num2str(dN{sp}(2,j)) ']']);
		 dummy=sum(niforce_si);
		 disp(['sum(niforce_si)=[' num2str(dummy(1)) ',' num2str(dummy(2)) '];']); 
		 1;
	 end
	%}
	%for p=1:2
	%    for q=1:2
	%        L_si(npid,p,q)=L_si(npid,p,q)+v_ssp(sp,p)*dN{sp}(q,j);
	%    end
	%end
	 % External forces
	%neforce_si(npid,:)         = neforce_si(npid,:) + b_sp*m_sp(sp)*N{sp}(j);

	 % Extra particle forces
	%pforce_si(npid,:)          = pforce_si(npid,:) + pforce_sp(sp,:)*N{sp}(j);

	% Traction
	%  traction_si(npid,:)       = traction_si(npid,:) + A_sp(sp)*ptraction_sp(sp,:)*N{sp}(j)/le(1,1)/le(1,2);
	 %traction_si(npid,1)       = traction_si(npid,1) + A_sp(sp)*t_sp(sp)*ptraction_sp(sp,1)*N{sp}(j)/le(2);
	 %traction_si(npid,2)       = traction_si(npid,2) + A_sp(sp)*t_sp(sp)*ptraction_sp(sp,2)*N{sp}(j)/le(1); 
	 end 
	 end
	%}
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [temp_si,temp_si_comb,shrinkage_si,shrinkage_si_comb,orientationoffset_si,orientationoffset_si_comb,mEfactor_si,x0_si,x_si,deltarideal_si,LW_si_comb,EW_si_comb,nmass_si,nmass_si_comb,nmomentum_si,niforce_si,neforce_si,traction_si,pforce_si,ncforce_si,s_si,s_si_comb,u_si,u_si_comb,v_si,uncrackable_si,uncrackable_si_comb,k_si,k_si_comb,weakeningfactor_si,weakeningfactor_si_comb,L_si]=Interpolate_Particle_To_Grid_WithPredeterminedVelocity2_optimized(temp_sp,shrinkage_sp,orientationoffset,weakeningfactor_sp,k_sp,LOC,N_crack,CONNECT_crack,NODES_crack,TheFieldSplit_cracktop,TheFieldSplit_crackbot,x_crack,deltarideal_sp,NODES,nodeCount,CONNECT,le,N,dN,spCount,b_sp,A_sp,t_sp,ptraction_sp,v_ssp,s_sp,m_sp,pforce_sp,TheFieldSplit,CasetoRun,fieldnumber,x_sp,x_spo,uncrackable_sp,LWStatus,EWStatus,Efactor_sp)
	%% Interpolation from particle to grid task
	% Node variables
	%grid mapping
	1;
	niforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal Internal force
	neforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal External force
	traction_si             = zeros(nodeCount,2,fieldnumber);                   % Nodal Traction
	pforce_si               = zeros(nodeCount,2,fieldnumber);                   % Nodal Extra Particle force
	L_si                    = zeros(nodeCount,2,2,fieldnumber);
	pforce_si               = zeros(nodeCount,2,fieldnumber);                   % Nodal traction
	ncforce_si              = zeros(nodeCount,2,fieldnumber);                   % Nodal crack force
	nmass_si                = zeros(nodeCount,fieldnumber);
	nmass_si_comb           = zeros(nodeCount,1);
	temp_si                = zeros(nodeCount,fieldnumber);
	temp_si_comb            = zeros(nodeCount,1);
	nmomentum_si            = zeros(nodeCount,2,fieldnumber);
	deltarideal_si          = zeros(nodeCount,fieldnumber);
	x0_si                   = zeros(nodeCount,2,fieldnumber);
	x_si                    = zeros(nodeCount,2,fieldnumber);
	orientationoffset_si    = zeros(nodeCount,fieldnumber);
	orientationoffset_si_comb    = zeros(nodeCount,1);
	orioff.values=zeros(nodeCount,100,fieldnumber);
	orioff.weights=zeros(nodeCount,100,fieldnumber);
	orioff.size=zeros(nodeCount,fieldnumber);
	curindex=zeros(1,1); %carries orioff.size value for temporary use, for shorter lines and better readability
	cursize=zeros(1,1); %carries orioff.size value for temporary use, but size was already decided and only called to pass on to angleaverage function, for shorter lines and better readability. cursize is essentially orioff.size(nodeCount,fieldnumber) for the current nodeCount and fieldnumber
		
	ms_si                    = zeros(nodeCount,3,fieldnumber);
	mu_si                    = zeros(nodeCount,2,fieldnumber);
	ms_si_comb               = zeros(nodeCount,3);
	mu_si_comb               = zeros(nodeCount,2);
	mLW_si                    = zeros(nodeCount,fieldnumber);
	mLW_si_comb               = zeros(nodeCount,1);
	mEW_si                    = zeros(nodeCount,fieldnumber);
	mEW_si_comb               = zeros(nodeCount,1);
	mdeltarideal_si           = zeros(nodeCount,fieldnumber);
	mx0_si                    = zeros(nodeCount,2,fieldnumber);
	mx_si                     = zeros(nodeCount,2,fieldnumber);
	Efactor_si                = zeros(nodeCount,fieldnumber);
	mEfactor_si               = zeros(nodeCount,fieldnumber);
	shrinkage_si    = zeros(2,2,nodeCount,fieldnumber);
	shrinkage_si_comb    = zeros(2,2,nodeCount);
	mshrinkage_si    = zeros(2,2,nodeCount,fieldnumber);
	mtemp_si                = zeros(nodeCount,fieldnumber);
	%TDL not necessary anymore, most definitely. keep it or delete?
	%morientationoffset_si    = zeros(nodeCount,2,fieldnumber);
	%morientationoffset_si_comb    = zeros(nodeCount,2);
	
	

	
	muncrackable_si=zeros(nodeCount,fieldnumber);
	uncrackable_si=zeros(nodeCount,fieldnumber);
	uncrackable_si_comb=zeros(nodeCount,1);
	
	mweakeningfactor_si=zeros(nodeCount,fieldnumber);
	weakeningfactor_si=zeros(nodeCount,fieldnumber);
	weakeningfactor_si_comb=zeros(nodeCount,1);
	
	mk_si=zeros(nodeCount,fieldnumber);
	k_si=zeros(nodeCount,fieldnumber);
	k_si_comb=zeros(nodeCount,1);
	
	s_si                    = zeros(nodeCount,3,fieldnumber);
	u_si                    = zeros(nodeCount,2,fieldnumber);
	v_si                    = zeros(nodeCount,2,fieldnumber);
	LW_si                   = zeros(nodeCount,fieldnumber);
	LW_si_comb              = zeros(nodeCount,1);
	EW_si                   = zeros(nodeCount,fieldnumber);
	EW_si_comb              = zeros(nodeCount,1);
	s_si_comb               = zeros(nodeCount,3);
	u_si_comb               = zeros(nodeCount,2);
	u_sp                    = zeros(spCount,2);
	
	parfor sp=1:spCount
		for dim=1:2
			u_sp(sp,dim)=x_sp(sp,dim)-x_spo(sp,dim);
		end
	end
	
	for sp=1:spCount
		% Build stress tensor
		SSP = [s_sp(sp,1) s_sp(sp,3);s_sp(sp,3) s_sp(sp,2)];

		for j=1:NODES(sp)
			npid                           = CONNECT{sp}(j);

			if N{sp}(j)==0
				continue
			end

			% Mass bn m 
			nmass_si(npid,TheFieldSplit(j,sp))            = nmass_si(npid,TheFieldSplit(j,sp)) + m_sp(sp)*N{sp}(j);

			% Momentumlp(1,1)lp(1,1)lp(1,1)
			nmomentum_si(npid,:,TheFieldSplit(j,sp))      = nmomentum_si(npid,:,TheFieldSplit(j,sp)) + m_sp(sp)*v_ssp(sp,:)*N{sp}(j);

			% Internal forces
			niforce_si(npid,:,TheFieldSplit(j,sp))        = niforce_si(npid,:,TheFieldSplit(j,sp)) - (A_sp(sp)*t_sp(sp)*SSP*dN{sp}(:,j))' ;%- 0.07*v_ssp(sp,:); %damping
			for p=1:2
				for q=1:2
					L_si(npid,p,q,TheFieldSplit(j,sp))    = L_si(npid,p,q,TheFieldSplit(j,sp))+v_ssp(sp,p)*dN{sp}(q,j);
				end
			end
			% External forces
			neforce_si(npid,:,TheFieldSplit(j,sp))         = neforce_si(npid,:,TheFieldSplit(j,sp)) + b_sp(sp,:)*m_sp(sp)*N{sp}(j);

			% Extra particle forces
			pforce_si(npid,:,TheFieldSplit(j,sp))          = pforce_si(npid,:,TheFieldSplit(j,sp)) + pforce_sp(sp,:)*N{sp}(j);

			% Traction
			%traction_si(npid,:)       = traction_si(npid,:) + A_sp(sp)*ptraction_sp(sp,:)*N{sp}(j)/le(1,1)/le(1,2);
			traction_si(npid,1,TheFieldSplit(j,sp))       = traction_si(npid,1,TheFieldSplit(j,sp)) + A_sp(sp)*t_sp(sp)*ptraction_sp(sp,1)*N{sp}(j)/le(2);
			traction_si(npid,2,TheFieldSplit(j,sp))       = traction_si(npid,2,TheFieldSplit(j,sp)) + A_sp(sp)*t_sp(sp)*ptraction_sp(sp,2)*N{sp}(j)/le(1);
			if CasetoRun==174
				mEfactor_si(npid,TheFieldSplit(j,sp))=mEfactor_si(npid,TheFieldSplit(j,sp))+Efactor_sp(sp)*m_sp(sp)*N{sp}(j);
			end
			if CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152
				muncrackable_si(npid,TheFieldSplit(j,sp))=muncrackable_si(npid,TheFieldSplit(j,sp))+m_sp(sp)*uncrackable_sp(sp)*N{sp}(j);
				mdeltarideal_si(npid,TheFieldSplit(j,sp))=mdeltarideal_si(npid,TheFieldSplit(j,sp))+m_sp(sp)*deltarideal_sp(sp)*N{sp}(j);
				for dim=1:2
					mx0_si(npid,dim,TheFieldSplit(j,sp))=mx0_si(npid,dim,TheFieldSplit(j,sp))+m_sp(sp)*x_spo(sp,dim)*N{sp}(j);
					mx_si(npid,dim,TheFieldSplit(j,sp))=mx_si(npid,dim,TheFieldSplit(j,sp))+m_sp(sp)*x_sp(sp,dim)*N{sp}(j);
				end
			elseif CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==190 || CasetoRun==187
				muncrackable_si(npid,TheFieldSplit(j,sp))=muncrackable_si(npid,TheFieldSplit(j,sp))+m_sp(sp)*uncrackable_sp(sp)*N{sp}(j);
			else
				muncrackable_si(npid,TheFieldSplit(j,sp))=0;
				mdeltarideal_si(npid,TheFieldSplit(j,sp))=0;
				for dim=1:2
					mx0_si(npid,dim,TheFieldSplit(j,sp))=0;
					mx_si(npid,dim,TheFieldSplit(j,sp))=0;
				end
			end
			ms_si(npid,:,TheFieldSplit(j,sp))=ms_si(npid,:,TheFieldSplit(j,sp))+m_sp(sp)*s_sp(sp,:)*N{sp}(j);
			
			mu_si(npid,:,TheFieldSplit(j,sp))=mu_si(npid,:,TheFieldSplit(j,sp))+m_sp(sp)*u_sp(sp,:)*N{sp}(j);
			if CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==211 || CasetoRun==212
				mweakeningfactor_si(npid,TheFieldSplit(j,sp))=mweakeningfactor_si(npid,TheFieldSplit(j,sp))+m_sp(sp)*weakeningfactor_sp(sp)*N{sp}(j);
				mk_si(npid,TheFieldSplit(j,sp))=mk_si(npid,TheFieldSplit(j,sp))+m_sp(sp)*k_sp(sp)*N{sp}(j);
				orioff.size(npid,TheFieldSplit(j,sp))=orioff.size(npid,TheFieldSplit(j,sp))+1;
				curindex=orioff.size(npid,TheFieldSplit(j,sp));
				orioff.values(npid,curindex,TheFieldSplit(j,sp))=orientationoffset(sp);
				orioff.weights(npid,curindex,TheFieldSplit(j,sp))=m_sp(sp)*N{sp}(j);
				mtemp_si(npid,TheFieldSplit(j,sp))=mtemp_si(npid,TheFieldSplit(j,sp))+m_sp(sp)*temp_sp(sp)*N{sp}(j);
			end
			
			if CasetoRun==124
				mLW_si_comb(npid)=mLW_si_comb(npid)+m_sp(sp)*LWStatus(sp)*N{sp}(j);
				mEW_si_comb(npid)=mEW_si_comb(npid)+m_sp(sp)*EWStatus(sp)*N{sp}(j);
			end
			if CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227
				mshrinkage_si(:,:,npid,TheFieldSplit(j,sp))=mshrinkage_si(:,:,npid,TheFieldSplit(j,sp))+m_sp(sp)*shrinkage_sp(:,:,sp)*N{sp}(j);
			end
		end
	end
	
	for icrackpath=1:x_crack.npaths
	if x_crack.cohesivepath(icrackpath)==1
		for iparticle=1:x_crack.nparticles(icrackpath)
		if x_crack.cohesivepoint(iparticle,icrackpath)==1
			for iro=1:NODES_crack.top(icrackpath,iparticle)
				io=CONNECT_crack.top.values(iparticle,iro,icrackpath);
				igridlayer=TheFieldSplit_cracktop{icrackpath}(iro,iparticle);
				for idim=1:2
					ncforce_si(io,idim,igridlayer)=ncforce_si(io,idim,igridlayer)+x_crack.force.top(iparticle,idim,icrackpath)*N_crack.top(1,iro,iparticle,icrackpath);
				end
			end
			for iro=1:NODES_crack.bot(icrackpath,iparticle)
				io=CONNECT_crack.bot.values(iparticle,iro,icrackpath);
				igridlayer=TheFieldSplit_crackbot{icrackpath}(iro,iparticle);
				for idim=1:2
					ncforce_si(io,idim,igridlayer)=ncforce_si(io,idim,igridlayer)+x_crack.force.bot(iparticle,idim,icrackpath)*N_crack.bot(1,iro,iparticle,icrackpath);
				end
			end
			end
		end
		end
	end
	
	parfor io=1:nodeCount
		nmass_si_comb(io)=sum(nmass_si(io,:));
	end
	parfor io=1:nodeCount
		if nmass_si_comb(io)>0
			for dim=1:3
				s_si_comb(io,dim)=sum(ms_si(io,dim,:))/nmass_si_comb(io);
				%tempmarker1
			end
		end
	end
	parfor io=1:nodeCount
		for ifield=1:fieldnumber
			if nmass_si(io,ifield)>0
				shrinkage_si(:,:,io,ifield)=mshrinkage_si(:,:,io,ifield)/nmass_si(io,ifield);
			end
		end
	end
	parfor io=1:nodeCount
		if nmass_si_comb(io)>0
			for idim1=1:2
				for idim2=1:2
					shrinkage_si_comb(idim1,idim2,io)=sum(mshrinkage_si(idim1,idim2,io,:))/nmass_si_comb(io);
				end
			end
		end
	end
	parfor io=1:nodeCount	
		if nmass_si_comb(io)>0
			for dim=1:2
				u_si_comb(io,dim)=sum(mu_si(io,dim,:))/nmass_si_comb(io);
			end
		end
	end
	parfor io=1:nodeCount
		for ifield=1:fieldnumber
			if nmass_si(io,ifield)>0
				for dim=1:2
					u_si(io,dim,ifield)=mu_si(io,dim,ifield)/nmass_si(io,ifield);
				end
			end
		end
	end
	parfor io=1:nodeCount
		for ifield=1:fieldnumber
			if nmass_si(io,ifield)>0
				for dim=1:2
					v_si(io,dim,ifield)=nmomentum_si(io,dim,ifield)/nmass_si(io,ifield);
				end
			end
		end
	end
	parfor io=1:nodeCount
		for ifield=1:fieldnumber
			if nmass_si(io,ifield)>0
				for dim=1:3
					s_si(io,dim,ifield)=ms_si(io,dim,ifield)/nmass_si(io,ifield);
				end
			end
		end
	end
	parfor io=1:nodeCount
		for ifield=1:fieldnumber
			if nmass_si(io,ifield)>0
				uncrackable_si(io,ifield)=muncrackable_si(io,ifield)/nmass_si(io,ifield);
			end
		end
	end
	parfor io=1:nodeCount
		for ifield=1:fieldnumber
			if nmass_si(io,ifield)>0
				weakeningfactor_si(io,ifield)=mweakeningfactor_si(io,ifield)/nmass_si(io,ifield);
			end
		end
	end
	if CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==211 || CasetoRun==212
		parfor io=1:nodeCount
			for ifield=1:fieldnumber
				if nmass_si(io,ifield)>0
					k_si(io,ifield)=mk_si(io,ifield)/nmass_si(io,ifield);
				end
			end
		end
		parfor io=1:nodeCount
			for ifield=1:fieldnumber
				if nmass_si(io,ifield)>0
					temp_si(io,ifield)=mtemp_si(io,ifield)/nmass_si(io,ifield);
				end
			end
		end
		parfor io=1:nodeCount
			for ifield=1:fieldnumber
				if nmass_si(io,ifield)>0
					cursize=orioff.size(io,ifield);
					orientationoffset_si(io,ifield)=angleaverage(orioff.values(io,1:cursize,ifield),orioff.weights(io,1:cursize,ifield),18,5,2);
				end
			end
		end
		parfor io=1:nodeCount
			if nmass_si_comb(io)>0
				orientationoffset_si_comb(io)=angleaverage(orientationoffset_si(io,:),nmass_si(io,:),18,5,2);
			end
		end
	end
	parfor io=1:nodeCount
		for ifield=1:fieldnumber
			if nmass_si(io,ifield)>0
				deltarideal_si(io,ifield)=mdeltarideal_si(io,ifield)/nmass_si(io,ifield);
			end
		end
	end
	parfor io=1:nodeCount
		for ifield=1:fieldnumber
			if nmass_si(io,ifield)>0
				for dim=1:2
					x_si(io,dim,ifield)=mx_si(io,dim,ifield)/nmass_si(io,ifield);
				end
			end
		end
	end
	parfor io=1:nodeCount
		for ifield=1:fieldnumber
			if nmass_si(io,ifield)>0
				for dim=1:2
					x0_si(io,dim,ifield)=mx0_si(io,dim,ifield)/nmass_si(io,ifield);
				end
			end
		end
	end

	for io=1:nodeCount	
		if nmass_si_comb(io)>0
			uncrackable_si_comb(io,1)=sum(muncrackable_si(io,:))/nmass_si_comb(io);
		end
	end
	for io=1:nodeCount	
		if nmass_si_comb(io)>0
			weakeningfactor_si_comb(io,1)=sum(mweakeningfactor_si(io,:))/nmass_si_comb(io);
		end
	end
	if CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==211 || CasetoRun==212
		for io=1:nodeCount	
			if nmass_si_comb(io)>0
				k_si_comb(io,1)=sum(mk_si(io,:))/nmass_si_comb(io);
			end
		end
		for io=1:nodeCount	
			if nmass_si_comb(io)>0
				temp_si_comb(io,1)=sum(mtemp_si(io,:))/nmass_si_comb(io);
			end
		end
	end
	for io=1:nodeCount
		if nmass_si_comb(io)>0
			LW_si_comb(io,1)=mLW_si_comb(io,1)/nmass_si_comb(io);
		end
	end
	for io=1:nodeCount
		if nmass_si_comb(io)>0
			EW_si_comb(io,1)=mEW_si_comb(io,1)/nmass_si_comb(io);
		end
	end
	for io=1:nodeCount
		if nmass_si_comb(io)>0
			EW_si_comb(io,1)=mEW_si_comb(io,1)/nmass_si_comb(io);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix] = Compute_Interpolator_CPDI_var(spCount,cellCount,x_sp,le_c,NN,LOC,r1_sp,r2_sp,A_sp,LOCX,LOCY)
	
	spElems        = zeros(spCount,1);
	N              = cell(1,spCount);
	dN             = cell(1,spCount);
	CONNECT        = cell(1,spCount);
	NODES          = zeros(1,spCount);
	siCount=NN(1)*NN(2);
	Nmatrix=zeros(siCount,spCount);
	dNxmatrix=zeros(siCount,spCount);
	dNymatrix=zeros(siCount,spCount);
	%spElems=zeros(1,spCount)
	
	%{
	%switchable1
	try
		parfor sp=1:spCount
			[N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow,dNxmatrixrow,dNymatrixrow] = ...
				Compute_Interpolator_CPDI_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
			Nmatrix(:,sp)=Nmatrixrow;
			dNxmatrix(:,sp)=dNxmatrixrow;
			dNymatrix(:,sp)=dNymatrixrow;
		end
	catch
		fprintf('%s',['parforred Compute_Interpolator_CPDI_parforred failed, switching to regular for!' char(10)]);
		%}
		%switchable1
		for sp=1:spCount
			[N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow,dNxmatrixrow,dNymatrixrow] = ...
				Compute_Interpolator_CPDI_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
			Nmatrix(:,sp)=Nmatrixrow;
			dNxmatrix(:,sp)=dNxmatrixrow;
			dNymatrix(:,sp)=dNymatrixrow;
		end
		%{
		%switchable1
	end
	%}
	%switchable1
	
	
	for c =1:cellCount
		id_sp = find(spElems==c);
		mspoints{c}=id_sp;
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,NODES,Nmatrixrow,dNxmatrixrow,dNymatrixrow] = ...
	Compute_Interpolator_CPDI_parforred_var(x_sp,le_c,LOC,r1_sp,r2_sp,A_sp,siCount,LOCX,LOCY)

	CONNECT_TEMP   = zeros(1,16);
	spElems_corner = zeros(1,4);
	x_corner{4}      = zeros(1,2);
	x_corner{3}      = zeros(1,2);
	x_corner{2}      = zeros(1,2);
	x_corner{1}      = zeros(1,2);
	Nmatrixrow     = zeros(siCount,1);
	dNxmatrixrow   = zeros(siCount,1);
	dNymatrixrow   = zeros(siCount,1);


	x_corner{1}(1,:) = x_sp(1,:) - r1_sp(1,:) - r2_sp(1,:);      % Position of corner 1
	x_corner{2}(1,:) = x_sp(1,:) + r1_sp(1,:) - r2_sp(1,:);
	x_corner{3}(1,:) = x_sp(1,:) + r1_sp(1,:) + r2_sp(1,:);
	x_corner{4}(1,:) = x_sp(1,:) - r1_sp(1,:) + r2_sp(1,:);

	%spElems(1) = ceil(x_sp(1,1)/le(1))+(NN(1)-1)*(fix(x_sp(1,2)/le(2)));   % compute vector store index elements                           
	
	spElems=identifycellsandnodes(x_sp,LOCX,LOCY,[],[],[1 0 0 0]);

	%spElems_corner(1,1) = ceil(x_corner{1}(1,1)/le(1))+(NN(1)-1)*(fix(x_corner{1}(1,2)/le(2)));                        
	%spElems_corner(1,2) = ceil(x_corner{2}(1,1)/le(1))+(NN(1)-1)*(fix(x_corner{2}(1,2)/le(2)));                        
	%spElems_corner(1,3) = ceil(x_corner{3}(1,1)/le(1))+(NN(1)-1)*(fix(x_corner{3}(1,2)/le(2)));
	%spElems_corner(1,4) = ceil(x_corner{4}(1,1)/le(1))+(NN(1)-1)*(fix(x_corner{4}(1,2)/le(2)));

	for i=1:4
		[spElems_corner(1,i), CONNECT_TEMP(1,((i-1)*4+1):(i*4))] = identifycellsandnodes(x_corner{i},LOCX,LOCY,[],[],[1 1 0 0]);
	end
	
	CONNECT=unique(CONNECT_TEMP(1,:));    % Store nodes interacting with corners
	NODES=zeros(1,1);
	NODES(1)=length(CONNECT);         % Store number of interacting nodes
	dN=zeros(2,NODES(1));

	N1 = zeros(1,NODES(1));   % Shape function of corner 1 for 16 nodes
	N2 = zeros(1,NODES(1));
	N3 = zeros(1,NODES(1));
	N4 = zeros(1,NODES(1));
	N_local = zeros(1,NODES(1));

	for i=1:NODES(1)
		[N1(i),~,~] = linearshape(x_corner{1}(1,:),LOC(CONNECT(i),:),le_c(spElems_corner(1,1),1),le_c(spElems_corner(1,1),2));
		[N2(i),~,~] = linearshape(x_corner{2}(1,:),LOC(CONNECT(i),:),le_c(spElems_corner(1,2),1),le_c(spElems_corner(1,2),2));
		[N3(i),~,~] = linearshape(x_corner{3}(1,:),LOC(CONNECT(i),:),le_c(spElems_corner(1,3),1),le_c(spElems_corner(1,3),2));
		[N4(i),~,~] = linearshape(x_corner{4}(1,:),LOC(CONNECT(i),:),le_c(spElems_corner(1,4),1),le_c(spElems_corner(1,4),2));
		N_local(i)  = 0.25*(N1(i)+N2(i)+N3(i)+N4(i));
	end

	N = N_local;

	% Build matrix of gradient of shape function 
	w1 = [r1_sp(1,2)-r2_sp(1,2) r2_sp(1,1)-r1_sp(1,1)];
	w2 = [r1_sp(1,2)+r2_sp(1,2) -r2_sp(1,1)-r1_sp(1,1)];

	for i=1:NODES(1)      
		dN(1,i)     = 1/A_sp(1)*((N1(i)-N3(i))*w1(1) + (N2(i)-N4(i))*w2(1));
		dN(2,i)     = 1/A_sp(1)*((N1(i)-N3(i))*w1(2) + (N2(i)-N4(i))*w2(2));
	end

	for i=1:NODES(1)
		Nmatrixrow(CONNECT(i),1)=N(i);
		dNxmatrixrow(CONNECT(i),1)=dN(1,i);
		dNymatrixrow(CONNECT(i),1)=dN(2,i);
	end
	
	
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix,CONNECTpn] = Compute_Interpolator_CPDI(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp)
	spElems        = zeros(spCount,1);
	N              = cell(1,spCount);
	dN             = cell(1,spCount);
	CONNECT        = cell(1,spCount);
	NODES          = zeros(1,spCount);
	siCount=NN(1)*NN(2);
	CONNECTpn=cell(1,siCount);
	Nmatrix=zeros(siCount,spCount);
	dNxmatrix=zeros(siCount,spCount);
	dNymatrix=zeros(siCount,spCount);
	%{
	%switchable1
	try
		parfor sp=1:spCount
			[N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow,dNxmatrixrow,dNymatrixrow] = ...
				Compute_Interpolator_CPDI_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
			Nmatrix(:,sp)=Nmatrixrow;
			dNxmatrix(:,sp)=dNxmatrixrow;
			dNymatrix(:,sp)=dNymatrixrow;
		end
	catch
		fprintf('%s',['parfor failed inside Compute_Interpolator_CPID, switching to regular for' char(10)]);
		%}
		%switchable1
		for sp=1:spCount
			[N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow,dNxmatrixrow,dNymatrixrow] = ...
				Compute_Interpolator_CPDI_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
			Nmatrix(:,sp)=Nmatrixrow;
			dNxmatrix(:,sp)=dNxmatrixrow;
			dNymatrix(:,sp)=dNymatrixrow;
		end
		%{
		%switchable1
	end
	%}
	%switchable1
	for sp=1:spCount
		for i=1:length(CONNECT{sp})
			CONNECTpn{CONNECT{sp}(i)}=[CONNECTpn{CONNECT{sp}(i)} sp];
		end
	end
	
	
	for c =1:cellCount
		id_sp = find(spElems==c);
		mspoints{c}=id_sp;
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N0] = Compute_Interpolator_CPDI_optimized_N0(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp,nvelo_skip,Npnskip)
	[DUMMY1,DUMMY2,DUMMY3,DUMMY4,DUMMY5,DUMMY6,CONNECTpn,Npn] = Compute_Interpolator_CPDI_optimized(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp,nvelo_skip,Npnskip);
	
	N0.CONNECTpn.values=zeros(size(CONNECTpn.values));
	N0.CONNECTpn.nrparticles=zeros(size(CONNECTpn.nrparticles));
	N0.Npn.values=zeros(size(Npn.values));
	N0.Npn.nrparticles=zeros(size(Npn.nrparticles));
	
	N0.CONNECTpn.values=CONNECTpn.values;
	N0.CONNECTpn.nrparticles=CONNECTpn.nrparticles;
	N0.Npn.values=Npn.values;
	N0.Npn.nrparticles=Npn.nrparticles;
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,mspoints,NODES,CONNECTpn,Npn] = Compute_Interpolator_CPDI_optimized(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp,nvelo_skip,Npnskip)
	spElems        = zeros(spCount,1);
	N              = cell(1,spCount);
	dN             = cell(1,spCount);
	CONNECT        = cell(1,spCount);
	NODES          = zeros(1,spCount);
	siCount=NN(1)*NN(2);
	%{
	%switchable1
	try
		parfor sp=1:spCount
			[N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow] = ...
				Compute_Interpolator_CPDI_parforred_optimized(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
			Nmatrix(:,sp)=Nmatrixrow;
		end
	catch
		fprintf('%s',['parfor failed inside Compute_Interpolator_CPID, switching to regular for' char(10)]);
		%}
		%switchable1
		fprintf('%s',['marker #645' char(10)]);
		parfor sp=1:spCount
			[N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp)] = ...
				Compute_Interpolator_CPDI_parforred_optimized(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
		end
		fprintf('%s',['marker #646' char(10)]);
		%{
		%switchable1
	end
	%}
	%switchable1
	if nvelo_skip==1
		CONNECTpn.values=zeros(siCount,2);
		CONNECTpn.nrparticles=zeros(1,siCount);
		Npn.values=zeros(siCount,2);
		Npn.nparticles=zeros(1,siCount);
		%might cause problems with Coder?
	else
		CONNECTpn_temp_sizes=zeros(1,siCount);
		for sp=1:spCount
			for i=1:length(CONNECT{sp})
				CONNECTpn_temp_sizes(CONNECT{sp}(i))=CONNECTpn_temp_sizes(CONNECT{sp}(i))+1;
			end
		end
		
		CONNECTpnMaxSize=1;
		for i=1:length(CONNECTpn_temp_sizes)
			if CONNECTpn_temp_sizes(i)>CONNECTpnMaxSize
				CONNECTpnMaxSize=CONNECTpn_temp_sizes(i);
			end
		end
		CONNECTpn_temp=zeros(siCount,CONNECTpnMaxSize);
		Npn_temp=zeros(siCount,CONNECTpnMaxSize);
		%{
		for i=1:size(CONNECTpn_temp,1)
			if CONNECTpn_temp_sizes(i)==0
				CONNECTpn_temp{i}=zeros(1,1);
			else
				CONNECTpn_temp{i}=zeros(1,CONNECTpn_temp_sizes(i));
			end
		end
		for i=1:size(CONNECTpn_temp,1)
			CONNECTpn_temp{i}=zeros(1,CONNECTpnMaxSize);
		end
		%}
		CONNECTpn_Counter=zeros(1,siCount);
		for sp=1:spCount
			for i=1:length(CONNECT{sp})
				CONNECTpn_Counter(CONNECT{sp}(i))=CONNECTpn_Counter(CONNECT{sp}(i))+1;
				CONNECTpn_temp(CONNECT{sp}(i),CONNECTpn_Counter(CONNECT{sp}(i)))=sp;
				if Npnskip==0
					Npn_temp(CONNECT{sp}(i),CONNECTpn_Counter(CONNECT{sp}(i)))=N{sp}(i);
				end
			end
		end
		CONNECTpn.nrparticles=zeros(1,siCount);
		CONNECTpn.values=zeros(siCount,CONNECTpnMaxSize);
		CONNECTpn.nrparticles=CONNECTpn_temp_sizes;
		CONNECTpn.values=CONNECTpn_temp;
		
		Npn.nrparticles=zeros(1,siCount);
		Npn.values=zeros(siCount,CONNECTpnMaxSize);
		Npn.nrparticles=CONNECTpn_temp_sizes;
		Npn.values=Npn_temp;
	end
	mspoints=cell(1,cellCount);
	for c =1:cellCount
		id_sp = find(spElems==c);
		mspoints{c}=id_sp;
	end
	fprintf('%s',['marker #647' char(10)]);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,NODES,Nmatrixrow,dNxmatrixrow,dNymatrixrow] = ...
	Compute_Interpolator_CPDI_parforred(x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,siCount)
	
	CONNECT_TEMP   = zeros(1,16);
	spElems_corner = zeros(1,4);
	x_corner1      = zeros(1,2);
	x_corner2      = zeros(1,2);
	x_corner3      = zeros(1,2);
	x_corner4      = zeros(1,2);
	Nmatrixrow     = zeros(siCount,1);
	dNxmatrixrow   = zeros(siCount,1);
	dNymatrixrow   = zeros(siCount,1);
	spElems        = zeros(1,1);
	NODES          = zeros(1,1);
	
	
	x_corner1(1,:) = x_sp(1,:) - r1_sp(1,:) - r2_sp(1,:);      % Position of corner 1
	x_corner2(1,:) = x_sp(1,:) + r1_sp(1,:) - r2_sp(1,:);
	x_corner3(1,:) = x_sp(1,:) + r1_sp(1,:) + r2_sp(1,:);
	x_corner4(1,:) = x_sp(1,:) - r1_sp(1,:) + r2_sp(1,:);
	
	spElems(1) = ceil(x_sp(1,1)/le(1))+(NN(1)-1)*(fix(x_sp(1,2)/le(2)));   % compute vector store index elements                           
	
	spElems_corner(1,1) = ceil(x_corner1(1,1)/le(1))+(NN(1)-1)*(fix(x_corner1(1,2)/le(2)));                        
	spElems_corner(1,2) = ceil(x_corner2(1,1)/le(1))+(NN(1)-1)*(fix(x_corner2(1,2)/le(2)));                        
	spElems_corner(1,3) = ceil(x_corner3(1,1)/le(1))+(NN(1)-1)*(fix(x_corner3(1,2)/le(2)));
	spElems_corner(1,4) = ceil(x_corner4(1,1)/le(1))+(NN(1)-1)*(fix(x_corner4(1,2)/le(2)));
	
	CONNECT_TEMP(1,1)  = spElems_corner(1,1) + myfloor((spElems_corner(1,1)-1)/(NN(1)-1));
	CONNECT_TEMP(1,2)  = CONNECT_TEMP(1,1) + 1;
	CONNECT_TEMP(1,3)  = CONNECT_TEMP(1,2) + NN(1);
	CONNECT_TEMP(1,4)  = CONNECT_TEMP(1,1) + NN(1);
	
	CONNECT_TEMP(1,5)  = spElems_corner(1,2) + myfloor((spElems_corner(1,2)-1)/(NN(1)-1));
	CONNECT_TEMP(1,6)  = CONNECT_TEMP(1,5) + 1;
	CONNECT_TEMP(1,7)  = CONNECT_TEMP(1,6) + NN(1);
	CONNECT_TEMP(1,8)  = CONNECT_TEMP(1,5) + NN(1); 
	
	CONNECT_TEMP(1,9)  = spElems_corner(1,3) + myfloor((spElems_corner(1,3)-1)/(NN(1)-1));
	CONNECT_TEMP(1,10) = CONNECT_TEMP(1,9) + 1;
	CONNECT_TEMP(1,11) = CONNECT_TEMP(1,10) + NN(1);
	CONNECT_TEMP(1,12) = CONNECT_TEMP(1,9) + NN(1); 
	
	CONNECT_TEMP(1,13) = spElems_corner(1,4) + myfloor((spElems_corner(1,4)-1)/(NN(1)-1));
	CONNECT_TEMP(1,14) = CONNECT_TEMP(1,13) + 1;
	CONNECT_TEMP(1,15) = CONNECT_TEMP(1,14) + NN(1);
	CONNECT_TEMP(1,16) = CONNECT_TEMP(1,13) + NN(1);
	
	CONNECT=unique(CONNECT_TEMP(1,:));    % Store nodes interacting with corners
	NODES(1)=length(CONNECT);         % Store number of interacting nodes
	dN=zeros(2,NODES(1));
	
	N1 = zeros(1,NODES(1));   % Shape function of corner 1 for 16 nodes
	N2 = zeros(1,NODES(1));
	N3 = zeros(1,NODES(1));
	N4 = zeros(1,NODES(1));
	N_local = zeros(1,NODES(1));
	
	for i=1:NODES(1)
		[N1(i),~,~] = linearshape(x_corner1(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
		[N2(i),~,~] = linearshape(x_corner2(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
		[N3(i),~,~] = linearshape(x_corner3(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
		[N4(i),~,~] = linearshape(x_corner4(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
		N_local(i)  = 0.25*(N1(i)+N2(i)+N3(i)+N4(i));
	end
	
	N = N_local;
	
	% Build matrix of gradient of shape function 
	w1 = [r1_sp(1,2)-r2_sp(1,2) r2_sp(1,1)-r1_sp(1,1)];
	w2 = [r1_sp(1,2)+r2_sp(1,2) -r2_sp(1,1)-r1_sp(1,1)];
	
	for i=1:NODES(1)      
		dN(1,i)     = 1/A_sp(1)*((N1(i)-N3(i))*w1(1) + (N2(i)-N4(i))*w2(1));
		dN(2,i)     = 1/A_sp(1)*((N1(i)-N3(i))*w1(2) + (N2(i)-N4(i))*w2(2));
	end
	
	for i=1:NODES(1)
		Nmatrixrow(CONNECT(i),1)=N(i);
		dNxmatrixrow(CONNECT(i),1)=dN(1,i);
		dNymatrixrow(CONNECT(i),1)=dN(2,i);
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,NODES] = Compute_Interpolator_CPDI_parforred_optimized(x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,siCount)
 
	CONNECT_TEMP   = zeros(1,16);
	spElems_corner = zeros(1,4);
	x_corner1      = zeros(1,2);
	x_corner2      = zeros(1,2);
	x_corner3      = zeros(1,2);
	x_corner4      = zeros(1,2);
	dNxmatrixrow   = zeros(siCount,1);
	dNymatrixrow   = zeros(siCount,1);
	spElems        = zeros(1,1);
	NODES          = zeros(1,1);


	x_corner1(1,:) = x_sp(1,:) - r1_sp(1,:) - r2_sp(1,:);      % Position of corner 1
	x_corner2(1,:) = x_sp(1,:) + r1_sp(1,:) - r2_sp(1,:);
	x_corner3(1,:) = x_sp(1,:) + r1_sp(1,:) + r2_sp(1,:);
	x_corner4(1,:) = x_sp(1,:) - r1_sp(1,:) + r2_sp(1,:);

	spElems(1) = ceil(x_sp(1,1)/le(1))+(NN(1)-1)*(fix(x_sp(1,2)/le(2)));   % compute vector store index elements                           

	spElems_corner(1,1) = ceil(x_corner1(1,1)/le(1))+(NN(1)-1)*(fix(x_corner1(1,2)/le(2)));                        
	spElems_corner(1,2) = ceil(x_corner2(1,1)/le(1))+(NN(1)-1)*(fix(x_corner2(1,2)/le(2)));                        
	spElems_corner(1,3) = ceil(x_corner3(1,1)/le(1))+(NN(1)-1)*(fix(x_corner3(1,2)/le(2)));
	spElems_corner(1,4) = ceil(x_corner4(1,1)/le(1))+(NN(1)-1)*(fix(x_corner4(1,2)/le(2)));

	CONNECT_TEMP(1,1)  = spElems_corner(1,1) + myfloor((spElems_corner(1,1)-1)/(NN(1)-1));
	CONNECT_TEMP(1,2)  = CONNECT_TEMP(1,1) + 1;
	CONNECT_TEMP(1,3)  = CONNECT_TEMP(1,2) + NN(1);
	CONNECT_TEMP(1,4)  = CONNECT_TEMP(1,1) + NN(1);

	CONNECT_TEMP(1,5)  = spElems_corner(1,2) + myfloor((spElems_corner(1,2)-1)/(NN(1)-1));
	CONNECT_TEMP(1,6)  = CONNECT_TEMP(1,5) + 1;
	CONNECT_TEMP(1,7)  = CONNECT_TEMP(1,6) + NN(1);
	CONNECT_TEMP(1,8)  = CONNECT_TEMP(1,5) + NN(1); 

	CONNECT_TEMP(1,9)  = spElems_corner(1,3) + myfloor((spElems_corner(1,3)-1)/(NN(1)-1));
	CONNECT_TEMP(1,10) = CONNECT_TEMP(1,9) + 1;
	CONNECT_TEMP(1,11) = CONNECT_TEMP(1,10) + NN(1);
	CONNECT_TEMP(1,12) = CONNECT_TEMP(1,9) + NN(1); 

	CONNECT_TEMP(1,13) = spElems_corner(1,4) + myfloor((spElems_corner(1,4)-1)/(NN(1)-1));
	CONNECT_TEMP(1,14) = CONNECT_TEMP(1,13) + 1;
	CONNECT_TEMP(1,15) = CONNECT_TEMP(1,14) + NN(1);
	CONNECT_TEMP(1,16) = CONNECT_TEMP(1,13) + NN(1);

	CONNECT=unique(CONNECT_TEMP(1,:));    % Store nodes interacting with corners
	NODES(1)=length(CONNECT);         % Store number of interacting nodes
	dN=zeros(2,NODES(1));
	
	N1 = zeros(1,NODES(1));   % Shape function of corner 1 for 16 nodes
	N2 = zeros(1,NODES(1));
	N3 = zeros(1,NODES(1));
	N4 = zeros(1,NODES(1));
	N_local = zeros(1,NODES(1));

	for i=1:NODES(1)
		[N1(i),~,~] = linearshape(x_corner1(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
		[N2(i),~,~] = linearshape(x_corner2(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
		[N3(i),~,~] = linearshape(x_corner3(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
		[N4(i),~,~] = linearshape(x_corner4(1,:),LOC(CONNECT(i),:),le(1,1),le(1,2));
		N_local(i)  = 0.25*(N1(i)+N2(i)+N3(i)+N4(i));
	end

	N = N_local;

	% Build matrix of gradient of shape function 
	w1 = [r1_sp(1,2)-r2_sp(1,2) r2_sp(1,1)-r1_sp(1,1)];
	w2 = [r1_sp(1,2)+r2_sp(1,2) -r2_sp(1,1)-r1_sp(1,1)];

	for i=1:NODES(1)      
		dN(1,i)     = 1/A_sp(1)*((N1(i)-N3(i))*w1(1) + (N2(i)-N4(i))*w2(1));
		dN(2,i)     = 1/A_sp(1)*((N1(i)-N3(i))*w1(2) + (N2(i)-N4(i))*w2(2));
	end

end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,dNxmatrix,dNymatrix,CONNECTpn] = Compute_Interpolator_MPM(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp)
	spElems        = zeros(spCount,1);
	N              = cell(1,spCount);
	dN             = cell(1,spCount);
	CONNECT        = cell(1,spCount);
	NODES          = zeros(1,spCount);
	siCount=NN(1)*NN(2);
	CONNECTpn=cell(1,siCount);
	Nmatrix=zeros(siCount,spCount);
	dNxmatrix=zeros(siCount,spCount);
	dNymatrix=zeros(siCount,spCount);

	%{
	%switchable1
	try
		parfor sp=1:spCount
			[N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow,dNxmatrixrow,dNymatrixrow] = Compute_Interpolator_MPM_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
			Nmatrix(:,sp)=Nmatrixrow;
			dNxmatrix(:,sp)=dNxmatrixrow;
			dNymatrix(:,sp)=dNymatrixrow;
		end
	catch
		fprintf('%s',['parfor failed inside Compute_Interpolator_MPM, switching to regular for' char(10)]);
		%}
		%switchable1
		for sp=1:spCount
			[N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow,dNxmatrixrow,dNymatrixrow] = Compute_Interpolator_MPM_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
			Nmatrix(:,sp)=Nmatrixrow;
			dNxmatrix(:,sp)=dNxmatrixrow;
			dNymatrix(:,sp)=dNymatrixrow;
		end
		%{
		%switchable1
	end        
	%}
	%switchable1
	for sp=1:spCount
		for i=1:length(CONNECT{sp})
			CONNECTpn{CONNECT{sp}(i)}=[CONNECTpn{CONNECT{sp}(i)} sp];
		end
	end

	for c =1:cellCount
		id_sp = find(spElems==c);
		mspoints{c}=id_sp;
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N_crack,dN_crack,CONNECT_crack,spElems_crack,NODES_crack,CONNECTpn_crack] = Compute_Interpolator_MPM_CrackParticleNoCell_topbotonly(x_crack,le,NN,LOC)
	maxnsp=size(x_crack.center,1);
	
	spElems_crack.top=zeros(x_crack.npaths,maxnsp);
	N_crack.top=zeros(1,4,maxnsp,x_crack.npaths);
	dN_crack.top=zeros(2,4,maxnsp,x_crack.npaths);
	NODES_crack.top=zeros(x_crack.npaths,maxnsp);
	CONNECT_crack.top.values=zeros(maxnsp,4,x_crack.npaths);
	CONNECT_crack.top.nrnodes=zeros(x_crack.npaths,maxnsp);
	CONNECT_crack.top.nparticles=zeros(x_crack.npaths);
	CONNECT_crack.top.npaths=zeros(1,1);
	CONNECT_crack.top.npaths=x_crack.npaths;
	
	spElems_crack.bot=zeros(x_crack.npaths,maxnsp);
	N_crack.bot=zeros(1,4,maxnsp,x_crack.npaths);
	dN_crack.bot=zeros(2,4,maxnsp,x_crack.npaths);
	NODES_crack.bot=zeros(x_crack.npaths,maxnsp);
	CONNECT_crack.bot.values=zeros(maxnsp,4,x_crack.npaths);
	CONNECT_crack.bot.nrnodes=zeros(x_crack.npaths,maxnsp);
	CONNECT_crack.bot.nparticles=zeros(x_crack.npaths);
	CONNECT_crack.bot.npaths=zeros(1,1);
	CONNECT_crack.bot.npaths=x_crack.npaths;
	
	max_x_crack_sizes=FindMaxVal(x_crack.nparticles);
	
	siCount=NN(1)*NN(2);
	CONNECTpn_crack_dummy.top.nrparticles=zeros(x_crack.npaths,siCount);
	CONNECTpn_crack_dummy.bot.nrparticles=zeros(x_crack.npaths,siCount);
	CONNECTpn_crack_dummy.top.maxnrparticles=zeros(1,1);
	CONNECTpn_crack_dummy.bot.maxnrparticles=zeros(1,1);
	%{
	CONNECTpn_crack.top.values=zeros(siCount,1,x_crack.npaths);
	coder.varsize('CONNECTpn_crack.top.values',[siCount max_x_crack_sizes x_crack.npaths]);
	CONNECTpn_crack.bot.values=zeros(siCount,1,x_crack.npaths);
	coder.varsize('CONNECTpn_crack.bot.values',[siCount max_x_crack_sizes x_crack.npaths]);
	%}
	
	for icrackpath=1:x_crack.npaths
		for sp=1:x_crack.nparticles(icrackpath)
			[N_crack.top(:,:,sp,icrackpath),dN_crack.top(:,:,sp,icrackpath),CONNECT_crack.top.values(sp,:,icrackpath),spElems_crack.top(icrackpath,sp),NODES_crack.top(icrackpath,sp)] = Compute_Interpolator_MPM_CrackParticleNoCellparforred(x_crack.top(sp,:,icrackpath),le,NN,LOC);
			[N_crack.bot(:,:,sp,icrackpath),dN_crack.bot(:,:,sp,icrackpath),CONNECT_crack.bot.values(sp,:,icrackpath),spElems_crack.bot(icrackpath,sp),NODES_crack.bot(icrackpath,sp)] = Compute_Interpolator_MPM_CrackParticleNoCellparforred(x_crack.bot(sp,:,icrackpath),le,NN,LOC);
		end
		CONNECT_crack.top.nparticles(icrackpath)=x_crack.nparticles(icrackpath);
		CONNECT_crack.bot.nparticles(icrackpath)=x_crack.nparticles(icrackpath);
	end
	CONNECT_crack.top.nrnodes=NODES_crack.top;
	CONNECT_crack.bot.nrnodes=NODES_crack.bot;
	
	
	for icrackpath=1:x_crack.npaths
		for sp=1:x_crack.nparticles(icrackpath)
			for i=1:4
				CONNECTpn_crack_dummy.top.nrparticles(icrackpath,CONNECT_crack.top.values(sp,i,icrackpath))=CONNECTpn_crack_dummy.top.nrparticles(icrackpath,CONNECT_crack.top.values(sp,i,icrackpath))+1;
				CONNECTpn_crack_dummy.bot.nrparticles(icrackpath,CONNECT_crack.bot.values(sp,i,icrackpath))=CONNECTpn_crack_dummy.bot.nrparticles(icrackpath,CONNECT_crack.bot.values(sp,i,icrackpath))+1;
			end
		end
	end
	
	CONNECTpn_crack_dummy.top.maxnrparticles=FindMaxValMatrix(CONNECTpn_crack_dummy.top.nrparticles);
	CONNECTpn_crack_dummy.bot.maxnrparticles=FindMaxValMatrix(CONNECTpn_crack_dummy.bot.nrparticles);
	
	CONNECTpn_crack.top.nrparticles=zeros(x_crack.npaths,siCount);
	CONNECTpn_crack.bot.nrparticles=zeros(x_crack.npaths,siCount);
	CONNECTpn_crack.top.maxnrparticles=zeros(1,1);
	CONNECTpn_crack.bot.maxnrparticles=zeros(1,1);
	CONNECTpn_crack.top.values=zeros(siCount,CONNECTpn_crack_dummy.top.maxnrparticles,x_crack.npaths);
	CONNECTpn_crack.bot.values=zeros(siCount,CONNECTpn_crack_dummy.bot.maxnrparticles,x_crack.npaths);
	
	CONNECTpn_crack.top.nrparticles=CONNECTpn_crack_dummy.top.nrparticles;
	CONNECTpn_crack.bot.nrparticles=CONNECTpn_crack_dummy.bot.nrparticles;
	CONNECTpn_crack.top.maxnrparticles=CONNECTpn_crack_dummy.top.maxnrparticles;
	CONNECTpn_crack.bot.maxnrparticles=CONNECTpn_crack_dummy.bot.maxnrparticles;
	
	CONNECTpn_crack.top.npaths=zeros(1,1);
	CONNECTpn_crack.bot.npaths=zeros(1,1);
	
	
	for icrackpath=1:x_crack.npaths
		countertop=zeros(1,siCount);
		counterbot=zeros(1,siCount);
		for sp=1:x_crack.nparticles(icrackpath)
			for i=1:4
				countertop(1,CONNECT_crack.top.values(sp,i,icrackpath))=countertop(1,CONNECT_crack.top.values(sp,i,icrackpath))+1;
				CONNECTpn_crack.top.values(CONNECT_crack.top.values(sp,i,icrackpath),countertop(1,CONNECT_crack.top.values(sp,i,icrackpath)),icrackpath)=sp;
				
				counterbot(1,CONNECT_crack.bot.values(sp,i,icrackpath))=counterbot(1,CONNECT_crack.bot.values(sp,i,icrackpath))+1;
				CONNECTpn_crack.bot.values(CONNECT_crack.bot.values(sp,i,icrackpath),counterbot(1,CONNECT_crack.bot.values(sp,i,icrackpath)),icrackpath)=sp;
			end
		end
	end
	
	CONNECTpn_crack.top.npaths=x_crack.npaths;
	CONNECTpn_crack.bot.npaths=x_crack.npaths;
	
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

%function [N_crack,dN_crack,CONNECT_crack,spElems_crack,NODES_crack,CONNECTpn_crack] = Compute_Interpolator_MPM_CrackParticleNoCell(x_crack,le,NN,LOC)
function [N_crack,dN_crack,CONNECT_crack,spElems_crack,NODES_crack,CONNECTpn_crack] = Compute_Interpolator_MPM_CrackParticleNoCell(t_time,x_crack,le,NN,LOC)
	maxnsp=size(x_crack.center,1);
	
	spElems_crack.top=zeros(x_crack.npaths,maxnsp);%if t_time>0.01770;fprintf('%s',['marker #802' char(10)]);end;
	N_crack.top=zeros(1,4,maxnsp,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #803' char(10)]);end;
	dN_crack.top=zeros(2,4,maxnsp,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #804' char(10)]);end;
	NODES_crack.top=zeros(x_crack.npaths,maxnsp);%if t_time>0.01770;fprintf('%s',['marker #805' char(10)]);end;
	CONNECT_crack.top.values=zeros(maxnsp,4,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #806' char(10)]);end;
	CONNECT_crack.top.nrnodes=zeros(x_crack.npaths,maxnsp);%if t_time>0.01770;fprintf('%s',['marker #807' char(10)]);end;
	CONNECT_crack.top.nparticles=zeros(x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #808' char(10)]);end;
	CONNECT_crack.top.npaths=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #809' char(10)]);end;
	CONNECT_crack.top.npaths=x_crack.npaths;%if t_time>0.01770;fprintf('%s',['marker #810' char(10)]);end;
	
	spElems_crack.bot=zeros(x_crack.npaths,maxnsp);%if t_time>0.01770;fprintf('%s',['marker #811' char(10)]);end;
	N_crack.bot=zeros(1,4,maxnsp,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #812' char(10)]);end;
	dN_crack.bot=zeros(2,4,maxnsp,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #813' char(10)]);end;
	NODES_crack.bot=zeros(x_crack.npaths,maxnsp);%if t_time>0.01770;fprintf('%s',['marker #814' char(10)]);end;
	CONNECT_crack.bot.values=zeros(maxnsp,4,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #815' char(10)]);end;
	CONNECT_crack.bot.nrnodes=zeros(x_crack.npaths,maxnsp);%if t_time>0.01770;fprintf('%s',['marker #816' char(10)]);end;
	CONNECT_crack.bot.nparticles=zeros(x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #817' char(10)]);end;
	CONNECT_crack.bot.npaths=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #818' char(10)]);end;
	CONNECT_crack.bot.npaths=x_crack.npaths;%if t_time>0.01770;fprintf('%s',['marker #819' char(10)]);end;
	
	spElems_crack.center=zeros(x_crack.npaths,maxnsp);%if t_time>0.01770;fprintf('%s',['marker #820' char(10)]);end;
	N_crack.center=zeros(1,4,maxnsp,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #821' char(10)]);end;
	dN_crack.center=zeros(2,4,maxnsp,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #822' char(10)]);end;
	NODES_crack.center=zeros(x_crack.npaths,maxnsp);%if t_time>0.01770;fprintf('%s',['marker #823' char(10)]);end;
	CONNECT_crack.center.values=zeros(maxnsp,4,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #824' char(10)]);end;
	CONNECT_crack.center.nrnodes=zeros(x_crack.npaths,maxnsp);%if t_time>0.01770;fprintf('%s',['marker #825' char(10)]);end;
	CONNECT_crack.center.nparticles=zeros(x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #826' char(10)]);end;
	CONNECT_crack.center.npaths=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #827' char(10)]);end;
	CONNECT_crack.center.npaths=x_crack.npaths;%if t_time>0.01770;fprintf('%s',['marker #828' char(10)]);end;
		
	max_x_crack_sizes=FindMaxVal(x_crack.nparticles);%if t_time>0.01770;fprintf('%s',['marker #829' char(10)]);end;
	
	N_crack.gauss=zeros(1,4,x_crack.gauss.npoints,x_crack.npaths,2); %dimension (only 1), i associated node, igausspoint, ipath,itip
	dN_crack.gauss=zeros(2,4,x_crack.gauss.npoints,x_crack.npaths,2); %dimension (2 of them), i associated node, igausspoint, ipath,itip
	NODES_crack.gauss=zeros(x_crack.npaths,x_crack.gauss.npoints,2); %ipath, igausspoint,itip
	CONNECT_crack.gauss=zeros(x_crack.gauss.npoints,4,x_crack.npaths,2); %igausspoint, i associated node, ipath, itip
	spElems_crack.gauss=zeros(x_crack.npaths,x_crack.gauss.npoints,2); %ipath, igausspoint, itip
	
	%TDL N Variables we have for boxcalc
	N_crack.boxcalc=zeros(1,4,4,x_crack.npaths,2); %dimension (only 1), i associated node, i corner number of the box, ipath, itip);
	dN_crack.boxcalc=zeros(2,4,4,x_crack.npaths,2); %dimension (2 of them), i associated node, i corner number of the box, ipath,itip
	NODES_crack.boxcalc=zeros(x_crack.npaths,4,2); %ipath, i corner number of the box,itip
	CONNECT_crack.boxcalc=zeros(4,4,x_crack.npaths,2); %i corner number of the box, i associated node, ipath, itip
	spElems_crack.boxcalc=zeros(x_crack.npaths,4,2); %ipath, i corner number of the box, itip
	
	
	niCount=NN(1)*NN(2);%if t_time>0.01770;fprintf('%s',['marker #830' char(10)]);end;
	CONNECTpn_crack_dummy.top.nrparticles=zeros(x_crack.npaths,niCount);%if t_time>0.01770;fprintf('%s',['marker #831' char(10)]);end;
	CONNECTpn_crack_dummy.bot.nrparticles=zeros(x_crack.npaths,niCount);%if t_time>0.01770;fprintf('%s',['marker #832' char(10)]);end;
	CONNECTpn_crack_dummy.center.nrparticles=zeros(x_crack.npaths,niCount);%if t_time>0.01770;fprintf('%s',['marker #833' char(10)]);end;
	CONNECTpn_crack_dummy.boxcalc.nrparticles=zeros(2,niCount,x_crack.npaths);%i tip, ipath, node number	
	
	CONNECTpn_crack_dummy.top.maxnrparticles=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #834' char(10)]);end;
	CONNECTpn_crack_dummy.bot.maxnrparticles=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #835' char(10)]);end;
	CONNECTpn_crack_dummy.center.maxnrparticles=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #836' char(10)]);end;
	CONNECTpn_crack_dummy.boxcalc.maxnrparticles=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #833' char(10)]);end;
	%{
	CONNECTpn_crack.top.values=zeros(niCount,1,x_crack.npaths);
	coder.varsize('CONNECTpn_crack.top.values',[niCount max_x_crack_sizes x_crack.npaths]);
	CONNECTpn_crack.bot.values=zeros(niCount,1,x_crack.npaths);
	coder.varsize('CONNECTpn_crack.bot.values',[niCount max_x_crack_sizes x_crack.npaths]);
	%}
	
	for icrackpath=1:x_crack.npaths
		for sp=1:x_crack.nparticles(icrackpath)
			[N_crack.top(:,:,sp,icrackpath),dN_crack.top(:,:,sp,icrackpath),CONNECT_crack.top.values(sp,:,icrackpath),spElems_crack.top(icrackpath,sp),NODES_crack.top(icrackpath,sp)] = Compute_Interpolator_MPM_CrackParticleNoCellparforred(x_crack.top(sp,:,icrackpath),le,NN,LOC);%if t_time>0.01770;fprintf('%s',['marker #837' char(10)]);end;
			[N_crack.bot(:,:,sp,icrackpath),dN_crack.bot(:,:,sp,icrackpath),CONNECT_crack.bot.values(sp,:,icrackpath),spElems_crack.bot(icrackpath,sp),NODES_crack.bot(icrackpath,sp)] = Compute_Interpolator_MPM_CrackParticleNoCellparforred(x_crack.bot(sp,:,icrackpath),le,NN,LOC);%if t_time>0.01770;fprintf('%s',['marker #838' char(10)]);end;
			[N_crack.center(:,:,sp,icrackpath),dN_crack.center(:,:,sp,icrackpath),CONNECT_crack.center.values(sp,:,icrackpath),spElems_crack.center(icrackpath,sp),NODES_crack.center(icrackpath,sp)] = Compute_Interpolator_MPM_CrackParticleNoCellparforred(x_crack.center(sp,:,icrackpath),le,NN,LOC);%if t_time>0.01770;fprintf('%s',['marker #839' char(10)]);end;
		end
		CONNECT_crack.top.nparticles(icrackpath)=x_crack.nparticles(icrackpath);%if t_time>0.01770;fprintf('%s',['marker #840' char(10)]);end;
		CONNECT_crack.bot.nparticles(icrackpath)=x_crack.nparticles(icrackpath);%if t_time>0.01770;fprintf('%s',['marker #841' char(10)]);end;
		CONNECT_crack.center.nparticles(icrackpath)=x_crack.nparticles(icrackpath);%if t_time>0.01770;fprintf('%s',['marker #842' char(10)]);end;
	end
	CONNECT_crack.top.nrnodes=NODES_crack.top;%if t_time>0.01770;fprintf('%s',['marker #843' char(10)]);end;
	CONNECT_crack.bot.nrnodes=NODES_crack.bot;%if t_time>0.01770;fprintf('%s',['marker #844' char(10)]);end;
	CONNECT_crack.center.nrnodes=NODES_crack.center;%if t_time>0.01770;fprintf('%s',['marker #845' char(10)]);end;
	
	%TDL gauss suspect 1
	for icrackpath=1:x_crack.npaths
		for itip=1:2
			for igausspoint=1:x_crack.gauss.npoints
				[N_crack.gauss(:,:,igausspoint,icrackpath,itip),dN_crack.gauss(:,:,igausspoint,icrackpath,itip),CONNECT_crack.gauss(igausspoint,:,icrackpath,itip),spElems_crack.gauss(icrackpath,igausspoint,itip),NODES_crack.gauss(icrackpath,igausspoint,itip)] = Compute_Interpolator_MPM_CrackParticleNoCellparforred(x_crack.gauss.locs(igausspoint,:,icrackpath,itip),le,NN,LOC);%if t_time>0.01770;fprintf('%s',['marker #846' char(10)]);end;
			end
			
			%TDL investigate zero N_crack.boxcalc
			if x_crack.boxcalc.active(icrackpath,itip)==1
			if x_crack.terminatedprop(icrackpath,itip)==0
			for icornerpoint=1:4
				[N_crack.boxcalc(:,:,icornerpoint,icrackpath,itip),dN_crack.boxcalc(:,:,icornerpoint,icrackpath,itip),CONNECT_crack.boxcalc(icornerpoint,:,icrackpath,itip),spElems_crack.boxcalc(icrackpath,icornerpoint,itip),NODES_crack.boxcalc(icrackpath,icornerpoint,itip)] = Compute_Interpolator_MPM_CrackParticleNoCellparforred(x_crack.boxcalc.locs(icornerpoint,:,icrackpath,itip),le,NN,LOC);
			end
			end
			end
		end
	end
	
	for icrackpath=1:x_crack.npaths
		for sp=1:x_crack.nparticles(icrackpath)
			for iro=1:4
				%iro: i of Relevant nOde
				CONNECTpn_crack_dummy.top.nrparticles(icrackpath,CONNECT_crack.top.values(sp,iro,icrackpath))=CONNECTpn_crack_dummy.top.nrparticles(icrackpath,CONNECT_crack.top.values(sp,iro,icrackpath))+1;%if t_time>0.01770;fprintf('%s',['marker #847' char(10)]);end;
				CONNECTpn_crack_dummy.bot.nrparticles(icrackpath,CONNECT_crack.bot.values(sp,iro,icrackpath))=CONNECTpn_crack_dummy.bot.nrparticles(icrackpath,CONNECT_crack.bot.values(sp,iro,icrackpath))+1;%if t_time>0.01770;fprintf('%s',['marker #848' char(10)]);end;
				CONNECTpn_crack_dummy.center.nrparticles(icrackpath,CONNECT_crack.center.values(sp,iro,icrackpath))=CONNECTpn_crack_dummy.center.nrparticles(icrackpath,CONNECT_crack.center.values(sp,iro,icrackpath))+1;%if t_time>0.01770;fprintf('%s',['marker #849' char(10)]);end;
			end
		end
	end
	
	for ipath=1:x_crack.npaths
	for itip=1:2
	if x_crack.boxcalc.active(ipath,itip)==1
	for icorner=1:4
	for iro=1:4
		CONNECTpn_crack_dummy.boxcalc.nrparticles(itip,CONNECT_crack.boxcalc(icorner,iro,ipath,itip),ipath)=CONNECTpn_crack_dummy.boxcalc.nrparticles(itip,CONNECT_crack.boxcalc(icorner,iro,ipath,itip),ipath)+1;
	end
	end
	end
	end
	end
	
	
	CONNECTpn_crack_dummy.top.maxnrparticles=FindMaxValMatrix(CONNECTpn_crack_dummy.top.nrparticles);%if t_time>0.01770;fprintf('%s',['marker #850' char(10)]);end;
	CONNECTpn_crack_dummy.bot.maxnrparticles=FindMaxValMatrix(CONNECTpn_crack_dummy.bot.nrparticles);%if t_time>0.01770;fprintf('%s',['marker #851' char(10)]);end;
	CONNECTpn_crack_dummy.center.maxnrparticles=FindMaxValMatrix(CONNECTpn_crack_dummy.center.nrparticles);%if t_time>0.01770;fprintf('%s',['marker #852' char(10)]);end;
	CONNECTpn_crack_dummy.boxcalc.maxnrparticles=FindMaxVal3DMatrix(CONNECTpn_crack_dummy.boxcalc.nrparticles);%if t_time>0.01770;fprintf('%s',['marker #852' char(10)]);end;
	
	CONNECTpn_crack.top.nrparticles=zeros(x_crack.npaths,niCount);%if t_time>0.01770;fprintf('%s',['marker #853' char(10)]);end;
	CONNECTpn_crack.bot.nrparticles=zeros(x_crack.npaths,niCount);%if t_time>0.01770;fprintf('%s',['marker #854' char(10)]);end;
	CONNECTpn_crack.center.nrparticles=zeros(x_crack.npaths,niCount);%if t_time>0.01770;fprintf('%s',['marker #855' char(10)]);end;
	CONNECTpn_crack.boxcalc.nrparticles=zeros(2,niCount,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #855' char(10)]);end;
	
	CONNECTpn_crack.top.maxnrparticles=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #856' char(10)]);end;
	CONNECTpn_crack.bot.maxnrparticles=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #857' char(10)]);end;
	CONNECTpn_crack.center.maxnrparticles=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #858' char(10)]);end;
	CONNECTpn_crack.boxcalc.maxnrparticles=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #858' char(10)]);end;
	
	CONNECTpn_crack.top.values=zeros(niCount,CONNECTpn_crack_dummy.top.maxnrparticles,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #859' char(10)]);end;
	CONNECTpn_crack.bot.values=zeros(niCount,CONNECTpn_crack_dummy.bot.maxnrparticles,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #860' char(10)]);end;
	CONNECTpn_crack.center.values=zeros(niCount,CONNECTpn_crack_dummy.center.maxnrparticles,x_crack.npaths);%if t_time>0.01770;fprintf('%s',['marker #861' char(10)]);end;
	CONNECTpn_crack.boxcalc.values=zeros(niCount,CONNECTpn_crack_dummy.boxcalc.maxnrparticles,2,x_crack.npaths); %niCount, irp (number of relevant particle), itip,ipath;
	
	CONNECTpn_crack.top.nrparticles=CONNECTpn_crack_dummy.top.nrparticles;%if t_time>0.01770;fprintf('%s',['marker #862' char(10)]);end;
	CONNECTpn_crack.bot.nrparticles=CONNECTpn_crack_dummy.bot.nrparticles;%if t_time>0.01770;fprintf('%s',['marker #863' char(10)]);end;
	CONNECTpn_crack.center.nrparticles=CONNECTpn_crack_dummy.center.nrparticles;%if t_time>0.01770;fprintf('%s',['marker #864' char(10)]);end;
	CONNECTpn_crack.boxcalc.nrparticles=CONNECTpn_crack_dummy.boxcalc.nrparticles;%if t_time>0.01770;fprintf('%s',['marker #864' char(10)]);end;
	
	CONNECTpn_crack.top.maxnrparticles=CONNECTpn_crack_dummy.top.maxnrparticles;%if t_time>0.01770;fprintf('%s',['marker #865' char(10)]);end;
	CONNECTpn_crack.bot.maxnrparticles=CONNECTpn_crack_dummy.bot.maxnrparticles;%if t_time>0.01770;fprintf('%s',['marker #866' char(10)]);end;
	CONNECTpn_crack.center.maxnrparticles=CONNECTpn_crack_dummy.center.maxnrparticles;%if t_time>0.01770;fprintf('%s',['marker #867' char(10)]);end;
	CONNECTpn_crack.boxcalc.maxnrparticles=CONNECTpn_crack_dummy.boxcalc.maxnrparticles;%if t_time>0.01770;fprintf('%s',['marker #867' char(10)]);end;
	
	CONNECTpn_crack.top.npaths=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #868' char(10)]);end;
	CONNECTpn_crack.bot.npaths=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #869' char(10)]);end;
	CONNECTpn_crack.center.npaths=zeros(1,1);%if t_time>0.01770;fprintf('%s',['marker #870' char(10)]);end;
	
	
	for ipath=1:x_crack.npaths
		countertop=zeros(1,niCount);%if t_time>0.01770;fprintf('%s',['marker #871' char(10)]);end;
		counterbot=zeros(1,niCount);%if t_time>0.01770;fprintf('%s',['marker #872' char(10)]);end;
		countercenter=zeros(1,niCount);%if t_time>0.01770;fprintf('%s',['marker #873' char(10)]);end;
		for sp=1:x_crack.nparticles(ipath)
			for iro=1:4
				%iro: rolling number (i) of Relevant nOdes
				countertop(1,CONNECT_crack.top.values(sp,iro,ipath))=countertop(1,CONNECT_crack.top.values(sp,iro,ipath))+1;%if t_time>0.01770;fprintf('%s',['marker #874' char(10)]);end;
				CONNECTpn_crack.top.values(CONNECT_crack.top.values(sp,iro,ipath),countertop(1,CONNECT_crack.top.values(sp,iro,ipath)),ipath)=sp;%if t_time>0.01770;fprintf('%s',['marker #875' char(10)]);end;
				
				counterbot(1,CONNECT_crack.bot.values(sp,iro,ipath))=counterbot(1,CONNECT_crack.bot.values(sp,iro,ipath))+1;%if t_time>0.01770;fprintf('%s',['marker #876' char(10)]);end;
				CONNECTpn_crack.bot.values(CONNECT_crack.bot.values(sp,iro,ipath),counterbot(1,CONNECT_crack.bot.values(sp,iro,ipath)),ipath)=sp;%if t_time>0.01770;fprintf('%s',['marker #877' char(10)]);end;
				
				countercenter(1,CONNECT_crack.center.values(sp,iro,ipath))=countercenter(1,CONNECT_crack.center.values(sp,iro,ipath))+1;%if t_time>0.01770;fprintf('%s',['marker #878' char(10)]);end;
				CONNECTpn_crack.center.values(CONNECT_crack.center.values(sp,iro,ipath),countercenter(1,CONNECT_crack.center.values(sp,iro,ipath)),ipath)=sp;%if t_time>0.01770;fprintf('%s',['marker #879' char(10)]);end;
			end
		end
	end
	for ipath=1:x_crack.npaths
	for itip=1:2
	if x_crack.boxcalc.active(ipath,itip)==1
		counterboxcalc=zeros(1,niCount);
		for icornerpoint=1:4
			for iro=1:4
				counterboxcalc(1,CONNECT_crack.boxcalc(icornerpoint,iro,ipath,itip))=counterboxcalc(1,CONNECT_crack.boxcalc(icornerpoint,iro,ipath,itip))+1;
				
				CONNECTpn_crack.boxcalc.values(CONNECT_crack.boxcalc(icornerpoint,iro,ipath,itip),counterboxcalc(1,CONNECT_crack.boxcalc(icornerpoint,iro,ipath,itip)),itip,ipath)=icornerpoint;
				
			end
		end
	end
	end
	end
	
	CONNECTpn_crack.top.npaths=x_crack.npaths;%if t_time>0.01770;fprintf('%s',['marker #880' char(10)]);end;
	CONNECTpn_crack.bot.npaths=x_crack.npaths;%if t_time>0.01770;fprintf('%s',['marker #881' char(10)]);end;
	CONNECTpn_crack.center.npaths=x_crack.npaths;%if t_time>0.01770;fprintf('%s',['marker #882' char(10)]);end;
	CONNECTpn_crack.boxcalc.npaths=x_crack.npaths;%if t_time>0.01770;fprintf('%s',['marker #882' char(10)]);end;
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,mspoints,NODES,Nmatrix,CONNECTpn] = Compute_Interpolator_MPM_optimized(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp)
	spElems        = zeros(spCount,1);
	N              = cell(1,spCount);
	dN             = cell(1,spCount);
	CONNECT        = cell(1,spCount);
	NODES          = zeros(1,spCount);
	siCount=NN(1)*NN(2);
	CONNECTpn=cell(1,siCount);
	Nmatrix=zeros(siCount,spCount);
	
	%{
	%switchable1
	try
		parfor sp=1:spCount
			[N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow] = Compute_Interpolator_MPM_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
			Nmatrix(:,sp)=Nmatrixrow;
		end
	catch
		fprintf('%s',['parfor failed inside Compute_Interpolator_MPM, switching to regular for' char(10)]);
		%}
		%switchable1
		for sp=1:spCount
			[N{sp},dN{sp},CONNECT{sp},spElems(sp),NODES(sp),Nmatrixrow] = Compute_Interpolator_MPM_parforred(x_sp(sp,:),le,NN,LOC,r1_sp(sp,:),r2_sp(sp,:),A_sp(sp,:),siCount);
			Nmatrix(:,sp)=Nmatrixrow;
		end
		%{
		%switchable1
	end        
	%}
	%switchable1
	CONNECTpnSizes=zeros(1,siCount);
	for sp=1:spCount
		for i=1:length(CONNECT{sp})
			CONNECTpnSizes(CONNECT{sp}(i))=CONNECTpnSizes(CONNECT{sp}(i))+1;
		end
	end
	
	CONNECTpnMaxSize=1;
	for i=1:length(CONNECTpnSizes)
		if CONNECTpnSizes(i)>CONNECTpnMaxSize
			CONNECTpnMaxSize=CONNECTpnSizes(i);
		end
	end
	
	CONNECTpn=zeros(siCount,CONNECTpnMaxSize);
	
%{	
	for sp=1:spCount
		for i=1:length(CONNECT{sp})
			CONNECTpn{CONNECT{sp}(i)}=[CONNECTpn{CONNECT{sp}(i)} sp];
		end
	end
%}
	CONNECTpnCounter=zeros(1,siCount);
	for sp=1:spCount
		for i=1:length(CONNECT{sp})
			CONNECTpnCounter(CONNECT{sp}(i))=CONNECTpnCounter(CONNECT{sp}(i))+1;
			CONNECTpn(i,CONNECTpnCounter(CONNECT{sp}(i)))=sp;
		end
	end
	
	mspoints=cell(1,cellCount);
	for c =1:cellCount
		id_sp = find(spElems==c);
		mspoints{c}=id_sp;
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,pElems,NODES,Nmatrixrow,dNxmatrixrow,dNymatrixrow] = Compute_Interpolator_MPM_parforred(x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,siCount)
	
	pElems         = zeros(1,1);                             % index of elements where stores particles
	CONNECT_TEMP    = zeros(1,4);                            % node 1=leftdown 2=righdown 3=rightup 4= leftup
	NODES           = 4 * ones(1,1);                         % Number of interation nodes for each particle
	N_local         = zeros(1,4);                            % Value of shape function
	dN_local        = zeros(1,8);                            % Value of gradient of shape function
	p=1;
	Nmatrixrow     = zeros(siCount,1);
	dNxmatrixrow   = zeros(siCount,1);
	dNymatrixrow   = zeros(siCount,1);
	
	N=zeros(1,NODES(p));
	dN=zeros(2,NODES(p));
	
	pElems(p) = ceil(x_sp(p,1)/le(1))+(NN(1)-1)*(fix(x_sp(p,2)/le(2)));   % compute vector store index elements                           
	
	CONNECT_TEMP(p,1) = pElems(p) + myfloor((pElems(p)-1)/(NN(1)-1));
	CONNECT_TEMP(p,2) = CONNECT_TEMP(p,1)+1; 
	CONNECT_TEMP(p,3) = CONNECT_TEMP(p,2)+NN(1); 
	CONNECT_TEMP(p,4) = CONNECT_TEMP(p,1)+NN(1);
	CONNECT        = [CONNECT_TEMP(p,1) CONNECT_TEMP(p,2) CONNECT_TEMP(p,3) CONNECT_TEMP(p,4)];
	 
	[N_local(p,1),dN_local(p,1),dN_local(p,5)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,1),:),le(1,1),le(1,2));
	[N_local(p,2),dN_local(p,2),dN_local(p,6)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,2),:),le(1,1),le(1,2));
	[N_local(p,3),dN_local(p,3),dN_local(p,7)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,3),:),le(1,1),le(1,2));
	[N_local(p,4),dN_local(p,4),dN_local(p,8)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,4),:),le(1,1),le(1,2));
	
	% Build matrix of gradient of shape function of 4 nodes of the cell which
	% contain the particles
	% dG((sp-1)*4+[1:4],:) = [dN(sp,1) dN(sp,5);dN(sp,2) dN(sp,6);dN(sp,3) dN(sp,7);dN(sp,4) dN(sp,8)];
	
	for i = 1:NODES(p)
		N(i) = N_local(p,i);    
		dN(1,i) = dN_local(p,i);
		dN(2,i) = dN_local(p,i+4);
	end
	 
	for i=1:NODES(1)
		Nmatrixrow(CONNECT(i),1)=N(i);
		dNxmatrixrow(CONNECT(i),1)=dN(1,i);
		dNymatrixrow(CONNECT(i),1)=dN(2,i);
	end
end

function [N,dN,CONNECT,pElems,NODES] = Compute_Interpolator_MPM_CrackParticleNoCellparforred(x_sp,le,NN,LOC)
	
	pElems         = zeros(1,1);                             % index of elements where stores particles
	CONNECT_TEMP    = zeros(1,4);                            % node 1=leftdown 2=righdown 3=rightup 4= leftup
	NODES           = 4 * ones(1,1);                         % Number of interation nodes for each particle
	N_local         = zeros(1,4);                            % Value of shape function
	dN_local        = zeros(1,8);                            % Value of gradient of shape function
	p=1;
	
	N=zeros(1,NODES(p));
	dN=zeros(2,NODES(p));
	
	pElems(p) = ceil(x_sp(p,1)/le(1))+(NN(1)-1)*(fix(x_sp(p,2)/le(2)));   % compute vector store index elements                           
	
	CONNECT_TEMP(p,1) = pElems(p) + myfloor((pElems(p)-1)/(NN(1)-1));
	CONNECT_TEMP(p,2) = CONNECT_TEMP(p,1)+1; 
	CONNECT_TEMP(p,3) = CONNECT_TEMP(p,2)+NN(1); 
	CONNECT_TEMP(p,4) = CONNECT_TEMP(p,1)+NN(1);
	CONNECT        = [CONNECT_TEMP(p,1) CONNECT_TEMP(p,2) CONNECT_TEMP(p,3) CONNECT_TEMP(p,4)];
	 
	[N_local(p,1),dN_local(p,1),dN_local(p,5)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,1),:),le(1,1),le(1,2));
	[N_local(p,2),dN_local(p,2),dN_local(p,6)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,2),:),le(1,1),le(1,2));
	[N_local(p,3),dN_local(p,3),dN_local(p,7)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,3),:),le(1,1),le(1,2));
	[N_local(p,4),dN_local(p,4),dN_local(p,8)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,4),:),le(1,1),le(1,2));
	
	% Build matrix of gradient of shape function of 4 nodes of the cell which
	% contain the particles
	% dG((sp-1)*4+[1:4],:) = [dN(sp,1) dN(sp,5);dN(sp,2) dN(sp,6);dN(sp,3) dN(sp,7);dN(sp,4) dN(sp,8)];
	
	for i = 1:NODES(p)
		N(i) = N_local(p,i);    
		dN(1,i) = dN_local(p,i);
		dN(2,i) = dN_local(p,i+4);
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,pElems,NODES,Nmatrixrow] = Compute_Interpolator_MPM_parforred_optimized(x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,siCount)
	
	pElems         = zeros(1,1);                             % index of elements where stores particles
	CONNECT_TEMP    = zeros(1,4);                            % node 1=leftdown 2=righdown 3=rightup 4= leftup
	NODES           = 4 * ones(1,1);                         % Number of interation nodes for each particle
	N_local         = zeros(1,4);                            % Value of shape function
	dN_local        = zeros(1,8);                            % Value of gradient of shape function
	p=1;
	Nmatrixrow     = zeros(siCount,1);
	N              = zeros(1,NODES(p));
	dN             = zeros(2,NODES(p));
	
	pElems(p) = ceil(x_sp(p,1)/le(1))+(NN(1)-1)*(fix(x_sp(p,2)/le(2)));   % compute vector store index elements                           
	
	CONNECT_TEMP(p,1) = pElems(p) + myfloor((pElems(p)-1)/(NN(1)-1));
	CONNECT_TEMP(p,2) = CONNECT_TEMP(p,1)+1; 
	CONNECT_TEMP(p,3) = CONNECT_TEMP(p,2)+NN(1); 
	CONNECT_TEMP(p,4) = CONNECT_TEMP(p,1)+NN(1);
	CONNECT        = [CONNECT_TEMP(p,1) CONNECT_TEMP(p,2) CONNECT_TEMP(p,3) CONNECT_TEMP(p,4)];
	
	[N_local(p,1),dN_local(p,1),dN_local(p,5)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,1),:),le(1,1),le(1,2));
	[N_local(p,2),dN_local(p,2),dN_local(p,6)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,2),:),le(1,1),le(1,2));
	[N_local(p,3),dN_local(p,3),dN_local(p,7)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,3),:),le(1,1),le(1,2));
	[N_local(p,4),dN_local(p,4),dN_local(p,8)]=linearshape(x_sp(p,1:2),LOC(CONNECT_TEMP(p,4),:),le(1,1),le(1,2));
	
	% Build matrix of gradient of shape function of 4 nodes of the cell which
	% contain the particles
	% dG((sp-1)*4+[1:4],:) = [dN(sp,1) dN(sp,5);dN(sp,2) dN(sp,6);dN(sp,3) dN(sp,7);dN(sp,4) dN(sp,8)];
	
	for i = 1:NODES(p)
		N(i) = N_local(p,i);    
		dN(1,i) = dN_local(p,i);
		dN(2,i) = dN_local(p,i+4);
	end
	
	for i=1:NODES(1)
		Nmatrixrow(CONNECT(i),1)=N(i);
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN,CONNECT,spElems,mspoints,NODES] = Compute_Interpolator_CPDI_regularloop(spCount,cellCount,x_sp,le,NN,LOC,r1_sp,r2_sp,A_sp,t_sp)
	
	CONNECT_TEMP   = zeros(spCount,16);
	spElems_corner = zeros(spCount,4);
	spElems        = zeros(spCount,1);
	x_corner1      = zeros(spCount,2);
	x_corner2      = zeros(spCount,2);
	x_corner3      = zeros(spCount,2);
	x_corner4      = zeros(spCount,2);
	NODES          = zeros(1,spCount);
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);      % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end
	
	for sp = 1:spCount
		spElems(sp) = ceil(x_sp(sp,1)/le(1))+(NN(1)-1)*(fix(x_sp(sp,2)/le(2)));   % compute vector store index elements                           
		
		spElems_corner(sp,1) = ceil(x_corner1(sp,1)/le(1))+(NN(1)-1)*(fix(x_corner1(sp,2)/le(2)));
		spElems_corner(sp,2) = ceil(x_corner2(sp,1)/le(1))+(NN(1)-1)*(fix(x_corner2(sp,2)/le(2)));
		spElems_corner(sp,3) = ceil(x_corner3(sp,1)/le(1))+(NN(1)-1)*(fix(x_corner3(sp,2)/le(2)));
		spElems_corner(sp,4) = ceil(x_corner4(sp,1)/le(1))+(NN(1)-1)*(fix(x_corner4(sp,2)/le(2)));
		
		CONNECT_TEMP(sp,1)  = spElems_corner(sp,1) + myfloor((spElems_corner(sp,1)-1)/(NN(1)-1));
		CONNECT_TEMP(sp,2)  = CONNECT_TEMP(sp,1) + 1;
		CONNECT_TEMP(sp,3)  = CONNECT_TEMP(sp,2) + NN(1);
		CONNECT_TEMP(sp,4)  = CONNECT_TEMP(sp,1) + NN(1);
		
		CONNECT_TEMP(sp,5)  = spElems_corner(sp,2) + myfloor((spElems_corner(sp,2)-1)/(NN(1)-1));
		CONNECT_TEMP(sp,6)  = CONNECT_TEMP(sp,5) + 1;
		CONNECT_TEMP(sp,7)  = CONNECT_TEMP(sp,6) + NN(1);
		CONNECT_TEMP(sp,8)  = CONNECT_TEMP(sp,5) + NN(1); 
		
		CONNECT_TEMP(sp,9)  = spElems_corner(sp,3) + myfloor((spElems_corner(sp,3)-1)/(NN(1)-1));
		CONNECT_TEMP(sp,10) = CONNECT_TEMP(sp,9) + 1;
		CONNECT_TEMP(sp,11) = CONNECT_TEMP(sp,10) + NN(1);
		CONNECT_TEMP(sp,12) = CONNECT_TEMP(sp,9) + NN(1); 
		
		CONNECT_TEMP(sp,13) = spElems_corner(sp,4) + myfloor((spElems_corner(sp,4)-1)/(NN(1)-1));
		CONNECT_TEMP(sp,14) = CONNECT_TEMP(sp,13) + 1;
		CONNECT_TEMP(sp,15) = CONNECT_TEMP(sp,14) + NN(1);
		CONNECT_TEMP(sp,16) = CONNECT_TEMP(sp,13) + NN(1);
		
		CONNECT{sp}=unique(CONNECT_TEMP(sp,:));    % Store nodes interacting with corners
		NODES(sp)=length(CONNECT{sp});         % Store number of interacting nodes
		
		N1 = zeros(1,NODES(sp));   % Shape function of corner 1 for 16 nodes
		N2 = zeros(1,NODES(sp));
		N3 = zeros(1,NODES(sp));
		N4 = zeros(1,NODES(sp));
		N_local = zeros(1,NODES(sp));
		
		for i=1:NODES(sp)
			[N1(i),~,~] = linearshape(x_corner1(sp,:),LOC(CONNECT{sp}(i),:),le(1,1),le(1,2));
			[N2(i),~,~] = linearshape(x_corner2(sp,:),LOC(CONNECT{sp}(i),:),le(1,1),le(1,2));
			[N3(i),~,~] = linearshape(x_corner3(sp,:),LOC(CONNECT{sp}(i),:),le(1,1),le(1,2));
			[N4(i),~,~] = linearshape(x_corner4(sp,:),LOC(CONNECT{sp}(i),:),le(1,1),le(1,2));
			N_local(i)  = 0.25*(N1(i)+N2(i)+N3(i)+N4(i));
		end
		
		N{sp} = N_local;
		
		% Build matrix of gradient of shape function 
		w1 = [r1_sp(sp,2)-r2_sp(sp,2) r2_sp(sp,1)-r1_sp(sp,1)];
		w2 = [r1_sp(sp,2)+r2_sp(sp,2) -r2_sp(sp,1)-r1_sp(sp,1)];
		
		for i=1:NODES(sp)      
			dN{sp}(1,i)     = 1/A_sp(sp)*((N1(i)-N3(i))*w1(1) + (N2(i)-N4(i))*w2(1));
			dN{sp}(2,i)     = 1/A_sp(sp)*((N1(i)-N3(i))*w1(2) + (N2(i)-N4(i))*w2(2));
		end
	end
	
	for c =1:cellCount
		id_sp = find(spElems==c);
		mspoints{c}=id_sp;
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

%[
%switchable2
function PrintResults_parfor(tiprename,le_base,switcher,TimeStampedName,videofps,tt,ttstart,DispPump,CModel,LOC,le,NN,d_sp,e_sp,v_ssp,spCount,niCount,E_acc,TLD,plotignore,matmodel,lp,layer,CasetoRun,orientationoffset,xdirletter,ydirletter,x_spo, ...
	ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,thetacrackrtl,refinementfactor, frameskip)

	%{
	if switcher==1
		switcher=17;
	elseif switcher==2
		switcher=20;
	elseif switcher==3
		switcher=26;
	elseif switcher==4
		switcher=29;
	elseif switcher==5
		switcher=13;
	elseif switcher==6
		switcher=43;
	end
	%}
	%{
	if switcher==1
		switcher=48;
	elseif switcher==2
		switcher=49;
	elseif switcher==3
		switcher=50;
	elseif switcher==4
		switcher=51;
	end
	%}  
	if CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==61 || CasetoRun==62 || CasetoRun==63
		if switcher==1
			%switcher=52;
			switcher=-99;
		elseif switcher==2
			switcher=53;
		else
			switcher=-99;
		end
	elseif CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==65 || CasetoRun==70
		if switcher==1
			switcher=54; %smax_var (with crack)
		elseif switcher==2
			switcher=55; %smax_var_nc (no crack)
		elseif switcher==3
			switcher=10; %uy
		elseif switcher==4
			switcher=45; %ux
		else
			switcher=-1;
		end
	elseif CasetoRun==73
		if switcher==1
			switcher=56; %crack_dirs
		elseif switcher==2
			switcher=10; %s_max
		elseif switcher==3
			switcher=9; %s_min
		elseif switcher==4
			switcher=-1; %nada
		else
			switcher=-1;
		end
	elseif CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==77
		if switcher==1
			switcher=57; %crack_dirs_nnairn
		elseif switcher==2
			switcher=54; %s_max_var
		elseif switcher==3
			switcher=9; %s_min_without
		elseif switcher==4
			switcher=-1; %nada
		else
			switcher=-1;
		end
	elseif CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85
		if switcher==1
			switcher=55;
		elseif switcher==2
			switcher=61;
		elseif switcher==3
			switcher=60; %crack_dirs_nnairn multi
		elseif switcher==4
			switcher=62; %minimum principal stress with cracks
		elseif switcher>=5 && switcher<=11
			switcher=switcher+10;
		else
			switcher=-1;
		end
	elseif CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==120 || CasetoRun==117
		if switcher==1
			switcher=63; %s_max with traction plots
		elseif switcher==2
			switcher=61;
		elseif switcher==3
			switcher=60; %crack_dirs_nnairn multi
		elseif switcher==4
			switcher=62; %minimum principal stress with cracks
		elseif switcher>=5 && switcher<=11
			switcher=switcher+10;
		else
			switcher=-1;
		end
	elseif CasetoRun==121
		if switcher==1
			switcher=67; %s_max with traction plots
		elseif switcher==2
			switcher=61;
		elseif switcher==3
			switcher=60; %crack_dirs_nnairn multi
		elseif switcher==4
			switcher=62; %minimum principal stress with cracks
		elseif switcher>=5 && switcher<=11
			switcher=switcher+10;
		else
			switcher=-1;
		end
	elseif CasetoRun==123 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==132 || CasetoRun==131 || CasetoRun==130
		if switcher==1
			switcher=68; %s_max with crack paths
		elseif switcher==2
			switcher=70; %s_si_max_K1 with crack paths
		elseif switcher==3
			switcher=71; %s_x with crack paths
		elseif switcher==4
			switcher=-1*61; %crack_dirs_nnairn multi
		elseif switcher==5
			switcher=-1*62; %minimum principal stress with cracks
		elseif switcher>=6 && switcher<=12
			%switcher=switcher+10;
		else
			switcher=-1*66;
			switcher=-1;
		end
	elseif CasetoRun==124
		if switcher==1
			switcher=75; %u_sp_y with crack paths
		elseif switcher==2
			switcher=68; %s_max with crack paths
		elseif switcher==3
			switcher=71; %s_x with crack paths
		elseif switcher==4
			switcher=-1*61; %crack_dirs_nnairn multi
		elseif switcher==5
			switcher=-1*62; %minimum principal stress with cracks
		elseif switcher>=6 && switcher<=12
			%switcher=switcher+10;
		else
			switcher=-1*66;
			switcher=-1;
		end
	elseif CasetoRun==133 || CasetoRun==135 || CasetoRun==134 || CasetoRun==129 || CasetoRun==138
		if switcher==1
			switcher=72; %s_si_max with propdir
		elseif switcher==2
			switcher=73; %s_si_min with propdir
		elseif switcher==3
			switcher=63; %s_x with crack paths with pforce too
		elseif switcher==13
			switcher=-68; %s_max with crack paths
		elseif switcher==4
			switcher=-1*61; %crack_dirs_nnairn multi
		elseif switcher==5
			switcher=-1*62; %minimum principal stress with cracks
		elseif switcher>=6 && switcher<=12
			%switcher=switcher+10;
		else
			switcher=-1*66;
			switcher=-1;
		end
	elseif CasetoRun==184
		if switcher==1
			switcher=78;
		elseif switcher==2
			switcher=61;
		elseif switcher==3
			switcher=76;
		else
			switcher=-1;
		end	
	elseif CasetoRun==191 || CasetoRun==197
		if switcher==1
			switcher=90;
		elseif switcher==2
			switcher=88;
		elseif switcher==3
			switcher=86;
		elseif switcher==4
			switcher=-78;
		elseif switcher==5
			switcher=-85; %stress, fixed scale, easy crop
		else
			switcher=-84;
		end	
	elseif CasetoRun==198 || CasetoRun==196 || CasetoRun==195
		if switcher==1
			switcher=88;
		elseif switcher==2
			switcher=86;
		elseif switcher==3
			switcher=83;
		elseif switcher==4
			switcher=78;
		elseif switcher==5
			switcher=85; %stress, fixed scale, easy crop
		else
			switcher=84;
		end	
	elseif CasetoRun==192
		if switcher==1
			switcher=78;
		elseif switcher==2
			switcher=61;
		elseif switcher==3
			switcher=83;
		elseif switcher==4
			switcher=81;
		elseif switcher==5
			switcher=84;
		else
			switcher=-1;
		end	
	elseif CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==189
		if switcher==1
			switcher=83;
		elseif switcher==2
			switcher=81;
		elseif switcher==3
			switcher=84;
		elseif switcher==4
			switcher=78;
		elseif switcher==5
			switcher=61;
		else
			switcher=-1;
		end	
	elseif CasetoRun==185
		if switcher==1
			switcher=79;
		elseif switcher==2
			switcher=78;
		elseif switcher==3
			switcher=61;
		elseif switcher==4
			switcher=76;
		else
			switcher=-1;
		end
	elseif CasetoRun==210
		if switcher==1
			switcher=102;
		elseif switcher==2
			switcher=95;
			switcher=103;
		elseif switcher==3
			%switcher=93;
			switcher=-92;
			switcher=96;
		else
			switcher=-94;
			switcher=61;
		end
	elseif CasetoRun==226 || CasetoRun==227
		if switcher==1
			switcher=96; %temperature
		elseif switcher==2
			switcher=104; %density
		elseif switcher==3
			switcher=98; %stress in y
		elseif switcher==4
			switcher=97; %stress in x
		else
			switcher=-105; %shrinkage in x
			switcher=106; %shrinkage in y
		end
	elseif CasetoRun==219 || CasetoRun==224 || CasetoRun==223
		if switcher==1
			switcher=102; %tagged
			switcher=95;
		elseif switcher==2
			switcher=103; %density
		elseif switcher==3
			%switcher=93;
			switcher=-92;
			switcher=96; %temperature
		else
			switcher=-94;
			switcher=61; %max principal stress
		end
	elseif CasetoRun==222 || CasetoRun==225
		if switcher==1
			switcher=81;
		elseif switcher==2
			switcher=61;
		elseif switcher==3
			%switcher=93;
			switcher=-92;
		else
			switcher=-94;
		end
	elseif CasetoRun==228
		if switcher==1
			switcher=107; %completeratio
		elseif switcher==2
			switcher=98; %sigma_yy
		elseif switcher==3
			switcher=97; %sigma_xx
		elseif switcher==4
			switcher=99; %sigma_xy
		else
			switcher=61; %sigma_max
		end
	elseif CasetoRun==217
		if switcher==1
			switcher=107; %completeratio
		elseif switcher==2
			switcher=98;
		elseif switcher==3
			switcher=91;
		else
			switcher=92;
		end
	elseif CasetoRun==230
		if switcher==1
			switcher=61; %sigma_max
		elseif switcher==2
			switcher=97; %sigma_xx
		elseif switcher==3
			switcher=98; %sigma_yy
		elseif switcher==4
			switcher=99; %sigma_xy
		else
			switcher=-1;
		end
	elseif CasetoRun==229
		if switcher==1
			switcher=108; %load-disp-time
		elseif switcher==2
			switcher=109; %load-disp-time
		elseif switcher==3
			switcher=-91;
			switcher=98;
		else
			switcher=-92;
		end
	elseif CasetoRun==205 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==214 || CasetoRun==221 || CasetoRun==220 || CasetoRun==207 || CasetoRun==212
		if switcher==1
			switcher=61;
			switcher=107; %completeratio
		elseif switcher==2
			switcher=91;
		elseif switcher==3
			%switcher=93;
			switcher=92;
		else
			switcher=94;
		end
	elseif CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==201
		if switcher==1
			switcher=61;
		elseif switcher==2
			switcher=87;
		elseif switcher==3
			switcher=76;
		else
			switcher=-1;
		end
	elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==178 || CasetoRun==169
		if switcher==1
			switcher=61;
		elseif switcher==2
			switcher=68;
		elseif switcher==3
			switcher=76;
		else
			switcher=-1;
		end
	elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165
		if switcher==1
			switcher=68;
		elseif switcher==2
			switcher=61;
		else
			switcher=-1;
		end
	elseif CasetoRun==139 || CasetoRun==136 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==118 || CasetoRun==173 || CasetoRun==151
		if switcher==1
			switcher=68; %s_si_max with nodal
		elseif switcher==2
			switcher=-73; %s_si_min with propdir
		elseif switcher==3
			switcher=-63; %s_x with crack paths with pforce too
		elseif switcher==13
			switcher=-68; %s_max with crack paths
		elseif switcher==4
			switcher=-1*61; %crack_dirs_nnairn multi
		elseif switcher==5
			switcher=-1*62; %minimum principal stress with cracks
		elseif switcher>=6 && switcher<=12
			%switcher=switcher+10;
		else
			switcher=-1*66;
			switcher=-1;
		end
	elseif CasetoRun==144 || CasetoRun==146
		if switcher==1
			switcher=74; %v_x
		elseif switcher==2
			switcher=68; %s_si_max with nodal
		elseif switcher==3
			switcher=-63; %s_x with crack paths with pforce too
		elseif switcher==13
			switcher=-68; %s_max with crack paths
		elseif switcher==4
			switcher=-1*61; %crack_dirs_nnairn multi
		elseif switcher==5
			switcher=-1*62; %minimum principal stress with cracks
		elseif switcher>=6 && switcher<=12
			%switcher=switcher+10;
		else
			switcher=-1*66;
			switcher=-1;
		end
	elseif CasetoRun==148 || CasetoRun==149 || CasetoRun==147
		if switcher==1
			switcher=61; %s_max_multiline
		elseif switcher==2
			switcher=68; %s_si_max with nodal
		elseif switcher==3
			switcher=-63; %s_x with crack paths with pforce too
		elseif switcher==13
			switcher=-68; %s_max with crack paths
		elseif switcher==4
			switcher=-1*61; %crack_dirs_nnairn multi
		elseif switcher==5
			switcher=-1*62; %minimum principal stress with cracks
		elseif switcher>=6 && switcher<=12
			%switcher=switcher+10;
		else
			switcher=-1*66;
			switcher=-1;
		end
	elseif CasetoRun==194
		if switcher==1
			switcher=61; %s_sp_velocity
		elseif switcher==2
			switcher=78; %s_max_multiline
		elseif switcher==3
			switcher=63; %pforce plot
		elseif switcher==13
			switcher=-68; %s_max with crack paths
		elseif switcher==4
			switcher=-1*61; %crack_dirs_nnairn multi
		elseif switcher==5
			switcher=-1*62; %minimum principal stress with cracks
		elseif switcher>=6 && switcher<=12
			%switcher=switcher+10;
		else
			switcher=-1*66;
			switcher=-1;
		end
	elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
		if switcher==1
			switcher=61; %s_max_multiline
		elseif switcher==2
			switcher=74; %s_sp_velocity
		elseif switcher==3
			switcher=63; %pforce plot
		elseif switcher==13
			switcher=-68; %s_max with crack paths
		elseif switcher==4
			switcher=-1*61; %crack_dirs_nnairn multi
		elseif switcher==5
			switcher=-1*62; %minimum principal stress with cracks
		elseif switcher>=6 && switcher<=12
			%switcher=switcher+10;
		else
			switcher=-1*66;
			switcher=-1;
		end
	else
		if switcher==1
	%switcher=13: constant scaling max epl shear
	%switcher=43: variable scaling max epl shear
	%switcher=41: load-disp
			switcher=43;
		elseif switcher==2
			%switcher=48; %uy
			switcher=41;
		elseif switcher==3
			%switcher=49; %sx or s1
			switcher=13;
		elseif switcher==4
			%switcher=50; %sy or s2
		elseif switcher==5
			%switcher=51; %deformed
		end
	end
	
	disp(['Start Plotting Switcher #' num2str(switcher)]);
	climit=[];
	if switcher==40
		VideoName           = 'e_pl_max';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(CModel) == length('Wood_Schmidt17')
				if CModel == 'Wood_Schmidt17'
					%if exist('climitse')==0
					%    climitse=[];
					%end
					[PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,1,0);
					if length(climit)==0
						climit(1)=min(cutvector(e_pl_sp_max,0,plotignore));
						climit(2)=max(cutvector(e_pl_sp_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(e_pl_sp_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(e_pl_sp_max,0,plotignore)));
					end
				end
			end
			%if exist('climitss')==0
			%    climitss=[];
			%end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(CModel) == length('Wood_Schmidt17')
				if CModel == 'Wood_Schmidt17'
					[PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,1,1);
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%    climitss=[];
			%end
		end
		close(writerObj);
	elseif switcher==52
		VideoName           = 'e_pl_shear_ovl';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(CModel) == length('Wood_Schmidt17')
				if CModel == 'Wood_Schmidt17'
					%if exist('climitse')==0
					%    climitse=[];
					%end
					[PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit_ovl(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,0,plotignore);
					if length(climit)==0
						climit(1)=min(cutvector(e_pl_sp_shear,0,plotignore));
						climit(2)=max(cutvector(e_pl_sp_shear,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(e_pl_sp_shear,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(e_pl_sp_shear,0,plotignore)));
					end
				end
			end
			%if exist('climitss')==0
			%    climitss=[];
			%end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(CModel) == length('Wood_Schmidt17')
				if CModel == 'Wood_Schmidt17'
					[PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit_ovl(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,1,plotignore);
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					eval(['cd ' TimeStampedName]);
					eval(['cd ' VideoName]);
					eval(['export_fig ' 'tt=' num2str(i) 'd=' num2str(DispPump) '.png' ' -transparent']);
					cd ..
					cd ..
					export_fig  -transparent
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%    climitss=[];
			%end
		end
		close(writerObj);

	elseif switcher==0 % here here
		if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==17
			VideoName           = 's2perlayer';
			mkdir([TimeStampedName '\\' VideoName]);
			writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
			writerObj.FrameRate = videofps;    % number of frame per second
			open(writerObj);

			for i=ttstart:tt
				load([TimeStampedName '\\' num2str(i) '.mat']);
				if i==ttstart
					x_sp_1=x_sp;
				end
				for j=1:size(layer,1)
					y_layer(i,j)=x_sp_1(layer(1,j),2);
					s_summed(i,j)=0;
					for k=1:size(layer,2)
						s_summed(i,j)=s_summed(i,j)+s_sp(layer(j,k),2);
					end
				end
			end
			s_min=min([0 min(min(s_summed))]);
			s_max=max([0 max(max(s_summed))]);
			for i=ttstart:tt
				load([TimeStampedName '\\' num2str(i) '.mat']);
				PlotImage=figure;
				set(PlotImage,'visible','off');
				plot(s_summed(i,:),y_layer(i,:));
				hold on
				plot(s_min,y_layer(i,1));
				plot(s_max,y_layer(i,1));
				xlabel('s2 (MPa)');
				ylabel('Particle Position (mm)');
				title('Summed layer Y-stress');
				saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
				%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
				frame=getframe(PlotImage);
				writeVideo(writerObj,frame);
				hold off
				close(PlotImage);
			end
			close(writerObj);
		elseif CasetoRun==4
		elseif CasetoRun==5 || CasetoRun==6
		elseif CasetoRun==7
			VideoName           = 's2perlayer';
			mkdir([TimeStampedName '\\' VideoName]);
			writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
			writerObj.FrameRate = videofps;    % number of frame per second
			open(writerObj);

			for i=ttstart:tt
				load([TimeStampedName '\\' num2str(i) '.mat']);
				if i==ttstart
					x_sp_1=x_sp;
				end
				for j=1:size(layer,1)
					y_layer(i,j)=x_sp_1(layer(1,j),2);
					s_summed(i,j)=0;
					for k=1:size(layer,2)
						s_summed(i,j)=s_summed(i,j)+s_sp(layer(j,k),2);
					end
				end
			end
			s_min=min([0 min(min(s_summed))]);
			s_max=max([0 max(max(s_summed))]);
			for i=ttstart:tt
				load([TimeStampedName '\\' num2str(i) '.mat']);
				PlotImage=figure;
				set(PlotImage,'visible','off');
				plot(s_summed(i,:),y_layer(i,:));
				hold on
				plot(s_min,y_layer(i,1));
				plot(s_max,y_layer(i,1));
				xlabel('s2 (MPa)');
				ylabel('Particle Position (mm)');
				title('Summed layer Y-stress');
				%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
				saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
				frame=getframe(PlotImage);
				writeVideo(writerObj,frame);
				hold off
				close(PlotImage);
			end
			close(writerObj);
		elseif CasetoRun==8 || CasetoRun==9
		elseif CasetoRun==10
			VideoName           = 's2perlayer';
			mkdir([TimeStampedName '\\' VideoName]);
			writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
			writerObj.FrameRate = videofps;    % number of frame per second
			open(writerObj);

			for i=ttstart:tt
				load([TimeStampedName '\\' num2str(i) '.mat']);
				if i==ttstart
					x_sp_1=x_sp;
				end
				for j=1:size(layer,1)
					y_layer(i,j)=x_sp_1(layer(1,j),2);
					s_summed(i,j)=0;
					for k=1:size(layer,2)
						s_summed(i,j)=s_summed(i,j)+s_sp(layer(j,k),2);
					end
				end
			end
			s_min=min([0 min(min(s_summed))]);
			s_max=max([0 max(max(s_summed))]);
			for i=ttstart:tt
				load([TimeStampedName '\\' num2str(i) '.mat']);
				PlotImage=figure;
				set(PlotImage,'visible','off');
				plot(s_summed(i,:),y_layer(i,:));
				hold on
				plot(s_min,y_layer(i,1));
				plot(s_max,y_layer(i,1));
				xlabel('s2 (MPa)');
				ylabel('Particle Position (mm)');
				title('Summed layer Y-stress');
				%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
				saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
				frame=getframe(PlotImage);
				writeVideo(writerObj,frame);
				hold off
				close(PlotImage);
			end
			close(writerObj);
		elseif CasetoRun==11
		elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		end

   elseif switcher==35
		VideoName           = 'deformed';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					%if exist('climitse')==0
					%    climitse=[];
					%end
					PlotImage=Plot_Current(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp);
					%climitserec=[climitserec;climitse];
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%    climitss=[];
			%end
		end
		close(writerObj);
		
   elseif switcher==56
		VideoName           = 'crackdir';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					%if exist('climitse')==0
					%    climitse=[];
					%end
					PlotImage=Plot_CrackDir(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack);
					%climitserec=[climitserec;climitse];
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%    climitss=[];
			%end
		end
		close(writerObj);
	elseif switcher==57
		VideoName           = 'crackdirnairn';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					%if exist('climitse')==0
					%    climitse=[];
					%end
					PlotImage=Plot_CrackDirNairn(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack,x_crackcenter,x_cracktop,x_crackbot);
					%climitserec=[climitserec;climitse];
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%    climitss=[];
			%end
		end
		close(writerObj);

	elseif switcher==59
		VideoName           = 'crackdirnairn_multi';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					%if exist('climitse')==0
					%    climitse=[];
					%end
					PlotImage=Plot_CrackDirNairn_multi(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack,x_crackcenter,x_cracktop,x_crackbot);
					%climitserec=[climitserec;climitse];
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%    climitss=[];
			%end
		end
		close(writerObj);
	elseif switcher==60
		VideoName           = 'crackdirnairn_multilines';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			%}
			%switchable1
			%[
			%switchable1
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' int2txt(tt) '' '-' 'x_sp' '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' int2txt(tt) '' '-' 'F_sp' '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' int2txt(tt) '' '-' 'thetacrack' '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' int2txt(tt) '' '-' 'x_crackcenter' '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' int2txt(tt) '' '-' 'x_cracktop' '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' int2txt(tt) '' '-' 'x_crackbot' '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' int2txt(tt) '' '-' 'DispPump' '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' int2txt(tt) '' '-' 't_time' '.txt']);
			%]
			%switchable1
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					%if exist('climitse')==0
					%	climitse=[];
					%end
					PlotImage=Plot_CrackDirNairn_multilines(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack,x_crackcenter,x_cracktop,x_crackbot,CasetoRun);
					%climitserec=[climitserec;climitse];
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%	climitss=[];
			%end
		end
		close(writerObj);
	elseif switcher==36
		VideoName           = 'e_pl_min';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if exist('climit')==0
						climit=[];
					end
					[PlotImage,DUMMY,e_pl_sp_min,~]=Plot_Final2_principalclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,2,0);
					if length(climit)==0
						climit(1)=min(cutvector(e_pl_sp_min,0,plotignore));
						climit(2)=max(cutvector(e_pl_sp_min,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(e_pl_sp_min,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(e_pl_sp_min,0,plotignore)));
					end
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(CModel) == length('Wood_Schmidt17')
				if CModel == 'Wood_Schmidt17'
					%climitserec=[climitserec;climitse];
					[PlotImage,DUMMY,e_pl_sp_min,~]=Plot_Final2_principalclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,2,1);
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%	climitss=[];
			%end
		end
		close(writerObj);
	
	elseif switcher==37
		VideoName           = 'e_el_min';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if exist('climit')==0
						climit=[];
					end
					e_el_sp=e_t_global_big(:,[1 2 4])-e_pl_sp;
					[PlotImage,DUMMY,e_pl_sp_min,~]=Plot_Final2_principalclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_el_sp,climit,2,0);
					if length(climit)==0
						climit(1)=min(cutvector(e_pl_sp_min,0,plotignore));
						climit(2)=max(cutvector(e_pl_sp_min,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(e_pl_sp_min,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(e_pl_sp_min,0,plotignore)));
					end
					%climitserec=[climitserec;climitse];
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					e_el_sp=e_t_global_big(:,[1 2 4])-e_pl_sp;
					[PlotImage,DUMMY,e_pl_sp_min,~]=Plot_Final2_principalclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_el_sp,climit,2,1);
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%	climitss=[];
			%end
		end
		close(writerObj);
	elseif switcher==38
		VideoName           = 'e_el_max';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if exist('climit')==0
						climit=[];
					end
					e_el_sp=e_t_global_big(:,[1 2 4])-e_pl_sp;
					[PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_el_sp,climit,1,0);
					if length(climit)==0
						climit(1)=min(cutvector(e_pl_sp_max,0,plotignore));
						climit(2)=max(cutvector(e_pl_sp_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(e_pl_sp_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(e_pl_sp_max,0,plotignore)));
					end
					%climitserec=[climitserec;climitse];
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					e_el_sp=e_t_global_big(:,[1 2 4])-e_pl_sp;
					[PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_el_sp,climit,1,1);
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%	climitss=[];
			%end
		end
		close(writerObj);
	
	elseif switcher==13
		VideoName           = 'e_pl_shear';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if exist('climit')==0
						climit=[];
					end
					[PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,0);
					if length(climit)==0
						climit(1)=min(cutvector(e_pl_sp_shear,0,plotignore));
						climit(2)=max(cutvector(e_pl_sp_shear,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(e_pl_sp_shear,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(e_pl_sp_shear,0,plotignore)));
					end
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,1);
					%climitserec=[climitserec;climitse];
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%	climitss=[];
			%end
		end
		close(writerObj);
	
	elseif switcher==53
		VideoName           = 'e_pl_shear_report';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		if CasetoRun==61 || CasetoRun==62 || CasetoRun==63
			tt=min([tt 120]);
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if exist('climit')==0
						climit=[];
					end
					[PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit_report(matmodel,CasetoRun,t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,0);
					if length(climit)==0
						climit(1)=min(cutvector(e_pl_sp_shear,0,plotignore));
						climit(2)=max(cutvector(e_pl_sp_shear,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(e_pl_sp_shear,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(e_pl_sp_shear,0,plotignore)));
					end
				end
			end
		end
		if CasetoRun==61 || CasetoRun==62 || CasetoRun==63
			climit(1)=0;
			climit(2)=0.18;
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit_report(matmodel,CasetoRun,t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,1);
					%climitserec=[climitserec;climitse];
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%	climitss=[];
			%end
		end
		close(writerObj);
	
	elseif switcher==43
		VideoName           = 'e_pl_shear2';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if exist('climit')==0
						climit=[];
					end
					%[PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,0);
					[PlotImage,DUMMY,DUMMY,e_pl_sp_shear]=Plot_Final2_principalclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,3,1);
					%climitserec=[climitserec;climitse];
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
					if length(climit)==0
						climit(1)=min(cutvector(e_pl_sp_shear,0,plotignore));
						climit(2)=max(cutvector(e_pl_sp_shear,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(e_pl_sp_shear,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(e_pl_sp_shear,0,plotignore)));
					end
				end
			end
		end
		close(writerObj);
	
	elseif switcher==54
		VideoName           = 's_max_var';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions_crack(x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_max,0,plotignore));
						climit(2)=max(cutvector(s_sp_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
					end
				%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	
	elseif switcher==58
		VideoName           = 's_max_multi';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions_crackmulti(x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_max,0,plotignore));
						climit(2)=max(cutvector(s_sp_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
					end
				%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
				%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	
	elseif switcher==61
		VideoName           = 's_max_multiline';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions_crackmultiline(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun,refinementfactor);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_max,0,plotignore));
						climit(2)=max(cutvector(s_sp_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
					end
				%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==103
		VideoName           = 'time_FDS';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			%TDL just tag check
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			time_FDS=loadmatrixlong([TimeStampedName '-Slave-' 'time_FDS' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Final2_singlevalue(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,time_FDS,climit,lp,plotignore,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(cutvector(s_sp_min,0,plotignore));
					%	climit(2)=max(cutvector(s_sp_min,0,plotignore));
					%else
					%	climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
					%	climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
					%end
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	elseif switcher==102
		VideoName           = 'tagged';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			%TDL just tag check
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			surroundtag_sp=loadmatrixlong([TimeStampedName '-Slave-' 'surroundtag_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Final2_singlevalue(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,surroundtag_sp,climit,lp,plotignore,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(cutvector(s_sp_min,0,plotignore));
					%	climit(2)=max(cutvector(s_sp_min,0,plotignore));
					%else
					%	climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
					%	climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
					%end
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	elseif switcher==106
		VideoName           = 'shrinkage_y';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			shrinkage_global_sp_vectorized=loadmatrixfloat([TimeStampedName '-Slave-' 'shrinkage_global_sp_vectorized' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Final2_singlevalue(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,shrinkage_global_sp_vectorized(:,2),climit,lp,plotignore,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(cutvector(s_sp_min,0,plotignore));
					%	climit(2)=max(cutvector(s_sp_min,0,plotignore));
					%else
					%	climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
					%	climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
					%end
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	elseif switcher==105
		VideoName           = 'shrinkage_x';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			shrinkage_global_sp_vectorized=loadmatrixfloat([TimeStampedName '-Slave-' 'shrinkage_global_sp_vectorized' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Final2_singlevalue(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,shrinkage_global_sp_vectorized(:,1),climit,lp,plotignore,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(cutvector(s_sp_min,0,plotignore));
					%	climit(2)=max(cutvector(s_sp_min,0,plotignore));
					%else
					%	climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
					%	climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
					%end
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	elseif switcher==104
		VideoName           = 'density';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			density_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'density_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Final2_singlevalue(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,density_sp,climit,lp,plotignore,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(cutvector(s_sp_min,0,plotignore));
					%	climit(2)=max(cutvector(s_sp_min,0,plotignore));
					%else
					%	climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
					%	climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
					%end
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	elseif switcher==96
		VideoName           = 'temperature';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			temp_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'temp_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Final2_singlevalue(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,temp_sp,climit,lp,plotignore,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(cutvector(s_sp_min,0,plotignore));
					%	climit(2)=max(cutvector(s_sp_min,0,plotignore));
					%else
					%	climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
					%	climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
					%end
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	elseif switcher==97
		VideoName           = 'sigma_xx';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			plotvector=s_sp(:,1);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Final2_singlevalue(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,plotvector,climit,lp,plotignore,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(cutvector(plotvector,0,plotignore));
					%	climit(2)=max(cutvector(plotvector,0,plotignore));
					%else
					%	climit(1)=min(climit(1),min(cutvector(plotvector,0,plotignore)));
					%	climit(2)=max(climit(2),max(cutvector(plotvector,0,plotignore)));
					%end
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
		
	elseif switcher==108 || switcher==109
		VideoName           = ['load-disp-loadcontrol' num2str(switcher-107)];
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		%{
		for i=1:9999
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_crack_bridge_base_absdeltax=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_base_absdeltax' '-' int2txt(i) '.txt']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if length(climit)==0
						climit(1)=min(min(x_crack_bridge_base_absdeltax));
						climit(2)=max(max(x_crack_bridge_base_absdeltax));
					else
						climit(1)=min(climit(1),min(min(x_crack_bridge_base_absdeltax)));
						climit(2)=max(climit(2),max(max(x_crack_bridge_base_absdeltax)));
					end
				end
			end
		end
		%}
		dispmin=inf
		dispmax=-inf
		loadmin=inf
		loadmax=-inf
		timemax=-inf
		t0=loadsinglefloat([TimeStampedName '-Master-' 't0' '.txt']);
		timemin=t0
		for i=1:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			end
			disp(['loading ' num2str(i) '/' num2str(tt)]);
			F_loadcontrolled=loadmatrixfloat([TimeStampedName '-Slave-' 'F_loadcontrolled' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			TLD(i,1)=t_time;
			TLD(i,2)=F_loadcontrolled;
			TLD(i,3)=DispPump;
			if t_time>t0+0.5
				dispmin=min(dispmin,DispPump);
				dispmax=max(dispmax,DispPump);
				loadmin=min(loadmin,F_loadcontrolled);
				loadmax=max(loadmax,F_loadcontrolled);
				timemax=max(timemax,t_time);
			end
			%]
			%switchable1			
			
		end
		
		%start of grabbing times crossing middle line
		%loadavg=(loadmin+loadmax)/2
		%dispavg=(dispmin+dispmax)/2
		
		%t_disp_0=[];
		%t_load_0=[];
		%dispbefore=0;
		%loadbefore=0;
		%for i=1:9999
			%tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			%if i>tt
				%break;
			%end
			%F_loadcontrolled=loadmatrixfloat([TimeStampedName '-Slave-' 'F_loadcontrolled' '-' int2txt(i) '.txt']);
			%DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			%t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			%dispnow=TLD(i,3);
			%loadnow=TLD(i,2);
			%tnow=TLD(i,1);
			%if t_time>0.25+t0
				%if (loadnow-loadavg)*(loadbefore-loadavg)<=0 && abs(loadbefore-loadavg)>0
					%t_load_0(end+1)=(tbefore*loadnow-tnow*loadbefore)/(loadnow-loadbefore);
				%end
				%if (dispnow-dispavg)*(dispbefore-dispavg)<=0 && abs(dispbefore-dispavg)>0
					%t_disp_0(end+1)=(tbefore*dispnow-tnow*dispbefore)/(dispnow-dispbefore);
				%end
			%end
			%dispbefore=dispnow;
			%loadbefore=loadnow;
			%tbefore=tnow;
		%end
		%end of grabbing times crossing middle line
		
		
		
		%start of grabbing times at peak
		t_disp_0=[];
		t_load_0=[];
		for i=2:9999
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt-1
				break;
			end
			%dispnow=TLD(i,3);
			%loadnow=TLD(i,2);
			%tnow=TLD(i,1);
			if t_time>0.25+t0
				x1=TLD(i-1,1);
				x2=TLD(i,1);
				x3=TLD(i+1,1);
				
				y1=TLD(i-1,2);
				y2=TLD(i,2);
				y3=TLD(i+1,2);
				
				disp(['calculating ' num2str(i) '/' num2str(tt)]);
				
				if (y2>=y1 && y2>y3) || (y2<=y1 && y2<y3)
					x_p=1/2*(x1^2*(y2-y3)+x2^2*(y3-y1)+x3^2*(y1-y2))/(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)); %(x at peak, and by x i.e. time)
					%derivation: /d/Users/Tito/Documents/Combined_2020-11-26/docs/quadraticpeak.tex 
					t_load_0(end+1)=x_p;
				end
				
				
				y1=TLD(i-1,3);
				y2=TLD(i,3);
				y3=TLD(i+1,3);
				if (y2>=y1 && y2>y3) || (y2<=y1 && y2<y3)
					x_p=1/2*(x1^2*(y2-y3)+x2^2*(y3-y1)+x3^2*(y1-y2))/(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)); %(x at peak, and by x i.e. time)
					t_disp_0(end+1)=x_p;
				end
			end
		end
		%end of grabbing times at peak
		
		
		n_0=min(length(t_disp_0),length(t_load_0));
		delta_t_0_avg=0
		delta_t_0=zeros(1,n_0);
		t_0_avg=zeros(1,n_0);
		for i_0=1:n_0
			delta_t_0(i_0)=t_disp_0(i_0)-t_load_0(i_0);
			t_0_avg(i_0)=(t_disp_0(i_0)+t_load_0(i_0))/2;
			delta_t_0_avg=delta_t_0_avg+delta_t_0(i_0);
		end
		delta_t_0_avg=delta_t_0_avg/n_0;
		delta_t_0_avg
		disp('delta_t_0=')
		disp(vpa(delta_t_0'))
		disp('t_0_avg=')
		disp(vpa(t_0_avg'))
		save('delta_t_0.mat','-v7.3','delta_t_0');
		PlotImage=figure;
		set(PlotImage,'visible','off');
		xlabel('Time (s)');
		yyaxis left;
		PlotImage=plot(TLD(:,1),TLD(:,2),'DisplayName','Load (N)');
		ylabel('Load (N)')
		if switcher==109
			axis([timemin,timemax,loadmin,loadmax]);
		end
		yyaxis right;
		PlotImage=plot(TLD(:,1),TLD(:,3),'DisplayName','Disp (mm)');
		ylabel('Disp (mm)');
		if switcher==109
			axis([timemin,timemax,dispmin,dispmax]);
		end
		saveas(PlotImage,[TimeStampedName '\\' VideoName '\\LDCurve.png']);
		close(gcf);
	elseif switcher==107
		VideoName           = 'coloredcrack';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			x_crack_bridge_completeratio=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_completeratio' '-' int2txt(i) '.txt']);
			climit=zeros(1,2);
			%climit(1)=min(min(x_crack_bridge_completeratio));
			%climit(2)=max(max(x_crack_bridge_completeratio));
			climit(1)=0;
			climit(2)=1;
			plotvector=s_sp(:,2);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_ColoredCrack(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,x_crack_bridge_completeratio,climit,lp,plotignore,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(cutvector(plotvector,0,plotignore));
					%	climit(2)=max(cutvector(plotvector,0,plotignore));
					%else
					%	climit(1)=min(climit(1),min(cutvector(plotvector,0,plotignore)));
					%	climit(2)=max(climit(2),max(cutvector(plotvector,0,plotignore)));
					%end
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	elseif switcher==98
		VideoName           = 'sigma_yy';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			plotvector=s_sp(:,2);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Final2_singlevalue(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,plotvector,climit,lp,plotignore,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(cutvector(plotvector,0,plotignore));
					%	climit(2)=max(cutvector(plotvector,0,plotignore));
					%else
					%	climit(1)=min(climit(1),min(cutvector(plotvector,0,plotignore)));
					%	climit(2)=max(climit(2),max(cutvector(plotvector,0,plotignore)));
					%end
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	elseif switcher==99
		VideoName           = 'sigma_xy';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			plotvector=s_sp(:,3);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Final2_singlevalue(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,plotvector,climit,lp,plotignore,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(cutvector(plotvector,0,plotignore));
					%	climit(2)=max(cutvector(plotvector,0,plotignore));
					%else
					%	climit(1)=min(climit(1),min(cutvector(plotvector,0,plotignore)));
					%	climit(2)=max(climit(2),max(cutvector(plotvector,0,plotignore)));
					%end
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	elseif switcher==100 || switcher==101
		idim=switcher-99;
		idimcomplement=mod(idim,2)+1;
		VideoName           = ['u_si_' num2str(idim)];
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			u_si_comb=loadmatrixfloat([TimeStampedName '-Slave-' 'u_si_comb' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			plotvector=u_si_comb(:,idim);
			plotvector_complement=u_si_comb(:,idimcomplement); %for calculating plotignore
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					%this is for particles by default, now we want this to be a nodal plot instead. hacks to do:
						%swap x_sp with LOC
						%swap plotvector to nodal values
						%revise plotignore to discount those with zero values (both x and y directions need to be zero for full discount)
					plotignore=zeros(1,niCount);
					for io=1:niCount
					if plotvector(io)==0 && plotvector_complement(io)==0
						plotignore(io)=1;
					end
					end
					[PlotImage]=Plot_Final2_singlevalue(NN,le_base,LOC,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,plotvector,climit,lp,plotignore,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(cutvector(plotvector,0,plotignore));
					%	climit(2)=max(cutvector(plotvector,0,plotignore));
					%else
					%	climit(1)=min(climit(1),min(cutvector(plotvector,0,plotignore)));
					%	climit(2)=max(climit(2),max(cutvector(plotvector,0,plotignore)));
					%end
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	elseif switcher==95
		VideoName           = 'epsilonshrink_matrix';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			shrinkage_global_sp_vectorized=loadmatrixfloat([TimeStampedName '-Slave-' 'shrinkage_global_sp_vectorized' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,s_sp_min]=Plot_Final2_principalclimit_directions_crackmultiline(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,shrinkage_global_sp_vectorized,climit,2,lp,plotignore,1,CasetoRun,refinementfactor);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_min,0,plotignore));
						climit(2)=max(cutvector(s_sp_min,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
					end
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==91
		VideoName           = 'e_t_schmidt_multiline';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			e_t_schmidtglobalmatrixsimple=loadmatrixfloat([TimeStampedName '-Slave-' 'e_t_schmidtglobalmatrixsimple' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,e_t_schmidtglobalmatrixsimple_max,~]=Plot_Final2_principalclimit_directions_crackmultiline(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_t_schmidtglobalmatrixsimple,climit,1,lp,plotignore,1,CasetoRun,refinementfactor);
					if length(climit)==0
						climit(1)=min(cutvector(e_t_schmidtglobalmatrixsimple_max,0,plotignore));
						climit(2)=max(cutvector(e_t_schmidtglobalmatrixsimple_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(e_t_schmidtglobalmatrixsimple_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(e_t_schmidtglobalmatrixsimple_max,0,plotignore)));
					end
				%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,e_t_schmidtglobalmatrixsimple_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_t_schmidtglobalmatrixsimple,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==92
		VideoName           = 'e_shrink_schmidt_multiline';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			epsilonshrink_sp_vectorized=loadmatrixfloat([TimeStampedName '-Slave-' 'epsilonshrink_sp_vectorized' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,epsilonshrink_sp_vectorized_max,~]=Plot_Final2_principalclimit_directions_crackmultiline(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,epsilonshrink_sp_vectorized,climit,2,lp,plotignore,1,CasetoRun,refinementfactor);
					if length(climit)==0
						climit(1)=min(cutvector(epsilonshrink_sp_vectorized_max,0,plotignore));
						climit(2)=max(cutvector(epsilonshrink_sp_vectorized_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(epsilonshrink_sp_vectorized_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(epsilonshrink_sp_vectorized_max,0,plotignore)));
					end
				%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,epsilonshrink_sp_vectorized_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,epsilonshrink_sp_vectorized,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==93
		VideoName           = 'e_shrinkdot_schmidt_multiline';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			epsilonshrinkdot_sp_vectorized=loadmatrixfloat([TimeStampedName '-Slave-' 'epsilonshrinkdot_sp_vectorized' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,epsilonshrinkdot_sp_vectorized_max,~]=Plot_Final2_principalclimit_directions_crackmultiline(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,epsilonshrinkdot_sp_vectorized,climit,2,lp,plotignore,1,CasetoRun,refinementfactor);
					if length(climit)==0
						climit(1)=min(cutvector(epsilonshrinkdot_sp_vectorized_max,0,plotignore));
						climit(2)=max(cutvector(epsilonshrinkdot_sp_vectorized_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(epsilonshrinkdot_sp_vectorized_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(epsilonshrinkdot_sp_vectorized_max,0,plotignore)));
					end
				%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,epsilonshrinkdot_sp_vectorized_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,epsilonshrinkdot_sp_vectorized,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==94
		VideoName           = 'e_t_schmidtswellsonly';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			e_t_schmidtswellsonly=loadmatrixfloat([TimeStampedName '-Slave-' 'e_t_schmidtswellsonly' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,e_t_schmidtswellsonly_max,~]=Plot_Final2_principalclimit_directions_crackmultiline(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_t_schmidtswellsonly,climit,2,lp,plotignore,1,CasetoRun,refinementfactor);
					if length(climit)==0
						climit(1)=min(cutvector(e_t_schmidtswellsonly_max,0,plotignore));
						climit(2)=max(cutvector(e_t_schmidtswellsonly_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(e_t_schmidtswellsonly_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(e_t_schmidtswellsonly_max,0,plotignore)));
					end
				%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,e_t_schmidtswellsonly_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_t_schmidtswellsonly,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==87
		VideoName           = 'e_pl_max_multiline';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			%s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			e_pl_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'e_pl_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit_directions_crackmultiline(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,1,lp,plotignore,1,CasetoRun,refinementfactor);
					if length(climit)==0
						climit(1)=min(cutvector(e_pl_sp_max,0,plotignore));
						climit(2)=max(cutvector(e_pl_sp_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(e_pl_sp_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(e_pl_sp_max,0,plotignore)));
					end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);


	elseif switcher==86
		VideoName           = 's_max_multiline_2';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		%{
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,0,CasetoRun);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_max,0,plotignore));
						climit(2)=max(cutvector(s_sp_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
					end
				end
			end
		end
		%}
		if CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==187
			climit(1)=-15;
			climit(2)=25;
		elseif CasetoRun==192
			climit(1)=-15;
			climit(2)=25;
		else
			climit(1)=-1;
			climit(2)=1;
		end
		for i=ttstart:9999
		
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions_crackmultiline_small(le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun,refinementfactor);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);


	elseif switcher==78
		VideoName           = 'cohesive';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		%{
		for i=ttstart:9999
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_crack_abs_force=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_absforce' '-' int2txt(i) '.txt']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if length(climit)==0
						climit(1)=min(min(x_crack_abs_force));
						climit(2)=max(max(x_crack_abs_force));
					else
						climit(1)=min(climit(1),min(min(x_crack_abs_force)));
						climit(2)=max(climit(2),max(max(x_crack_abs_force)));
					end
				end
			end
		end
		%}
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			
			
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			x_crack_abs_force=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_absforce' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Cohesive(le_base,x_crack_abs_force,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun,refinementfactor);
					if length(climit)==0
						climit(1)=min(min(x_crack_abs_force));
						climit(2)=max(max(x_crack_abs_force));
					else
						climit(1)=min(climit(1),min(min(x_crack_abs_force)));
						climit(2)=max(climit(2),max(max(x_crack_abs_force)));
					end

					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	
	elseif switcher==85
		VideoName           = 'sequence';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		%{
		for i=ttstart:9999
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_crack_abs_force=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_absforce' '-' int2txt(i) '.txt']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if length(climit)==0
						climit(1)=min(min(x_crack_abs_force));
						climit(2)=max(max(x_crack_abs_force));
					else
						climit(1)=min(climit(1),min(min(x_crack_abs_force)));
						climit(2)=max(climit(2),max(max(x_crack_abs_force)));
					end
				end
			end
		end
		%}
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			%elseif mod(i-1,frameskip+1)>0
			%	continue;
			end
			x_crack_sequence_tipreg=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_sequence_tipreg' '-' int2txt(i) '.txt']);
			x_crack_sequence_merge=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_sequence_merge' '-' int2txt(i) '.txt']);
			if sum(sum(x_crack_sequence_tipreg))+sum(sum(x_crack_sequence_merge))>0
			else
				continue;
			end
			
			
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			
			
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			x_crack_abs_force=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_absforce' '-' int2txt(i) '.txt']);
			x_crack_nparticles=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_nparticles' '-' int2txt(i) '.txt']);
			
			%]
			%switchable1			
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Sequence(x_crack_sequence_merge,x_crack_sequence_tipreg,x_crack_nparticles,le_base,x_crack_abs_force,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun,refinementfactor);
					if length(climit)==0
						climit(1)=min(min(x_crack_abs_force));
						climit(2)=max(max(x_crack_abs_force));
					else
						climit(1)=min(climit(1),min(min(x_crack_abs_force)));
						climit(2)=max(climit(2),max(max(x_crack_abs_force)));
					end

					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	
	elseif switcher==89
		VideoName           = 'crackforce_plot';
		mkdir([TimeStampedName '\\' VideoName]);
		PlotImage=figure;
		
		%{
		for i=ttstart:9999
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
		end
		%}
		icounter=0;
		plotcounter=0;
		climit=[inf -inf];
		propagplot.map=parula(256);
		propagplot.relativescale=zeros(1,1);
		propagplot.index=zeros(1,1);
		propagplot.rgb=zeros(1,3);
		propagplot.timestep=zeros(1,1);
		propagplot.tipnum=zeros(1,1);
		for i=ttstart+1:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			%elseif mod(i-1,frameskip+1)>0
			%	continue;
			end
			x_crack_acctipcrackratio=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_acctipcrackratio' '-' int2txt(i) '.txt']);
			x_crack_sequence_tipreg=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_sequence_tipreg' '-' int2txt(i) '.txt']);
			x_crack_sequence_merge=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_sequence_merge' '-' int2txt(i) '.txt']);
			x_crack_terminatedprop=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_terminatedprop' '-' int2txt(i-1) '.txt']);
			
			if sum(sum(x_crack_sequence_tipreg))+sum(sum(x_crack_sequence_merge))>0
			else
				continue;
			end
			icounter=icounter+1;
			
			x_crack_npaths=loadsinglelong([TimeStampedName '-Slave-' 'x_crack_npaths' '.txt']);
			
			acctipratio.data=x_crack_acctipcrackratio;
			[acctipratio.rankmat acctipratio.rankindex]=rank2d(x_crack_acctipcrackratio(1:x_crack_npaths,:),x_crack_terminatedprop);
			acctipratio.maxtip=zeros(1,1);
			acctipratio.maxpath=zeros(1,1);
			acctipratio.maxtipnum=zeros(1,1);
			acctipratio.maxpath=acctipratio.rankindex(1,1);
			acctipratio.maxtip=acctipratio.rankindex(1,2);
			acctipratio.relratio=acctipratio.data/acctipratio.data(acctipratio.rankindex(1,1),acctipratio.rankindex(1,2));
			acctipratio.maxtipnum=2*(acctipratio.maxpath-1)+acctipratio.maxtip;
			%timestep   tip with/ max. force	tip #1 relative crack force	tip #2 relative crack force	tip #3 relative crack force
			acctipdump(icounter,1)=i-1;
			acctipdump(icounter,2)=tiprename(acctipratio.maxtipnum);
			acctipdump(icounter,3)=acctipratio.data(3,2);
			acctipdump(icounter,4)=acctipratio.data(2,1);
			acctipdump(icounter,5)=acctipratio.data(2,2);
			for icrackpath=1:x_crack_npaths
				for itip=1:2
					if acctipratio.data(icrackpath,itip)>1
						climit(1)=min(climit(1),acctipratio.data(icrackpath,itip));
						climit(2)=max(climit(2),acctipratio.data(icrackpath,itip));
					end
				end
			end
			%]
			%switchable1			
		end
		save('aa_acctipdump.mat','acctipdump');
		if climit(1)==climit(2)
			climit(1)=climit(1)-1e-9;
			climit(2)=climit(2)+1e-9;
		end
		for i=ttstart+1:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			%elseif mod(i-1,frameskip+1)>0
			%	continue;
			end
			x_crack_acctipcrackratio=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_acctipcrackratio' '-' int2txt(i) '.txt']);
			x_crack_sequence_tipreg=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_sequence_tipreg' '-' int2txt(i) '.txt']);
			x_crack_sequence_merge=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_sequence_merge' '-' int2txt(i) '.txt']);
			x_crack_terminatedprop=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_terminatedprop' '-' int2txt(i-1) '.txt']);
			
			if sum(sum(x_crack_sequence_tipreg))+sum(sum(x_crack_sequence_merge))>0
			else
				continue;
			end
			icounter=icounter+1;
			
			x_crack_npaths=loadsinglelong([TimeStampedName '-Slave-' 'x_crack_npaths' '.txt']);
			acctipratio.data=x_crack_acctipcrackratio;
			[acctipratio.rankmat acctipratio.rankindex]=rank2d(x_crack_acctipcrackratio(1:x_crack_npaths,:),x_crack_terminatedprop);
			acctipratio.maxtip=zeros(1,1);
			acctipratio.maxpath=zeros(1,1);
			acctipratio.maxtipnum=zeros(1,1);
			acctipratio.maxpath=acctipratio.rankindex(1,1);
			acctipratio.maxtip=acctipratio.rankindex(1,2);
			acctipratio.relratio=acctipratio.data/acctipratio.data(acctipratio.rankindex(1,1),acctipratio.rankindex(1,2));
			acctipratio.maxtipnum=2*(acctipratio.maxpath-1)+acctipratio.maxtip;
			%timestep   tip with/ max. force	tip #1 relative crack force	tip #2 relative crack force	tip #3 relative crack force
			for icrackpath=1:x_crack_npaths
				for itip=1:2
					if acctipratio.data(icrackpath,itip)>1
						plotcounter=plotcounter+1;
						propagplot.relativescale=(acctipratio.data(icrackpath,itip)-climit(1))/(climit(2)-climit(1));
						propagplot.index=round(propagplot.relativescale*255+1);
						propagplot.rgb=propagplot.map(propagplot.index,:);
						propagplot.timestep=i-1;
						propagplot.tipnum=tiprename(2*(icrackpath-1)+itip);
						PlotImage=plot(propagplot.timestep,propagplot.tipnum,'x','Color',propagplot.rgb);
						if plotcounter==1
							hold on;
							set(gca,'ytick',1:(max(tiprename)));
							title('Propagation Times');
							ylim([0 (max(tiprename)+1)]);
							xlabel('Time Step');
							ylabel('Tip Number');
							h=colorbar;
							colormap(propagplot.map);
							%set(gca,'FontSize',20); %in case wanna change font size, here it is
							ylabel(h,'Crack Force / Material Strength');
							caxis(climit);
						end
					end
				end
			end
			%]
			%switchable1			
		end
		saveas(PlotImage,[TimeStampedName '\\' VideoName '\\Propagation.pdf']);
	
	elseif switcher==88
		VideoName           = 'crackforce_ranking';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		%{
		for i=ttstart:9999
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_crack_abs_force=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_absforce' '-' int2txt(i) '.txt']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if length(climit)==0
						climit(1)=min(min(x_crack_abs_force));
						climit(2)=max(max(x_crack_abs_force));
					else
						climit(1)=min(climit(1),min(min(x_crack_abs_force)));
						climit(2)=max(climit(2),max(max(x_crack_abs_force)));
					end
				end
			end
		end
		%}
		icounter=0;
		plotcounter=0;
		propagplot.map=jet(256);
		propagplot.relativescale=zeros(1,1);
		propagplot.index=zeros(1,1);
		propagplot.rgb=zeros(1,3);
		propagplot.timestep=zeros(1,1);
		propagplot.tipnum=zeros(1,1);
		for i=ttstart+1:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			%elseif mod(i-1,frameskip+1)>0
			%	continue;
			end
			x_crack_acctipcrackratio=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_acctipcrackratio' '-' int2txt(i) '.txt']);
			x_crack_sequence_tipreg=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_sequence_tipreg' '-' int2txt(i) '.txt']);
			x_crack_sequence_merge=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_sequence_merge' '-' int2txt(i) '.txt']);
			x_crack_terminatedprop=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_terminatedprop' '-' int2txt(i-1) '.txt']);
			
			if sum(sum(x_crack_sequence_tipreg))+sum(sum(x_crack_sequence_merge))>0
			else
				continue;
			end
			icounter=icounter+1;
			
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i-1) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i-1) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i-1) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i-1) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i-1) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i-1) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i-1) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i-1) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i-1) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i-1) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i-1) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i-1) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i-1) '.txt']);
			x_crack_abs_force=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_absforce' '-' int2txt(i-1) '.txt']);
			x_crack_nparticles=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_nparticles' '-' int2txt(i-1) '.txt']);
			
			%]
			%switchable1			
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_CrackForce(tiprename,i-1,x_crack_terminatedprop,x_crack_acctipcrackratio,x_crack_nparticles,le_base,x_crack_abs_force,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun,refinementfactor);

					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i-1) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	
	elseif switcher==79
		VideoName           = 'cohesive_inelastic';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		%{
		for i=ttstart:9999
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_crack_bridge_absdeltaxmaxi=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_absdeltaxmaxi' '-' int2txt(i) '.txt']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if length(climit)==0
						climit(1)=min(min(x_crack_bridge_absdeltaxmaxi));
						climit(2)=max(max(x_crack_bridge_absdeltaxmaxi));
					else
						climit(1)=min(climit(1),min(min(x_crack_bridge_absdeltaxmaxi)));
						climit(2)=max(climit(2),max(max(x_crack_bridge_absdeltaxmaxi)));
					end
				end
			end
		end
		%}
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			
			
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			x_crack_abs_force=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_absforce' '-' int2txt(i) '.txt']);
			x_crack_bridge_absdeltaxmaxi=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_absdeltaxmaxi' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Cohesive_dispi(x_crack_abs_force,x_crack_bridge_absdeltaxmaxi,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun,refinementfactor);
					if length(climit)==0
						climit(1)=min(min(x_crack_bridge_absdeltaxmaxi));
						climit(2)=max(max(x_crack_bridge_absdeltaxmaxi));
					else
						climit(1)=min(climit(1),min(min(x_crack_bridge_absdeltaxmaxi)));
						climit(2)=max(climit(2),max(max(x_crack_bridge_absdeltaxmaxi)));
					end

					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	
	elseif switcher==80
		VideoName           = 'bridge_absdeltax';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		%{
		for i=ttstart:9999
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_crack_bridge_base_absdeltax=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_base_absdeltax' '-' int2txt(i) '.txt']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if length(climit)==0
						climit(1)=min(min(x_crack_bridge_base_absdeltax));
						climit(2)=max(max(x_crack_bridge_base_absdeltax));
					else
						climit(1)=min(climit(1),min(min(x_crack_bridge_base_absdeltax)));
						climit(2)=max(climit(2),max(max(x_crack_bridge_base_absdeltax)));
					end
				end
			end
		end
		%}
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			
			
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			x_crack_abs_force=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_absforce' '-' int2txt(i) '.txt']);
			x_crack_bridge_base_absdeltax=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_base_absdeltax' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Cohesive_dispi(x_crack_abs_force,x_crack_bridge_base_absdeltax,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun,refinementfactor);
					if length(climit)==0
						climit(1)=min(min(x_crack_bridge_base_absdeltax));
						climit(2)=max(max(x_crack_bridge_base_absdeltax));
					else
						climit(1)=min(climit(1),min(min(x_crack_bridge_base_absdeltax)));
						climit(2)=max(climit(2),max(max(x_crack_bridge_base_absdeltax)));
					end

					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	
	elseif switcher==82
		VideoName           = 'firsttimeactive';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		%{
		for i=ttstart:9999
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_crack_bridge_firsttimeactive=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_firsttimeactive' '-' int2txt(i) '.txt']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if length(climit)==0
						climit(1)=min(min(x_crack_bridge_firsttimeactive));
						climit(2)=max(max(x_crack_bridge_firsttimeactive));
					else
						climit(1)=min(climit(1),min(min(x_crack_bridge_firsttimeactive)));
						climit(2)=max(climit(2),max(max(x_crack_bridge_firsttimeactive)));
					end
				end
			end
		end
		%}
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			
			
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			x_crack_abs_force=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_absforce' '-' int2txt(i) '.txt']);
			x_crack_bridge_firsttimeactive=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_firsttimeactive' '-' int2txt(i) '.txt']);
			%]
			%switchable1			
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage]=Plot_Cohesive_dispi(x_crack_abs_force,x_crack_bridge_firsttimeactive,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun,refinementfactor);
					if length(climit)==0
						climit(1)=min(min(x_crack_bridge_firsttimeactive));
						climit(2)=max(max(x_crack_bridge_firsttimeactive));
					else
						climit(1)=min(climit(1),min(min(x_crack_bridge_firsttimeactive)));
						climit(2)=max(climit(2),max(max(x_crack_bridge_firsttimeactive)));
					end

					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	
	elseif switcher==83
		VideoName           = 'energy';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		x_crack_bridge_tt_first=loadsinglelong([TimeStampedName '-Master-' 'x_crack_bridge_tt_first' '.txt']);
		x_crack_bridge_tt_last=loadsinglelong([TimeStampedName '-Master-' 'x_crack_bridge_tt_last' '.txt']);
		%{
		for i=1:9999
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_crack_bridge_base_absdeltax=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_base_absdeltax' '-' int2txt(i) '.txt']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if length(climit)==0
						climit(1)=min(min(x_crack_bridge_base_absdeltax));
						climit(2)=max(max(x_crack_bridge_base_absdeltax));
					else
						climit(1)=min(climit(1),min(min(x_crack_bridge_base_absdeltax)));
						climit(2)=max(climit(2),max(max(x_crack_bridge_base_absdeltax)));
					end
				end
			end
		end
		%}
		for i=1:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			end
			energy_kinetic_value=loadsinglefloat([TimeStampedName '-Slave-' 'energy_kinetic_value' '-' int2txt(i) '.txt']);
			energy_strain_value=loadsinglefloat([TimeStampedName '-Slave-' 'energy_strain_value' '-' int2txt(i) '.txt']);
			energy_work_value=loadsinglefloat([TimeStampedName '-Slave-' 'energy_work_value' '-' int2txt(i) '.txt']);
			F_rollerY=loadmatrixfloat([TimeStampedName '-Slave-' 'F_rollerY' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			TLD(i,1)=t_time;
			TLD(i,2)=0;
			TLD(i,3)=DispPump;
			energy.work(i)=energy_work_value;
			energy.strain(i)=energy_strain_value;
			energy.kinetic(i)=energy_kinetic_value;
			energy.dissipation(i)=energy_work_value-energy_strain_value-energy_kinetic_value;
			%]
			%switchable1			
			
		end
		PlotImage=figure;
		set(PlotImage,'visible','off');
		PlotImage=plot(TLD(:,3),energy.work,'DisplayName','BC Work','LineStyle','--');
		hold on
		PlotImage=plot(TLD(:,3),energy.strain,'DisplayName','Strain Energy','LineStyle',':');
		PlotImage=plot(TLD(:,3),energy.kinetic,'DisplayName','Kinetic Energy','LineStyle','-.');
		PlotImage=plot(TLD(:,3),energy.dissipation,'DisplayName','Dissipation');
		PlotImage=plot(TLD(x_crack_bridge_tt_first,3),energy.dissipation(x_crack_bridge_tt_first),'x','DisplayName','First Cohesion');
		PlotImage=plot(TLD(x_crack_bridge_tt_last,3),energy.dissipation(x_crack_bridge_tt_last),'x','DisplayName','Last Cohesion');
		legend show
		xlabel('Displacement (mm)');
		ylabel('Energy (Nmm)');
		saveas(PlotImage,[TimeStampedName '\\' VideoName '\\EnergyCurve.png']);
		close(gcf);
	elseif switcher==84
		VideoName           = 'disp-time';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		%{
		for i=1:9999
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_crack_bridge_base_absdeltax=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_base_absdeltax' '-' int2txt(i) '.txt']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if length(climit)==0
						climit(1)=min(min(x_crack_bridge_base_absdeltax));
						climit(2)=max(max(x_crack_bridge_base_absdeltax));
					else
						climit(1)=min(climit(1),min(min(x_crack_bridge_base_absdeltax)));
						climit(2)=max(climit(2),max(max(x_crack_bridge_base_absdeltax)));
					end
				end
			end
		end
		%}
		for i=1:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			end
			F_rollerY=loadmatrixfloat([TimeStampedName '-Slave-' 'F_rollerY' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			TLD(i,1)=t_time;
			TLD(i,2)=sum(sum(F_rollerY));
			TLD(i,3)=DispPump;
			%]
			%switchable1			
			
		end
		PlotImage=figure;
		set(PlotImage,'visible','off');
		PlotImage=plot(TLD(:,1),TLD(:,3));
		hold on;
		xlabel('Time (s)');
		ylabel('Displacement (mm)');
		saveas(PlotImage,[TimeStampedName '\\' VideoName '\\LDCurve.png']);
		close(gcf);
	
	elseif switcher==90
		VideoName           = 'F(d)_with_marker';
		mkdir([TimeStampedName '\\' VideoName]);
		
		
		icounter=0;
		plotcounter=0;
		climit=[inf -inf];
		propagplot.map=parula(256);
		propagplot.relativescale=zeros(1,1);
		propagplot.index=zeros(1,1);
		propagplot.rgb=zeros(1,3);
		propagplot.timestep=zeros(1,1);
		propagplot.tipnum=zeros(1,1);
		propagplot.maxdisp=zeros(1,1);
		for i=ttstart+1:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			%elseif mod(i-1,frameskip+1)>0
			%	continue;
			end
			x_crack_acctipcrackratio=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_acctipcrackratio' '-' int2txt(i) '.txt']);
			x_crack_sequence_tipreg=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_sequence_tipreg' '-' int2txt(i) '.txt']);
			x_crack_sequence_merge=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_sequence_merge' '-' int2txt(i) '.txt']);
			x_crack_terminatedprop=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_terminatedprop' '-' int2txt(i-1) '.txt']);
			
			if sum(sum(x_crack_sequence_tipreg))+sum(sum(x_crack_sequence_merge))>0
			else
				continue;
			end
			icounter=icounter+1;
			
			x_crack_npaths=loadsinglelong([TimeStampedName '-Slave-' 'x_crack_npaths' '-' int2txt(i-1) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i-1) '.txt']); propagplot.maxdisp=max(propagplot.maxdisp,DispPump); 
			if CasetoRun==197
			if DispPump>0.350
				break;
			end
			end
			
			acctipratio.data=x_crack_acctipcrackratio;
			[acctipratio.rankmat acctipratio.rankindex]=rank2d(x_crack_acctipcrackratio(1:x_crack_npaths,:),x_crack_terminatedprop);
			acctipratio.maxtip=zeros(1,1);
			acctipratio.maxpath=zeros(1,1);
			acctipratio.maxtipnum=zeros(1,1);
			acctipratio.maxpath=acctipratio.rankindex(1,1);
			acctipratio.maxtip=acctipratio.rankindex(1,2);
			acctipratio.relratio=acctipratio.data/acctipratio.data(acctipratio.rankindex(1,1),acctipratio.rankindex(1,2));
			acctipratio.maxtipnum=2*(acctipratio.maxpath-1)+acctipratio.maxtip;
			%timestep   tip with/ max. force	tip #1 relative crack force	tip #2 relative crack force	tip #3 relative crack force
			acctipdump(icounter,1)=i-1;
			acctipdump(icounter,2)=tiprename(acctipratio.maxtipnum);
			acctipdump(icounter,3)=acctipratio.data(3,2);
			acctipdump(icounter,4)=acctipratio.data(2,1);
			acctipdump(icounter,5)=acctipratio.data(2,2);
			for icrackpath=1:x_crack_npaths
				for itip=1:2
					if acctipratio.data(icrackpath,itip)>1
						climit(1)=min(climit(1),acctipratio.data(icrackpath,itip));
						climit(2)=max(climit(2),acctipratio.data(icrackpath,itip));
					end
				end
			end
			%]
			%switchable1			
		end
		save('aa_acctipdump.mat','acctipdump');
		if climit(1)==climit(2)
			climit(1)=climit(1)-1e-9;
			climit(2)=climit(2)+1e-9;
		end
		for i=1:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			end
			F_rollerY=loadmatrixfloat([TimeStampedName '-Slave-' 'F_rollerY' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			if DispPump>propagplot.maxdisp
				break;
			end
			TLD(i,1)=t_time;
			TLD(i,2)=sum(sum(F_rollerY));
			TLD(i,3)=DispPump;
			%]
			%switchable1			
		end
		plot(TLD(:,3),TLD(:,2));
		ax=gca;
		xlimit=ax.XLim;
		close(gcf);
		PlotImage=figure;
		%set(PlotImage,'visible','off'); 
		
		
		h=colorbar;
		colormap(propagplot.map);
		%set(gca,'FontSize',20); %in case wanna change font size, here it is
		ylabel(h,'Crack Force / Material Strength');
		caxis(climit);
		hold on;	
		
		yyaxis right;
		for i=1:max(tiprename)
			PlotImage=plot(xlimit,[i i],'-','Color',[0.875 0.875 0.875],'HandleVisibility','Off');
		end
		
		yyaxis left;
		PlotImage=plot(TLD(:,3),TLD(:,2),'DisplayName','F(d) curve');
		xlabel('Displacement (mm)');
		ylabel('Load (N)');
		
		for i=ttstart+1:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			%elseif mod(i-1,frameskip+1)>0
			%	continue;
			end
			x_crack_acctipcrackratio=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_acctipcrackratio' '-' int2txt(i) '.txt']);
			x_crack_sequence_tipreg=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_sequence_tipreg' '-' int2txt(i) '.txt']);
			x_crack_sequence_merge=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_sequence_merge' '-' int2txt(i) '.txt']);
			x_crack_terminatedprop=loadmatrixlong([TimeStampedName '-Slave-' 'x_crack_terminatedprop' '-' int2txt(i-1) '.txt']);
			
			if sum(sum(x_crack_sequence_tipreg))+sum(sum(x_crack_sequence_merge))>0
			else
				continue;
			end
			icounter=icounter+1;
			
			x_crack_npaths=loadsinglelong([TimeStampedName '-Slave-' 'x_crack_npaths' '-' int2txt(i-1) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i-1) '.txt']);
			acctipratio.data=x_crack_acctipcrackratio;
			[acctipratio.rankmat acctipratio.rankindex]=rank2d(x_crack_acctipcrackratio(1:x_crack_npaths,:),x_crack_terminatedprop);
			acctipratio.maxtip=zeros(1,1);
			acctipratio.maxpath=zeros(1,1);
			acctipratio.maxtipnum=zeros(1,1);
			acctipratio.maxpath=acctipratio.rankindex(1,1);
			acctipratio.maxtip=acctipratio.rankindex(1,2);
			acctipratio.relratio=acctipratio.data/acctipratio.data(acctipratio.rankindex(1,1),acctipratio.rankindex(1,2));
			acctipratio.maxtipnum=2*(acctipratio.maxpath-1)+acctipratio.maxtip;
			%timestep   tip with/ max. force	tip #1 relative crack force	tip #2 relative crack force	tip #3 relative crack force
			for icrackpath=1:x_crack_npaths
				for itip=1:2
					if acctipratio.data(icrackpath,itip)>1
						plotcounter=plotcounter+1;
						propagplot.relativescale=(acctipratio.data(icrackpath,itip)-climit(1))/(climit(2)-climit(1));
						propagplot.index=round(propagplot.relativescale*255+1);
						propagplot.rgb=propagplot.map(propagplot.index,:);
						propagplot.timestep=i-1;
						propagplot.tipnum=tiprename(2*(icrackpath-1)+itip);
						propagplot.disppump=DispPump;
						if plotcounter==1
							yyaxis right;
						end
						if plotcounter==1
							PlotImage=plot(propagplot.disppump,propagplot.tipnum,'x','Color',propagplot.rgb,'DisplayName','Propagating Tip');
						else
							PlotImage=plot(propagplot.disppump,propagplot.tipnum,'x','Color',propagplot.rgb,'HandleVisibility','Off');
						end
						if plotcounter==1
							hold on;
							%legend show;
							h2=legend;
							set(h2,'Location','NorthWest');
							set(gca,'ytick',1:(max(tiprename)));
							%title(['F(d) curve with propagation markers' char(10)]);
							%title('Propagation Times');
							ylim([0 (max(tiprename)+1)]);
							%xlabel('Time Step');
							ylabel('Tip Number');
						end
					end
				end
			end
			%]
			%switchable1		
		end
		
		%set(gcf,'Position',[0 0 300 400])%;
		saveas(PlotImage,[TimeStampedName '\\' VideoName '\\MarkedF(d).png']);
		saveas(PlotImage,[TimeStampedName '\\' VideoName '\\MarkedF(d).pdf']);
		close(gcf);
	elseif switcher==81
		VideoName           = 'load-displacement';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		%{
		for i=1:9999
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_crack_bridge_base_absdeltax=loadmatrixfloat([TimeStampedName '-Slave-' 'x_crack_bridge_base_absdeltax' '-' int2txt(i) '.txt']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					if length(climit)==0
						climit(1)=min(min(x_crack_bridge_base_absdeltax));
						climit(2)=max(max(x_crack_bridge_base_absdeltax));
					else
						climit(1)=min(climit(1),min(min(x_crack_bridge_base_absdeltax)));
						climit(2)=max(climit(2),max(max(x_crack_bridge_base_absdeltax)));
					end
				end
			end
		end
		%}
		for i=1:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			end
			F_rollerY=loadmatrixfloat([TimeStampedName '-Slave-' 'F_rollerY' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			TLD(i,1)=t_time;
			TLD(i,2)=sum(sum(F_rollerY));
			TLD(i,3)=DispPump;
			%]
			%switchable1			
			
		end
		PlotImage=figure;
		set(PlotImage,'visible','off');
		PlotImage=plot(TLD(:,3),TLD(:,2));
		hold on;
		xlabel('Displacement (mm)');
		ylabel('Load (N)');
		saveas(PlotImage,[TimeStampedName '\\' VideoName '\\LDCurve.png']);
		close(gcf);
	
	elseif switcher==68
		VideoName           = 's_max_node_multiline';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1			
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_si=loadmatrix3float([TimeStampedName '-Slave-' 's_si' '-' int2txt(i) '.txt']);
			%s_si_comb=loadmatrixfloat([TimeStampedName '-Slave-' 's_si_comb' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			s_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 's_tip_dump' '-' int2txt(i) '.txt']);
			x_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'x_tip_dump' '-' int2txt(i) '.txt']);
			%]
			%switchable1
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_si_comb_max,~]=Plot_Final2_principalclimit_directions_node(x_crackcenter,x_cracktop,x_crackbot,[LOC;x_tip_dump],le,d_sp,e_sp,v_ssp,niCount+size(x_tip_dump,1),r1_sp,r2_sp,E_acc,[s_si(:,:,1);s_tip_dump],climit,1,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(s_si_comb_max);
					%	climit(2)=max(s_si_comb_max);
					%else
					%	climit(1)=min(climit(1),min(s_si_comb_max));
					%	climit(2)=max(climit(2),max(s_si_comb_max));
					%end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==76
		VideoName           = 's_max_node_comb_multiline';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1			
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			%s_si=loadmatrix3float([TimeStampedName '-Slave-' 's_si' '-' int2txt(i) '.txt']);
			s_si_comb=loadmatrixfloat([TimeStampedName '-Slave-' 's_si_comb' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			s_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 's_tip_dump' '-' int2txt(i) '.txt']);
			x_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'x_tip_dump' '-' int2txt(i) '.txt']);
			%]
			%switchable1
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_si_comb_max,~]=Plot_Final2_principalclimit_directions_node(x_crackcenter,x_cracktop,x_crackbot,[LOC;x_tip_dump],le,d_sp,e_sp,v_ssp,niCount+size(x_tip_dump,1),r1_sp,r2_sp,E_acc,[s_si_comb;s_tip_dump],climit,1,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(s_si_comb_max);
					%	climit(2)=max(s_si_comb_max);
					%else
					%	climit(1)=min(climit(1),min(s_si_comb_max));
					%	climit(2)=max(climit(2),max(s_si_comb_max));
					%end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==72
		VideoName           = 's_max_node_proppath';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1			
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			%s_si=loadmatrix3float([TimeStampedName '-Slave-' 's_si' '-' int2txt(i) '.txt']);
			s_si_comb=loadmatrixfloat([TimeStampedName '-Slave-' 's_si_comb' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			s_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 's_tip_dump' '-' int2txt(i) '.txt']);
			x_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'x_tip_dump' '-' int2txt(i) '.txt']);
			r_propdirweighted_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'r_propdirweighted_dump' '-' int2txt(i) '.txt']);
			%]
			%switchable1
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_si_comb_max,~]=Plot_principaldirs_node_proppath(x_crackcenter,x_cracktop,x_crackbot,[LOC;x_tip_dump],le,d_sp,e_sp,v_ssp,niCount+size(x_tip_dump,1),r1_sp,r2_sp,E_acc,[s_si_comb;s_tip_dump],climit,1,1,CasetoRun,refinementfactor,x_tip_dump,r_propdirweighted_dump);
					%if length(climit)==0
					%	climit(1)=min(s_si_comb_max);
					%	climit(2)=max(s_si_comb_max);
					%else
					%	climit(1)=min(climit(1),min(s_si_comb_max));
					%	climit(2)=max(climit(2),max(s_si_comb_max));
					%end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==73
		VideoName           = 's_min_node_proppath';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1			
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			%s_si=loadmatrix3float([TimeStampedName '-Slave-' 's_si' '-' int2txt(i) '.txt']);
			s_si_comb=loadmatrixfloat([TimeStampedName '-Slave-' 's_si_comb' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			s_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 's_tip_dump' '-' int2txt(i) '.txt']);
			x_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'x_tip_dump' '-' int2txt(i) '.txt']);
			r_propdirweighted_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'r_propdirweighted_dump' '-' int2txt(i) '.txt']);
			%]
			%switchable1
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,DUMMY2,s_si_comb_min,~]=Plot_principaldirs_node_proppath(x_crackcenter,x_cracktop,x_crackbot,[LOC;x_tip_dump],le,d_sp,e_sp,v_ssp,niCount+size(x_tip_dump,1),r1_sp,r2_sp,E_acc,[s_si_comb;s_tip_dump],climit,2,1,CasetoRun,refinementfactor,x_tip_dump,r_propdirweighted_dump);
					%if length(climit)==0
					%	climit(1)=min(s_si_comb_min);
					%	climit(2)=max(s_si_comb_min);
					%else
					%	climit(1)=min(climit(1),min(s_si_comb_min));
					%	climit(2)=max(climit(2),max(s_si_comb_min));
					%end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==71
		VideoName           = 's_si_x';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1			
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			%s_si=loadmatrix3float([TimeStampedName '-Slave-' 's_si' '-' int2txt(i) '.txt']);
			s_si_comb=loadmatrixfloat([TimeStampedName '-Slave-' 's_si_comb' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			s_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 's_tip_dump' '-' int2txt(i) '.txt']);
			x_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'x_tip_dump' '-' int2txt(i) '.txt']);
			%]
			%switchable1
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_si_x,~]=Plot_Final2_xyz_node(x_crackcenter,x_cracktop,x_crackbot,[LOC;x_tip_dump],le,d_sp,e_sp,v_ssp,niCount+size(x_tip_dump,1),r1_sp,r2_sp,E_acc,[s_si_comb;s_tip_dump],climit,1,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(s_si_x);
					%	climit(2)=max(s_si_x);
					%else
					%	climit(1)=min(climit(1),min(s_si_x));
					%	climit(2)=max(climit(2),max(s_si_x));
					%end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==74
		VideoName           = 'v_sp_x';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1			
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			%s_si=loadmatrix3float([TimeStampedName '-Slave-' 's_si' '-' int2txt(i) '.txt']);
			s_si_comb=loadmatrixfloat([TimeStampedName '-Slave-' 's_si_comb' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			s_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 's_tip_dump' '-' int2txt(i) '.txt']);
			x_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'x_tip_dump' '-' int2txt(i) '.txt']);
			%]
			%switchable1
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_si_x,~]=Plot_Final2_xyz_particle(x_crackcenter,x_cracktop,x_crackbot,x_sp,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,v_ssp,climit,1,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(s_si_x);
					%	climit(2)=max(s_si_x);
					%else
					%	climit(1)=min(climit(1),min(s_si_x));
					%	climit(2)=max(climit(2),max(s_si_x));
					%end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==75
		VideoName           = 'u_sp_y';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1			
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			%s_si=loadmatrix3float([TimeStampedName '-Slave-' 's_si' '-' int2txt(i) '.txt']);
			s_si_comb=loadmatrixfloat([TimeStampedName '-Slave-' 's_si_comb' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			s_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 's_tip_dump' '-' int2txt(i) '.txt']);
			x_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'x_tip_dump' '-' int2txt(i) '.txt']);
			u_sp=x_sp-x_spo;
			%]
			%switchable1
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_si_x,~]=Plot_Final2_xyz_particle(x_crackcenter,x_cracktop,x_crackbot,x_sp,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,u_sp,climit,2,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(s_si_x);
					%	climit(2)=max(s_si_x);
					%else
					%	climit(1)=min(climit(1),min(s_si_x));
					%	climit(2)=max(climit(2),max(s_si_x));
					%end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==77
		VideoName           = 'u_sp_x';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1			
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			%s_si=loadmatrix3float([TimeStampedName '-Slave-' 's_si' '-' int2txt(i) '.txt']);
			s_si_comb=loadmatrixfloat([TimeStampedName '-Slave-' 's_si_comb' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			s_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 's_tip_dump' '-' int2txt(i) '.txt']);
			x_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'x_tip_dump' '-' int2txt(i) '.txt']);
			u_sp=x_sp-x_spo;
			%]
			%switchable1
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_si_x,~]=Plot_Final2_xyz_particle(x_crackcenter,x_cracktop,x_crackbot,x_sp,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,u_sp,climit,1,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(s_si_x);
					%	climit(2)=max(s_si_x);
					%else
					%	climit(1)=min(climit(1),min(s_si_x));
					%	climit(2)=max(climit(2),max(s_si_x));
					%end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==69
		VideoName           = 's_max_gauss_multiline';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1			
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			%s_si=loadmatrix3float([TimeStampedName '-Slave-' 's_si' '-' int2txt(i) '.txt']);
			%s_si_comb=loadmatrixfloat([TimeStampedName '-Slave-' 's_si_comb' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			s_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 's_tip_dump' '-' int2txt(i) '.txt']);
			x_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'x_tip_dump' '-' int2txt(i) '.txt']);
			s_gauss_dump=loadmatrixfloat([TimeStampedName '-Slave-' 's_gauss_dump' '-' int2txt(i) '.txt']);
			x_gauss_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'x_gauss_dump' '-' int2txt(i) '.txt']);
			%]
			%switchable1
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_si_comb_max,~]=Plot_Final2_principalclimit_directions_node(x_crackcenter,x_cracktop,x_crackbot,[x_gauss_dump;x_tip_dump],le,d_sp,e_sp,v_ssp,size(x_gauss_dump,1)+size(x_tip_dump,1),r1_sp,r2_sp,E_acc,[s_gauss_dump;s_tip_dump],climit,1,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(s_si_comb_max);
					%	climit(2)=max(s_si_comb_max);
					%else
					%	climit(1)=min(climit(1),min(s_si_comb_max));
					%	climit(2)=max(climit(2),max(s_si_comb_max));
					%end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==70
		VideoName           = 's_si_K1';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1			
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			%s_si=loadmatrix3float([TimeStampedName '-Slave-' 's_si' '-' int2txt(i) '.txt']);
			s_si_K1=loadmatrixfloat([TimeStampedName '-Slave-' 's_si_K1' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			s_tip_K1_dump=loadmatrixfloat([TimeStampedName '-Slave-' 's_tip_K1_dump' '-' int2txt(i) '.txt']);
			x_tip_dump=loadmatrixfloat([TimeStampedName '-Slave-' 'x_tip_dump' '-' int2txt(i) '.txt']);
			%]
			%switchable1
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_si_comb_max,~]=Plot_Final2_principalclimit_directions_node(x_crackcenter,x_cracktop,x_crackbot,[LOC;x_tip_dump],le,d_sp,e_sp,v_ssp,niCount+size(x_tip_dump,1),r1_sp,r2_sp,E_acc,[s_si_K1;s_tip_K1_dump],climit,1,1,CasetoRun,refinementfactor);
					%if length(climit)==0
					%	climit(1)=min(s_si_comb_max);
					%	climit(2)=max(s_si_comb_max);
					%else
					%	climit(1)=min(climit(1),min(s_si_comb_max));
					%	climit(2)=max(climit(2),max(s_si_comb_max));
					%end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==62
		VideoName           = 's_min_multiline';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,DUMMY,s_sp_min,~]=Plot_Final2_principalclimit_directions_crackmultiline(NN,le_base,x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,2,lp,plotignore,1,CasetoRun);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_min,0,plotignore));
						climit(2)=max(cutvector(s_sp_min,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
					end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	elseif switcher==63
		VideoName           = 's_max_pforce';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:9999
			%{
			%switchable1
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%}
			%switchable1
			%[
			%switchable1
			tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
			if i>tt
				break;
			elseif mod(i-1,frameskip+1)>0
				continue;
			end
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			pforce_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'pforce_sp' '-' int2txt(i) '.txt']);
			%]
			%switchable1	
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_principal_crackmulti_pforce(x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun,pforce_sp);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_max,0,plotignore));
						climit(2)=max(cutvector(s_sp_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
					end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	
	elseif switcher==67
		VideoName           = 's_max_ntforce_si';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		
		for i=ttstart:tt
			%disp(['Loading ' TimeStampedName '\\' num2str(i) '.mat']);
			%load([TimeStampedName '\\' num2str(i) '.mat']);
			
			x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(i) '.txt']);
			F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(i) '.txt']);
			thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(i) '.txt']);
			x_crackcenter=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackcenter' '-' int2txt(i) '.txt']);
			x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(i) '.txt']);
			x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(i) '.txt']);
			DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(i) '.txt']);
			t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
			v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(i) '.txt']);
			r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(i) '.txt']);
			r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(i) '.txt']);
			E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(i) '.txt']);
			s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(i) '.txt']);
			ntforce_si=loadmatrixfloat([TimeStampedName '-Slave-' 'ntforce_si' '-' int2txt(i) '.txt']);
			
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_principal_crackmulti_ntforce(x_sp,x_crackcenter,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun,ntforce_si);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_max,0,plotignore));
						climit(2)=max(cutvector(s_sp_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
					end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	

	elseif switcher==55
		VideoName           = 's_max_var_nc';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_max,0,plotignore));
						climit(2)=max(cutvector(s_sp_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
					end
					%{
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1);
					%}
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	
	elseif switcher==10
		VideoName           = 's_max';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,0,CasetoRun);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_max,0,plotignore));
						climit(2)=max(cutvector(s_sp_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_max,0,plotignore)));
					end
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,s_sp_max,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,1,lp,plotignore,1,CasetoRun);
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		
		close(writerObj);
	
	elseif switcher==22
		VideoName           = 's_shr';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,DUMMY,DUMMY2,s_sp_shr]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,3,lp,plotignore,0,CasetoRun);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_shr,0,plotignore));
						climit(2)=max(cutvector(s_sp_shr,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_shr,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_shr,0,plotignore)));
					end
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);		
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,DUMMY,DUMMY2,s_sp_shr]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,3,lp,plotignore,1,CasetoRun);
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	
	elseif switcher==9
		VideoName           = 's_min';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,DUMMY,s_sp_min,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,2,lp,plotignore,0,CasetoRun);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_min,0,plotignore));
						climit(2)=max(cutvector(s_sp_min,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
					end
				end
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,DUMMY,s_sp_min,~]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,2,lp,plotignore,1,CasetoRun);
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	
	elseif switcher==42
		VideoName           = 's1';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%climit=[-11 8];
			%[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,1),climit,plotignore,0);
			if length(climit)==0
				climit(1)=min(cutvector(s_sp(:,1),0,plotignore));
				climit(2)=max(cutvector(s_sp(:,1),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(s_sp(:,1),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(s_sp(:,1),0,plotignore)));
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,1),climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);

	elseif switcher==1
		VideoName           = 'evaltimes';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			evaltimes_accummulated=zeros(spCount,1);
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(climit)==0
				climit(1)=min(cutvector(evaltimes_accummulated,0,plotignore));
				climit(2)=max(cutvector(evaltimes_accummulated,0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(evaltimes_accummulated,0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(evaltimes_accummulated,0,plotignore)));
			end
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,evaltimes_accummulated,climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);
		
	elseif switcher==45
		VideoName           = 'ux';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		direction           = 1;
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			u_sp=x_sp(:,direction)-x_spo(:,direction);
			if length(climit)==0
				climit(1)=min(cutvector(u_sp,0,plotignore));
				climit(2)=max(cutvector(u_sp,0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(u_sp,0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(u_sp,0,plotignore)));
			end
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,u_sp,climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);
	elseif switcher==64 || switcher==65 || switcher==66
		direction           = switcher-63;
		
		if direction==1
			VideoName           = ['ux_multiline'];
		elseif direction==2
			VideoName           = ['uy_multiline'];
		elseif direction==3
			VideoName           = ['um_multiline'];
		end
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			u_sp_all=x_sp-x_spo;
			if direction<3
				u_sp=u_sp_all(:,direction);
			else
				for isp=1:spCount
					u_sp(isp,1)=sqrt(dot(u_sp_all(isp,:),u_sp_all(isp,:)));
				end
			end
			if length(climit)==0
				climit(1)=min(cutvector(u_sp,0,plotignore));
				climit(2)=max(cutvector(u_sp,0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(u_sp,0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(u_sp,0,plotignore)));
			end
			[PlotImage]=Plot_Final2_regularclimit_multiline(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,u_sp,climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);
	elseif switcher==46
		VideoName           = 'uy';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		direction           = 2;
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			u_sp=x_sp(:,direction)-x_spo(:,direction);
			if length(climit)==0
				climit(1)=min(cutvector(u_sp,0,plotignore));
				climit(2)=max(cutvector(u_sp,0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(u_sp,0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(u_sp,0,plotignore)));
			end
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,u_sp,climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);

	elseif switcher==31
		VideoName           = 's12';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%climit=[-11 8];
			%[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,1),climit,plotignore,0);
			if length(climit)==0
				climit(1)=min(cutvector(s_sp(:,3),0,plotignore));
				climit(2)=max(cutvector(s_sp(:,3),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(s_sp(:,3),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(s_sp(:,3),0,plotignore)));
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,3),climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);

		
	elseif switcher==44
		VideoName           = 'fmax';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_f_plot(t_time,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,plotignore,f_final_vect,alphahp);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);

		
	elseif switcher==2 || switcher==3 || switcher==4 || switcher==5 || switcher==6 || switcher==7 || switcher==8
		surface=switcher-1;
		VideoName           = ['alpha_' num2str(surface)];
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(climit)==0
				climit(1)=min(cutvector(alphahp(:,surface),0,plotignore));
				climit(2)=max(cutvector(alphahp(:,surface),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(alphahp(:,surface),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(alphahp(:,surface),0,plotignore)));
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_alpha(climit,x_sp,LOC,spCount,r1_sp,r2_sp,plotignore,alphahp,surface);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);

		
	elseif switcher==24 || switcher==25 || switcher==26 || switcher==27 || switcher==28 || switcher==29 || switcher==30
		surface=switcher-23;
		VideoName           = ['q_' num2str(surface)];
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		qtoprint=zeros(spCount,tt);        
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			for sp=1:spCount
				if plotignore(sp)
					continue;
				end
				[qtemp,~]=qandDfromalpha2(alphahp(sp,:),ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
				qtoprint(sp,i)=qtemp(surface);
			end
			if length(climit)==0
				climit(1)=min(cutvector(qtoprint(:,i),0,plotignore));
				climit(2)=max(cutvector(qtoprint(:,i),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(qtoprint(:,i),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(qtoprint(:,i),0,plotignore)));
			end
		%end
		%for i=ttstart:tt
			%load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,qtoprint(:,i),climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);

		
	elseif switcher==14
		VideoName           = 's2';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(climit)==0
				climit(1)=min(cutvector(s_sp(:,2),0,plotignore));
				climit(2)=max(cutvector(s_sp(:,2),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(s_sp(:,2),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(s_sp(:,2),0,plotignore)));
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,2),climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);

	elseif switcher==39
		VideoName           = 's2d';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(climit)==0
				climit(1)=min(cutvector(s_sp(:,2),0,plotignore));
				climit(2)=max(cutvector(s_sp(:,2),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(s_sp(:,2),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(s_sp(:,2),0,plotignore)));
			end
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,2),climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);

	elseif switcher==15 || switcher==16 || switcher==17 || switcher==18 || switcher==19 || switcher==20 || switcher==21
		surface=switcher-14;
		VideoName           = ['f_' num2str(surface)];
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(climit)==0
				climit(1)=min(cutvector(f_final_vect(:,surface),0,plotignore));
				climit(2)=max(cutvector(f_final_vect(:,surface),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(f_final_vect(:,surface),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(f_final_vect(:,surface),0,plotignore)));
			end
		%end
		%for i=ttstart:tt
			%load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,f_final_vect(:,surface),climit,plotignore);
			%climitsfrec=[climitsfrec;climitsf];
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);

	elseif switcher==41

		xmax=max(-TLD(:,3));
		xmin=min(-TLD(:,3));
		ymax=max(-TLD(:,2));
		ymin=min(-TLD(:,2));
		TLDmaxsize=size(TLD,1);
		
		VideoName           = 'load-disp';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		if CasetoRun==5
			tt=min(tt,2399);
		end
		for i=ttstart:tt
			PlotImage=figure;
			set(PlotImage,'visible','off');
			if CasetoRun==5
				plot(-TLD(1:i,3),-TLD(1:i,2));
			else
				plot(TLD(1:i,3),TLD(1:i,2));
			end
			hold on
			plot(xmax,ymax);
			plot(xmin,ymax);
			plot(xmax,ymin);
			plot(xmin,ymin);
			xlabel('Displacement (mm)');
			ylabel('Load (N)');
			if CasetoRun==5
			else
				title('Load vs Displacement Curve');
			end
			
			set(gca,'FontSize',20)
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) '.png']);
			frame=getframe(PlotImage);
			writeVideo(writerObj,frame);
			hold off
			close(PlotImage);
		end
		close(writerObj);
   
	
	elseif switcher==47

		mkdir([TimeStampedName '\\schedule']);
		%writerObj           = VideoWriter([TimeStampedName '\\schedule.avi']);
		%writerObj.FrameRate = videofps;    % number of frame per second
		%open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if i==ttstart
				xupperlimit=stackvars(size(stackvars,1),2);
			else
				xupperlimit=max(xupperlimit,stackvars(size(stackvars,1),2));
			end
			for j=1:size(stackvars,1)
				if stackvars(j,2)==0
					stackvars(j,3)=stackvars(size(stackvars,1),2)/1000;
				else
					stackvars(j,3)=0;
				end
			end
			PlotImage=figure;
			set(PlotImage,'visible','off');
			hold on;
			set(PlotImage,'Position',[0 0 720 1280]);
			title(['tt=' num2str(i) ', t_time=' char(vpa(t_time))]);
			%xlim([0 xupperlimit]);
			
			BarProfile=barh(stackvars,'stacked');
			set(BarProfile,{'FaceColor'},{'none';'k';'r'},'EdgeColor','none','BarWidth',1);
			%set(BarProfile,'BarWidth',1);
			saveas(PlotImage,[TimeStampedName '\\schedule\\tt=' num2str(i) ', t_time=' char(vpa(t_time)) '.png']);
			%%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			%frame = getframe(PlotImage);
			%writeVideo(writerObj,frame);
			hold off;
			close(PlotImage);
		end
		%close(writerObj);
   
	
	elseif switcher==11
		VideoName           = 'sr';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(climit)==0
				climit(1)=min(cutvector(sigma_local_big(:,1),0,plotignore));
				climit(2)=max(cutvector(sigma_local_big(:,1),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(sigma_local_big(:,1),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(sigma_local_big(:,1),0,plotignore)));
			end
			%climitssrec=[climitssrec;climitss];
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,sigma_local_big(:,1),climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);
   
	elseif switcher==32
		VideoName           = 'srt';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(climit)==0
				climit(1)=min(cutvector(sigma_local_big(:,4),0,plotignore));
				climit(2)=max(cutvector(sigma_local_big(:,4),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(sigma_local_big(:,4),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(sigma_local_big(:,4),0,plotignore)));
			end
			%climitssrec=[climitssrec;climitss];
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,sigma_local_big(:,4),climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);
   
	elseif switcher==33
		VideoName           = 'stl';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(climit)==0
				climit(1)=min(cutvector(sigma_local_big(:,5),0,plotignore));
				climit(2)=max(cutvector(sigma_local_big(:,5),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(sigma_local_big(:,5),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(sigma_local_big(:,5),0,plotignore)));
			end
			%climitssrec=[climitssrec;climitss];
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,sigma_local_big(:,5),climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);
   
	elseif switcher==34
		VideoName           = 'srl';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(climit)==0
				climit(1)=min(cutvector(sigma_local_big(:,6),0,plotignore));
				climit(2)=max(cutvector(sigma_local_big(:,6),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(sigma_local_big(:,6),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(sigma_local_big(:,6),0,plotignore)));
			end
			%climitssrec=[climitssrec;climitss];
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,sigma_local_big(:,6),climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);
   
	
	elseif switcher==23
		VideoName           = 'st';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(climit)==0
				climit(1)=min(cutvector(sigma_local_big(:,2),0,plotignore));
				climit(2)=max(cutvector(sigma_local_big(:,2),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(sigma_local_big(:,2),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(sigma_local_big(:,2),0,plotignore)));
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,sigma_local_big(:,2),climit,plotignore);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);


			%if exist('climitsf')==0
			%	climitsf=[];
			%end
		end
		close(writerObj);
	
   
	
	elseif switcher==12
		VideoName           = 'sl';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(climit)==0
				climit(1)=min(cutvector(sigma_local_big(:,3),0,plotignore));
				climit(2)=max(cutvector(sigma_local_big(:,3),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(sigma_local_big(:,3),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(sigma_local_big(:,3),0,plotignore)));
			end
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_regularclimit(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,sigma_local_big(:,3),climit,plotignore);
			%climitssrec=[climitssrec;climitss];
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);


			%if exist('climitsf')==0
			%	climitsf=[];
			%end
		end
		close(writerObj);
	elseif switcher==48
		%stress x black and white
		VideoName           = 's1_bw';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		if CasetoRun==5
			tt=min(tt,2399);
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			%climit=[-11 8];
			if length(climit)==0
				climit(1)=min(cutvector(s_sp(:,1),0,plotignore));
				climit(2)=max(cutvector(s_sp(:,1),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(s_sp(:,1),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(s_sp(:,1),0,plotignore)));
			end
		end
		if CasetoRun==5
			tt=min(tt,2399);
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			[PlotImage]=Plot_Final2_regularclimit_black(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,1),climit,plotignore,CasetoRun);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);

	elseif switcher==49
		%stress y black and white
		VideoName           = 's2_bw';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);
		if CasetoRun==5
			tt=min(tt,2399);
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(climit)==0
				climit(1)=min(cutvector(s_sp(:,2),0,plotignore));
				climit(2)=max(cutvector(s_sp(:,2),0,plotignore));
			else
				climit(1)=min(climit(1),min(cutvector(s_sp(:,2),0,plotignore)));
				climit(2)=max(climit(2),max(cutvector(s_sp(:,2),0,plotignore)));
			end
		end
		if CasetoRun==5
			tt=min(tt,2399);
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if CasetoRun==10
				climit(1)=-3.8;
				climit(2)=3.8;
			end
			[PlotImage]=Plot_Final2_regularclimit_black(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp(:,2),climit,plotignore,CasetoRun);
			%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
			saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
			frame = getframe(PlotImage);
			writeVideo(writerObj,frame);
			close(PlotImage);
		end
		close(writerObj);

	elseif switcher==50
		%min princ plastic strain 
		VideoName           = 's_min_bw';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		if CasetoRun==5
			tt=min(tt,2399);
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);        
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,DUMMY,s_sp_min,~]=Plot_Final2_principalclimit_directions_black(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,2,lp,plotignore,0,CasetoRun);
					if length(climit)==0
						climit(1)=min(cutvector(s_sp_min,0,plotignore));
						climit(2)=max(cutvector(s_sp_min,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(s_sp_min,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(s_sp_min,0,plotignore)));
					end
				end
			end
		end
		if CasetoRun==5
			tt=min(tt,2399);
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(CModel) == length('Wood_Schmidt17');
				if CModel == 'Wood_Schmidt17'
					[PlotImage,DUMMY,s_sp_min,~]=Plot_Final2_principalclimit_directions_black(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,s_sp,climit,2,lp,plotignore,1,CasetoRun);
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
		end
		close(writerObj);
	
	elseif switcher==51
		VideoName           = 'e_pl_max_bw';
		mkdir([TimeStampedName '\\' VideoName]);
		writerObj           = VideoWriter([TimeStampedName '\\' VideoName '.avi']);
		writerObj.FrameRate = videofps;    % number of frame per second
		open(writerObj);

		if CasetoRun==5
			tt=min(tt,2399);
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(CModel) == length('Wood_Schmidt17')
				if CModel == 'Wood_Schmidt17'
					%if exist('climitse')==0
					%	climitse=[];
					%end
					if CasetoRun==10
						climit(1)=0;
						climit(2)=0.21;
					end
					[PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit_black(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,1,plotignore,0,CasetoRun);
					if length(climit)==0
						climit(1)=min(cutvector(e_pl_sp_max,0,plotignore));
						climit(2)=max(cutvector(e_pl_sp_max,0,plotignore));
					else
						climit(1)=min(climit(1),min(cutvector(e_pl_sp_max,0,plotignore)));
						climit(2)=max(climit(2),max(cutvector(e_pl_sp_max,0,plotignore)));
					end
				end
			end
		end
		if CasetoRun==5
			tt=min(tt,2399);
		end
		for i=ttstart:tt
			load([TimeStampedName '\\' num2str(i) '.mat']);
			if length(CModel) == length('Wood_Schmidt17')
				if CModel == 'Wood_Schmidt17'
					[PlotImage,e_pl_sp_max,~]=Plot_Final2_principalclimit_black(t_time,i,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climit,1,plotignore,1,CasetoRun);
					%saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.emf']);
					saveas(PlotImage,[TimeStampedName '\\' VideoName '\\tt=' num2str(i) ',d=' num2str(DispPump) ',t_time=' char(vpa(t_time)) '.png']);
					frame = getframe(PlotImage);
					writeVideo(writerObj,frame);
					close(PlotImage);
				end
			end
			%if exist('climitss')==0
			%	climitss=[];
			%end
		end
		close(writerObj);
	else
		disp('switcher error!')
	end
	
	% End of Printing TLD Video
	close all
	disp(['Done Plotting Switcher #' num2str(switcher)]);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [rankmat, rankindex]=rank2d(matin,matignore)
	interm.data=matin;
	interm.ignore=matignore;
	interm.ranked=zeros(size(matin));
	interm.rankmat=zeros(size(matin));
	interm.rankindex=zeros(size(matin,1)*size(matin,2),2);
	interm.size1=size(matin,1);
	interm.size2=size(matin,2);
	interm.curmaxval=zeros(1,1);
	interm.curmaxindex=zeros(1,2);
	interm.currank=zeros(1,1);
	interm.firstcheck=zeros(1,1);

	for k=1:interm.size1
		for l=1:interm.size2
			interm.firstcheck=1;
			for i=1:interm.size1
				for j=1:interm.size2
					if interm.ranked(i,j)==1 || interm.ignore(i,j)==1
					else
						if interm.firstcheck==1
							interm.firstcheck=0;
							interm.curmaxval=interm.data(i,j);
							interm.curmaxindex=[i j];
						else
							if interm.data(i,j)>interm.curmaxval
								interm.curmaxval=interm.data(i,j);
								interm.curmaxindex=[i j];
							end
						end
					end
				end
			end
			if interm.ignore(k,l)==0
				interm.currank=interm.currank+1;
				interm.ranked(interm.curmaxindex(1),interm.curmaxindex(2))=1;
				interm.rankmat(interm.curmaxindex(1),interm.curmaxindex(2))=interm.currank;
				interm.rankindex(interm.currank,:)=interm.curmaxindex;
			end
		end
	end
	rankmat=interm.rankmat;
	rankindex=interm.rankindex;
end

%]
%switchable2

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [s_sp,e_pl,sigma_global_big,e_t_global_big,e_pl_global_big,alpha_out,f_final_vect,surfacewithfmax,sigma_local_big,AbeforeQ_rtl,evaltimes,thetacrackrtl,justcracked,Qacoustic,h,Ktangent_local,Ktangent_global,Ktangent_global_2D,Ktangent_global_tens,Ktangent_global_tens_2D,activesurfacelist,lambdamin,thetamin]= ...
	Wood_Schmidt17(k,dk,analyseparticle,dESP,sigma_global_big,e_t_global_big,e_pl_global_big,alpha_in,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,t_time,dt,spid,Debugging,thetacrackrtl,dudx_rtl)
	%start function of Wood_Schmidt17
	%{
	for idim1=1:2
	for idim2=1:2
		fprintf('%s',['spid=' int2txt(spid) ', dudx_rtl(' int2txt(idim1) ',' int2txt(idim2) ')=' float2scitxt(5,dudx_rtl(idim1,idim2)) char(10)]);
	end
	end
	%}
	%remember 3 stage rotation!
	%from global to local: GLOBAL --> rotation from polar decomposition --> rotation as defined --> rtl rotation --> local to matmodel
	% move efficient than version 16
	%function [outputArg1,outputArg2] = Wood_Schmidt(inputArg1,inputArg2)
	%SCHMIDT Summary of this function goes here
	%   Detailed explanation goes here
	%{
	Voigt's Notation direction:
	1: r
	2: t
	3: l
	4: rt
	5: tl
	6: rl
	
	Failure surfaces:
	1: r tension
	2: r compression
	3: t tension
	4: t compression
	5: l tension
	6: l compression
	7: shear
	
	%}
	
	evaltimes=0;
	step=1;
	
	deltaepsilonglobal=zeros(6,1);
	deltaepsilonglobal(1,1)=real(dESP(1,1));
	deltaepsilonglobal(2,1)=real(dESP(2,2));
	deltaepsilonglobal(3,1)=0;
	deltaepsilonglobal(4,1)=real(dESP(1,2));
	deltaepsilonglobal(5,1)=0;
	deltaepsilonglobal(6,1)=0;
	
	ddtepsilonglobal=zeros(6,1);
	ddtepsilonglobal(1,1)=real(dESP(1,1))/dt;
	ddtepsilonglobal(2,1)=real(dESP(2,2))/dt;
	ddtepsilonglobal(3,1)=0;
	ddtepsilonglobal(4,1)=real(dESP(1,2))/dt;
	ddtepsilonglobal(5,1)=0;
	ddtepsilonglobal(6,1)=0;
	
	if dESP(1,2)>0
	end
	
	xdir=RTLtranslator(xdirletter);
	ydir=RTLtranslator(ydirletter);
	zdir=RTLtranslator(zdirletter);
	xydir=RTLtranslator(xydirletter);
	yzdir=RTLtranslator(yzdirletter);
	xzdir=RTLtranslator(xzdirletter);

	dirglobal=[xdir ydir zdir xydir yzdir xzdir];

	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
		planestressmod=1;
	elseif CasetoRun==4
		planestressmod=1;
	elseif CasetoRun==5 || CasetoRun==6
		planestressmod=0;
	elseif CasetoRun==7
		planestressmod=1;
	elseif CasetoRun==8 || CasetoRun==9
		planestressmod=0;
	elseif CasetoRun==10
		planestressmod=1;
	elseif CasetoRun==11
		planestressmod=1;
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		%planestressmod=0;
		%planestressmod=1; %turns out it's plane STRAIN all along, let's do plane STRESS now.
		planestressmod=0; %plane stress is being done, need PLANE STRAIN for more correctness.
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		%planestressmod=0; %note it's plane strain unlinke CasetoRun==11
		%planestressmod=1; %turns out it's plane STRAIN all along, let's do plane STRESS now.
		planestressmod=0; %plane stress is being done, need PLANE STRAIN for more correctness.
	elseif CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77
		planestressmod=0;
	elseif CasetoRun==229 || CasetoRun==230
		planestressmod=1;
	elseif CasetoRun==-99
		planestressmod=0;
	end
	
	nsurface=length(alpha_in); %to stop coder whining
	nstressvect=length(sigma_global_big); %to stop coder whining
	
	deltaepsilon=zeros(nstressvect,1);
	deltaepsilon(xdir,1)=deltaepsilonglobal(1);
	deltaepsilon(ydir,1)=deltaepsilonglobal(2);
	deltaepsilon(zdir,1)=deltaepsilonglobal(3);
	deltaepsilon(xydir,1)=deltaepsilonglobal(4);
	deltaepsilon(yzdir,1)=deltaepsilonglobal(5);
	deltaepsilon(xzdir,1)=deltaepsilonglobal(6);
	
	ddtepsilon=zeros(nstressvect,1);
	ddtepsilon(xdir,1)=ddtepsilonglobal(1);
	ddtepsilon(ydir,1)=ddtepsilonglobal(2);
	ddtepsilon(zdir,1)=ddtepsilonglobal(3);
	ddtepsilon(xydir,1)=ddtepsilonglobal(4);
	ddtepsilon(yzdir,1)=ddtepsilonglobal(5);
	ddtepsilon(xzdir,1)=ddtepsilonglobal(6);
	
	epsilonp=zeros(nstressvect,1);
	epsilonp(xdir,1)=e_pl_global_big(1);
	epsilonp(ydir,1)=e_pl_global_big(2);
	epsilonp(zdir,1)=e_pl_global_big(3);
	epsilonp(xydir,1)=e_pl_global_big(4);
	epsilonp(yzdir,1)=e_pl_global_big(5);
	epsilonp(xzdir,1)=e_pl_global_big(6);
	
	epsilont=zeros(nstressvect,1);
	epsilont(xdir,1)=e_t_global_big(1);
	epsilont(ydir,1)=e_t_global_big(2);
	epsilont(zdir,1)=e_t_global_big(3);
	epsilont(xydir,1)=e_t_global_big(4);
	epsilont(yzdir,1)=e_t_global_big(5);
	epsilont(xzdir,1)=e_t_global_big(6);
	
	sigma0=zeros(nstressvect,1);
	sigma0(xdir,1)=sigma_global_big(1);
	sigma0(ydir,1)=sigma_global_big(2);
	sigma0(zdir,1)=sigma_global_big(3);
	sigma0(xydir,1)=sigma_global_big(4);
	sigma0(yzdir,1)=sigma_global_big(5);
	sigma0(xzdir,1)=sigma_global_big(6);
	
	q=zeros(1,nsurface);
	qtest=zeros(1,nsurface);
	
	sigma=cell(1,3);
	sigma{1}=zeros(nstressvect,1);
	sigma{2}=zeros(nstressvect,1);
	sigma{3}=zeros(nstressvect,1);
	alphahp=cell(1,3);
	alphahp{1}=zeros(1,nsurface);
	alphahp{2}=zeros(1,nsurface);
	alphahp{3}=zeros(1,nsurface);
	
	ftrial=cell(1,nsurface);
	coder.varsize('ftrial');
	fprev=cell(1,nsurface);
	coder.varsize('fprev');
	fimplicitstart=cell(1,nsurface);
	coder.varsize('fimplicitstart');
	fimplicitstarttrial=cell(1,nsurface);
	coder.varsize('fimplicitstarttrial');
	f_final=cell(1,nsurface);
	f1trial=cell(1,nsurface);
	f10=cell(1,nsurface);
	f2trial=cell(1,nsurface);
	f20=cell(1,nsurface);
	dfdsigma=cell(1,nsurface);
	dfdq=cell(1,nsurface);
	dfdqchosen=cell(1,nsurface);
	d2fdsigma2=cell(1,nsurface);
	d2fdsigmadq=cell(1,nsurface);
	d2fdq2=cell(1,nsurface);
	for i=1:nsurface
		ftrial{i}=0;
		fprev{i}=0;
		fimplicitstart{i}=0;
		fimplicitstarttrial{i}=0;
		f_final{i}=0;
		f1trial{i}=0;
		f10{i}=0;
		f2trial{i}=0;
		f20{i}=0;
		dfdsigma{i}=zeros(nstressvect,1);
		dfdq{i}=zeros(nsurface,1);
		dfdqchosen{i}=zeros(nsurface,1);
		d2fdsigma2{i}=zeros(nstressvect,nstressvect);
		d2fdsigmadq{i}=zeros(nstressvect,nsurface);
		d2fdq2{i}=zeros(nsurface,nsurface);
	end
	for i=1:nstressvect
		sigma{1}(i,1)=sigma0(i,1);
	end
	
	chosensurface=0;
	chosensurface1=0;
	chosensurface2=0;
	justcracked=0;
	surfacehistory=zeros(1,nsurface);
	A1=0;
	A2=0;
	B=0;
	sigmaimplicitstart=zeros(nstressvect,1);
	sigmaimplicitstarttrial=zeros(nstressvect,1);
	sigmawidened=zeros(nstressvect,1);
	sigmaimp=zeros(nstressvect,1);
	sigmaimpn=zeros(nstressvect,1);
	deltalambda1ok=0;
	deltalambda2ok=0;
	alphafactchosen=0;
	deltaalpha1=0;
	deltaalpha2=0;
	deltaalphataken=0;
	deltalambdanice=0;
	deltalambdaguess=0;
	deltagamma=0;
	deltagamma1=0;
	deltagamma2=0;
	alphawidened=zeros(1,nsurface);
	alphaimplicitstart=zeros(1,nsurface);
	alphaimpn=zeros(1,nsurface);
	alphaimp=zeros(1,nsurface);
	q=zeros(1,nsurface);
	dqdalpha=zeros(1,nsurface);
	d2qdalpha2=zeros(1,nsurface);	
	qfordeltaT=0;
	last5surfaces=zeros(5,2);
	
	
	Comp=[1/Er -nurt/Et -nurl/El 0 0 0;
		-nurt/Et 1/Et -nutl/El 0 0 0;
		-nurl/El -nutl/El 1/El 0 0 0;
		0 0 0 1/Grt 0 0;
		0 0 0 0 1/Gtl 0;
		0 0 0 0 0 1/Grl];

	%{
	sigmarr=sigmatrial(1);
	sigmatt=sigmatrial(2);
	sigmall=sigmatrial(3);
	sigmart=sigmatrial(4);
	sigmatl=sigmatrial(5);
	sigmarl=sigmatrial(6);
	%}    
	
	%{
	for i=1:7
		deltagamma(i)=0;
	end
	%}
		
	C=Comp^-1;
	Cplanestrain=C;
	if planestressmod==1
		C=MatCondensor(Cplanestrain,[zdir yzdir xzdir]);
	elseif planestressmod==2
		C=MatCondensor(Cplanestrain,[ydir zdir xydir yzdir xzdir]);
	end
	C=k*C;
	Comp=Comp/k;
	%{
	if planestressmod
		C=zeros(6,6);
		for i=1:6
			if i==zdir|i==yzdir|i==xzdir
				continue;
			end
			if planestressmod==2
				if i==ydir|i==xydir
					continue;
				end
			end
			for j=1:6
				if j==zdir|j==yzdir|j==xzdir
					continue;
				end
				if planestressmod==2
					if j==ydir|j==xydir
						continue;
					end
				end
				C(i,j)=Cplanestrain(i,j);
			end
		end
	end
	%}
	
	%sigmastep(:,1)=transpose([0 0 0 0 0 0]);
	
	%sigmatrial{1}=zeros(6,1);
	
	
	%q{1}=transpose([0 0 0 0 0 0 0]);
	for j=1:length(alphahp)
		for i=1:nsurface
			alphahp{j}(i)=alpha_in(i);
		end
	end
	
	NormLimit=1e-5;
	%fstep=zeros(7,1);
	hardeningsurfaces=[1 2 3 4 5 6 7];
	%hardeningsurfaces=[1 3];
	
	q=[0 0 0 0 0 0 0];
	dqdalpha=[0 0 0 0 0 0 0];
	d2qdalpha2=[0 0 0 0 0 0 0];

	[q,~]=qandDfromalpha2(alphahp{1},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
	
	if 0
		%TDL wood viscoelastic damping here (before mat model)
		tandelta=0.03;
		omega=2*pi;
		%viscosity salsa: https://link.springer.com/article/10.1023/A:1017986119559
			%length is from 12 mm to 24 mm
			%thickness is 1.3 mm
			%width is 3 mm
		%strength salsa: https://link.springer.com/article/10.1007/BF02427975
		etadamp=0
		for ivoigtdir=1:3
			if 1 %application of elastoplasticity
				etadamp=max(0,C(ivoigtdir,ivoigtdir))*tandelta/omega;
				if 0 %reduction of damping due to plastic softening
					if ivoigtdir==1
						etadamp=etadamp*(1-q(1));
					elseif ivoigtdir==2
						etadamp=etadamp*(1-q(3));
					elseif ivoigtdir==3
						etadamp=etadamp*(1-q(5));
					end
				end
				sigma{1}(ivoigtdir)=sigma{1}(ivoigtdir)+etadamp*ddtepsilon(ivoigtdir);
			end
			if 0 %increase in strength due to high strain rate
				if abs(ddtepsilon(ivoigtdir))<0.001
					strengthfactor=1;
				else
					strengthfactor=max([1 (0.0542*log(abs(ddtepsilon(ivoigtdir)))+1.3654)]);
				end
				if ivoigtdir==1
					ftr=ftr*strengthfactor;
					fcr=fcr*strengthfactor;
				elseif ivoigtdir==2
					ftt=ftt*strengthfactor;
					fct=fct*strengthfactor;
				elseif ivoigtdir==3
					ftl=ftl*strengthfactor;
					fcl=fcl*strengthfactor;
				end
			end
		end
	end
	
	
	sigmatrial=sigma{1}+C*deltaepsilon+dk/k*sigma{1};
	evaltimes=evaltimes+2;
	[ftrial,~,~]=Wood_Schmidt_EvalSigmaEff(sigmatrial,q,hardeningsurfaces,[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
	[fprev,~,~]=Wood_Schmidt_EvalSigmaEff(sigma{1},q,hardeningsurfaces,[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
	elastic=1;
	if t_time>=3.2395443013820597322194316802779-dt/2 && t_time<=3.2395443013820597322194316802779+dt/2 && (spid==17 || spid==17)
		1;
	end
	%surfaceallpositiveproblem=zeros(7,1);
	%surfacevalallpositiveproblem=zeros(7,1);
	
	alphafact=zeros(1,7);
	for i=1:7
		if ftrial{i}>0 && ftrial{i}>fprev{i}
			alphafact(i)=(fprev{i}/(fprev{i}-ftrial{i}));
			elastic=0;
		else
			if ftrial{i}>0
				%disp(['Warning for spid=' num2str(spid) ': ftrial{' num2str(i) '}>0 but <fprev{' num2str(i) '}, special treatment is assumed']);
				%disp('Press any key to continue');
				%pause;
				alphafact(i)=-fprev{i};
				elastic=0;
				1;
			else
				alphafact(i)=1;
			end
		end
	end
	%if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
	%elseif CasetoRun==4
	%    elastic=1; %forces the system to remain elastic
	%end
	% force elastic here
	%if CasetoRun==4
	%    elastic=1;
	%end
	%if CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
	%    elastic=1;
	%end
	Rimp=zeros(8,1);
	if Debugging.Active && CloseEnough(t_time,Debugging.Time,1e-5,2) && spid==Debugging.Particle
        1;
	end
	if elastic
		substepiter=1;
		sigma{2}=sigmatrial;
		alphahp{2}=alphahp{2};
		substepiter=2;
	else
		alphafactchosen=min(alphafact);
		for i=1:7
			if alphafactchosen==alphafact(i)
				chosensurface=i;
				break;
			end
		end
		alphafactchosen=max(0,alphafactchosen);
		sigma{2}=sigma{1}+alphafactchosen*(C*deltaepsilon+dk/k*sigma{1});
		alphahp{2}=alphahp{1};
		deltaepsilone=(1-alphafactchosen)*deltaepsilon;
		deltasigmae=(1-alphafactchosen)*(C*deltaepsilon+dk/k*sigma{1});
		T=0;
		deltaT=1;
		substepiter=2;
		last5surfaces=zeros(5,2);
		consistentmultisurfaceconfirmed=0;
		implicithasfailed=0;
		stoprepeater=0;
		implicitsubstepfactor=10;
		implicitsubstepnumber=0;
		while substepiter<inf
			if deltaT<1e-4
				1;
			end
			if Debugging.Active && CloseEnough(t_time,Debugging.Time,1e-5,2) && spid==Debugging.Particle
				1;
				if substepiter>=2
					disp('plastic');
					substepiter;
					alphahp{2};
					stoprepeater=stoprepeater+1;
					stoprepeater;
					1;
					if consistentmultisurfaceconfirmed==1
						1;
					end
					if stoprepeater>=Debugging.DesignatedStopRepeater
						1;
					end
				end
			end
			
			if min(alphahp{2})<0
				fprintf('%s',['alphahp < zero found!' char(10)]);
				1;
				pause
				1;
			end
			if T==1
				[qtest,~]=qandDfromalpha2(alphahp{2},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
				evaltimes=evaltimes+1;
				[ftest,~]=Wood_Schmidt_EvalSigmaEff(sigma{2},qtest,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
				if CellMax(ftest)<NormLimit
					break
				else
					implicithasfailed=1;
					1;
				end
			elseif T>1
				fprintf('%s',['T>1' char(10)]);
				pause
			end
			deltaT=min(deltaT,1-T);
			sigma1=sigma{2};
			alpha1=alphahp{2};
			sigma1trial=sigma1+deltasigmae*deltaT;
			if consistentmultisurfaceconfirmed==1 && implicithasfailed==0
				if implicitsubstepnumber==0
					%disp('Implicit is a go!')
				end
				alphaimpn=alpha1;                
				alphaimp=alphaimpn;
				sigmaimpn=sigma1trial;
				%sigmaimp=transpose([0 0 0 0 0 0]);
				[q,dqdalpha,~]=qandDfromalpha2(alphaimpn,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
				evaltimes=evaltimes+1;
				[f,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigmaimpn,q,[chosensurface1 chosensurface2],[0 1 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
				
				deltagamma1startreference=transpose(dfdsigma{chosensurface1})*sigma1trial/(transpose(dfdsigma{chosensurface1})*C*dfdsigma{chosensurface1});
				deltagamma2startreference=transpose(dfdsigma{chosensurface2})*sigma1trial/(transpose(dfdsigma{chosensurface2})*C*dfdsigma{chosensurface2});

				deltagamma1=deltagamma1startreference;
				deltagamma2=deltagamma2startreference;
				
				sigmaimp=sigma1trial-C*(deltagamma1*dfdsigma{chosensurface1}+deltagamma2*dfdsigma{chosensurface2});
				
				alphaimp(chosensurface1)=alphaimpn(chosensurface1)+deltagamma1;
				alphaimp(chosensurface2)=alphaimpn(chosensurface2)+deltagamma2;
				alphaerrortracker=zeros(1,16);
				for alphaiteration=1:99999
					if alphaiteration==40
						implicithasfailed=1;
						break;
					end
					[q,dqdalpha,~]=qandDfromalpha2(alphaimp,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
					imperrortracker=zeros(1,16);
					for impiteration=1:100
						if impiteration==20
							implicithasfailed=1;
							break;
						end
						evaltimes=evaltimes+1;
						[f,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigmaimp,q,[chosensurface1 chosensurface2],[1 1 0 1 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
						Rimp(1:6,1)=sigmaimp-sigmaimpn+C*(deltagamma1*dfdsigma{chosensurface1}+deltagamma2*dfdsigma{chosensurface2});
						%Rimp(7,1)=alphaimp(chosensurface1)-alphaimpn(chosensurface1)-deltagamma1;
						%Rimp(8,1)=alphaimp(chosensurface2)-alphaimpn(chosensurface2)-deltagamma2;
						Rimp(7,1)=f{chosensurface1};
						Rimp(8,1)=f{chosensurface2};
						Err=sqrt(dot(Rimp,Rimp));
						for i=15:-1:1
							imperrortracker(i+1)=imperrortracker(i);
						end
						imperrortracker(1)=Err;
						if Err<NormLimit
							break
						end
						if impiteration>=16
							m=ManualLinReg([1:16],log(imperrortracker));
							if m<0
							%if imperrortracker(1)>sum(imperrortracker(2:5))/4;
								%disp('no error improvement, implicit newton terminated');
								implicithasfailed=1;
								break;
							end
						end
						J=zeros(8,8);
						J(1:6,1:6)=eye(6,6)+C*(deltagamma1*d2fdsigma2{chosensurface1}+deltagamma2*d2fdsigma2{chosensurface2});
						J(1:6,7)=C*dfdsigma{chosensurface1};
						J(1:6,8)=C*dfdsigma{chosensurface2};
						%J(7,7)=1;
						%J(8,8)=1;
						%J(7,9)=-1;
						%J(8,10)=-1;
						J(7,1:6)=transpose(dfdsigma{chosensurface1});
						J(8,1:6)=transpose(dfdsigma{chosensurface2});
						%J(9,7)=dqdalpha(chosensurface1);
						%J(10,8)=dqdalpha(chosensurface2);
						if rcond(J)<1e-15
							implicithasfailed=1;
							break;
						end
						deltaX=-(J^-1)*Rimp;
						sigmaimp=sigmaimp+deltaX(1:6,1);
						%alphaimp(chosensurface1)=alphaimp(chosensurface1)+deltaX(7,1);
						%alphaimp(chosensurface2)=alphaimp(chosensurface2)+deltaX(8,1);
						deltagamma1=deltagamma1+deltaX(7,1);
						deltagamma2=deltagamma2+deltaX(8,1);
						%if deltagamma1<0
							%{
							deltagamma1startreference=deltagamma1startreference*2;
							deltagamma1=deltagamma1startreference;
							sigmaimp=sigma1trial-C*(deltagamma1*dfdsigma{chosensurface1}+deltagamma2*dfdsigma{chosensurface2});
							alphaimp(chosensurface1)=alphaimpn(chosensurface1)+deltagamma1;
							%}
							%implicithasfailed=1;
							%break;
						%end
						%if deltagamma2<0
							%{
							deltagamma2startreference=deltagamma2startreference*2;
							deltagamma2=deltagamma2startreference;
							sigmaimp=sigma1trial-C*(deltagamma1*dfdsigma{chosensurface1}+deltagamma2*dfdsigma{chosensurface2});
							alphaimp(chosensurface2)=alphaimpn(chosensurface2)+deltagamma2;
							%}
							%implicithasfailed=1;
							%break;
						%end
						%{
						[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alphaimp);
						[f,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigmaimp,q,chosensurface,[1 1 1 1 0 0]);
						Rimp(1:6,1)=-epsilonpimp+epsilonpimpn+deltagamma*dfdsigma{chosensurface};
						Rimp(7,1)=-alphaimp(chosensurface)+alphaimpn(chosensurface)+deltagamma;
						if impiteration>1 & sqrt(dot(Rimp,Rimp))<NormLimit & f{chosensurface}<NormLimit
							break
						end
						Ainv=zeros(7,7);
						Ainv(1:6,1:6)=(C^-1)+deltagamma*d2fdsigma2{chosensurface};
						Ainv(7,7)=-(1/dqdalpha(chosensurface));
						Aimp=Ainv^-1;
						delta2gamma=(f{chosensurface}-[transpose(dfdsigma{chosensurface}) 1]*Aimp*Rimp)/([transpose(dfdsigma{chosensurface}) 1]*Aimp*[dfdsigma{chosensurface};1]);
						deltaepsilondeltaalpha=[C^-1 zeros(6,1);zeros(1,6) -(1/dqdalpha(chosensurface))]*Aimp*(Rimp+delta2gamma*[dfdsigma{chosensurface};1]);
						epsilonpimp=epsilonpimp+deltaepsilondeltaalpha(1:6);
						alphaimp(chosensurface)=alphaimp(chosensurface)+deltaepsilondeltaalpha(7);
						deltagamma=deltagamma+delta2gamma;
						%}
					end
					if implicithasfailed==1
						break;
					end
					alphaimp1new=alphaimpn(chosensurface1)+deltagamma1;
					alphaimp2new=alphaimpn(chosensurface2)+deltagamma2;
					alphaerror=sqrt((alphaimp(chosensurface1)-alphaimp1new)^2+(alphaimp(chosensurface2)-alphaimp2new)^2);
					for i=15:-1:1
						alphaerrortracker(i+1)=alphaerrortracker(i);
					end
					alphaerrortracker(1)=alphaerror;
					alphaimp(chosensurface1)=alphaimp1new;
					alphaimp(chosensurface2)=alphaimp2new;
					if alphaerror<NormLimit
						break;
					end
					if alphaiteration>=16
						m=ManualLinReg([1:16],log(alphaerrortracker));
						if m<0
						%if alphaerrortracker(1)>alphaerrortracker(5)
							%disp('no error improvement, alpha iteration terminated');
							implicithasfailed=1;
							break;
						end
					end
				end
				if implicithasfailed==1
					if implicitsubstepnumber<=4
						%disp('Implicit Didnt converge, substepping');
						deltaT=min(deltaT/implicitsubstepfactor,1-T);
						implicithasfailed=0;
						implicitsubstepnumber=implicitsubstepnumber+1;
					else
						%disp('Implicit Didnt converge, switching back');
						implicithasfailed=1;
					end
					continue;
				end
				sigma{3}=sigmaimp;
				alphahp{3}=alphaimp;
				if deltagamma1>min(0,-alphaimp(chosensurface1)*NormLimit) && deltagamma2>min(0,-alphaimp(chosensurface2)*NormLimit)
					substepiter=substepiter+1;
					sigma{2}=sigma{3};
					alphahp{2}=alphahp{3};
					T=T+deltaT;
					deltaT=min(1-T,deltaT*min(1.5,10^(implicitsubstepnumber)));
					implicitsubstepnumber=implicitsubstepnumber-(log(1.5)/log(10));
				else
					%disp('deltagamma less than zero!')
					if implicitsubstepnumber<=4
						%disp('Implicit Didnt converge, substepping');
						deltaT=min(deltaT/implicitsubstepfactor,1-T);
						implicithasfailed=0;
						implicitsubstepnumber=implicitsubstepnumber+1;
					else
						%disp('Implicit Didnt converge, switching back')
						implicithasfailed=1;
					end
					1;
				end
				continue;
			end
			[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alpha1,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
			evaltimes=evaltimes+2;
			[f10,~]=Wood_Schmidt_EvalSigmaEff(sigma1,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
			[f1trial,~]=Wood_Schmidt_EvalSigmaEff(sigma1trial,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
			elastic=1;
			for i=1:7
				if f1trial{i}>0 && f1trial{i}>f10{i}
					alphafact(i)=(f10{i}/(f10{i}-f1trial{i}));
					elastic=0;
				else
					if f1trial{i}>0
						%disp(['Warning for spid=' num2str(spid) ': f1trial{' num2str(i) '}>0 but <f10{' num2str(i) '}, special treatment is assumed']);
						%disp('Press any key to continue');
						%pause;
						alphafact(i)=-f10{i};
						elastic=0;
						1;
					else
						alphafact(i)=1;
					end
				end
			end
			if elastic
				%disp('Turns Out to be Elastic on deltalambda1');
				deltalambda1=0;
				deltalambdanice=0;
				deltasigmanice=0;
				sigma{3}=sigma1trial;
				T=T+deltaT;
				alphahp{3}=alphahp{2};
				substepiter=substepiter+1;
				sigma{2}=sigma{3}; %packaged with substepiter++
				alphahp{2}=alphahp{3}; %packaged with substepiter++
				qfordeltaT=2;
				deltaT=deltaT*qfordeltaT;
				continue;
			else
				alphafactchosen=min(alphafact);
				if alphafactchosen~=1
					for i=1:7
						if alphafactchosen==alphafact(i)
							chosensurface=i;
						end
					end
				end
				alphafactchosen=max(0,alphafactchosen);
				evaltimes=evaltimes+1;
				[DUMMY,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigma1,q,chosensurface,[0 1 1 1 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
				A1=-dfdqchosen{chosensurface}(chosensurface)*dqdalpha(chosensurface);
				%A1=-dfdqchosen{chosensurface}(chosensurface)*dqdalpha(chosensurface)*([1 1 1 1 1 1])*dfdsigma{chosensurface};
				B=transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface};
				%deltalambda1=(transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,(2*deltaT/(1-T))*f10{chosensurface}))/(A1+B);
				deltalambda1=(transpose(dfdsigma{chosensurface})*deltasigmae*deltaT)/(A1+B);
				deltalambdanice=f10{chosensurface}/(A1+B);
				deltasigmanice=-C*deltalambdanice*dfdsigma{chosensurface};
				chosensurface1=chosensurface;
			end
			%recalculating dfdsigma and dfdq
			
			%end of recalculating dfdsigma and dfdq
			
			%deltalambdadrift=f10{chosensurface};
			%deltalambda1=(transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,deltaT*fprev{chosensurface}))/(A1+B);
			deltalambda1ok=1;
			if deltalambda1<0
				%disp('deltalambda1<0!')
				if A1+B<0
					%disp('A<B!')
					%deltaTbackup=deltaT;
					%deltaT=0;
					%printvector(substepiter,'substepiter');
					%printvector(chosensurface,'chosensurface');
					%printvector(alphafactchosen,'alphafactchosen');
					%printvector(sigma{2},'sigma{2}');
					%printvector(alphahp{2},'alphahp{2}');
					%uisave;
					Aq1=0.5*transpose(C*dfdsigma{chosensurface})*(d2fdsigma2{chosensurface})*(C*dfdsigma{chosensurface})+0.5*d2qdalpha2(chosensurface);
					%Bq1=dqdalpha(chosensurface)-transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}-transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*(deltasigmae*deltaT);
					%Cq1=transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,(2*deltaT/(1-T))*f10{chosensurface})+0.5*transpose(deltasigmae*deltaT)*d2fdsigma2{chosensurface}*(deltasigmae*deltaT);
					%Cq1=transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,deltaT*fprev{chosensurface})+0.5*transpose(deltasigmae*deltaT)*d2fdsigma2{chosensurface}*(deltasigmae*deltaT);
					Pq1=(-transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae)^2+(-2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*C*dfdsigma{chosensurface}-2*d2qdalpha2(chosensurface))*(1/2)*transpose(deltasigmae)*d2fdsigma2{chosensurface}*deltasigmae;
					Qq1=2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae*(transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}-dqdalpha(chosensurface))+(-2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*C*dfdsigma{chosensurface}-2*d2qdalpha2(chosensurface))*transpose(dfdsigma{chosensurface})*deltasigmae;
					Rq1=(-transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}+dqdalpha(chosensurface))^2+(-2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*C*dfdsigma{chosensurface}-2*d2qdalpha2(chosensurface))*f10{chosensurface};
					if Rq1<=0
						deltalambda1=0;
					else
						Kq1=-(Pq1/(2*sqrt(Rq1))-Qq1^2/(8*Rq1*sqrt(Rq1)))/(2*Aq1);
						Lq1a=(transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae-Qq1/(2*sqrt(Rq1)))/(2*Aq1);
						Lq1b=(transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae+Qq1/(2*sqrt(Rq1)))/(2*Aq1);
						Lq1=max(Lq1a,Lq1b);
						Mq1=(transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}-dqdalpha(chosensurface)-sqrt(Rq1))/(2*Aq1);
						%deltalambda1=(-Bq1-sqrt(Bq1^2-4*Aq1*Cq1))/(2*Aq1);
						%deltalambda1=Kq1*deltaT^2+Lq1*deltaT+Mq1;
						%deltalambda1=Kq1*deltaT^2+Lq1*deltaT+(200*deltaT/(1-T))*Mq1;
						%deltalambda1=Kq1*deltaT^2+Lq1*deltaT;
						deltalambda1=Lq1*deltaT;
						if deltalambda1<0
							deltalambda1=0;
						end
					end
					%deltalambdadrift=Mq1;
					%disp('deltalambda1 not ok');
					deltalambda1ok=0;
				else
					deltalambda1=0;
				end
			end
			
			%intermediate for calculating alphahp nice
			deltasigma1=deltasigmae*deltaT-deltalambda1*C*dfdsigma{chosensurface};
			deltaalpha1=[0 0 0 0 0 0 0];
			deltaalpha1(chosensurface)=deltalambda1;
			% start of deltalambdaok
			%if deltalambda1ok
			sigma2=sigma1+deltasigma1;
			alpha2=alpha1+deltaalpha1;
			[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alpha2,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
			evaltimes=evaltimes+1;
			[f20,~]=Wood_Schmidt_EvalSigmaEff(sigma2,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
			%alphanice=f20{chosensurface}/f10{chosensurface};
			%deltalambda1=deltalambda1+alphanice*deltalambdadrift;
			%deltasigmanice=-deltalambdadrift*C*dfdsigma{chosensurface}
			%end of intermediate for calculating alphahp nice
			
			%deltasigma1=deltasigmae*deltaT-deltalambda1*C*dfdsigma{chosensurface};
			%deltaalpha1=[0 0 0 0 0 0 0];
			%deltaalpha1(chosensurface)=deltalambda1;
			% start of deltalambdaok
			%if deltalambda1ok
			%sigma2=sigma1+deltasigma1;%+alphanice*deltasigmanice;
			%alpha2=alpha1+deltaalpha1;%+alphanice*deltalambdadrift;
			%[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alpha2);
			%[f20,dfdsigma,dfdqchosen,~]=Wood_Schmidt_EvalSigmaEff(sigma2,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
			sigma2trial=sigma2+deltasigmae*deltaT;
			evaltimes=evaltimes+1;
			[f2trial,~]=Wood_Schmidt_EvalSigmaEff(sigma2trial,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
			elastic=1;
			for i=1:7
				if f2trial{i}>0 && f2trial{i}>f20{i}
					alphafact(i)=(f20{i}/(f20{i}-f2trial{i}));
					elastic=0;
				else
					if f2trial{i}>0
						%disp(['Warning for spid=' num2str(spid) ': f2trial{' num2str(i) '}>0 but <f20{' num2str(i) '}, special treatment is assumed']);
						%disp('Press any key to continue');
						%pause;
						alphafact(i)=-f20{i};
						elastic=0;
						1;
					else
						alphafact(i)=1;
					end
				end
				
			end
			if elastic
				%disp('Turns Out to be Elastic on deltalambda2');
				deltalambda2=0;
			else
				alphafactchosen=min(alphafact);
				if alphafactchosen~=1
					for i=1:7
						if alphafactchosen==alphafact(i)
							chosensurface=i;
						end
					end
				end
				if implicithasfailed && deltaT<1e-3
					chosensurface=chosensurface1;
				end
				alphafactchosen=max(0,alphafactchosen);
				evaltimes=evaltimes+1;
				[DUMMY,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigma2,q,chosensurface,[0 1 1 1 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
				A2=-dfdqchosen{chosensurface}(chosensurface)*dqdalpha(chosensurface);
				%A2=-dfdqchosen{chosensurface}(chosensurface)*dqdalpha(chosensurface)*([1 1 1 1 1 1])*dfdsigma{chosensurface};
				B=transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface};
				%deltalambda2=(transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,(2*deltaT/(1-T))*f20{chosensurface}))/(A2+B);
				deltalambda2=(transpose(dfdsigma{chosensurface})*deltasigmae*deltaT)/(A2+B);
				%deltalambda2=(transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,deltaT*fprev{chosensurface}))/(A2+B);
				chosensurface2=chosensurface;
			end
			deltalambda2ok=1;


			if deltalambda2<0
				%disp('deltalambda2<0!')
				if A2+B<0
					%printvector(substepiter,'substepiter');
					%printvector(chosensurface,'chosensurface');
					%printvector(alphafactchosen,'alphafactchosen');
					%printvector(sigma{2},'sigma{2}');
					%printvector(alphahp{2},'alphahp{2}');
					Aq2=0.5*transpose(C*dfdsigma{chosensurface})*(d2fdsigma2{chosensurface})*(C*dfdsigma{chosensurface})+0.5*d2qdalpha2(chosensurface);
					%Bq2=dqdalpha(chosensurface)-transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}-transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*(deltasigmae*deltaT);
					%Cq2=transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,(2*deltaT/(1-T))*f20{chosensurface})+0.5*transpose(deltasigmae*deltaT)*d2fdsigma2{chosensurface}*(deltasigmae*deltaT);
					%Cq2=transpose(dfdsigma{chosensurface})*deltasigmae*deltaT+max(0,deltaT*fprev{chosensurface})+0.5*transpose(deltasigmae*deltaT)*d2fdsigma2{chosensurface}*(deltasigmae*deltaT);
					Pq2=(-transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae)^2+(-2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*C*dfdsigma{chosensurface}-2*d2qdalpha2(chosensurface))*(1/2)*transpose(deltasigmae)*d2fdsigma2{chosensurface}*deltasigmae;
					Qq2=2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae*(transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}-dqdalpha(chosensurface))+(-2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*C*dfdsigma{chosensurface}-2*d2qdalpha2(chosensurface))*transpose(dfdsigma{chosensurface})*deltasigmae;
					Rq2=(-transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}+dqdalpha(chosensurface))^2+(-2*transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*C*dfdsigma{chosensurface}-2*d2qdalpha2(chosensurface))*f20{chosensurface};
					if Rq2<=0
						deltalambda2=0;
					else
						Kq2=-(Pq2/(2*sqrt(Rq2))-Qq2^2/(8*Rq2*sqrt(Rq2)))/(2*Aq2);
						Lq2a=(transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae-Qq2/(2*sqrt(Rq2)))/(2*Aq2);
						Lq2b=(transpose(C*dfdsigma{chosensurface})*d2fdsigma2{chosensurface}*deltasigmae+Qq2/(2*sqrt(Rq2)))/(2*Aq2);
						Lq2=max(Lq2a,Lq2b);
						Mq2=(transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface}-dqdalpha(chosensurface)-sqrt(Rq2))/(2*Aq2);
						%deltalambda1=(-Bq1-sqrt(Bq1^2-4*Aq2*Cq2))/(2*Aq2);
						%deltalambda1=Kq2*deltaT^2+Lq2*deltaT+Mq2;
						%deltalambda2=Kq2*deltaT^2+Lq2*deltaT+(200*deltaT/(1-T))*Mq2;
						%deltalambda2=Kq2*deltaT^2+Lq2*deltaT;
						%deltalambda2ok=0;
						deltalambda2=Lq2*deltaT;
						if deltalambda2<0
							deltalambda2=0;
						end
					end
					%disp('deltalambda2 not ok');
					deltalambda2ok=0;
					%uisave;
				else
					deltalambda2=0;
				end
			end
			%if deltalambda2ok
			deltasigma2=deltasigmae*deltaT-deltalambda2*C*dfdsigma{chosensurface};
			deltaalpha2=[0 0 0 0 0 0 0];
			deltaalpha2(chosensurface)=deltalambda2;%+alphanice*deltalambdadrift;
			E=0.5*(-deltasigma1+deltasigma2);
			
			sigma{3}=sigma{2}+0.5*(deltasigma1+deltasigma2);
			if deltalambda1ok && deltalambda2ok && (deltaT>0 || deltalambdanice>0)
				sigma{3}=sigma{3}+deltasigmanice;
				R=sqrt(dot(E,E))/sqrt(dot(sigma{3},sigma{3}));
			else
				sigmaimplicitstart=sigma{3};
				R=sqrt(dot(E,E))/sqrt(dot(sigma{3}+deltasigmanice,sigma{3}+deltasigmanice));
			end
			
			if chosensurface1~=0
				surfacehistory(chosensurface1)=1;
			end
			if chosensurface2~=0
				surfacehistory(chosensurface2)=1;
			end

			%{
			if sqrt(dot(deltasigmanice,deltasigmanice))>1;
				1;
			end
			%}
			
			%end
			%else
			%    sigma{3}=sigma{2}+deltasigma1;
			%    R=0;
			%end
				
			% end of delta lambda OK
			
			if R>NormLimit
				qfordeltaT=max(0.8*sqrt(NormLimit/R),0.1);
				deltaT=deltaT*qfordeltaT;
				%disp(['deltaT reduced to ' num2str(deltaT)]);
			else
				T=T+deltaT;
				if deltalambda1ok & deltalambda2ok && (deltaT>0 || deltalambdanice>0)
				%if deltalambda1ok
					deltaalphataken=0.5*(deltaalpha1+deltaalpha2);
					alphahp{3}=alphahp{2}+deltaalphataken;
					deltalambdanice=max([deltalambdanice -deltaalphataken(chosensurface1)]);
					alphahp{3}(chosensurface1)=alphahp{3}(chosensurface1)+deltalambdanice;
				%else
				%    alphahp{3}=alphahp{2}+(deltaalpha1);
				%end
				else
					alphaimplicitstart=alphahp{2}+0.5*(deltaalpha1+deltaalpha2);
					[q,~]=qandDfromalpha2(alphaimplicitstart,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
					evaltimes=evaltimes+1;
					[fimplicitstart,~]=Wood_Schmidt_EvalSigmaEff(sigmaimplicitstart,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);

					sigmaimplicitstarttrial=sigmaimplicitstart+deltasigmae*deltaT;
					evaltimes=evaltimes+1;
					[fimplicitstarttrial,~]=Wood_Schmidt_EvalSigmaEff(sigmaimplicitstarttrial,q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
					for i=1:7
						if fimplicitstarttrial{i}<=0
							alphafact(i)=1;
						else
							alphafact(i)=(fimplicitstart{i}/(fimplicitstart{i}-fimplicitstarttrial{i}));
							if alphafact(i)>1
								alphafact(i)=-fimplicitstarttrial{i};
							end
						end
					end
					if chosensurface1==chosensurface2
						chosensurface=chosensurface1;
					elseif deltalambda1ok==0 && deltalambda2ok==1
						chosensurface=chosensurface1;
					elseif deltalambda1ok==1 && deltalambda2ok==0
						chosensurface=chosensurface2;
					else
						alphafactchosen=min(alphafact);
						if alphafactchosen~=1
							for i=1:7
								if alphafactchosen==alphafact(i)
									chosensurface=i;
								end
							end
						end
					end
					surfacehistory(chosensurface)=1;
					%{
					if chosensurface1==chosensurface2
						chosensurface=chosensurface1;
					else
						if deltalambda1ok==0 & deltalambda2ok==0
							disp('warning: ambiguous choice of chosensurface for implicit correction');
							uisave;
							chosensurface=chosensurface2;
						elseif deltalambda1ok==0
							chosensurface=chosensurface1;
						elseif deltalambda2ok==0
							chosensurface=chosensurface2;
						else
							disp('unexpected error here');
							uisave;
						end
					end
					%}
					1;
					% start of deltalambda guess (alphahp-widening)
					if CellMax(fimplicitstart)>0
						[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alphaimplicitstart,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
						evaltimes=evaltimes+1;
						[fimplicitstart,dfdsigma,dfdqchosen,~]=Wood_Schmidt_EvalSigmaEff(sigmaimplicitstart,q,chosensurface,[1 1 1 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
						if deltaT==0
							deltalambdaguess=1.1*transpose(dfdsigma{chosensurface})*deltaepsilone*(NormLimit^2)/(transpose(dfdsigma{chosensurface})*dfdsigma{chosensurface});
						else
							deltalambdaguess=1.1*transpose(dfdsigma{chosensurface})*deltaepsilone*deltaT/(transpose(dfdsigma{chosensurface})*dfdsigma{chosensurface});
						end
						if deltalambdaguess<=0
							%disp('deltalambdaguess<0!')
							if deltaT==0
								deltalambdaguess=-0.1*transpose(dfdsigma{chosensurface})*deltaepsilone*(NormLimit^2)/(transpose(dfdsigma{chosensurface})*dfdsigma{chosensurface});
							else
								deltalambdaguess=-0.1*transpose(dfdsigma{chosensurface})*deltaepsilone*deltaT/(transpose(dfdsigma{chosensurface})*dfdsigma{chosensurface});
							end
							%deltalambdaguess=-0.1*transpose(dfdsigma{chosensurface})*deltaepsilone*deltaT/(transpose(dfdsigma{chosensurface})*dfdsigma{chosensurface});
						end
						for wideningiteration=1:99999
							alphawidened=alphaimplicitstart;
							alphawidened(chosensurface)=alphaimplicitstart(chosensurface)+deltalambdaguess;
							sigmawidened=sigmaimplicitstart-C*deltalambdaguess*dfdsigma{chosensurface};
							[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alphawidened,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
							evaltimes=evaltimes+1;
							[fimplicitstart,dfdsigma,~]=Wood_Schmidt_EvalSigmaEff(sigmawidened,q,chosensurface,[1 1 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
							if fimplicitstart{chosensurface}<0
								break
							else
								deltalambdaguess=deltalambdaguess*1.1;
							end
						end
						
						% end of deltalambda guess
					end
					
					% start of implicit iteration
					%{
					epsilontimp=epsilont+T*deltaepsilon;
					epsiloneimp=(C^-1)*sigmaimplicitstart;
					epsilonpimpn=epsilontimp-epsiloneimp;
					epsilonpimp=epsilontimp-epsiloneimp;
					%}
					alphaimpn=alphaimplicitstart;                
					alphaimp=alphawidened;
					sigmaimpn=sigmaimplicitstart;
					sigmaimp=sigmawidened;
					deltagamma=0;
					for impiteration=1:99999
						[q,dqdalpha,~]=qandDfromalpha2(alphaimp,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
						evaltimes=evaltimes+1;
						[f,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigmaimp,q,chosensurface,[1 1 0 1 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
						Rimp(1:6,1)=sigmaimp-sigmaimpn+C*deltagamma*dfdsigma{chosensurface};
						Rimp(7,1)=alphaimp(chosensurface)-alphaimpn(chosensurface)-deltagamma;
						Rimp(8,1)=f{chosensurface};
						Err=sqrt(dot(Rimp,Rimp));
						if Err<NormLimit
							break
						end
						J=zeros(8,8);
						J(1:6,1:6)=eye(6,6)+C*deltagamma*d2fdsigma2{chosensurface};
						J(1:6,8)=C*dfdsigma{chosensurface};
						J(7,7)=1;
						J(7,8)=-1;
						J(8,1:6)=transpose(dfdsigma{chosensurface});
						J(8,7)=dqdalpha(chosensurface);
						deltaX=-(J^-1)*Rimp;
						sigmaimp=sigmaimp+deltaX(1:6,1);
						alphaimp(chosensurface)=alphaimp(chosensurface)+deltaX(7,1);
						deltagamma=deltagamma+deltaX(8,1);
						%{
						[q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alphaimp);
						[f,dfdsigma,dfdqchosen,d2fdsigma2,~]=Wood_Schmidt_EvalSigmaEff(sigmaimp,q,chosensurface,[1 1 1 1 0 0]);
						Rimp(1:6,1)=-epsilonpimp+epsilonpimpn+deltagamma*dfdsigma{chosensurface};
						Rimp(7,1)=-alphaimp(chosensurface)+alphaimpn(chosensurface)+deltagamma;
						if impiteration>1 & sqrt(dot(Rimp,Rimp))<NormLimit & f{chosensurface}<NormLimit
							break
						end
						Ainv=zeros(7,7);
						Ainv(1:6,1:6)=(C^-1)+deltagamma*d2fdsigma2{chosensurface};
						Ainv(7,7)=-(1/dqdalpha(chosensurface));
						Aimp=Ainv^-1;
						delta2gamma=(f{chosensurface}-[transpose(dfdsigma{chosensurface}) 1]*Aimp*Rimp)/([transpose(dfdsigma{chosensurface}) 1]*Aimp*[dfdsigma{chosensurface};1]);
						deltaepsilondeltaalpha=[C^-1 zeros(6,1);zeros(1,6) -(1/dqdalpha(chosensurface))]*Aimp*(Rimp+delta2gamma*[dfdsigma{chosensurface};1]);
						epsilonpimp=epsilonpimp+deltaepsilondeltaalpha(1:6);
						alphaimp(chosensurface)=alphaimp(chosensurface)+deltaepsilondeltaalpha(7);
						deltagamma=deltagamma+delta2gamma;
						%}
					end
					sigma{3}=sigmaimp;
					alphahp{3}=alphaimp;

					% end of implicit iteration
				end
				substepiter=substepiter+1;
				sigma{2}=sigma{3}; %packaged with substepiter++
				alphahp{2}=alphahp{3}; %packaged with substepiter++
				%if deltalambda1ok
					qfordeltaT=min(0.8*sqrt(NormLimit/R),2);
					deltaT=deltaT*qfordeltaT;
				%else
				%    deltaT=deltaTbackup;
				%end
			end
			if chosensurface1>0 && chosensurface2>0 && chosensurface1~=chosensurface2
				for i=size(last5surfaces,1):-1:2
					last5surfaces(i,:)=last5surfaces(i-1,:);
				end
				if chosensurface1<chosensurface2
					last5surfaces(1,1)=chosensurface1;
					last5surfaces(1,2)=chosensurface2;
				else
					last5surfaces(1,1)=chosensurface2;
					last5surfaces(1,2)=chosensurface1;
				end
				%disp(['different surfaces carried out, ' num2str(chosensurface1) ' and ' num2str(chosensurface2) ', deltaT=' num2str(deltaT)]);
				consistentmultisurfaceconfirmed=1;
				for i=2:size(last5surfaces,1)
					if last5surfaces(1,1)~=last5surfaces(i,1) || last5surfaces(1,2)~=last5surfaces(i,2)
						consistentmultisurfaceconfirmed=0;
						break;
					end
				end
			end
			%{
			implicitsubstepnumber=0;
			implicithasfailed=0;
			%}
			if consistentmultisurfaceconfirmed==1 && implicithasfailed==0
				deltaT=1-T;
			end
		end
	end
		
	1;
	
	%hardeningsurfacesoriginal=hardeningsurfaces;
	
	%iteration=0;
	%{
	substepnum=10;
	deltaepsilonsubstep=deltaepsilon/substepnum;
	
	
	for substepiter=1:substepnum
		%deltaepsilon=transpose([1*sin(step/100*2*pi) 1*cos(step/100*2*pi) 1/100*step 1*sin(step/100*2*pi) 1*cos(step/100*2*pi) 1/100*step])/1000;
		[q,Dcut]=qandDfromalpha(alphahp{2},hardeningsurfaces);
		sigmatrial=sigma{2}+C*deltaepsilonsubstep;
		evaltimes=evaltimes+2;
		[ftrial,~,~]=Wood_Schmidt_EvalSigmaHardening(sigmatrial,q,hardeningsurfaces);
		[fprev,~,~]=Wood_Schmidt_EvalSigmaHardening(sigma{2},q,hardeningsurfaces);
		elastic=1;
		for i=1:7
			if ftrial{i}<=0
				alphafact(i)=1;
			%elseif fprev{i}<=0 & ftrial{i}>0
			%    alphafact(i)=(fprev{i}/(fprev{i}-ftrial{i}));
			%else
			%    alphafact(i)=0;
			else
				alphafact(i)=(fprev{i}/(fprev{i}-ftrial{i}));
				elastic=0;
			end
		end
		if elastic
			sigma{3}=sigmatrial;
			alphahp{3}=alphahp{2};
		else
			alphafactchosen=min(alphafact);
			for i=1:7
				if alphafactchosen==alphafact(i)
					chosensurface=i;
					break;
				end
			end
			alphafactchosen=max(0,alphafactchosen);
			sigmaalpha=sigma{2}+(sigmatrial-sigma{2})*alphafactchosen;
			[q,Dchosen]=qandDfromalpha(alphahp{2},chosensurface);
			[DUMMY,dfdsigma,dfdqchosen,~]=Wood_Schmidt_EvalSigmaHardening(sigmaalpha,q,chosensurface);
			A=dfdqchosen{chosensurface}*Dchosen;
			deltaepsilonsubstepalpha=deltaepsilonsubstep*(1-alphafactchosen);
			deltalambda=transpose(dfdsigma{chosensurface})*C/(A+transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface})*deltaepsilonsubstepalpha;
			if deltalambda<0
				disp('deltalambda<0!')
				printvector(substepiter,'substepiter');
				printvector(chosensurface,'chosensurface');
				printvector(alphafactchosen,'alphafactchosen');
				printvector(sigma{2},'sigma{2}');
				printvector(alphahp{2},'alphahp{2}');
				pause
			end
			Cp=C*dfdsigma{chosensurface}*transpose(dfdsigma{chosensurface})*C/(A+transpose(dfdsigma{chosensurface})*C*dfdsigma{chosensurface});
			Cep=C-Cp;
			alphahp{3}=alphahp{2};
			alphahp{3}(chosensurface)=alphahp{2}(chosensurface)+deltalambda;
			sigma{3}=sigmaalpha+Cep*deltaepsilonsubstepalpha;
		end
	end
	%}
	[q,~]=qandDfromalpha2(alphahp{2},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);
	evaltimes=evaltimes+1;
	[f_final,~]=Wood_Schmidt_EvalSigmaEff(sigma{2},q,[1 2 3 4 5 6 7],[1 0 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);
	[f_maxfinal,surfacewithfmax]=CellMax(f_final);
	f_final_vect=zeros(1,7);
	for i=1:7
		f_final_vect(i)=f_final{i};
	end
	epsilone=Comp*sigma{2};
	epsilont=epsilont+deltaepsilon;
	epsilonp=epsilont-epsilone;
	epsilonp_planestrain=epsilonp;
	if planestressmod
		epsilonp=zeros(6,1);
		for i=1:6
			if i==zdir||i==yzdir||i==xzdir
				continue;
			end
			if planestressmod==2
				if i==ydir||i==xydir
					continue;
				end
			end
			epsilonp(i,1)=epsilonp_planestrain(i,1);
		end
	end
	epsilont=epsilone+epsilonp;

	1;

	%{
	disp('From Previous Step')
	printvector(sigma0,'sigma');
	printvector(epsilonp{step},'epsilonp')
	printvector(epsilont{step}-epsilonp{step},'epsilone');
	printvector(epsilont{step},'epsilont');
	printvector(alphahp{step},'alphahp');
	print11cell(fprev,'f');
	disp(' ')
	printvector(deltaepsilon,'applying deltaepsilon');

	for i=1:7
		if ftrial{i}>0
			elastic=0;
			suspectedsurfaces=[suspectedsurfaces i];
		end
	end
	if elastic
		for i=1:6
			sigma(i,1)=sigmatrial(i);
			%sigmastep(i,step+1)=sigmatrial(i);
		end
		for i=1:7
			fstep(i,step+1)=ftrial{i};
		end
	else
		activesurface=suspectedsurfaces;
		for shediter=1:length(suspectedsurfaces)
			for i=1:length(activesurface)
				reversedactivesurface(1+length(activesurface)-i)=activesurface(i);
			end
			%activesurface=reversedactivesurface;
			sigma=sigmatrial;
			deltagamma=[];
			for i=1:length(activesurface)
				deltagamma(i)=0;
			end
			%start of iteration
			%hardeningsurfaces=[];
			
			
			[q,Dcut]=qandDfromalpha(alphahp{step+1},hardeningsurfaces);
			[f, dfdsigma, dfdqcut, d2fdsigma2, d2fdsigmadqcut, d2fdq2cut]=Wood_Schmidt_EvalSigmaHardening(sigma,q,hardeningsurfaces);
			%q=[ 0.33427665424966501728221146549913, -0.0077191419876790618273584205447933, 0, -0.0077191419876790618273584205447933, 0, -0.10020040080160320641282565130261, -0.0077191419876790618273584205447933];
			%q=[ 0.95, -0.0077191419876790618273584205447933, 0, -0.0077191419876790618273584205447933, 0, -0.10020040080160320641282565130261, -0.0077191419876790618273584205447933];
			%sigma=transpose([0 0 0 0 0 0])
			%sigma=sigma-C*(dfdsigma{1}*0.0037143167443528112177386635295306);
			disp(' ')
			disp('Guess #1, assuming all elastic, deltaepsilone=deltaepsilon')
			
			
	%start of wojtek print
	
	printvector(sigma,'sigma')
	printvector(epsilonp{step+1},'epsilonp')
	printvector(epsilont{step+1}-epsilonp{step+1},'epsilone')
	printvector(epsilont{step+1},'epsilont')
	printvector(alphahp{step+1},'alphahp',activesurface)
	print11cell(f,'f',activesurface)

	%end of wojtek print
			disp(' ');
			disp('Guess #2, assuming all plastic, deltaeisplonp=deltaepsilon');
			
	
			for i=1:length(activesurface)
				%deltagamma(alphaiter)=transpose(deltaepsilon)*dfdsigma{1}/(transpose(dfdsigma{1})*dfdsigma{1});
				deltagamma(i)=f{activesurface(i)}/(transpose(C*dfdsigma{activesurface(i)})*dfdsigma{activesurface(i)});
				alphahp{step+1}(activesurface(i))=alphahp{step}(activesurface(i))+deltagamma(i);
				disp(['best guess of deltaalpha for ' surfacenumtoname(activesurface(i)) ' (surface #' num2str(activesurface(i)) ') = ' num2str(alphahp{step+1}(activesurface(i)))]);
			end

			%start of backforthloop
			for backforthloop=1:999
				%start of alphaexpansion loop
				disp(' ');
				disp(' ');
				disp(['trial #' num2str(backforthloop)]);
				for alphaiter=1:length(activesurface)
					disp([' ']);
					disp(['active surface ' num2str(alphaiter) '/' num2str(length(activesurface)) ' : ' surfacenumtoname(activesurface(alphaiter)) ' (#' num2str(activesurface(alphaiter)) ')']);
					if f{activesurface(alphaiter)}<=0
						disp(' ')
						disp(['f{' num2str(activesurface(alphaiter)) '} already less than zero'])
						disp(['sticking with alphahp(' num2str(activesurface(alphaiter)) ')=' num2str(alphahp{step+1}(activesurface(alphaiter)))]);
						continue
					end
					
					disp(' ')
					%disp(['trial #' num2str(alphaguesstry2)]);
					alphaguesstry2=[];
					alphahp{step+1}(activesurface(alphaiter))=alphahp{step}(activesurface(alphaiter))+deltagamma(alphaiter);
					[q,~]=qandDfromalpha(alphahp{step+1},hardeningsurfaces);
					deltaepsilonp=transpose([0 0 0 0 0 0]);
					for i=1:length(activesurface)
						deltaepsilonp=deltaepsilonp+deltagamma(i)*dfdsigma{activesurface(i)};
					end
					epsilonp{step+1}=epsilonp{step}+deltaepsilonp;
					sigma=sigmatrial-C*deltaepsilonp;
					[f,dfdsigma]=Wood_Schmidt_EvalSigmaHardening(sigma,q,hardeningsurfaces);

					%start of wojtek print

					printvector(sigma,'sigma')
					printvector(epsilonp{step+1},'epsilonp')
					printvector(epsilont{step+1}-epsilonp{step+1},'epsilone')
					printvector(epsilont{step+1},'epsilont')
					printvector(alphahp{step+1},'alphahp',activesurface)
					print11cell(f,'f',activesurface)


					%end of wojtek print

					if f{(activesurface(alphaiter))}<0
						disp(' ')
						disp(['take alphahp(' num2str(activesurface(alphaiter)) ')=' num2str(alphahp{step+1}(activesurface(alphaiter)))]);
						break
					else
						deltagamma(alphaiter)=deltagamma(alphaiter)*1.2;
						disp(['multiplying deltaalpha of surface ' num2str(alphaiter) '/' num2str(length(activesurface)) ' by 1.2'])
						alphahp{step+1}(activesurface(alphaiter))=alphahp{step}(activesurface(alphaiter))+deltagamma(alphaiter);
						printvector(alphahp{step+1},'alphahp',activesurface)
					end
				end        
				%end of alphahp expansion loop
				alphaexpansionbreaksignal=1;
				for i=1:length(activesurface)
					if f{activesurface(i)}>0
						alphaexpansionbreaksignal=0;
					end
				end
				if alphaexpansionbreaksignal==1
					disp('all f are < 0');
					break
				end
			end
			%end of backforthloop
			%sigma=transpose([0 0 0 0 0 0]);
			disp(' ')
			texttodisplay=['starting newton-rhapson from guess #2, initial sigma=['];
			for i=1:length(sigma);
				if i>1
					texttodisplay=[texttodisplay ','];
				end
				texttodisplay=[texttodisplay num2str(sigma(i))];
			end
			texttodisplay=[texttodisplay ']'];
			disp(texttodisplay);
			deltagamma=zeros(1,length(activesurface));
			alphahp{step+1}=alphahp{step};
			[q,~]=qandDfromalpha(alphahp{step+1},hardeningsurfaces);
			for iteration=1:999
				if step==94
				end
				[f, dfdsigma, dfdqcut, d2fdsigma2, d2fdsigmadqcut, d2fdq2cut]=Wood_Schmidt_EvalSigmaHardening(sigma,q,hardeningsurfaces);
				sigmadeltagammadfdsigmadfdq=zeros(6+length(hardeningsurfaces),1);
				for i=1:length(activesurface)
					sigmadeltagammadfdsigmadfdq=sigmadeltagammadfdsigmadfdq+deltagamma(i)*[dfdsigma{activesurface(i)};dfdqcut{activesurface(i)}];
				end
				epsilonandalphavector=[-epsilonp{step+1}+epsilonp{step}];
				for i=1:length(hardeningsurfaces)
					epsilonandalphavector=[epsilonandalphavector;-alphahp{step+1}(hardeningsurfaces(i))+alphahp{step}(hardeningsurfaces(i))];
				end
				R=epsilonandalphavector+sigmadeltagammadfdsigmadfdq;
				BigR=[R];
				for i=1:length(activesurface);
					BigR=[BigR;f{activesurface(i)}];
				end
				Norm=sqrt(dot(BigR,BigR));
				%disp(['Norm=' num2str(Norm)]);
				if length(activesurface)>1
				end
				Cep=Cepcalc(C,deltagamma,dfdsigma,d2fdsigma2,activesurface);
				if Norm<NormLimit
					break
				end
				%Calculating A
				sigmadeltagammad2fdsigma2dsigmadqdqdsigmadq2=zeros(length(epsilonandalphavector),length(epsilonandalphavector));
				for i=1:length(activesurface)
					sigmadeltagammad2fdsigma2dsigmadqdqdsigmadq2=sigmadeltagammad2fdsigma2dsigmadqdqdsigmadq2+deltagamma(i)*[d2fdsigma2{activesurface(i)} d2fdsigmadqcut{activesurface(i)};transpose(d2fdsigmadqcut{activesurface(i)}) d2fdq2cut{activesurface(i)}];
				end
				Ainv=[C^-1 zeros(6,length(hardeningsurfaces));zeros(length(hardeningsurfaces),6) Dcut^-1]+sigmadeltagammad2fdsigma2dsigmadqdqdsigmadq2;
				A=Ainv^-1;
				Gdown=[];
				Gup=[];
				if step==30
				end
				for alphaindex=1:length(activesurface)
					for beta=1:length(activesurface)
						Gdown(alphaindex,beta)=transpose([dfdsigma{activesurface(alphaindex)};dfdqcut{activesurface(alphaindex)}])*A*[dfdsigma{activesurface(beta)};dfdqcut{activesurface(beta)}];
						%Gup(alphaindex,beta)=1/Gdown(alphaindex,beta);
					end
				end
				Gup=Gdown^-1;
				delta2gamma=[];
				for alphaindex=1:length(activesurface)
					delta2gamma(alphaindex)=0;
					for beta=1:length(activesurface)
						delta2gamma(alphaindex)=delta2gamma(alphaindex)+Gup(alphaindex,beta)*(f{activesurface(beta)}-transpose([dfdsigma{activesurface(beta)};dfdqcut{activesurface(beta)}])*A*R);
					end
				end
				if delta2gamma>0 & iteration==1
					if length(activesurface)==1
						if activesurface==[1];
						end
					end
				end
				deltagamma=deltagamma+delta2gamma;
				shedsignal=0;
				newactivesurface=[];
				%{
				for i=1:length(deltagamma)
					if deltagamma(i)<0
						shedsignal=1;
					else
						newactivesurface=[newactivesurface activesurface(i)];
					end
				end
				if shedsignal==1
					activesurface=newactivesurface;
					break
				end
				%}
				sigmadelta2gammadfdsigmadfdq=zeros(length(epsilonandalphavector),1);
				for beta=1:length(activesurface)
					sigmadelta2gammadfdsigmadfdq=sigmadelta2gammadfdsigmadfdq+delta2gamma(beta)*[dfdsigma{activesurface(beta)};dfdqcut{activesurface(beta)}];
				end
				deltaepsilonpdeltaalpha=[C^-1 zeros(6,length(hardeningsurfaces));zeros(length(hardeningsurfaces),6) Dcut^-1]*A*(R+sigmadelta2gammadfdsigmadfdq);
				deltaepsilonp=deltaepsilonpdeltaalpha(1:6);
				epsilonp{step+1}=epsilonp{step+1}+deltaepsilonp;
				epsilone=epsilont{step+1}-epsilonp{step+1};
				deltaalpha=zeros(7,1);
				for i=1:length(hardeningsurfaces)
					deltaalpha(hardeningsurfaces(i))=deltaepsilonpdeltaalpha(6+i);
					alphahp{step+1}(hardeningsurfaces(i))=alphahp{step+1}(hardeningsurfaces(i))+deltaalpha(hardeningsurfaces(i));
				end
				if iteration==1
					%alphahp{step+1}(1)=alphahp{step}(1)+deltagamma(1);
				end
				%hardeningsurfaces=hardeningsurfacesoriginal;
				
				
	
				
				[q,Dcut]=qandDfromalpha(alphahp{step+1},hardeningsurfaces);
				sigma=C*epsilone;
				
				%start of wojtek display
				disp(' ')
				
		texttodisplay=['step=' num2str(step+1) '; '];
		texttodisplay=[texttodisplay 'iteration=' num2str(iteration) '; '];
		texttodisplay=[texttodisplay 'deltaepsilonmag=' num2str(sqrt(dot(deltaepsilon,deltaepsilon))*100) '%; '];
			disp(texttodisplay)
		texttodisplay=[];
		
		printvector(sigma,'sigma')
		if elastic==0
			printvector(activesurface,'activesurface')
			print11cell(f,'f',activesurface);
			printvector(deltagamma,'deltagamma')
			
		end
		printvector(epsilonp{step+1},'epsilonp')
		printvector(epsilont{step+1}-epsilonp{step+1},'epsilone')
		printvector(epsilont{step+1},'epsilont')
		printvector(alphahp{step+1},'alphahp',activesurface)
				%end of wojtek display
			end
			if shedsignal==1
				continue
			end
			%end of iteration
			breaksignal=1;
			newactivesurface=activesurface;
			%{
			newactivesurface=[];
			for i=1:length(deltagamma)
				if deltagamma(i)<0
					breaksignal=0;
				else
					newactivesurface=[newactivesurface activesurface(i)];
				end
			end
			%}
			if breaksignal
				for i=1:6
					%sigmastep(i,step+1)=sigma(i);
				end
				for i=1:7
					fstep(i,step+1)=f{i};
				end
				break
			else
				activesurface=newactivesurface;
				if length(activesurface)==0
					disp('All Surfaces Shedded, Didnt Converge');
					pause;
				end
			end
		end
	end
	%}
	
	
	sigma_global_big(1)=sigma{2}(xdir);
	sigma_global_big(2)=sigma{2}(ydir);
	sigma_global_big(3)=sigma{2}(zdir);
	sigma_global_big(4)=sigma{2}(xydir);
	sigma_global_big(5)=sigma{2}(yzdir);
	sigma_global_big(6)=sigma{2}(xzdir);
	

	sigma_local_big=sigma{2};
	s_sp=zeros(1,3);
	s_sp(1)=sigma_global_big(1);
	s_sp(2)=sigma_global_big(2);
	s_sp(3)=sigma_global_big(4);
	%fprintf('%s',['inside, s_sp(1,1)=' float2scitxt(6,s_sp(1,1)) char(10)]);
	
	e_t_global_big(1)=epsilont(xdir);
	e_t_global_big(2)=epsilont(ydir);
	e_t_global_big(3)=epsilont(zdir);
	e_t_global_big(4)=epsilont(xydir);
	e_t_global_big(5)=epsilont(yzdir);
	e_t_global_big(6)=epsilont(xzdir);


	e_pl_global_big(1)=epsilonp(xdir);
	e_pl_global_big(2)=epsilonp(ydir);
	e_pl_global_big(3)=epsilonp(zdir);
	e_pl_global_big(4)=epsilonp(xydir);
	e_pl_global_big(5)=epsilonp(yzdir);
	e_pl_global_big(6)=epsilonp(xzdir);
	
	e_pl=zeros(1,3);
	e_pl(1)=e_pl_global_big(1);
	e_pl(2)=e_pl_global_big(2);
	e_pl(3)=e_pl_global_big(4);

	alpha_out=alphahp{2};%alpha_out is alphahp{2}, alphahp{2} is the alpha value (hardening parameter) at the next time step, it's in the form of vector.
	activesurfacelist=zeros(1,100);
	coder.varsize('activesurfacelist');
	%start Calculating tangent stiffness matrix
	%if (isnan(thetacrackrtl) || isinf(thetacrackrtl)) && max(alpha_out)>0
	activesurfacelist=zeros(1,0);
	for i=1:length(surfacehistory)
		if surfacehistory(i)==1
			activesurfacelist=[activesurfacelist i];
		end
	end

	if length(activesurfacelist)==0
		Ktangent_local=C;
	else
		[q,dqdalpha,~]=qandDfromalpha2(alpha_out,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit);

		dqdalphamat=zeros(length(activesurfacelist));
		for i=1:length(activesurfacelist)
			dqdalphamat(i,i)=dqdalpha(activesurfacelist(i));
		end

		dfdsigmamat=zeros(length(sigma_local_big),length(activesurfacelist));
		[~, dfdsigma,~]=Wood_Schmidt_EvalSigmaEff(sigma_local_big,q,activesurfacelist,[1 1 0 0 0 0],ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun);

		for i=1:length(sigma_local_big)
			for j=1:length(activesurfacelist)
				dfdsigmamat(i,j)=dfdsigma{activesurfacelist(j)}(i);
			end
		end

		Ktangent_local=C*(eye(length(sigma_local_big))-dfdsigmamat*(transpose(dfdsigmamat)*C*dfdsigmamat-dqdalphamat)^(-1)*transpose(dfdsigmamat)*C);
	end
	
	
	if 0
		%TDL wood viscoelastic damping here (after mat model)
		tandelta=0;
		omega=2*pi;
		%salsa: https://link.springer.com/article/10.1023/A:1017986119559
		for ivoigtdir=1:3
			etadamp=max(0,Ktangent_local(ivoigtdir,ivoigtdir))*tandelta/omega;
			sigma{2}(ivoigtdir)=sigma{2}(ivoigtdir)+etadamp*ddtepsilon(ivoigtdir);
		end
	end
	
	sigma_global_big(1)=sigma{2}(xdir);
	sigma_global_big(2)=sigma{2}(ydir);
	sigma_global_big(3)=sigma{2}(zdir);
	sigma_global_big(4)=sigma{2}(xydir);
	sigma_global_big(5)=sigma{2}(yzdir);
	sigma_global_big(6)=sigma{2}(xzdir);
	

	sigma_local_big=sigma{2};
	s_sp=zeros(1,3);
	s_sp(1)=sigma_global_big(1);
	s_sp(2)=sigma_global_big(2);
	s_sp(3)=sigma_global_big(4);
	%fprintf('%s',['inside, s_sp(1,1)=' float2scitxt(6,s_sp(1,1)) char(10)]);
	
	Ktangent_global=zeros(size(Ktangent_local));
	for i=1:length(dirglobal)
		for j=1:length(dirglobal)
			Ktangent_global(i,j)=Ktangent_local(dirglobal(i),dirglobal(j));
		end
	end

	reductiondesignatorvoight=[1 2 4];

	Ktangent_global_2D=zeros(length(reductiondesignatorvoight),length(reductiondesignatorvoight));

	for i=1:length(reductiondesignatorvoight)
		for j=1:length(reductiondesignatorvoight)
			Ktangent_global_2D(i,j)=Ktangent_global(reductiondesignatorvoight(i),reductiondesignatorvoight(j));
		end
	end
	
	voigt=cell(1,6);
	tensor=cell(3,3,3,3);
	
	voigt{1}=[1 1];
	voigt{2}=[2 2];
	voigt{3}=[3 3];
	voigt{4}=[1 2];
	voigt{5}=[2 3];
	voigt{6}=[1 3];

	for i=1:6
		for j=1:6
			tensor{voigt{i}(1),voigt{i}(2),voigt{j}(1),voigt{j}(2)}=[i j];
			tensor{voigt{i}(1),voigt{i}(2),voigt{j}(2),voigt{j}(1)}=[i j];
			tensor{voigt{i}(2),voigt{i}(1),voigt{j}(1),voigt{j}(2)}=[i j];
			tensor{voigt{i}(2),voigt{i}(1),voigt{j}(2),voigt{j}(1)}=[i j];
		end
	end

	Ktangent_global_tens=zeros(3,3,3,3);
	for i=1:3
		for j=1:3
			for k=1:3
				for l=1:3
					Ktangent_global_tens(i,j,k,l)=Ktangent_global(tensor{i,j,k,l}(1),tensor{i,j,k,l}(2));
				end
			end
		end
	end

	
	reductiondesignatortensor=[1 2];
	Ktangent_global_tens_2D=zeros(length(reductiondesignatortensor),length(reductiondesignatortensor),length(reductiondesignatortensor),length(reductiondesignatortensor));

	for i=1:length(reductiondesignatortensor)
		for j=1:length(reductiondesignatortensor)
			for k=1:length(reductiondesignatortensor)
				for l=1:length(reductiondesignatortensor)
					Ktangent_global_tens_2D(i,j,k,l)=Ktangent_global_tens(reductiondesignatortensor(i),reductiondesignatortensor(j),reductiondesignatortensor(k),reductiondesignatortensor(l));
				end
			end
		end
	end
	
	s_sp_tens_2D=zeros(2,2);
	s_sp_tens_2D(1,1)=s_sp(1);
	s_sp_tens_2D(2,2)=s_sp(2);
	s_sp_tens_2D(1,2)=s_sp(3);
	s_sp_tens_2D(2,1)=s_sp(3);
	
	sigmacrosseye=zeros(2,2,2,2); %it's 2D mkay?
	eyecrosser=eye(2);
	
	for i=1:2
		for j=1:2
			for k=1:2
				for l=1:2
					sigmacrosseye(i,j,k,l)=s_sp_tens_2D(i,j)*eyecrosser(k,l);
				end
			end
		end
	end
	
	AbeforeQ_rtl=Ktangent_global_tens_2D+sigmacrosseye; %_rtl designates it's been transformed from pure local to rtl adjusted, or 1 stage up from pure local, see 3 stage transformation, reverse 1 stage
	
	%start of adding bogus outputs 
	thetamin=NaN;
	lambdamin=0;
	%justcracked already assigned in the first 200 lines
	thetamin=0;
	ntestedangle=36;%TDL this is dangerous for memory allocation, proper clean up of output variables required 
	Qacoustic=zeros(2,2,ntestedangle);
	h=zeros(2,2,ntestedangle);
	%end of adding bogus outputs
		
	if analyseparticle
		if (isnan(thetacrackrtl) || isinf(thetacrackrtl)) && max(alpha_out)>0
			lambdamin=inf;
			thetamin=NaN;
			ntestedangle=36*1*1*1;
			lambda1=zeros(ntestedangle,1);
			lambda2=zeros(ntestedangle,1);
			theta=zeros(ntestedangle,1);
			n=zeros(2,1);
			h=zeros(2,2,ntestedangle); %1st index: direction; 2nd index: which lambda; 3rd index: which angle
			Qacoustic=zeros(2,2,ntestedangle);
			for i=1:ntestedangle
				if CasetoRun==81
					theta(i)=i/ntestedangle*pi;
				else
					theta(i)=i/ntestedangle*2*pi; %change your checked angle here!
				end
				n(1)=cos(theta(i));
				n(2)=sin(theta(i));
				for m=1:2
					for nn=1:2
						for o=1:2
							for p=1:2
								Qacoustic(nn,o,i)=Qacoustic(nn,o,i)+n(m)*AbeforeQ_rtl(m,nn,o,p)*n(p);
							end
						end
					end
				end
				[h_eig,lambda_eig]=eig(Qacoustic(:,:,i));
				h(:,:,i)=real(h_eig);
				lambda1(i)=real(lambda_eig(1,1));
				lambda2(i)=real(lambda_eig(2,2));
			end
			lambdamin=min([lambda1;lambda2]);
			if length(lambdamin)>1
				fprintf('%s',['length(lamdabmin)>1!' char(10)]);
				pause;
				1;
			end
			if lambdamin>0
				thetacrackrtl=NaN;
			else
				localminima1index=zeros(1,0);
				localminima2index=zeros(1,0);
				for i=1:ntestedangle
					if lambda1(i)<0 && lambda1(i)<=lambda1(mod((i-1)-1,ntestedangle)+1) && lambda1(i)<=lambda1(mod((i+1)-1,ntestedangle)+1)
						localminima1index=[localminima1index i];
					end
					if lambda2(i)<0 && lambda2(i)<=lambda2(mod((i-1)-1,ntestedangle)+1) && lambda2(i)<=lambda2(mod((i+1)-1,ntestedangle)+1)
						localminima2index=[localminima2index i];
					end
				end
				nldudxhl=zeros(length(localminima1index)+length(localminima2index),1);
				h_localminima=zeros(2,length(localminima1index)+length(localminima2index));
				for i=1:length(localminima1index)
					n(1)=cos(theta(localminima1index(i)));
					n(2)=sin(theta(localminima1index(i)));
					nldudxhl(i)=real(transpose(n)*dudx_rtl*h(:,1,localminima1index(i)));
					h_localminima(:,i)=h(:,1,localminima1index(i));
				end
				for i=1:length(localminima2index)
					n(1)=cos(theta(localminima2index(i)));
					n(2)=sin(theta(localminima2index(i)));
					nldudxhl(i+length(localminima1index))=real(transpose(n)*dudx_rtl*h(:,2,localminima2index(i)));
					h_localminima(:,i+length(localminima1index))=h(:,2,localminima2index(i));
				end
				localminimaindex=[localminima1index localminima2index];
				FindMaxnldudxhl=FindMax(nldudxhl); %I put FindMax(nldudxhl) to a variable FindMaxnldudxhl as I need to call it twice. Better to save the result rather than calling the function twice.
				crackindex=localminimaindex(FindMaxnldudxhl);
				thetamin=theta(crackindex);
				h_crackdecision=zeros(size(h_localminima,1),1);
				h_crackdecision(:,1)=h_localminima(:,FindMaxnldudxhl);
				thetacrackrtl=mod(thetamin+pi/2+pi/2,pi)-pi/2;
				justcracked=1;
				1;
			end
		else
			%used to be empty bogus definitions	
		end
	end
	
	%end Calculating tangent stiffness matrix
	
	%{
	disp(' ')
		texttodisplay=['step=' num2str(step+1) '; '];
		texttodisplay=[texttodisplay 'iteration=' num2str(iteration) '; '];
		texttodisplay=[texttodisplay 'deltaepsilonmag=' num2str(sqrt(dot(deltaepsilon,deltaepsilon))*100) '%; '];
			disp(texttodisplay)
		
		printvector(sigma,'sigma')
		if elastic==0
			printvector(activesurface,'activesurface')
			print11cell(f,'f',activesurface)
		end
		printvector(deltagamma,'deltagamma')
		printvector(epsilonp{step+1},'epsilonp')
		printvector(epsilont{step+1}-epsilonp{step+1},'epsilone')
		printvector(epsilont{step+1},'epsilont')
		if elastic
			printvector(alphahp{step+1},'alphahp')
		else
			printvector(alphahp{step+1},'alphahp',activesurface)
		end
			
	%}
	%end function of Wood_Schmidt17
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MatOut=MatCondensor(MatIn,CondensedIndex)
	ThrowSwitch=zeros(1,size(MatIn,1));
	for i=1:length(CondensedIndex);
		ThrowSwitch(CondensedIndex(i))=1;
	end
	UncondensedIndex=zeros(1,size(MatIn,1)-length(CondensedIndex));
	icount=1;
	for i=1:length(ThrowSwitch);
		if ThrowSwitch
			continue;
		end
		UncondensedIndex(icount)=i;
		icount=icount+1;
	end
	TopLeft=zeros(size(MatIn,1)-length(CondensedIndex));
	TopRight=zeros(size(MatIn,1)-length(CondensedIndex),length(CondensedIndex));
	BottomLeft=zeros(length(CondensedIndex),size(MatIn,2)-length(CondensedIndex));
	BottomRight=zeros(length(CondensedIndex),length(CondensedIndex));
	for i=1:length(UncondensedIndex)
		for j=1:length(UncondensedIndex)
			TopLeft(i,j)=MatIn(UncondensedIndex(i),UncondensedIndex(j));
		end
		for j=1:length(CondensedIndex)
			TopRight(i,j)=MatIn(UncondensedIndex(i),CondensedIndex(j));
		end
	end
	for i=1:length(CondensedIndex)
		for j=1:length(UncondensedIndex)
			BottomLeft(i,j)=MatIn(CondensedIndex(i),UncondensedIndex(j));
		end
		for j=1:length(CondensedIndex)
			BottomRight(i,j)=MatIn(CondensedIndex(i),CondensedIndex(j));
		end
	end
	MatNew=TopLeft-TopRight*(BottomRight^-1)*BottomLeft;
	MatOut=zeros(size(MatIn,1));
	for i=1:length(UncondensedIndex)
		for j=1:length(UncondensedIndex)
			MatOut(UncondensedIndex(i),UncondensedIndex(j))=MatNew(i,j);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MatOut=MatCondensor_old201807031046(MatIn,CondensedIndex)
	MatCurrent=MatIn;
	for IndexIter=1:length(CondensedIndex)
		MatCut=zeros(size(MatCurrent,1));
		ReductorComponentA=zeros(size(MatCut,1),1);
		ReductorComponentB=zeros(1,size(MatCut,1));
		for i=1:size(MatCurrent,1)
			if i==CondensedIndex(IndexIter)
				continue;
			end
			ReductorComponentA(i,1)=MatCurrent(i,CondensedIndex(IndexIter));
			ReductorComponentB(i)=MatCurrent(CondensedIndex(IndexIter),i);
			for j=1:size(MatCurrent,2)
				if j==CondensedIndex(IndexIter)
					continue;
				end
				MatCut(i,j)=MatCurrent(i,j);
			end
		end
		MatCurrent=MatCut-1/MatCurrent(CondensedIndex(IndexIter),CondensedIndex(IndexIter))*ReductorComponentA*ReductorComponentB;
	end
	MatOut=MatCurrent;
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [LOC,LOCC,cellCount,nodeCount]=Grid_Generation(NN,le)
	%% Generate the structured grid

	% Input
	% NN(1): number of nodes in X direction
	% NN(2): number of nodes in Y direction
	% le(1): element size in X direction
	% le(2): element size in X direction

	% Output
	% nodeCount: total number of nodes
	% cellCount: total number of elements
	% LOC(n,1:2): localtion coordinate of node "n" in x(1) and y(2) direction
	% LOCC(e,1:2): localtion coordinate of element centroid "e" in x(1) and y(2) direction

	%% Grid generation
	cellCount	           = (NN(1)-1)*(NN(2)-1);              % number of elements
	nodeCount	           = NN(1)*NN(2);                      % number of nodes
	LOC	                 = zeros(NN(1)*NN(2),2);             % zero matrix of all nodal coordinate

	LOCX	                = [0:NN(1)-1]'*le(1);               % Location of all nodes in X direction
	LOCY	                = [0:NN(2)-1]'*le(2);               % Location of all nodes in Y direction
	
	LOCC	                = zeros(cellCount,2);
	LOCCX	               = [0:(NN(1)-1)-1]'*le(1)+le(1)/2;   % Location of cells in X direction
	LOCCY	               = [0:(NN(2)-1)-1]'*le(2)+le(2)/2;   % Location of cells in X direction

	for i=1:NN(2)
		LOC((1+NN(1)*(i-1)):(NN(1)*(i-1)+NN(1)),1) = LOCX;	  % generate the X node position in LOC
	end

	for i=1:NN(2)
		LOC((NN(1)*(i-1))+1:NN(1)*i,2) = LOCY(i);	           % generate the Y node position in LOC
	end

	for i=1:NN(2)-1
		LOCC((1+(NN(1)-1)*(i-1)):((NN(1)-1)*(i-1)+(NN(1)-1)),1) = LOCCX;	    % generate the X element position in LOCC
	end

	for i=1:NN(2)-1
		LOCC(((NN(1)-1)*(i-1))+1:(NN(1)-1)*i,2) = LOCCY(i);	                 % generate the Y element position in LOCC
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [LOC,LOCC,cellCount,nodeCount,LOCX,LOCY,le_c]=Grid_Generation_var(NN,le_x,le_y)
	%% Generate the structured grid
	
	% Input
	% NN(1): number of nodes in X direction
	% NN(2): number of nodes in Y direction
	% le(1): element size in X direction
	% le(2): element size in X direction
	
	% Output
	% nodeCount: total number of nodes
	% cellCount: total number of elements
	% LOC(n,1:2): localtion coordinate of node "n" in x(1) and y(2) direction
	% LOCC(e,1:2): localtion coordinate of element centroid "e" in x(1) and y(2) direction
	
	%% Grid generation
	cellCount	           = (NN(1)-1)*(NN(2)-1);              % number of elements
	nodeCount	           = NN(1)*NN(2);                      % number of nodes
	LOC	                 = zeros(NN(1)*NN(2),2);             % zero matrix of all nodal coordinate
	LOCC	                = zeros(cellCount,2);
	le_c	                = zeros(cellCount,2);
	LOCX	                = zeros(NN(1),1);
	LOCY	                = zeros(NN(2),1);
	LOCCX	               = zeros(NN(1)-1,1);
	LOCCY	               = zeros(NN(2)-1,1);
	
	LOCX(1)=0;
	LOCY(1)=0;
	
	for i=1:NN(1)-1
		LOCX(i+1)=LOCX(i)+le_x(i);	      % Location of all nodes in X direction
		LOCCX(i)=LOCX(i)+le_x(i)/2;	     % Location of cells in X direction
	end
	
	for i=1:NN(2)-1
		LOCY(i+1)=LOCY(i)+le_y(i);	      % Location of all nodes in Y direction
		LOCCY(i)=LOCY(i)+le_y(i)/2;	     % Location of cells in Y direction
	end
	
	for i=1:NN(2)
		LOC((1+NN(1)*(i-1)):(NN(1)*(i-1)+NN(1)),1) = LOCX;	  % generate the X node position in LOC
	end
	
	for i=1:NN(2)
		LOC((NN(1)*(i-1))+1:NN(1)*i,2) = LOCY(i);	           % generate the Y node position in LOC
	end
	
	for i=1:NN(2)-1
		LOCC((1+(NN(1)-1)*(i-1)):((NN(1)-1)*(i-1)+(NN(1)-1)),1) = LOCCX;	    % generate the X element position in LOCC
	end
	
	for i=1:NN(2)-1
		LOCC(((NN(1)-1)*(i-1))+1:(NN(1)-1)*i,2) = LOCCY(i);	                 % generate the Y element position in LOCC
	end
	
	
	for i=1:length(le_y)
		for j=1:length(le_x)
			le_c((i-1)*length(le_x)+j,1)=le_x(j);
			le_c((i-1)*length(le_x)+j,2)=le_y(i);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [nfbcx,nfbcy,fbcx,fbcy]=Compute_Boundary_Nodes(nodeCount,LOC,x_max,x_min,y_max,y_min)
	% Input
	% nodeCount: total number of nodes
	% LOC(n,1:2): localtion coordinate of node "n" in x(1) and y(2) direction

	% Output
	% nfbcx: number of boundary nodes in X direction
	% nfbcy: number of boundary nodes in Y direction
	% fbcx: index of all boundary nodes in X direction
	% fbcy: index of all boundary nodes in Y direction


	nfbcx	               = 0              ;  % initial number of fixed nodes in x direction
	nfbcy	               = 0              ;  % initial number of fixed nodes in y direction
	fbcx = zeros(1,0); fbcy = zeros(1,0);	   % vector store the index of boundary nodes

	for n=1:nodeCount
		if LOC(n,1)<=x_min || LOC(n,1)>=x_max
			nfbcx = nfbcx+1;
			fbcx = [fbcx n];
		end
	end

	for n=1:nodeCount
		if LOC(n,2)<=y_min || LOC(n,2)>=y_max
			nfbcy = nfbcy+1;
			fbcy = [fbcy n];
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%{
%switchable1
function initial_figure = Plot_Initial_var(x_sp,LOC,LOCX,LOCY,orientationoffset,xdirletter,ydirletter,lp)
	initial_figure=figure;
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	lp_take=sum(sum(lp))/(size(lp,1)*size(lp,2));
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			continue
		end
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',LOCX);
	set(gca,'ytick',LOCY);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_linehighlighted2(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp)
	initial_figure=figure;
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
			LineColor='red';
			CircColor='green';
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			LineColor='red';
			CircColor='green';
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
			LineColor='black';
			CircColor='black';
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			LineColor='black';
			CircColor='black';
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			plot(x_sp(i,1),x_sp(i,2),'o','Color','Blue');
			continue;
		end
		plot(x_sp(i,1),x_sp(i,2),'o','Color',CircColor);
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color',LineColor);
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_squishy2(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,matmodel)
	initial_figure=figure;
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			if matmodel(i)==2
				plot(x_sp(i,1),x_sp(i,2),'o','Color','Blue');
			elseif matmodel(i)==3
				plot(x_sp(i,1),x_sp(i,2),'o','Color','Cyan');
			end
			continue;
		end
		plot(x_sp(i,1),x_sp(i,2),'o','Color','Green');
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:inf:max(LOC(:,1))])
	set(gca,'ytick',[0:inf:max(LOC(:,2))])
	set(initial_figure,'Position',[2560 0 1000 1600]);
	set(gca,'color','none')
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_squishy(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,matmodel)
	initial_figure=figure;
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			if matmodel(i)==2
				plot(x_sp(i,1),x_sp(i,2),'o','Color','Blue');
			elseif matmodel(i)==3
				plot(x_sp(i,1),x_sp(i,2),'o','Color','Cyan');
			end
			continue;
		end
		plot(x_sp(i,1),x_sp(i,2),'o','Color','Green');
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_linehighlighted(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp)
	initial_figure=figure;
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			plot(x_sp(i,1),x_sp(i,2),'o','Color','Blue');
			continue;
		end
		plot(x_sp(i,1),x_sp(i,2),'o','Color','Green');
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp)
	initial_figure=figure;
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			continue;
		end
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_crackmulti(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,x_crack,CasetoRun)
	initial_figure=figure;
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			continue;
		end
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	%{
	for i=1:length(x_crack)
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			plot(x_crack{i}(:,1),x_crack{i}(:,2),'-','Color','Black','LineWidth',2);
		else
			plot(x_crack{i}(:,1),x_crack{i}(:,2),'-o','Color','Green');
		end
	end
	%}
	for ipath=1:x_crack.npaths
		if ipath==1
			plot(x_crack.center(1:x_crack.nparticles(ipath),1,ipath),x_crack.center(1:x_crack.nparticles(ipath),2,ipath),'displayname','Initial Crack','color','black','LineWidth',2)
		else
			plot(x_crack.center(1:x_crack.nparticles(ipath),1,ipath),x_crack.center(1:x_crack.nparticles(ipath),2,ipath),'HandleVisibility','off','color','black','LineWidth',2)
		end
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_crackmulti_r_sp(r1_sp,r2_sp,x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp,x_crack,CasetoRun)
	initial_figure=figure;
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			continue;
		end
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	spCount=length(orientationoffset);
	%{
	for i=1:length(x_crack)
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			plot(x_crack{i}(:,1),x_crack{i}(:,2),'-','Color','Black','LineWidth',2);
		else
			plot(x_crack{i}(:,1),x_crack{i}(:,2),'-o','Color','Green');
		end
	end
	%}
	for ipath=1:x_crack.npaths
		if ipath==1
			plot(x_crack.center(1:x_crack.nparticles(ipath),1,ipath),x_crack.center(1:x_crack.nparticles(ipath),2,ipath),'displayname','Initial Crack','color','black','LineWidth',2)
		else
			plot(x_crack.center(1:x_crack.nparticles(ipath),1,ipath),x_crack.center(1:x_crack.nparticles(ipath),2,ipath),'HandleVisibility','off','color','black','LineWidth',2)
		end
	end
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end
	for sp=1:spCount
		x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
		y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
		plot(x_cor,y_cor,'r')
	end



	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function initial_figure = Plot_Initial_sp(x_sp,LOC,le,orientationoffset,xdirletter,ydirletter,lp)
	initial_figure=figure;
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
		if length(xdirletter{i})==1 && xdirletter{i}=='l'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
		elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
			orientationoffset(i)=orientationoffset(i)+pi/2;
		else
			continue;
		end
		xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(orientationoffset(i));
		xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(orientationoffset(i));
		ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(orientationoffset(i));
		yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(orientationoffset(i));
		plot([xstart xend],[ystart yend],'color','red');
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,156]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):156]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end
%}
%switchable1
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [N,dN1,dN2]=linearshape(xp,xn,Lx,Ly)


if abs(xp(1)-xn(1))<Lx 
	
	Nx = 1-abs(xp(1)-xn(1))/Lx;    
	dNx = -sign(xp(1)-xn(1))/Lx;
else
	Nx = 0;
	dNx = 0;
end

if abs(xp(2)-xn(2))<Ly 
	Ny = 1-abs(xp(2)-xn(2))/Ly;     
	dNy = -sign(xp(2)-xn(2))/Ly;
else
	Ny = 0;
	dNy = 0;
end


	N = Nx*Ny;
	dN1 = dNx*Ny;
	dN2 = Nx*dNy;
   
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [x_crack,x_cracktop,x_crackbot] = UpdateCrackPosition2(x_crack,x_cracktop,x_crackbot,nmass_si,nmomentum_si,Nmatrix_crack,Nmatrix_cracktop,Nmatrix_crackbot,dt,Nmatrix,v_ssp_out,m_sp,nfbcx,nfbcy,fbcx,fbcy)
	
	Nmatrixtop=Nmatrix(:,:,1)+Nmatrix(:,:,2);
	Nmatrixbot=Nmatrix(:,:,1)+Nmatrix(:,:,3);
	%nmatrixtop/nmatrixbot: for mapping variables from real particles to background grid appropriate for calculating velocity for updating top/bottom crack particle positions
	
	nmass_si_comb=zeros(size(nmass_si,1));
	nmass_si_top=zeros(size(nmass_si,1));
	nmass_si_bot=zeros(size(nmass_si,1));
	
	v_si_comb=zeros(size(nmass_si,1),2);
	v_si_top=zeros(size(nmass_si,1),2);
	v_si_bot=zeros(size(nmass_si,1),2);
	
	nmomentum_si_top=zeros(size(Nmatrixtop,1),2);
	nmomentum_si_bot=zeros(size(Nmatrixbot,1),2);
	nmomentum_si_top(:,1)=Nmatrixtop*(v_ssp_out(:,1).*m_sp(:,1));
	nmomentum_si_top(:,2)=Nmatrixtop*(v_ssp_out(:,2).*m_sp(:,1));
	nmomentum_si_bot(:,1)=Nmatrixbot*(v_ssp_out(:,1).*m_sp(:,1));
	nmomentum_si_bot(:,2)=Nmatrixbot*(v_ssp_out(:,2).*m_sp(:,1));
	
	[nmomentum_si]  = Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,nmomentum_si); % Boundary condition for nodal force
	[nmomentum_si_top]  = Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,nmomentum_si_top); % Boundary condition for nodal force
	[nmomentum_si_bot]  = Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,nmomentum_si_bot); % Boundary condition for nodal force
	
	nmass_si_top=Nmatrixtop*m_sp;
	nmass_si_bot=Nmatrixbot*m_sp;
	
	
	for i=1:size(nmass_si,1);
		nmass_si_comb(i)=sum(nmass_si(i,:));
		%nmass_si_top(i)=nmass_si(i,2);
		%nmass_si_bot(i)=nmass_si(i,3);
		
		if nmass_si_comb(i)>0
			v_si_comb(i,1)=sum(nmomentum_si(i,1,:))/nmass_si_comb(i);
			v_si_comb(i,2)=sum(nmomentum_si(i,2,:))/nmass_si_comb(i);
		end
		
		if nmass_si_top(i)>0
			v_si_top(i,1)=nmomentum_si_top(i,1)/nmass_si_top(i);
			v_si_top(i,2)=nmomentum_si_top(i,2)/nmass_si_top(i);
		end
		
		if nmass_si_bot(i)>0
			v_si_bot(i,1)=nmomentum_si_bot(i,1)/nmass_si_bot(i);
			v_si_bot(i,2)=nmomentum_si_bot(i,2)/nmass_si_bot(i);
		end
	end
	
	v_crack=transpose(Nmatrix_crack)*v_si_comb;
	v_cracktop=transpose(Nmatrix_cracktop)*v_si_top;
	v_crackbot=transpose(Nmatrix_crackbot)*v_si_bot;
	
	x_crack=x_crack+dt*v_crack;
	x_cracktop=x_cracktop+dt*v_cracktop;
	x_crackbot=x_crackbot+dt*v_crackbot;
	
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [x_sp] = UpdateCrackPosition_multi(Nmatrix,NmatrixAll,dt,nmass_si,nmomentum_si,x_sp)
	%Nmatrix,NmatrixAll,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredXVel2,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredXVel2,PredYVel,PredYVel2
	fieldnumber=size(Nmatrix,3);

	a_si=zeros(size(nmass_si,1),2,fieldnumber);
	v_si=zeros(size(nmass_si,1),2,fieldnumber);

	for field=1:fieldnumber
	%	try
	%		parfor i=1:size(nmass_si,1)
	%			if nmass_si(i,field)==0
	%			else
	%				a_si(i,:,field)=nforce_si(i,:,field)/nmass_si(i,field);
	%				v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
	%			end
	%		end
	%	catch
	%		disp('Update_Particle_Position_WithPredVel2 a_si v_si parfor failed!');
	%		disp('Rolling back to regular for');
			for i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
%					a_si(i,:,field)=nforce_si(i,:,field)/nmass_si(i,field);
					v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
	%	end
	end

	for field=1:fieldnumber
		for direction=1:2
			if field==1
				x_sp(:,direction)=x_sp(:,direction)+dt*transpose(NmatrixAll(:,:))*(v_si(:,direction,field));
			else
				x_sp(:,direction)=x_sp(:,direction)+dt*transpose(Nmatrix(:,:,field))*(v_si(:,direction,field));
			end
		end
	end

	%{
	v_ssp_free=v_ssp;

	for ni=1:length(NodeswithPredXVel)
		i=NodeswithPredXVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+NmatrixAll(i,sp)*(PredXVel - v_ssp_free(sp,1));
		end
	end
	
	for ni=1:length(NodeswithPredXVel2)
		i=NodeswithPredXVel2(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+NmatrixAll(i,sp)*(PredXVel2 - v_ssp_free(sp,1));
		end
	end

	for ni=1:length(NodeswithPredYVel)
		i=NodeswithPredYVel(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+NmatrixAll(i,sp)*(PredYVel - v_ssp_free(sp,2));
		end
	end

	for ni=1:length(NodeswithPredYVel2)
		i=NodeswithPredYVel2(ni);
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+NmatrixAll(i,sp)*(PredYVel2 - v_ssp_free(sp,2));
		end
	end
	%}
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [x_sp] = UpdateCrackPosition_multioptimized(N,NODES,CONNECT,dt,nmass_si,nmomentum_si,x_sp,TheFieldSplit)
	spCount=size(x_sp,1);
	x_sp_temp=zeros(1,2);
	
	
	for sp = 1:spCount
		for j = 1:NODES(1,sp)
			
			npid	                       = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			end
			
			
			for i=1:2
				x_sp_temp(1,i)	                   = x_sp(sp,i) + nmomentum_si(npid,i,TheFieldSplit(npid,sp))*N{sp}(j)*dt/nmass_si(npid,TheFieldSplit(npid,sp));
			end
			
			for i=1:2
				x_sp(sp,i)=x_sp_temp(1,i);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [x_crack] = UpdateCrackPosition_multioptimized_topandbot(m_sp,N_crack,NODES_crack,CONNECT_crack,dt,nmass_si,nmomentum_si,x_crack,TheFieldSplit_cracktop,TheFieldSplit_crackbot,CasetoRun)
	dx_sp=zeros(1,2);
	sigmaN=0;
	
	
	follow.list.top=zeros(size(x_crack.center,1),size(x_crack.center,3)); %icrackparticle,icrackpath
	follow.list.bot=zeros(size(x_crack.center,1),size(x_crack.center,3)); %icrackparticle,icrackpath
	follow.distance.top=zeros(size(x_crack.center,1),2,size(x_crack.center,3)); %icrackparticle,dimension,icrackpath
	follow.distance.bot=zeros(size(x_crack.center,1),2,size(x_crack.center,3));%icrackparticle,dimension,icrackpath
	follow.distance.mag=zeros(1,1);
	follow.angle=zeros(1,1);

	
	for icrackpath=1:x_crack.npaths
		for sp = 1:x_crack.nparticles(icrackpath)
			follow.list.top(sp,icrackpath)=1;
			for j = 1:4
				npid	                       = CONNECT_crack.top.values(sp,j,icrackpath);
				%low mass filter
				if nmass_si(npid,TheFieldSplit_cracktop{icrackpath}(j,sp))>0.0001*m_sp(1)
					follow.list.top(sp,icrackpath)=0;
					break;
				end
			end
		end
	end
	for icrackpath=1:x_crack.npaths
		for sp = 1:x_crack.nparticles(icrackpath)
			follow.list.bot(sp,icrackpath)=1;
			for j = 1:4
				npid	                       = CONNECT_crack.bot.values(sp,j,icrackpath);
				%low mass filter
				if nmass_si(npid,TheFieldSplit_crackbot{icrackpath}(j,sp))>0.0001*m_sp(1)
					follow.list.bot(sp,icrackpath)=0;
					break;
				end
			end
		end
	end
	for icrackpath=1:x_crack.npaths
		for sp = floor(x_crack.nparticles(icrackpath)/2):-1:1
			if follow.list.top(sp,icrackpath)==1
				follow.distance.top(sp,:,icrackpath)=x_crack.top(sp,:,icrackpath)-x_crack.top(sp+1,:,icrackpath);
			end
			if follow.list.bot(sp,icrackpath)==1
				follow.distance.bot(sp,:,icrackpath)=x_crack.bot(sp,:,icrackpath)-x_crack.bot(sp+1,:,icrackpath);
			end
		end
		for sp = floor(x_crack.nparticles(icrackpath)/2)+1:x_crack.nparticles(icrackpath)
			if follow.list.top(sp,icrackpath)==1
				follow.distance.top(sp,:,icrackpath)=x_crack.top(sp,:,icrackpath)-x_crack.top(sp-1,:,icrackpath);
			end
			if follow.list.bot(sp,icrackpath)==1
				follow.distance.bot(sp,:,icrackpath)=x_crack.bot(sp,:,icrackpath)-x_crack.bot(sp-1,:,icrackpath);
			end
		end
	end
	
	for icrackpath=1:x_crack.npaths
		for sp = 1:x_crack.nparticles(icrackpath)
			dx_sp=zeros(1,2);
			sigmaN=0;
			for j = 1:4
				
				npid	                       = CONNECT_crack.top.values(sp,j,icrackpath);
				%low mass filter
				if nmass_si(npid,TheFieldSplit_cracktop{icrackpath}(j,sp))<0.0001*m_sp(1)
					continue;
				end
				
				sigmaN=sigmaN+N_crack.top(1,j,sp,icrackpath);
				for i=1:2
					dx_sp(1,i)=dx_sp(1,i)+nmomentum_si(npid,i,TheFieldSplit_cracktop{icrackpath}(j,sp))*N_crack.top(1,j,sp,icrackpath)*dt/nmass_si(npid,TheFieldSplit_cracktop{icrackpath}(j,sp));
				end
			end
			%Nscale crack
			if sigmaN>0
				for i=1:2
					%x_crack.top(sp,i,icrackpath)=x_crack.top(sp,i,icrackpath)+dx_sp(1,i)/sigmaN;
					x_crack.top(sp,i,icrackpath)=x_crack.top(sp,i,icrackpath)+dx_sp(1,i);
				end
			end
			

			dx_sp=zeros(1,2);
			sigmaN=0;
			for j = 1:4
				
				npid	                       = CONNECT_crack.bot.values(sp,j,icrackpath);
				if nmass_si(npid,TheFieldSplit_crackbot{icrackpath}(j,sp))<0.0001*m_sp(1)
					continue;
				end
				
				sigmaN=sigmaN+N_crack.bot(1,j,sp,icrackpath);
				for i=1:2
					dx_sp(1,i)=dx_sp(1,i)+nmomentum_si(npid,i,TheFieldSplit_crackbot{icrackpath}(j,sp))*N_crack.bot(1,j,sp,icrackpath)*dt/nmass_si(npid,TheFieldSplit_crackbot{icrackpath}(j,sp));
				end
			end
			if sigmaN>0
				for i=1:2
					%x_crack.bot(sp,i,icrackpath)=x_crack.bot(sp,i,icrackpath)+dx_sp(1,i)/sigmaN;
					x_crack.bot(sp,i,icrackpath)=x_crack.bot(sp,i,icrackpath)+dx_sp(1,i);
				end
			end
		end
	end
	
	%below is the mechanism that moves crack particles outside of the "problem domain", i.e. spatial position associated with any non-zero nodal mass
	for icrackpath=1:x_crack.npaths
		if CasetoRun==172 || CasetoRun==174 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
			if x_crack.terminatedprop(icrackpath,2)==0 %tip=1: highest particle index, tip=2: lowest particle index
			for sp = floor(x_crack.nparticles(icrackpath)/2):-1:1
				if follow.list.top(sp,icrackpath)==1
					follow.distance.mag=sqrt(dot(follow.distance.top(sp,:,icrackpath),follow.distance.top(sp,:,icrackpath)));
					follow.angle=reliableatan(x_crack.top(sp+1,1,icrackpath)-x_crack.top(sp+2,1,icrackpath),x_crack.top(sp+1,2,icrackpath)-x_crack.top(sp+2,2,icrackpath));
					x_crack.top(sp,1,icrackpath)=x_crack.top(sp+1,1,icrackpath)+follow.distance.mag*cos(follow.angle);
					x_crack.top(sp,2,icrackpath)=x_crack.top(sp+1,2,icrackpath)+follow.distance.mag*sin(follow.angle);
				end
				if follow.list.bot(sp,icrackpath)==1
					follow.distance.mag=sqrt(dot(follow.distance.bot(sp,:,icrackpath),follow.distance.bot(sp,:,icrackpath)));
					follow.angle=reliableatan(x_crack.bot(sp+1,1,icrackpath)-x_crack.bot(sp+2,1,icrackpath),x_crack.bot(sp+1,2,icrackpath)-x_crack.bot(sp+2,2,icrackpath));
					x_crack.bot(sp,1,icrackpath)=x_crack.bot(sp+1,1,icrackpath)+follow.distance.mag*cos(follow.angle);
					x_crack.bot(sp,2,icrackpath)=x_crack.bot(sp+1,2,icrackpath)+follow.distance.mag*sin(follow.angle);
				end
			end
			end
			if x_crack.terminatedprop(icrackpath,1)==0
			for sp = floor(x_crack.nparticles(icrackpath)/2)+1:x_crack.nparticles(icrackpath)
				if follow.list.top(sp,icrackpath)==1
					follow.distance.mag=sqrt(dot(follow.distance.top(sp,:,icrackpath),follow.distance.top(sp,:,icrackpath)));
					follow.angle=reliableatan(x_crack.top(sp-1,1,icrackpath)-x_crack.top(sp-2,1,icrackpath),x_crack.top(sp-1,2,icrackpath)-x_crack.top(sp-2,2,icrackpath));
					x_crack.top(sp,1,icrackpath)=x_crack.top(sp-1,1,icrackpath)+follow.distance.mag*cos(follow.angle);
					x_crack.top(sp,2,icrackpath)=x_crack.top(sp-1,2,icrackpath)+follow.distance.mag*sin(follow.angle);
				end
				if follow.list.bot(sp,icrackpath)==1
					follow.distance.mag=sqrt(dot(follow.distance.bot(sp,:,icrackpath),follow.distance.bot(sp,:,icrackpath)));
					follow.angle=reliableatan(x_crack.bot(sp-1,1,icrackpath)-x_crack.bot(sp-2,1,icrackpath),x_crack.bot(sp-1,2,icrackpath)-x_crack.bot(sp-2,2,icrackpath));
					x_crack.bot(sp,1,icrackpath)=x_crack.bot(sp-1,1,icrackpath)+follow.distance.mag*cos(follow.angle);
					x_crack.bot(sp,2,icrackpath)=x_crack.bot(sp-1,2,icrackpath)+follow.distance.mag*sin(follow.angle);
				end
			end
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [x_sp] = UpdateCrackPosition_multioptimized_fail(Nmatrix,dt,nmass_si,nmomentum_si,x_sp,TheFieldSplit)
	fieldnumber=max(max(TheFieldSplit));
	a_si=zeros(size(nmass_si,1),2,fieldnumber);
	v_si=zeros(size(nmass_si,1),2,fieldnumber);
	for field=1:fieldnumber
		for i=1:size(nmass_si,1)
			if nmass_si(i,field)==0
			else
				v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
			end
		end
	end
	for field=1:fieldnumber
		if nmass_si(i,field)==0
			for direction=1:2
				x_sp(:,direction)=x_sp(:,direction)+dt*transpose(Nmatrix)*(nmomentum_si(:,direction,field)./nmass_si(:,field));
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [x_crack,x_cracktop,x_crackbot] = UpdateCrackPosition(x_crack,x_cracktop,x_crackbot,nmass_si,nmomentum_si,Nmatrix_crack,Nmatrix_cracktop,Nmatrix_crackbot,dt,Nmatrixtop,Nmatrixbot,v_ssp_out,m_sp)
	
	nmass_si_comb=zeros(size(nmass_si,1));
	nmass_si_top=zeros(size(nmass_si,1));
	nmass_si_bot=zeros(size(nmass_si,1));
	
	v_si_comb=zeros(size(nmass_si,1),2);
	v_si_top=zeros(size(nmass_si,1),2);
	v_si_bot=zeros(size(nmass_si,1),2);
	
	nmomentum_si_top=zeros(size(Nmatrixtop,1),2);
	nmomentum_si_bot=zeros(size(Nmatrixbot,1),2);
	nmomentum_si_top(:,1)=Nmatrixtop*(v_ssp_out(:,1).*m_sp(:,1));
	nmomentum_si_top(:,2)=Nmatrixtop*(v_ssp_out(:,2).*m_sp(:,1));
	nmomentum_si_bot(:,1)=Nmatrixbot*(v_ssp_out(:,1).*m_sp(:,1));
	nmomentum_si_bot(:,2)=Nmatrixbot*(v_ssp_out(:,2).*m_sp(:,1));
	
	
	nmass_si_top=Nmatrixtop*m_sp;
	nmass_si_bot=Nmatrixbot*m_sp;
	
	
	for i=1:size(nmass_si,1);
		nmass_si_comb(i)=sum(nmass_si(i,:));
		%nmass_si_top(i)=nmass_si(i,2);
		%nmass_si_bot(i)=nmass_si(i,3);
		
		if nmass_si_comb(i)>0
			v_si_comb(i,1)=sum(nmomentum_si(i,1,:))/nmass_si_comb(i);
			v_si_comb(i,2)=sum(nmomentum_si(i,2,:))/nmass_si_comb(i);
		end
		
		if nmass_si_top(i)>0
			v_si_top(i,1)=nmomentum_si_top(i,1)/nmass_si_top(i);
			v_si_top(i,2)=nmomentum_si_top(i,2)/nmass_si_top(i);
		end
		
		if nmass_si_bot(i)>0
			v_si_bot(i,1)=nmomentum_si_bot(i,1)/nmass_si_bot(i);
			v_si_bot(i,2)=nmomentum_si_bot(i,2)/nmass_si_bot(i);
		end
	end
	
	v_crack=transpose(Nmatrix_crack)*v_si_comb;
	v_cracktop=transpose(Nmatrix_cracktop)*v_si_top;
	v_crackbot=transpose(Nmatrix_crackbot)*v_si_bot;
	
	x_crack=x_crack+dt*v_crack;
	x_cracktop=x_cracktop+dt*v_cracktop;
	x_crackbot=x_crackbot+dt*v_crackbot;
	
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [v_ssp,x_sp] = Update_Particle_Position_WithPredVel2(Nmatrix,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredXVel2,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredXVel2,PredYVel,PredYVel2,fieldnumber)
	%v_ssp=v_ssp*(0.5^(1/1000)); %damping

	a_si=zeros(length(nmass_si),2,fieldnumber);
	v_si=zeros(length(nmass_si),2,fieldnumber);

	for field=1:fieldnumber
	%{
	%switchable1
		try
			parfor i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
					a_si(i,:,field)=nforce_si(i,:,field)/nmass_si(i,field);
					v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
		catch
			fprintf('%s',['Update_Particle_Position_WithPredVel2 a_si v_si parfor failed!' char(10)]);
			fprintf('%s',['Rolling back to regular for' char(10)]);
			%}
			%switchable1
			for i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
					a_si(i,:,field)=nforce_si(i,:,field)/nmass_si(i,field);
					v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
			%{
			%switchable1
		end
		%}
		%switchable1
	end

	for field=1:fieldnumber
		for direction=1:2
			v_ssp(:,direction)=v_ssp(:,direction)+dt*transpose(Nmatrix(:,:,field))*(a_si(:,direction,field));
			x_sp(:,direction)=x_sp(:,direction)+dt*transpose(Nmatrix(:,:,field))*(v_si(:,direction,field));
		end
	end

	%{
	for sp = 1:spCount
		 for j = 1:NODES(sp)
			 npid	                       = CONNECT{sp}(j);
			  if nmass_si(npid)==0
				continue
			  end
			  %{
			  NodeisPredXVel=0;
			  for k=1:length(NodeswithPredXVel)
				 if npid==NodeswithPredXVel(k)
					 NodeisPredXVel=1;
					 break
				 end
			 end
			  NodeisPredXVel2=0;
			  for k=1:length(NodeswithPredXVel2)
				 if npid==NodeswithPredXVel2(k)
					 NodeisPredXVel2=1;
					 break
				 end
			 end
			  NodeisPredYVel=0;	      
			  for k=1:length(NodeswithPredYVel)
				 if npid==NodeswithPredYVel(k)
					 NodeisPredYVel=1;
					 break
				 end
			  end
			  NodeisPredYVel2=0;
			  for k=1:length(NodeswithPredYVel2)
				 if npid==NodeswithPredYVel2(k)
					 NodeisPredYVel2=1;
					 break
				 end
			  end
			  %}
			  %if NodeisPredXVel==0
				 v_ssp(sp,1)	              = v_ssp(sp,1) + dt * N{sp}(j) * (nforce_si(npid,1)/nmass_si(npid));%*(0.5^(1/1000)); %damping
			 %else
			 %	v_ssp(sp,1)                  = v_ssp(sp,1) + N{sp}(j)*(PredXVel - v_ssp(sp,1));
			 %end
			 
			  %if NodeisPredXVel2==0
				 v_ssp(sp,1)	              = v_ssp(sp,1) + dt * N{sp}(j) * (nforce_si(npid,1)/nmass_si(npid));%*(0.5^(1/1000)); %damping
			 %else
			 %	v_ssp(sp,1)                  = v_ssp(sp,1) + N{sp}(j)*(PredXVel2 - v_ssp(sp,1));
			 %end
			 
			 %if NodeisPredYVel==0
				 v_ssp(sp,2)	                  = v_ssp(sp,2) + dt * N{sp}(j) * (nforce_si(npid,2)/nmass_si(npid));%*(0.5^(1/1000)); %damping
			 %else
			 %	v_ssp(sp,2)                  = v_ssp(sp,2) + N{sp}(j)*(PredYVel - v_ssp(sp,2));
			 %end
			 
			 %if NodeisPredYVel2==0
			 %	v_ssp(sp,2)                      = v_ssp(sp,2) + dt * N{sp}(j) * (nforce_si(npid,2)/nmass_si(npid));%*(0.5^(1/1000)); %damping
			 %else
			 %	v_ssp(sp,2)                  = v_ssp(sp,2) + N{sp}(j)*(PredYVel2 - v_ssp(sp,2));
			 %end
			 %v_ssp(sp,2)	                  = v_ssp(sp,2) + dt * N{sp}(j) * (nforce_si(npid,2)/nmass_si(npid));
			 
			 x_sp(sp,:)	                   = x_sp(sp,:) + nmomentum_si(npid,:)*N{sp}(j)*dt/ nmass_si(npid);
		 end   
	end
	%}

	v_ssp_free=v_ssp;

	for ni=1:length(NodeswithPredXVel)
		i=NodeswithPredXVel(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2);
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn{i}(nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+sum(Nmatrix(i,sp,:))*(PredXVel - v_ssp_free(sp,1));
		end
	end
	
	for ni=1:length(NodeswithPredXVel2)
		i=NodeswithPredXVel2(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2);
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+sum(Nmatrix(i,sp,:))*(PredXVel2 - v_ssp_free(sp,1));
		end
	end
	
	for ni=1:length(NodeswithPredYVel)
		i=NodeswithPredYVel(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2);
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp,:))*(PredYVel - v_ssp_free(sp,2));
		end
	end

	for ni=1:length(NodeswithPredYVel2)
		i=NodeswithPredYVel2(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2);
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp,:))*(PredYVel2 - v_ssp_free(sp,2));
		end
	end


end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [v_ssp,x_sp] = Update_Prtcl_Posn_WPredVOR_optmzd(PredVelVect,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredXVel2,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredXVel2,PredYVel,PredYVel2,TheFieldSplit,fieldnumber,spSizes,CasetoRun)

	%v_ssp=v_ssp*(0.5^(1/1000)); %damping
	
	%fieldnumber=max(max(TheFieldSplit));
	
	% keeping the original code incase parfor fails
	%{
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid	                       = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			end
			v_ssp(sp,:)	              = v_ssp(sp,:) + dt * N{sp}(j) * (nforce_si(npid,:,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)));%*(0.5^(1/1000)); %damping

			x_sp(sp,:)	                   = x_sp(sp,:) + nmomentum_si(npid,:,TheFieldSplit(npid,sp))*N{sp}(j)*dt/nmass_si(npid,TheFieldSplit(npid,sp));
		end   
	end
	%}
	
	v_ssp_before=v_ssp;
	x_sp_before=x_sp;
	%{
	%switchable1
	try
		parfor sp = 1:spCount
			[v_ssp(sp,:),x_sp(sp,:)]=Update_Prtcl_Posn_WPredVOR_optmzd_prfrd(NODES(sp),dt,CONNECT{sp},N{sp},nmass_si,nforce_si,nmomentum_si,v_ssp(sp,:),x_sp(sp,:),TheFieldSplit(:,sp));
		end
	catch
		v_ssp=v_ssp_before;
		x_sp=x_sp_before;
		%}
		%switchable1
		parfor sp = 1:spCount
	    %for sp = 1:spCount
			[v_ssp(sp,:),x_sp(sp,:)]=Update_Prtcl_Posn_WPredVOR_optmzd_prfrd(NODES(sp),dt,CONNECT{sp},N{sp},nmass_si,nforce_si,nmomentum_si,v_ssp(sp,:),x_sp(sp,:),TheFieldSplit(1:spSizes(sp),sp));
		end
		%{
		%switchable1
	end
	%}
	%switchable1
	
	%124 PredVel sp Protocol
	v_ssp_free=v_ssp;
	if CasetoRun==124 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
		
		for ni=1:PredVelVect.nX
			i=PredVelVect.XNodes(ni);
			if i==59
				1;
			end
			for nsp=1:CONNECTpn.nrparticles(i)
				%nni=0;
				sp=CONNECTpn.values(i,nsp);
				% you're iterating over ni,nsp with CONNECTpn, but N runs on sp,nni. so you need nni, hence the loop below
				for nni=1:length(CONNECT{sp});
					if CONNECT{sp}(nni)==i;
						if TheFieldSplit(nni,sp)==1
							v_ssp(sp,1)=v_ssp(sp,1)+PredVelVect.XPhase(ni)*N{sp}(nni)*(PredVelVect.XVel(ni) - v_ssp_free(sp,1));
						end
						break;
					end
				end
			end
		end

		for ni=1:PredVelVect.nY
			i=PredVelVect.YNodes(ni);
			for nsp=1:CONNECTpn.nrparticles(i)
				%nni=0;
				sp=CONNECTpn.values(i,nsp);
				for nni=1:length(CONNECT{sp});
					if CONNECT{sp}(nni)==i;
						if TheFieldSplit(nni,sp)==1
							v_ssp(sp,2)=v_ssp(sp,2)+PredVelVect.YPhase(ni)*N{sp}(nni)*(PredVelVect.YVel(ni) - v_ssp_free(sp,2));
						end
						break;
					end
				end
			end
		end
		
		
	elseif CasetoRun==183
	else
		for ni=1:length(NodeswithPredXVel)
			i=NodeswithPredXVel(ni);
			if i==59
				1;
			end
			for nsp=1:CONNECTpn.nrparticles(i)
				%nni=0;
				sp=CONNECTpn.values(i,nsp);
				% you're iterating over ni,nsp with CONNECTpn, but N runs on sp,nni. so you need nni, hence the loop below
				for nni=1:length(CONNECT{sp});
					if CONNECT{sp}(nni)==i;
						if TheFieldSplit(nni,sp)==1
							v_ssp(sp,1)=v_ssp(sp,1)+N{sp}(nni)*(PredXVel - v_ssp_free(sp,1));
						end
						break;
					end
				end
			end
		end
		
		for ni=1:length(NodeswithPredXVel2)
			i=NodeswithPredXVel2(ni);
			for nsp=1:CONNECTpn.nrparticles(i)
				%nni=0;
				sp=CONNECTpn.values(i,nsp);
				for nni=1:length(CONNECT{sp});
					if CONNECT{sp}(nni)==i;
						if TheFieldSplit(nni,sp)==1
							v_ssp(sp,1)=v_ssp(sp,1)+N{sp}(nni)*(PredXVel2 - v_ssp_free(sp,1));
						end
						break;
					end
				end
			end
		end

		for ni=1:length(NodeswithPredYVel)
			i=NodeswithPredYVel(ni);
			for nsp=1:CONNECTpn.nrparticles(i)
				%nni=0;
				sp=CONNECTpn.values(i,nsp);
				for nni=1:length(CONNECT{sp});
					if CONNECT{sp}(nni)==i;
						if TheFieldSplit(nni,sp)==1
							v_ssp(sp,2)=v_ssp(sp,2)+N{sp}(nni)*(PredYVel - v_ssp_free(sp,2));
						end
						break;
					end
				end
			end
		end

		for ni=1:length(NodeswithPredYVel2)
			i=NodeswithPredYVel2(ni);
			for nsp=1:CONNECTpn.nrparticles(i)
				%nni=0;
				sp=CONNECTpn.values(i,nsp);
				for nni=1:length(CONNECT{sp});
					if CONNECT{sp}(nni)==i;
						if TheFieldSplit(nni,sp)==1
							v_ssp(sp,2)=v_ssp(sp,2)+N{sp}(nni)*(PredYVel2 - v_ssp_free(sp,2));
						end
						break;
					end
				end
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [v_ssp,x_sp] = Update_Prtcl_Posn_WPredVOR_optmzd_prfrd(NODES,dt,CONNECT,N,nmass_si,nforce_si,nmomentum_si,v_ssp,x_sp,TheFieldSplit)
	
	for j = 1:NODES
		npid	                       = CONNECT(j);
		if nmass_si(npid,TheFieldSplit(j))==0
			continue;
		end
		v_ssp(1,:)	              = v_ssp(1,:) + dt * N(j) * (nforce_si(npid,:,TheFieldSplit(j))/nmass_si(npid,TheFieldSplit(j)));%*(0.5^(1/1000)); %damping

		x_sp(1,:)	                   = x_sp(1,:) + nmomentum_si(npid,:,TheFieldSplit(j))*N(j)*dt/nmass_si(npid,TheFieldSplit(j));
	end   
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [v_ssp,x_sp] = Update_Particle_Position_WithPredVel2_optimized(ParticleswithPredYVel,ParticlePredYVel,Nmatrix,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2,TheFieldSplit)
	
	%v_ssp=v_ssp*(0.5^(1/1000)); %damping
	
	fieldnumber=max(max(TheFieldSplit));
	
	a_si=zeros(length(nmass_si),2,fieldnumber);
	v_si=zeros(length(nmass_si),2,fieldnumber);
	
	
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid	                       = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			end
			v_ssp(sp,:)	              = v_ssp(sp,:) + dt * N{sp}(j) * (nforce_si(npid,:,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)));%*(0.5^(1/1000)); %damping
		end   
	end
	npredvelsp=length(ParticleswithPredYVel);
	v_ssp_out=[];
	for ipredvelsp=1:npredvelsp
		sp=ParticleswithPredYVel(ipredvelsp);
		pyforcedispctrl=zeros(1,2);
		pyforcedispctrl(1)=0;
		pyforcedispctrl(2)=1;
		for iteration=1:9999
			v_ssp_temp=v_ssp;
			nforcedispctrl_si=zeros(size(nforce_si));
			if iteration>2
				pyforcedispctrl=VectorInsertion(pyforcedispctrl,iteration,pyforcedispctrl(iteration-1)+(pyforcedispctrl(iteration-1)-pyforcedispctrl(iteration-2))/(v_ssp_out(iteration-1)-v_ssp_out(iteration-2))*(ParticlePredYVel(ipredvelsp)-v_ssp_out(iteration-1)));
			end
			for ni=1:length(CONNECT{ParticleswithPredYVel(ipredvelsp)})
				npid=CONNECT{ParticleswithPredYVel(ipredvelsp)}(ni);
				nforcedispctrl_si(npid,2,TheFieldSplit(npid,ParticleswithPredYVel(ipredvelsp)))=nforcedispctrl_si(npid,2,TheFieldSplit(npid,ParticleswithPredYVel(ipredvelsp)))+pyforcedispctrl(iteration)*Nmatrix(npid,ParticleswithPredYVel(ipredvelsp));
				CONNECTpnLength=0;
				for j=1:size(CONNECTpn,2);
					if CONNECTpn(npid,j)>0
						CONNECTpnLength=CONNECTpnLength+1;
					else
						break;
					end
				end
				for nsp=1:CONNECTpnLength
					sp=CONNECTpn(npid,nsp);
					if nmass_si(npid,TheFieldSplit(npid,sp))==0
						continue;
					end
					v_ssp_temp(sp,:)	              = v_ssp_temp(sp,:) + dt * Nmatrix(npid,sp) * (nforcedispctrl_si(npid,:,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)));%*(0.5^(1/1000)); %damping
				end
			end
			v_ssp_out=VectorInsertion(v_ssp_out,iteration,v_ssp_temp(ParticleswithPredYVel(ipredvelsp),2));
			if abs(v_ssp_out(iteration)-ParticlePredYVel(ipredvelsp))<1e-9
				v_ssp=v_ssp_temp;
				nmomentum_si=nmomentum_si+nforcedispctrl_si*dt;
				break;
			end
		end
	end
	
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid	                       = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			end
			x_sp(sp,:)	                   = x_sp(sp,:) + nmomentum_si(npid,:,TheFieldSplit(npid,sp))*N{sp}(j)*dt/nmass_si(npid,TheFieldSplit(npid,sp));
		end   
	end
	
	v_ssp_free=v_ssp;
	
	for ni=1:length(NodeswithPredXVel)
		i=NodeswithPredXVel(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2)
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:length(CONNECTpn{i})
			sp=CONNECTpn(i,nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+sum(Nmatrix(i,sp))*(PredXVel - v_ssp_free(sp,1));
		end
	end
	
	for ni=1:length(NodeswithPredYVel)
		i=NodeswithPredYVel(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2)
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp))*(PredYVel - v_ssp_free(sp,2));
		end
	end
	
	for ni=1:length(NodeswithPredYVel2)
		i=NodeswithPredYVel2(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2)
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp))*(PredYVel2 - v_ssp_free(sp,2));
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [v_ssp,x_sp] = Update_Particle_Position_WithPredVel3_optimized(ParticleswithPredYVel,ParticlePredYVel,Nmatrix,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2,TheFieldSplit)

	%v_ssp=v_ssp*(0.5^(1/1000)); %damping
	
	fieldnumber=max(max(TheFieldSplit));
	
	a_si=zeros(length(nmass_si),2,fieldnumber);
	v_si=zeros(length(nmass_si),2,fieldnumber);

	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid	                       = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			end
			v_ssp(sp,:)	              = v_ssp(sp,:) + dt * N{sp}(j) * (nforce_si(npid,:,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)));%*(0.5^(1/1000)); %damping
		end   
	end
	v_ssp_free=v_ssp;
	nmomentum_si_trial=nmomentum_si;
	
	npredvelsp=length(ParticleswithPredYVel);
	deltavp=[];
	v_ssp_out=[];
	
	for ipredvelsp=1:npredvelsp
		sigmaNsquare=0;
		sp=ParticleswithPredYVel(ipredvelsp);
		
		% sigmaNsquare needs to be calculated for determining the imposed deltavp
		for ni=1:length(CONNECT{sp})
			sigmaNsquare=sigmaNsquare+N{sp}(ni)^2;
	    end
	    tolerance=1e-3;
	    for iteration=1:999
	        v_ssp_trial=v_ssp;
	        sp=ParticleswithPredYVel(ipredvelsp);
	        if iteration==1
				deltavp=VectorInsertion(deltavp,iteration,(ParticlePredYVel(ipredvelsp)-v_ssp_free(sp,2))/sigmaNsquare);
	        elseif iteration==2
				deltavp=VectorInsertion(deltavp,iteration,deltavp(iteration-1)*2+tolerance);
	        else
				deltavp=VectorInsertion(deltavp,iteration,deltavp(iteration-1)+(deltavp(iteration-2)-deltavp(iteration-1))/(v_ssp_out(iteration-2)-v_ssp_out(iteration-1))*(ParticlePredYVel(ipredvelsp)-v_ssp_out(iteration-1)));
	        end

	        % spreading deltavp to PredYVel of nodes
	        PredYVelFromParticle=zeros(length(CONNECT{sp}),1);
	        for ni=1:length(CONNECT{sp})
	            i=CONNECT{sp}(ni);
	            if nmass_si(i,TheFieldSplit(i,sp))==0
	                continue;
	            end
	            PredYVelFromParticle(ni)=nmomentum_si(i,2,TheFieldSplit(i,sp))/nmass_si(i,TheFieldSplit(i,sp))+N{sp}(ni)*deltavp(iteration);
	            nmomentum_si_trial(i,2,TheFieldSplit(i,sp))=PredYVelFromParticle(ni)*nmass_si(i,TheFieldSplit(i,sp));
	        end

	        % mapping back the spread 
	        Nsum=0;%debugging disp control
	        for ni=1:length(CONNECT{ParticleswithPredYVel(ipredvelsp)})
	            i=CONNECT{ParticleswithPredYVel(ipredvelsp)}(ni);
				CONNECTpnLength=0;
				for j=1:size(CONNECTpn,2)
					if CONNECTpn(i,j)>0
						CONNECTpnLength=CONNECTpnLength+1;
					else
						break;
					end
				end
	            for nsp=1:CONNECTpnLength
	                sp=CONNECTpn(i,nsp);
	                v_ssp_trial(sp,2)=v_ssp_trial(sp,2)+sum(Nmatrix(i,sp))*(PredYVelFromParticle(ni) - v_ssp_free(sp,2));
	            end
	        end
			v_ssp_out=VectorInsertion(v_ssp_out,iteration,v_ssp_trial(ParticleswithPredYVel(ipredvelsp),2));
	        if abs(v_ssp_out(iteration)-ParticlePredYVel(ipredvelsp))<tolerance
	            v_ssp=v_ssp_trial;
	            nmomentum_si=nmomentum_si_trial;
	            break;
	        end
	    end
	    
		v_ssp_free=v_ssp;
	end
	
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid	                       = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			end
			x_sp(sp,:)	                   = x_sp(sp,:) + nmomentum_si(npid,:,TheFieldSplit(npid,sp))*N{sp}(j)*dt/nmass_si(npid,TheFieldSplit(npid,sp));
		end   
	end
	
	
	for ni=1:length(NodeswithPredXVel)
		i=NodeswithPredXVel(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2)
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+sum(Nmatrix(i,sp))*(PredXVel - v_ssp_free(sp,1));
		end
	end

	for ni=1:length(NodeswithPredYVel)
		i=NodeswithPredYVel(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2)
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp))*(PredYVel - v_ssp_free(sp,2));
		end
	end

	for ni=1:length(NodeswithPredYVel2)
		i=NodeswithPredYVel2(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2)
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp))*(PredYVel2 - v_ssp_free(sp,2));
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [v_ssp,x_sp] = Update_Particle_Position_WithPredVel2_optimized_failed(Nmatrix,CONNECTpn,NODES,dt,CONNECT,N,spCount,nmass_si,nforce_si,nmomentum_si,x_spo,v_ssp,x_sp,NodeswithPredXVel,NodeswithPredYVel,NodeswithPredYVel2,PredXVel,PredYVel,PredYVel2,TheFieldSplit)
	%v_ssp=v_ssp*(0.5^(1/1000)); %damping

	fieldnumber=size(Nmatrix,3);

	a_si=zeros(length(nmass_si),2,fieldnumber);
	v_si=zeros(length(nmass_si),2,fieldnumber);
%{
	for field=1:fieldnumber
		try
			parfor i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
					a_si(i,:,field)=nforce_si(i,:,field)/nmass_si(i,field);
					v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
		catch
			disp('Update_Particle_Position_WithPredVel2 a_si v_si parfor failed!');
			disp('Rolling back to regular for');
			for i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
					a_si(i,:,field)=nforce_si(i,:,field)/nmass_si(i,field);
					v_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
		end
	end

	for field=1:fieldnumber
		for direction=1:2
			v_ssp(:,direction)=v_ssp(:,direction)+dt*transpose(Nmatrix(:,:,field))*(a_si(:,direction,field));
			x_sp(:,direction)=x_sp(:,direction)+dt*transpose(Nmatrix(:,:,field))*(v_si(:,direction,field));
		end
	end
%}
	
	for sp = 1:spCount
		 for j = 1:NODES(sp)
			 npid	                       = CONNECT{sp}(j);
			  if nmass_si(npid,TheFieldSplit(npid,sp))==0
				continue;
			  end
			  %{
			  NodeisPredXVel=0;
			  for k=1:length(NodeswithPredXVel)
				 if npid==NodeswithPredXVel(k)
					 NodeisPredXVel=1;
					 break
				 end
			 end
			  NodeisPredYVel=0;	      
			  for k=1:length(NodeswithPredYVel)
				 if npid==NodeswithPredYVel(k)
					 NodeisPredYVel=1;
					 break
				 end
			  end
			  NodeisPredYVel2=0;
			  for k=1:length(NodeswithPredYVel2)
				 if npid==NodeswithPredYVel2(k)
					 NodeisPredYVel2=1;
					 break
				 end
			  end
			  %}
			  %if NodeisPredXVel==0
				 v_ssp(sp,1)	              = v_ssp(sp,1) + dt * Nmatrix(npid,sp,TheFieldSplit(npid,sp)) * (nforce_si(npid,1,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)));%*(0.5^(1/1000)); %damping
			 %else
			 %	v_ssp(sp,1)                  = v_ssp(sp,1) + N{sp}(j)*(PredXVel - v_ssp(sp,1));
			 %end
			 
			 %if NodeisPredYVel==0
				 v_ssp(sp,2)	                  = v_ssp(sp,2) + dt * Nmatrix(npid,sp,TheFieldSplit(npid,sp)) * (nforce_si(npid,2,TheFieldSplit(npid,sp))/nmass_si(npid,TheFieldSplit(npid,sp)));%*(0.5^(1/1000)); %damping
			 %else
			 %	v_ssp(sp,2)                  = v_ssp(sp,2) + N{sp}(j)*(PredYVel - v_ssp(sp,2));
			 %end
			 
			 %if NodeisPredYVel2==0
			 %	v_ssp(sp,2)                      = v_ssp(sp,2) + dt * N{sp}(j) * (nforce_si(npid,2)/nmass_si(npid));%*(0.5^(1/1000)); %damping
			 %else
			 %	v_ssp(sp,2)                  = v_ssp(sp,2) + N{sp}(j)*(PredYVel2 - v_ssp(sp,2));
			 %end
			 %v_ssp(sp,2)	                  = v_ssp(sp,2) + dt * N{sp}(j) * (nforce_si(npid,2)/nmass_si(npid));
			 
			 x_sp(sp,:)	                   = x_sp(sp,:) + nmomentum_si(npid,:,TheFieldSplit(npid,sp))*Nmatrix(npid,sp,TheFieldSplit(npid,sp))*dt/ nmass_si(npid,TheFieldSplit(npid,sp));
		 end   
	end
	

	v_ssp_free=v_ssp;

	for ni=1:length(NodeswithPredXVel)
		i=NodeswithPredXVel(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2)
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			v_ssp(sp,1)=v_ssp(sp,1)+sum(Nmatrix(i,sp,:))*(PredXVel - v_ssp_free(sp,1));
		end
	end

	for ni=1:length(NodeswithPredYVel)
		i=NodeswithPredYVel(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2)
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp,:))*(PredYVel - v_ssp_free(sp,2));
		end
	end

	for ni=1:length(NodeswithPredYVel2)
		i=NodeswithPredYVel2(ni);
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2)
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			v_ssp(sp,2)=v_ssp(sp,2)+sum(Nmatrix(i,sp,:))*(PredYVel2 - v_ssp_free(sp,2));
		end
	end


end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [nvelo_si,L_si] = Interpolate_velocity_back(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp,N,dN,nmass_si,Nmatrix,dNxmatrix,dNymatrix)
	fieldnumber=size(Nmatrix,3);

	%% Interpolation from particle to grid task
	% Node variables

	 nvelo_si	            = zeros(nodeCount,2,fieldnumber);                   % Nodal Velocity
	 nmomentum_si	        = zeros(nodeCount,2,fieldnumber);                   % Nodal Momentum
	 L_si	                = zeros(nodeCount,2,2,fieldnumber);

	for field=fieldnumber:-1:1
		nmass_si(:,field)	            = Nmatrix(:,:,field)*m_sp;                         % Nodal Mass
		nmomentum_si(:,1,field)	   = Nmatrix(:,:,field)*(m_sp.*v_ssp(:,1));           % Nodal Momentum in X direction
		nmomentum_si(:,2,field)	   = Nmatrix(:,:,field)*(m_sp.*v_ssp(:,2));           % Nodal Momentum in Y direction
		L_si(:,1,1,field)=dNxmatrix(:,:,field)*v_ssp(:,1);
		L_si(:,1,2,field)=dNymatrix(:,:,field)*v_ssp(:,1);
		L_si(:,2,1,field)=dNxmatrix(:,:,field)*v_ssp(:,2);
		L_si(:,2,2,field)=dNymatrix(:,:,field)*v_ssp(:,2);
	end
	 
	 for field=1:fieldnumber
		%{
		%switchable1
		try
			parfor i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
					nvelo_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
		catch
			fprintf('%s',['Update_Particle_Position_WithPredVel2 a_si v_si parfor failed!' char(10)]);
			fprintf('%s',['Rolling back to regular for' char(10)]);
			%}
			%switchable1
			for i=1:size(nmass_si,1)
				if nmass_si(i,field)==0
				else
					nvelo_si(i,:,field)=nmomentum_si(i,:,field)/nmass_si(i,field);
				end
			end
			%{
			%switchable1
		end
		%}
		%switchable1
	end

	 
	 % Momentum
	 %{
	 for sp = 1:spCount
		 for j = 1:NODES(sp)
			 npid	              = CONNECT{sp}(j);
			 nmomentum_si(npid,:)  = nmomentum_si(npid,:) + m_sp(sp)*v_ssp(sp,:)*N{sp}(j);

	%{
	if v_ssp(sp,1)*N{sp}(j)~=0|v_ssp(sp,2)*N{sp}(j)~=0
		texttodisplay=[];
		texttodisplay=[texttodisplay 'sp=' num2str(sp)];
		texttodisplay=[texttodisplay '; npid=' num2str(npid)];
		texttodisplay=[texttodisplay '; j=' num2str(j)];
		texttodisplay=[texttodisplay '; v_ssp(sp,1)=' num2str(v_ssp(sp,1))];
		texttodisplay=[texttodisplay '; N{sp}(j)=' num2str(N{sp}(j))];
		texttodisplay=[texttodisplay '; v_ssp(sp,1)*N{sp}(j)=' num2str(v_ssp(sp,1)*N{sp}(j))];
		texttodisplay=[texttodisplay '; nmomentum_si(npid,1)=' num2str(nmomentum_si(npid,1))];
		disp(texttodisplay);
	1;
	end
	%}
			 
			for p=1:2
				for q=1:2
					L_si(npid,p,q)=L_si(npid,p,q)+v_ssp(sp,p)*dN{sp}(q,j);
				end
			end
		 end
	 end
	 
	 % Velocity
	  for sp = 1:spCount
	 for j = 1:NODES(sp)
		 npid	                  = CONNECT{sp}(j);
				  if nmass_si(npid)==0
					continue
				  end 
				  
	nvelo_si(npid,:)	           = nmomentum_si(npid,:)/nmass_si(npid); 
	%{
	if nvelo_si(npid,1)~=0|nvelo_si(npid,2)~=0
		texttodisplay=[];
		texttodisplay=[texttodisplay 'npid=' num2str(npid)];
		texttodisplay=[texttodisplay '; nmomentum_si(npid,:)=[' num2str(nmomentum_si(npid,1)) ',' num2str(nmomentum_si(npid,2)) ']'];
		texttodisplay=[texttodisplay '; nmass_si(npid)=' num2str(nmass_si(npid))];
		texttodisplay=[texttodisplay '; nvelo_si(npid,:)=[' num2str(nvelo_si(npid,1)) ',' num2str(nvelo_si(npid,2)) ']'];
		disp(texttodisplay);
		1;
	end
	%}
	 end
	  end
	 %}
	1;
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [nvelo_si] = Interpolate_velocity_back_optimized(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp,N,dN,nmass_si,TheFieldSplit,fieldnumber)

	%% Interpolation from particle to grid task
	% Node variables
 
	 nvelo_si	            = zeros(nodeCount,2,fieldnumber);                   % Nodal Velocity
	 nmomentum_si	        = zeros(nodeCount,2,fieldnumber);                   % Nodal Momentum
	% L_si	                = zeros(nodeCount,2,2,fieldnumber);

	 % Momentum
	
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid	              = CONNECT{sp}(j);
			nmomentum_si(npid,:,TheFieldSplit(j,sp))  = nmomentum_si(npid,:,TheFieldSplit(j,sp)) + m_sp(sp)*v_ssp(sp,:)*N{sp}(j);
%{
			for p=1:2
				for q=1:2
					L_si(npid,p,q,TheFieldSplit{sp}(j))=L_si(npid,p,q,TheFieldSplit{sp}(j))+v_ssp(sp,p)*dN{sp}(q,j);
				end
			end
%}
		end
	end

	% Velocity
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid	                  = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(j,sp))==0
				continue
			end 
			nvelo_si(npid,:,TheFieldSplit(j,sp))	           = nmomentum_si(npid,:,TheFieldSplit(j,sp))/nmass_si(npid,TheFieldSplit(j,sp)); 
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [nvelo_si] = Interpolate_velocity_back_optimized_msp(NODES,nodeCount,spCount,CONNECT,m_sp,v_ssp,N,dN,TheFieldSplit,fieldnumber)

	%% Interpolation from particle to grid task
	% Node variables
 
	 nvelo_si	            = zeros(nodeCount,2,fieldnumber);                   % Nodal Velocity
	 nmomentum_si	        = zeros(nodeCount,2,fieldnumber);                   % Nodal Momentum
	 nmass_si	            = zeros(nodeCount,fieldnumber);
	% L_si	                = zeros(nodeCount,2,2,fieldnumber);

	 % Momentum
	
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid	              = CONNECT{sp}(j);
			nmomentum_si(npid,:,TheFieldSplit(j,sp))  = nmomentum_si(npid,:,TheFieldSplit(j,sp)) + m_sp(sp)*v_ssp(sp,:)*N{sp}(j);
			nmass_si(npid,TheFieldSplit(j,sp))=nmass_si(npid,TheFieldSplit(j,sp))+m_sp(sp)*N{sp}(j);
			%nmomentum_si(npid,:,1)  = nmomentum_si(npid,:,1) + m_sp(sp)*v_ssp(sp,:)*N{sp}(j);
			%nmass_si(npid,1)=nmass_si(npid,1)+m_sp(sp)*N{sp}(j);
%{
			for p=1:2
				for q=1:2
					L_si(npid,p,q,TheFieldSplit{sp}(j))=L_si(npid,p,q,TheFieldSplit{sp}(j))+v_ssp(sp,p)*dN{sp}(q,j);
				end
			end
%}
		end
	end

	% Velocity
	for sp = 1:spCount
		for j = 1:NODES(sp)
			npid	                  = CONNECT{sp}(j);
			if nmass_si(npid,TheFieldSplit(j,sp))==0
			%if nmass_si(npid,1)==0
				continue
			end 
			nvelo_si(npid,:,TheFieldSplit(j,sp))	           = nmomentum_si(npid,:,TheFieldSplit(j,sp))/nmass_si(npid,TheFieldSplit(j,sp)); 
			%nvelo_si(npid,:,1)	           = nmomentum_si(npid,:,1)/nmass_si(npid,1); 
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [data]=Boundary_Dirichlet(nfbcx,nfbcy,fbcx,fbcy,data)
	for i=1:nfbcx
		data(fbcx(i),1,1)	 = 0;
	end

	for i=1:nfbcy
		data(fbcy(i),2,1)	 = 0;
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [F_sp,A_sp,t_sp,s_sp,p_sp,E_acc,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,evaltimes,stackvars,duration,dudx_sp,W_sp,thetacrackrtl,thetacrack,justcracked,Qacoustic,h,RQ,QbackRback,AbeforeQ_rtl] = ...
	Update_Stress_par(CModel,NODES,dt,cellCount,mspoints,CONNECT,nvelo_si,dN,E,nu,F_sp,A_spo,t_spo,m_sp,s_sp,p_sp,A_sp,t_sp,E_acc,epsilonshrinkdot_sp,epsilonshrinkdotmat_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,troubleshotparticles,matmodel,k_sp,kdot_sp,weakeningfactor_sp,orientationoffset,Rdisplayedparticles,t_time,Debugging,Nmatrix,dNxmatrix,dNymatrix,spCount,dudx_sp,W_sp,thetacrackrtl)
	% Calculate stress for solid phase
	% deactivated, check zz2008221605.m for last working version
	DUMMY=input_codegen(['Update_Stress_par called, this function is deactivated' char(13) char(10) 'this is bogus input prompt']);
	F_sp=[];
	A_sp=[];
	t_sp=[];
	s_sp=[];
	p_sp=[];
	E_acc=[];
	e_pl_sp=[];
	sigma_global_big=[];
	e_t_global_big=[];
	e_pl_global_big=[];
	alphahp=[];
	f_final_vect=[];
	surfacewithfmax=[];
	sigma_local_big=[];
	evaltimes=[];
	stackvars=[];
	duration=[];
	dudx_sp=[];
	W_sp=[];
	thetacrackrtl=[];
	thetacrack=[];
	justcracked=[];
	Qacoustic=[];
	h=[];
	RQ=[];
	QbackRback=[];
	AbeforeQ_rtl=[];
	
	
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [e_t_schmidtswellsonly,e_t_schmidtglobalmatrixsimple,sse_sp,F_sp,A_sp,t_sp,s_sp,p_sp,E_acc,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,evaltimes,stackvars,duration,dudx_sp,W_sp,thetacrackrtl,thetacrack,justcracked,Qacoustic,h,RQ,QbackRback,AbeforeQ,Ktangent_local] = ...
	Update_Stress_par_optimized(e_t_schmidtswellsonly,e_t_schmidtglobalmatrixsimple,CModel,NODES,dt,cellCount,mspoints,CONNECT,nvelo_si,dN,E,nu,F_sp,A_spo,t_spo,m_sp,s_sp,p_sp,A_sp,t_sp,E_acc,epsilonshrinkdot_sp,epsilonshrinkdotmat_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,troubleshotparticles,matmodel,k_sp,kdot_sp,weakeningfactor_sp,orientationoffset,Rdisplayedparticles,t_time,Debugging,spCount,dudx_sp,W_sp,thetacrackrtl,TheFieldSplit,fieldnumber,Efactor_sp)
	% Calculate stress for solid phase
	L_sp=cell(1,spCount);
	dudx_matrix=zeros(2,2,spCount);
	duration=zeros(1,spCount);
	sse_sp=zeros(1,spCount); %specific (volume) elastic strain energy
	
	dESP=cell(1,spCount);
	J=cell(1,spCount);

	for i=1:spCount
		L_sp{i}=zeros(2,2);
		J{i}=0;
		dESP{i}=zeros(2,2);
	end
	
	
	for c=1:cellCount
		mpts = mspoints{c};
		
		for sp = 1:length(mpts)
			spid = mpts(sp);
			%L_sp{spid} = [L_sp_vect(spid,1,1) L_sp_vect(spid,1,2) ; L_sp_vect(spid,2,1) L_sp_vect(spid,2,2)];
			L_sp{spid} = zeros(2,2);
			for j=1:NODES(spid)
				if dN{spid}(1,j)==0 && dN{spid}(2,j)==0
					continue
				end
				npid = CONNECT{spid}(j);
				L_sp{spid} = L_sp{spid} + (nvelo_si(npid,:,TheFieldSplit(j,spid))'*dN{spid}(:,j)');
	        end
			%ESP_prev=[e_t_global_big(spid,1) e_t_global_big(spid,4);e_t_global_big(spid,4) e_t_global_big(spid,2)];
			dESP_swells=zeros(2,2);
			dESP{spid} = ((L_sp{spid} + L_sp{spid}')/2-([epsilonshrinkdot_sp(spid) 0;0 epsilonshrinkdot_sp(spid)]+epsilonshrinkdotmat_sp(:,:,spid)))*dt; 
			%TDL where total strain is calculated for schmidt model with shrinkage
			e_t_schmidtglobalmatrixsimple(spid,1)=e_t_schmidtglobalmatrixsimple(spid,1)+dESP{spid}(1,1);
			e_t_schmidtglobalmatrixsimple(spid,2)=e_t_schmidtglobalmatrixsimple(spid,2)+dESP{spid}(2,2);
			e_t_schmidtglobalmatrixsimple(spid,3)=e_t_schmidtglobalmatrixsimple(spid,3)+dESP{spid}(1,2);
			
			dESP_swells=([epsilonshrinkdot_sp(spid) 0;0 epsilonshrinkdot_sp(spid)]+epsilonshrinkdotmat_sp(:,:,spid))*dt;
			
			e_t_schmidtswellsonly(spid,1)=e_t_schmidtswellsonly(spid,1)+dESP_swells(1,1);
			e_t_schmidtswellsonly(spid,2)=e_t_schmidtswellsonly(spid,2)+dESP_swells(2,2);
			e_t_schmidtswellsonly(spid,3)=e_t_schmidtswellsonly(spid,3)+dESP_swells(1,2);
			% if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
			%    W{spid}=(L_sp{spid} - L_sp{spid}')/2;
			%    s_sp_prev(spid,1)=sigma_global_big(spid,1);
			%    s_sp_prev(spid,2)=sigma_global_big(spid,2);
			%    s_sp_prev(spid,3)=sigma_global_big(spid,4);
			%end
			
			F_sp{spid} = (eye(2,2)+L_sp{spid}*dt)*F_sp{spid};
			%dESP{spid} = transpose(F_sp{spid})*dESP{spid}*F_sp{spid};
			%deltaF=L_sp{spid}*dt*F_sp{spid};
			J{spid} = det(F_sp{spid});
			A_sp(spid)=A_spo(spid)*J{spid};
			
			t_sp(spid)=t_spo(spid)*exp(e_t_global_big(spid,3));

			p_sp(spid) = m_sp(spid)/(A_sp(spid)*t_sp(spid));
			%ESP_now=1/2*(transpose(F_sp{spid})*F_sp{spid}-eye(2));
			%dESP{spid} = ESP_now-ESP_prev;
			%dESP{spid}=1/2*(deltaF*transpose(F_sp{spid})+F_sp{spid}*transpose(deltaF));
			%dESP{spid}=1/2*(deltaF+transpose(deltaF)+transpose(deltaF)*deltaF);
			
			%{
			dudx_sp(spid,1)=dudx_sp(spid,1)+L_sp{spid}(1,1)*dt;
			dudx_sp(spid,2)=dudx_sp(spid,2)+L_sp{spid}(1,2)*dt;
			dudx_sp(spid,3)=dudx_sp(spid,3)+L_sp{spid}(2,1)*dt;
			dudx_sp(spid,4)=dudx_sp(spid,4)+L_sp{spid}(2,2)*dt;
			%}
			
			
			dudx_matrix(:,:,spid)=eye(2)-(F_sp{spid}^(-1));
			dudx_sp(spid,1)=dudx_matrix(1,1,spid);
			dudx_sp(spid,2)=dudx_matrix(1,2,spid);
			dudx_sp(spid,3)=dudx_matrix(2,1,spid);
			dudx_sp(spid,4)=dudx_matrix(2,2,spid);
		end	  
	end
	evaltimes=zeros(length(dESP),1);
	for i=1:length(Rdisplayedparticles)
		Rback=poldecomp(F_sp{Rdisplayedparticles(i)},0);
		R=transpose(Rback);
		Q=[cos(orientationoffset(Rdisplayedparticles(i))) sin(orientationoffset(Rdisplayedparticles(i))); -sin(orientationoffset(Rdisplayedparticles(i))) cos(orientationoffset(Rdisplayedparticles(i)))];
		%Qback=[cos(-orientationoffset(Rdisplayedparticles(i))) sin(-orientationoffset(Rdisplayedparticles(i))); -sin(-orientationoffset(Rdisplayedparticles(i))) cos(-orientationoffset(Rdisplayedparticles(i)))];
		RQ=R*Q;
		thetarotateall=asin(RQ(1,2));
		thetarotateoriginal=asin(Q(1,2));
		fprintf('%s',[PrintMatrixVectorized(RQ,['RQ{' float2txt(5,Rdisplayedparticles(i)) '}'],0) '; theta=' float2txt(5,thetarotateall*180/pi) ' deg; thetaoriginal=' float2txt(5,thetarotateoriginal*180/pi) ' deg' char(10)]);
	end
	
	f_final_vect=zeros(size(alphahp));
	surfacewithfmax=zeros(size(E_acc));
	sigma_local_big=zeros(size(sigma_global_big));
	AbeforeQ_rtl=zeros(2,2,2,2,length(dESP));
	AbeforeQ=zeros(2,2,2,2,length(dESP));
	Ktangent_local=zeros(6,6,length(dESP));
	
	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17 || CasetoRun==11 || CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44 || CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14 || CasetoRun==5 || CasetoRun==6 || CasetoRun==10 || CasetoRun==64 || CasetoRun==66 || CasetoRun==69 || CasetoRun==67 || CasetoRun==68 || CasetoRun==71 || CasetoRun==72 || CasetoRun==73 || CasetoRun==74 || CasetoRun==78 || CasetoRun==81 || CasetoRun==79 || CasetoRun==80 || CasetoRun==82 || CasetoRun==83 || CasetoRun==84 || CasetoRun==88 || CasetoRun==98 || CasetoRun==100 || CasetoRun==101 || CasetoRun==109 || CasetoRun==105 || CasetoRun==102 || CasetoRun==106 || CasetoRun==107 || CasetoRun==103 || CasetoRun==104 || CasetoRun==108 || CasetoRun==114 || CasetoRun==111 || CasetoRun==115 || CasetoRun==116 || CasetoRun==119 || CasetoRun==137 || CasetoRun==122 || CasetoRun==121 || CasetoRun==120 || CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==117 || CasetoRun==113 || CasetoRun==112 || CasetoRun==110 || CasetoRun==96 || CasetoRun==86 || CasetoRun==87 || CasetoRun==91 || CasetoRun==95 || CasetoRun==97 || CasetoRun==99 || CasetoRun==92 || CasetoRun==94 || CasetoRun==93 || CasetoRun==90 || CasetoRun==89 || CasetoRun==85 || CasetoRun==77 || CasetoRun==65 || CasetoRun==70
		if s_sp(3,1)<-5.95
			1;
		end
		
		switcherconfirmer=zeros(1,length(dESP));
		thetacrack=zeros(1,length(dESP));
		
		s_sp_store=s_sp;
		sigma_global_big_store=sigma_global_big;
		e_t_global_big_store=e_t_global_big;
		e_pl_global_big_store=e_pl_global_big;
		alphahp_store=alphahp;
		thetacrackrtl_store=thetacrackrtl;
		stackvars=zeros(length(dESP)+1,2);
		justcracked=zeros(length(dESP),1);
		Qacoustic=cell(1,spCount);
		Qacoustic{1}=zeros(2,2,36*1*1*1); %for debugging crashing coder purpose delete this later
		for i=1:spCount
			Qacoustic{i}=zeros(2,2,36*1*1*1); %ntestedangle is 36*1*1*1, see at 15638
		end
		h=cell(1,length(dESP));
		RQ=zeros(2,2,length(dESP));
		QbackRback=zeros(2,2,length(dESP));
		elasticstrength=0;
		elasticstrength_loaded=loadvariable('elasticstrength');
		if elasticstrength_loaded.found
			elasticstrength=str2float(elasticstrength_loaded.valuetext);
		end
		%{
		%switchable1
		try
			if Debugging.Active && CloseEnough(t_time,Debugging.Time,1e-5,2)
				asdf(-pi);
	        end
			parforstarttime=clockallsec;
			parfor spid=1:length(dESP) %originally parfor
				[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid),switcherconfirmer(spid),evaltimes(spid),stackvars(spid,:),duration(spid),thetacrackrtl(spid),thetacrack(spid),justcracked(spid),Qacoustic{spid},h{spid},RQ(:,:,spid),QbackRback(:,:,spid),AbeforeQ(:,:,:,:,spid)]= ... 
					Matmodel_parforred_confirmer(elasticstrength,F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,k_sp(spid),kdot_sp(spid),weakeningfactor_sp(spid),orientationoffset(spid),switcherconfirmer(spid),t_time,dt,spid,Debugging,parforstarttime,thetacrackrtl(spid),dudx_matrix(:,:,spid),Efactor_sp(spid));   
			end
		catch		
			s_sp=s_sp_store;
			sigma_global_big=sigma_global_big_store;
			e_t_global_big=e_t_global_big_store;
			e_pl_global_big=e_pl_global_big_store;
			alphahp=alphahp_store;
			thetacrackrtl=thetacrackrtl_store;
			
			fprintf('%s',['that parfor random error again!' char(10)]);
			printvector(switcherconfirmer,'switcherconfirmer');
			fprintf('%s',['# of done particles = ' int2txt(sum(switcherconfirmer)) char(10)]);
			switcherconfirmer=zeros(1,length(dESP));
			parforstarttime=clockallsec;
		if CloseEnough(t_time,0.00073950997288745197975889933417193,1e-5,2)
			1;
		end
		%}
		%switchable1

		%[
		%switchable1
		parforstarttime=0;
		%]
		%switchable1
			parfor spid=1:length(dESP)
				[sse_sp(spid),s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid),switcherconfirmer(spid),evaltimes(spid),stackvars(spid,:),duration(spid),thetacrackrtl(spid),thetacrack(spid),justcracked(spid),Qacoustic{spid},h{spid},RQ(:,:,spid),QbackRback(:,:,spid),AbeforeQ(:,:,:,:,spid),Ktangent_local(:,:,spid)]= ... 
					Matmodel_parforred_confirmer(elasticstrength,F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,k_sp(spid),kdot_sp(spid),weakeningfactor_sp(spid),orientationoffset(spid),switcherconfirmer(spid),t_time,dt,spid,Debugging,parforstarttime,thetacrackrtl(spid),dudx_matrix(:,:,spid),Efactor_sp(spid));
			end
			%tempmarker2
		
			%{
			%switchable1
			fprintf('%s',['regular for alternative successful!' char(10)]);
			printvector(switcherconfirmer,'switcherconfirmer');
			1;
		end
		stackvars(length(dESP)+1,2)=max(stackvars(:,1)+stackvars(:,2));
		stackvars(length(dESP)+1,1)=0;
		if CloseEnough(t_time,0.00073950997288745197975889933417193,1e-5,2)
			1;
		end	
		1==1;
		if 1==0
			h = barh(stackvars,'stacked');
			set(h,{'FaceColor'},{'w';'k'},'EdgeColor','none');
		end
		%}
		%switchable1
		1;
	elseif CasetoRun==4
		parfor spid=1:length(dESP)
			switch CModel
				case 'Neo_Hookean_Elastic'
					[s_sp(spid,:)]=Neo_Hookean_elastic(F_sp{spid},J{spid},E,nu);
				case 'Linear_Elastic'
					[s_sp(spid,:)]=Linear_elastic(dESP{spid},s_sp(spid,:),E,nu);
					f_final_vect(spid,:)=zeros(1,7);
					surfacewithfmax(spid)=0;
				case 'Mises'
					[s_sp(spid,:)]=Von_Mises(dESP{spid},s_sp(spid,:),E,nu,30);
				case 'Mises_Softening'
					[s_sp(spid,:),E_acc(spid),e_pl_sp(spid,:)]=Von_Mises_Softening(dESP{spid},s_sp(spid,:),E,nu,30,E_acc(spid),e_pl_sp(spid,:));
				case 'Wood_Schmidt5'
					[s_sp(spid,:),e_pl_sp(spid,:)]=Wood_Schmidt5(dESP{spid},s_sp(spid,:),e_pl_sp(spid,:));
					E_acc(spid)=0;
				case 'Wood_Schmidt15'
					[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:)]=Wood_Schmidt15_function(dESP{spid},sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:));
					E_acc(spid)=0;
				case 'Wood_Schmidt16'
					[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:)]=Wood_Schmidt16(dESP{spid},sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:));
					E_acc(spid)=0;
				case 'Wood_Schmidt17'
					[s_sp(spid,:),e_pl_sp(spid,: ),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),AbeforeQ_rtl(:,:,:,:,spid)]= ...
						Wood_Schmidt17(dESP{spid},sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun);

					E_acc(spid)=0;
			end	
		end
	%elseif CasetoRun==5 || CasetoRun==6
	%	f_final_vect=zeros(size(alphahp));
	%	surfacewithfmax=zeros(size(E_acc));
	%	sigma_local_big=zeros(size(sigma_global_big));
	%	parfor spid=1:length(dESP) %originally parfor
	%	    [s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid)]= ... 
	%	        Matmodel_parforred(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,weakeningfactor_sp(spid),orientationoffset(spid));   
	%	end
	elseif CasetoRun==7
		if s_sp(3,1)<-5.95
			1;
		end
		f_final_vect=zeros(size(alphahp));
		surfacewithfmax=zeros(size(E_acc));
		sigma_local_big=zeros(size(sigma_global_big));
		parfor spid=1:length(dESP) %originally parfor
			[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid),AbeforeQ_rtl(:,:,:,:,spid)]= ... 
				Matmodel_parforred(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,k_sp(spid),kdot_sp(spid),weakeningfactor_sp(spid),orientationoffset(spid));   
		end
	elseif CasetoRun==8 || CasetoRun==9
		f_final_vect=zeros(size(alphahp));
		surfacewithfmax=zeros(size(E_acc));
		sigma_local_big=zeros(size(sigma_global_big));
		parfor spid=1:length(dESP) %originally parfor
			[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid),AbeforeQ_rtl(:,:,:,:,spid)]= ... 
				Matmodel_parforred(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,k_sp(spid),kdot_sp(spid),weakeningfactor_sp(spid),orientationoffset(spid));   
		end
	%{	
	elseif CasetoRun==10
		if s_sp(3,1)<-5.95
			1;
		end
		f_final_vect=zeros(size(alphahp));
		surfacewithfmax=zeros(size(E_acc));
		sigma_local_big=zeros(size(sigma_global_big));
		parfor spid=1:length(dESP) %originally parfor
			[s_sp(spid,:),e_pl_sp(spid,:),sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),f_final_vect(spid,:),surfacewithfmax(spid),sigma_local_big(spid,:),E_acc(spid)]= ... 
				Matmodel_parforred(F_sp{spid},matmodel(spid),dESP{spid},s_sp(spid,:),E,nu,sigma_global_big(spid,:),e_t_global_big(spid,:),e_pl_global_big(spid,:),alphahp(spid,:),xdirletter{spid},ydirletter{spid},zdirletter{spid},xydirletter{spid},yzdirletter{spid},xzdirletter{spid},ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,k_sp(spid),kdot_sp(spid),weakeningfactor_sp(spid),orientationoffset(spid));   
		end
		%}
	end
	for sp=1:spCount
		dW_sp=sum(sum([s_sp(sp,1) s_sp(sp,3);s_sp(sp,3) s_sp(sp,2)].*dESP{sp}));
		W_sp(sp)=W_sp(sp)+dW_sp;
	end
	%{
	for spid=1:length(dESP)
	%	if spid==troubleshotparticles(1) | spid==troubleshotparticles(2)
	%	    if e_pl_sp(troubleshotparticles(1),1)<-1e-10 | e_pl_sp(troubleshotparticles(2),1)<-1e-10
	%	        1;
	%	    end
	%	end
		newSSP=(1/J{spid})*F_sp{spid}*[s_sp(spid,1) s_sp(spid,3);s_sp(spid,3) s_sp(spid,2)]*transpose(F_sp{spid});
		s_sp(spid,1)=newSSP(1,1);
		s_sp(spid,2)=newSSP(2,2);
		s_sp(spid,3)=newSSP(1,2);
	end
	%}
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [AbeforeQ_si,AbeforeQ_si_active]=Interpolate_AbeforeQ(AbeforeQ,NODES,nodeCount,CONNECT,N,spCount,m_sp,TheFieldSplit,CasetoRun,fieldnumber)
	%% Interpolation from particle to grid task
	% Node variables
	% grid mapping
	nmass_si=zeros(nodeCount,fieldnumber);
	AbeforeQ_si=zeros(2,2,2,2,nodeCount,fieldnumber); %remember this order, nonstandard!
	AbeforeQ_si_active=zeros(nodeCount,fieldnumber); %to identify whether a node is active for AbeforeQ crack initiation/mapping
	mAbeforeQ_si=zeros(2,2,2,2,nodeCount,fieldnumber); %remember this order, nonstandard!
	
	for sp=1:spCount
		for j=1:NODES(sp)
			npid	                       = CONNECT{sp}(j);
			if N{sp}(j)==0
				continue
			end
			
			% Mass 
			nmass_si(npid,TheFieldSplit(j,sp))	        = nmass_si(npid,TheFieldSplit(j,sp)) + m_sp(sp)*N{sp}(j);
			
			% m * A before Q (4th order tensor)
			for p=1:2
			for q=1:2
			for r=1:2
			for s=1:2
				mAbeforeQ_si(p,q,r,s,npid,TheFieldSplit(j,sp))=mAbeforeQ_si(p,q,r,s,npid,TheFieldSplit(j,sp))+m_sp(sp)*AbeforeQ(p,q,r,s,sp);
			end
			end
			end
			end
		end
	end
	
	
	parfor io=1:nodeCount
		[AbeforeQ_si(:,:,:,:,io,:),AbeforeQ_si_active(io,:)]=AbeforeQ_si_inparfor(fieldnumber,mAbeforeQ_si(:,:,:,:,io,:),nmass_si(io,:));
		%{
		for ifield=1:fieldnumber
			if nmass_si(io,ifield)>0
				AbeforeQ_si_active(io,ifield)=1;
				for dim1=1:2
				for dim2=1:2
				for dim3=1:2
				for dim4=1:2
					AbeforeQ_si(dim1,dim2,dim3,dim4,io,ifield)=mAbeforeQ_si(dim1,dim2,dim3,dim4,io,ifield)/nmass_si(io,ifield);
				end
				end
				end
				end
			end
		end
		%}
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [AbeforeQ_si,AbeforeQ_si_active]=AbeforeQ_si_inparfor(fieldnumber,mAbeforeQ_si,nmass_si);
	AbeforeQ_si=zeros(2,2,2,2,1,fieldnumber);
	AbeforeQ_si_active=zeros(1,fieldnumber);
	for ifield=1:fieldnumber
		if nmass_si(1,ifield)>0
			AbeforeQ_si_active(1,ifield)=1;
			for dim1=1:2
			for dim2=1:2
			for dim3=1:2
			for dim4=1:2
				AbeforeQ_si(dim1,dim2,dim3,dim4,1,ifield)=mAbeforeQ_si(dim1,dim2,dim3,dim4,1,ifield)/nmass_si(1,ifield);
			end
			end
			end
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [sse_sp,s_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,E_acc,switcherconfirmer,evaltimes,stackvars,duration,thetacrackrtl,thetacrack,justcracked,Qacoustic,h,RQ,QbackRback,AbeforeQ,Ktangent_local]= ... 
	Matmodel_parforred_confirmer(elasticstrength,F_sp,matmodel,dESP,s_sp,E,nu,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,k_sp,kdot_sp,weakeningfactor_sp,orientationoffset,switcherconfirmer,t_time,dt,spid,Debugging,parforstarttime,thetacrackrtl,dudx_matrix,Efactor_sp)
	%{
	%switchable1
	matmodelstarttime=clockallsec;
	%}
	%switchable1
	evaltimes=0;
	%s_sp=zeros(1,3);
	
	surfacewithfmax=zeros(1,1);
	surfacewithfmax(1)=0;
	thetacrack=NaN;
	justcracked=0;
	
	sse_sp=0;
	e_pl_sp=zeros(1,3);
	%e_t_global_big=zeros(1,6);
	%e_pl_global_big=zeros(1,6);
	%alphahp=zeros(1,7);
	sigma_local_big=zeros(1,6);
	E_acc=0;
	Qacoustic=[];
	h=[];
	stackvars=zeros(1,2);
	RQ=eye(2);
	QbackRback=eye(2);
	AbeforeQ_rtl=zeros(2,2,2,2,1);
	AbeforeQ=zeros(2,2,2,2,1); %to stop coder whining
	Ktangent_local=zeros(6,6); %local tangent stiffness
	%sigma_global_big(1,:)=zeros(1,6);
	f_final_vect=zeros(1,7);
	duration=0;
	
	if CasetoRun==172 || CasetoRun==174
		%turned off for now %NOT
		E=E*Efactor_sp; %Efactor_sp is a scalar here
	end
	
	switch matmodel(1)
		%TDL latest material model switcher
		%TDL matmodel case switch statement
		case 1
			%thetacrackrtl=NaN;
			Rback=poldecomp(F_sp,0);
			%Rback=eye(2);
			%TDL constitutive rotation here
			R=transpose(Rback);
			Q=[cos(orientationoffset) sin(orientationoffset); -sin(orientationoffset) cos(orientationoffset)];
			Qback=[cos(-orientationoffset) sin(-orientationoffset); -sin(-orientationoffset) cos(-orientationoffset)];
			RQ=R*Q;
			QbackRback=Qback*Rback;
			dESP=(RQ)*dESP*transpose(RQ);
			dudx_rtl=(RQ)*dudx_matrix*transpose(RQ);
			[s_sp(1,:),e_pl_sp(1,:),sigma_global_big(1,:),e_t_global_big(1,:),e_pl_global_big(1,:),alphahp(1,:),f_final_vect(1,:),surfacewithfmax(1),sigma_local_big(1,:),AbeforeQ_rtl(:,:,:,:,1),evaltimes,thetacrackrtl,justcracked,Qacoustic,h,Ktangent_local,~]= ... 
				Wood_Schmidt17(k_sp,kdot_sp*dt,1,dESP,sigma_global_big(1,:),e_t_global_big(1,:),e_pl_global_big(1,:),alphahp(1,:),xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl*(1-weakeningfactor_sp),ftr*(1-weakeningfactor_sp),ftt*(1-weakeningfactor_sp),fcl*(1-weakeningfactor_sp),fcr*(1-weakeningfactor_sp),fct*(1-weakeningfactor_sp),fvrt*(1-weakeningfactor_sp),fvrl*(1-weakeningfactor_sp),fvtl*(1-weakeningfactor_sp),Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,t_time,dt,spid,Debugging,thetacrackrtl,dudx_rtl);
			%fprintf('%s',['s_sp(1,1)=' float2scitxt(6,s_sp(1,1)) char(10)]);
			AbeforeQ=zeros(2,2,2,2,1);
			for i=1:2
			for j=1:2
			for k=1:2
			for l=1:2
			for p=1:2
			for q=1:2
			for r=1:2
			for s=1:2
				AbeforeQ(i,j,k,l,1)=AbeforeQ(i,j,k,l,1)+real(QbackRback(i,p)*QbackRback(j,q)*QbackRback(k,r)*QbackRback(l,s)*AbeforeQ_rtl(p,q,r,s,1));
			end
			end
			end
			end
			end
			end
			end
			end
			thetacrack=real(thetacrackrtl+reliableatan(RQ(1,1),RQ(1,2)));
			thetacrack=mod(thetacrack+pi/2,pi)-pi/2;
			%dummy=input_codegen('This is Bogus Input, close console!');
			E_acc(1)=0;
			
			s_sp_mat_backrotated=(QbackRback)*[s_sp(1,1) s_sp(1,3);s_sp(1,3) s_sp(1,2)]*transpose(QbackRback);
			s_sp(1,1)=real(s_sp_mat_backrotated(1,1));
			s_sp(1,2)=real(s_sp_mat_backrotated(2,2));
			s_sp(1,3)=real(s_sp_mat_backrotated(1,2));
		case 2
			s_sp(1,1)=sigma_global_big(1,1);
			s_sp(1,2)=sigma_global_big(1,2);
			s_sp(1,3)=sigma_global_big(1,4);
			[s_sp(1,:)]=Linear_elastic(dESP,s_sp(1,:),E,nu);
			
			thetacrackrtl=NaN;
			thetacrack=NaN;
			justcracked=0;
			
			sigma_global_big(1,1)=s_sp(1,1);
			sigma_global_big(1,2)=s_sp(1,2);
			sigma_global_big(1,4)=s_sp(1,3);
			
		case 3
			thetacrackrtl=NaN;
			thetacrack=NaN;
			justcracked=0;
			s_sp(1,1)=sigma_global_big(1,1);
			s_sp(1,2)=sigma_global_big(1,2);
			s_sp(1,3)=sigma_global_big(1,4);
			%[s_sp(1,:)]=Linear_elastic_orthotropic(dESP,s_sp(1,:),1.5*Er*2,1.5*Er,1.5*Er,nu);
			if CasetoRun==55 || CasetoRun==56 || CasetoRun==57
				[s_sp(1,:)]=Linear_elastic_orthotropic_2(dESP,s_sp(1,:),10*Er,1.5*Er,El,Grt,Grl,Grl,nurt,nurl,nurl);
			elseif CasetoRun==58 || CasetoRun==59 || CasetoRun==60
				[s_sp(1,:)]=Linear_elastic_orthotropic_2(dESP,s_sp(1,:),200*Er,0.001*Er,El,Grt,Grl,Grl,nurt,nurl,nurl);
			elseif CasetoRun==61 || CasetoRun==62 || CasetoRun==63
				[s_sp(1,:)]=Linear_elastic_orthotropic_2(dESP,s_sp(1,:),1.5*Er,1.5*Er/(10^5),El,Grt,Grl,Grl,0,0,0);
			end
			%[s_sp(1,:)]=Linear_elastic(dESP,s_sp(1,:),1.5*Er,nu);
			sigma_global_big(1,1)=s_sp(1,1);
			sigma_global_big(1,2)=s_sp(1,2);
			sigma_global_big(1,4)=s_sp(1,3);
		case 4
			%Late Wood
			if spid==239 && CloseEnough(t_time,0.005842128785810849801729549568563,1e-5,2)
				1;
			end
			s_sp(1,1)=sigma_global_big(1,1);
			s_sp(1,2)=sigma_global_big(1,2);
			s_sp(1,3)=sigma_global_big(1,4);
			[sse_sp,s_sp(1,:)]=Linear_elastic_se(dESP,s_sp(1,:),E,nu);

			if CasetoRun==208 || CasetoRun==209 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218
				elasticstrength=99999;
			elseif CasetoRun==217 || CasetoRun==229 || CasetoRun==228
				elasticstrength=25;
			elseif CasetoRun==230
				%nothing, we take elasticstrength from the loaded
			else
				elasticstrength=0.125;
			end
			%printfloat(1,elasticstrength,'in 43317, elasticstrength')
			sigmamaxprinc=(s_sp(1,1)+s_sp(1,2))/2+sqrt( ((s_sp(1,1)-s_sp(1,2))/2)^2 + (s_sp(1,3))^2 );
			%{
			if sigmamaxprinc>elasticstrength
				%disp(sigmamaxprinc);
			end
			%}
			if isnan(thetacrackrtl)
				sigmamaxprinc=(s_sp(1,1)+s_sp(1,2))/2+sqrt( ((s_sp(1,1)-s_sp(1,2))/2)^2 + (s_sp(1,3))^2 );
				%disp(sigmamaxprinc);
				if sigmamaxprinc>elasticstrength
					%disp('just cracked!')
					thetacrackrtl=0.5*(pi-reliableatan((s_sp(1,1)-s_sp(1,2))/2,-s_sp(1,3)));
					thetacrack=thetacrackrtl;
					justcracked=1;
				else
					thetacrack=NaN;
					justcracked=0;
				end
			else
				thetacrack=NaN;
				justcracked=0;
			end
			
			sigma_global_big(1,1)=s_sp(1,1);
			sigma_global_big(1,2)=s_sp(1,2);
			sigma_global_big(1,4)=s_sp(1,3);
		case 5
			%Early Wood
			%tempmarker6
			E_EW=40/1200*E;
			s_sp(1,1)=sigma_global_big(1,1);
			s_sp(1,2)=sigma_global_big(1,2);
			s_sp(1,3)=sigma_global_big(1,4);
			[s_sp(1,:)]=Linear_elastic(dESP,s_sp(1,:),E_EW,nu);

			elasticstrength=0.125*sqrt(E_EW/E);
			sigmamaxprinc=(s_sp(1,1)+s_sp(1,2))/2+sqrt( ((s_sp(1,1)-s_sp(1,2))/2)^2 + (s_sp(1,3))^2 );
			%{
			if sigmamaxprinc>elasticstrength
				%disp(sigmamaxprinc);
			end
			%}
			if isnan(thetacrackrtl)
				sigmamaxprinc=(s_sp(1,1)+s_sp(1,2))/2+sqrt( ((s_sp(1,1)-s_sp(1,2))/2)^2 + (s_sp(1,3))^2 );
				%disp(sigmamaxprinc);
				if sigmamaxprinc>elasticstrength
					%disp('just cracked!')
					thetacrackrtl=0.5*(pi-reliableatan((s_sp(1,1)-s_sp(1,2))/2,-s_sp(1,3)));
					thetacrack=thetacrackrtl;
					justcracked=1;
				else
					thetacrack=NaN;
					justcracked=0;
				end
			else
				thetacrack=NaN;
				justcracked=0;
			end
			
			sigma_global_big(1,1)=s_sp(1,1);
			sigma_global_big(1,2)=s_sp(1,2);
			sigma_global_big(1,4)=s_sp(1,3);
		case 6
			%hyperelastic
			[s_sp(1,:)]=Neo_Hookean_elastic(F_sp,E,nu);

			thetacrackrtl=NaN;
			thetacrack=NaN;
			justcracked=0;
			
			sigma_global_big(1,1)=s_sp(1,1);
			sigma_global_big(1,2)=s_sp(1,2);
			sigma_global_big(1,4)=s_sp(1,3);
	end
	switcherconfirmer=switcherconfirmer+1;
	%{
	%switchable1
	matmodelendtime=clockallsec;
	duration=matmodelendtime-matmodelstarttime;
	stackvars(1,1)=matmodelstarttime-parforstarttime;
	stackvars(1,2)=duration;
	%}
	%switchable1
	QbackRback=real(QbackRback);
	RQ=real(RQ);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [s_sp,e_pl_sp,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax,sigma_local_big,E_acc,AbeforeQ_rtl]= ... 
	Matmodel_parforred(F_sp,matmodel,dESP,s_sp,E,nu,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,xdirletter,ydirletter,zdirletter,xydirletter,yzdirletter,xzdirletter,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,Grt,Gtl,Grl,nurt,nutl,nurl,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit,CasetoRun,k_sp,kdot_sp,weakeningfactor_sp,orientationoffset)
	% this function is probably INACTIVE
	% not in use, deactivated, legacy code,
	% check zz2008221606.m for last working version
	DUMMY=input_codegen(['Matmodel_parforred called, this function is deactivated' char(13) char(10) 'this is bogus input prompt']);
	s_sp=[];
	e_pl_sp=[];
	sigma_global_big=[];
	e_t_global_big=[];
	e_pl_global_big=[];
	alphahp=[];
	f_final_vect=[];
	surfacewithfmax=[];
	sigma_local_big=[];
	E_acc=[];
	AbeforeQ_rtl=[];
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [f, dfdsigma, dfdq, d2fdsigma2, d2fdsigmadq, d2fdq2]=Wood_Schmidt_EvalSigmaEff(sigma,q,requestedfaces,requestedoutput,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,CasetoRun)
	requestedfacesarr=[0 0 0 0 0 0 0];
	for i=1:length(requestedfaces)
		requestedfacesarr(requestedfaces(i))=1;
	end
	%requestedoutput: f, dfdsigma, dfdq, d2fdsigma2, d2fdsigmadq, d2fdq2

	sigmarr=sigma(1);
	sigmatt=sigma(2);
	sigmall=sigma(3);
	sigmart=sigma(4);
	sigmatl=sigma(5);
	sigmarl=sigma(6);

	q1=q(1);
	q2=q(2);
	q3=q(3);
	q4=q(4);
	q5=q(5);
	q6=q(6);
	q7=q(7);

	if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21
		%q7=0;
	elseif CasetoRun==4
		%q1=-1e99;
		%q2=-1e99;
		q3=-1e99;
		q4=-1e99;
		%q5=-1e99;
		%q6=-1e99;
		q7=-1e99;
	elseif CasetoRun==5 || CasetoRun==6
	elseif CasetoRun==7
	elseif CasetoRun==8 || CasetoRun==9
	elseif CasetoRun==10
	elseif CasetoRun==11
	elseif CasetoRun==12 || CasetoRun==16 || CasetoRun==18 || CasetoRun==23 || CasetoRun==38 || CasetoRun==51 || CasetoRun==53 || CasetoRun==50 || CasetoRun==49 || CasetoRun==47 || CasetoRun==46 || CasetoRun==41 || CasetoRun==43 || CasetoRun==44
		%q7=0;
		% direct elastic plastic revoked, parameter adjustment chosen instead
	elseif CasetoRun==13 || CasetoRun==20 || CasetoRun==25 || CasetoRun==57 || CasetoRun==58 || CasetoRun==61 || CasetoRun==32 || CasetoRun==55 || CasetoRun==59 || CasetoRun==62 || CasetoRun==56 || CasetoRun==60 || CasetoRun==63 || CasetoRun==35 || CasetoRun==36 || CasetoRun==37 || CasetoRun==15 || CasetoRun==14
		%q7=0; %note perfect shear plasticity unlike CasetoRun==11
		% direct elastic plastic revoked, parameter adjustment chosen instead
	elseif CasetoRun==17
		q7=0;
	elseif CasetoRun==77
		q1=-1e99;
		q2=-1e99;
		q3=-1e99;
		q4=-1e99;
		q5=-1e99;
		q6=-1e99;
		q7=-1e99;
	end
	
	nsurface=7; %use nsurface instead of the number 7 to satisfy coder whining
	nstressvect=6; %just to be with inline with nsurface
	
	f=cell(1,nsurface);
	dfdsigma=cell(1,nsurface);
	dfdq=cell(1,nsurface);
	d2fdsigma2=cell(1,nsurface);
	d2fdsigmadq=cell(1,nsurface);
	d2fdq2=cell(1,nsurface);
	for i=1:nsurface
		f{i}=0;
		dfdsigma{i}=zeros(nstressvect,1);
		dfdq{i}=zeros(nsurface,1);
		d2fdsigma2{i}=zeros(nstressvect,nstressvect);
		d2fdsigmadq{i}=zeros(nstressvect,nsurface);
		d2fdq2{i}=zeros(nsurface,nsurface);
	end
	
	
	% start sym paste, paste here!
	if requestedfacesarr(1)==1
		if requestedoutput(1)==1
			f{1}=0+q1 + sigmarr/ftr + sigmatt^2/(2*fct^2) + (33*sigmarl^2)/(100*fvrl^2) + sigmart^2/(2*fvrt^2) + (33*sigmatl^2)/(100*fvtl^2) - sigmall^2/(4*fcl*ftl) - 1;
		else
			f{1}=[0];
		end
		if requestedoutput(2)==1
			dfdsigma{1}(1,1)=1/ftr;
			dfdsigma{1}(2,1)=sigmatt/fct^2;
			dfdsigma{1}(3,1)=-sigmall/(2*fcl*ftl);
			dfdsigma{1}(4,1)=sigmart/fvrt^2;
			dfdsigma{1}(5,1)=(33*sigmatl)/(50*fvtl^2);
			dfdsigma{1}(6,1)=(33*sigmarl)/(50*fvrl^2);
		else
			dfdsigma{1}(1,1)=[0];
		end
		if requestedoutput(3)==1
			dfdq{1}(1,1)=1;
			dfdq{1}(2,1)=0;
			dfdq{1}(3,1)=0;
			dfdq{1}(4,1)=0;
			dfdq{1}(5,1)=0;
			dfdq{1}(6,1)=0;
			dfdq{1}(7,1)=0;
		else
			dfdq{1}(1,1)=[0];
		end
		if requestedoutput(4)==1
			d2fdsigma2{1}(1,1)=0;
			d2fdsigma2{1}(1,2)=0;
			d2fdsigma2{1}(1,3)=0;
			d2fdsigma2{1}(1,4)=0;
			d2fdsigma2{1}(1,5)=0;
			d2fdsigma2{1}(1,6)=0;
			d2fdsigma2{1}(2,1)=0;
			d2fdsigma2{1}(2,2)=1/fct^2;
			d2fdsigma2{1}(2,3)=0;
			d2fdsigma2{1}(2,4)=0;
			d2fdsigma2{1}(2,5)=0;
			d2fdsigma2{1}(2,6)=0;
			d2fdsigma2{1}(3,1)=0;
			d2fdsigma2{1}(3,2)=0;
			d2fdsigma2{1}(3,3)=-1/(2*fcl*ftl);
			d2fdsigma2{1}(3,4)=0;
			d2fdsigma2{1}(3,5)=0;
			d2fdsigma2{1}(3,6)=0;
			d2fdsigma2{1}(4,1)=0;
			d2fdsigma2{1}(4,2)=0;
			d2fdsigma2{1}(4,3)=0;
			d2fdsigma2{1}(4,4)=1/fvrt^2;
			d2fdsigma2{1}(4,5)=0;
			d2fdsigma2{1}(4,6)=0;
			d2fdsigma2{1}(5,1)=0;
			d2fdsigma2{1}(5,2)=0;
			d2fdsigma2{1}(5,3)=0;
			d2fdsigma2{1}(5,4)=0;
			d2fdsigma2{1}(5,5)=33/(50*fvtl^2);
			d2fdsigma2{1}(5,6)=0;
			d2fdsigma2{1}(6,1)=0;
			d2fdsigma2{1}(6,2)=0;
			d2fdsigma2{1}(6,3)=0;
			d2fdsigma2{1}(6,4)=0;
			d2fdsigma2{1}(6,5)=0;
			d2fdsigma2{1}(6,6)=33/(50*fvrl^2);
		else
			d2fdsigma2{1}(1,1)=[0];
		end
		if requestedoutput(5)==1
			d2fdsigmadq{1}(1,1)=0;
			d2fdsigmadq{1}(1,2)=0;
			d2fdsigmadq{1}(1,3)=0;
			d2fdsigmadq{1}(1,4)=0;
			d2fdsigmadq{1}(1,5)=0;
			d2fdsigmadq{1}(1,6)=0;
			d2fdsigmadq{1}(1,7)=0;
			d2fdsigmadq{1}(2,1)=0;
			d2fdsigmadq{1}(2,2)=0;
			d2fdsigmadq{1}(2,3)=0;
			d2fdsigmadq{1}(2,4)=0;
			d2fdsigmadq{1}(2,5)=0;
			d2fdsigmadq{1}(2,6)=0;
			d2fdsigmadq{1}(2,7)=0;
			d2fdsigmadq{1}(3,1)=0;
			d2fdsigmadq{1}(3,2)=0;
			d2fdsigmadq{1}(3,3)=0;
			d2fdsigmadq{1}(3,4)=0;
			d2fdsigmadq{1}(3,5)=0;
			d2fdsigmadq{1}(3,6)=0;
			d2fdsigmadq{1}(3,7)=0;
			d2fdsigmadq{1}(4,1)=0;
			d2fdsigmadq{1}(4,2)=0;
			d2fdsigmadq{1}(4,3)=0;
			d2fdsigmadq{1}(4,4)=0;
			d2fdsigmadq{1}(4,5)=0;
			d2fdsigmadq{1}(4,6)=0;
			d2fdsigmadq{1}(4,7)=0;
			d2fdsigmadq{1}(5,1)=0;
			d2fdsigmadq{1}(5,2)=0;
			d2fdsigmadq{1}(5,3)=0;
			d2fdsigmadq{1}(5,4)=0;
			d2fdsigmadq{1}(5,5)=0;
			d2fdsigmadq{1}(5,6)=0;
			d2fdsigmadq{1}(5,7)=0;
			d2fdsigmadq{1}(6,1)=0;
			d2fdsigmadq{1}(6,2)=0;
			d2fdsigmadq{1}(6,3)=0;
			d2fdsigmadq{1}(6,4)=0;
			d2fdsigmadq{1}(6,5)=0;
			d2fdsigmadq{1}(6,6)=0;
			d2fdsigmadq{1}(6,7)=0;
		else
			d2fdsigmadq{1}(1,1)=[0];
		end
		if requestedoutput(6)==1
			d2fdq2{1}(1,1)=0;
			d2fdq2{1}(1,2)=0;
			d2fdq2{1}(1,3)=0;
			d2fdq2{1}(1,4)=0;
			d2fdq2{1}(1,5)=0;
			d2fdq2{1}(1,6)=0;
			d2fdq2{1}(1,7)=0;
			d2fdq2{1}(2,1)=0;
			d2fdq2{1}(2,2)=0;
			d2fdq2{1}(2,3)=0;
			d2fdq2{1}(2,4)=0;
			d2fdq2{1}(2,5)=0;
			d2fdq2{1}(2,6)=0;
			d2fdq2{1}(2,7)=0;
			d2fdq2{1}(3,1)=0;
			d2fdq2{1}(3,2)=0;
			d2fdq2{1}(3,3)=0;
			d2fdq2{1}(3,4)=0;
			d2fdq2{1}(3,5)=0;
			d2fdq2{1}(3,6)=0;
			d2fdq2{1}(3,7)=0;
			d2fdq2{1}(4,1)=0;
			d2fdq2{1}(4,2)=0;
			d2fdq2{1}(4,3)=0;
			d2fdq2{1}(4,4)=0;
			d2fdq2{1}(4,5)=0;
			d2fdq2{1}(4,6)=0;
			d2fdq2{1}(4,7)=0;
			d2fdq2{1}(5,1)=0;
			d2fdq2{1}(5,2)=0;
			d2fdq2{1}(5,3)=0;
			d2fdq2{1}(5,4)=0;
			d2fdq2{1}(5,5)=0;
			d2fdq2{1}(5,6)=0;
			d2fdq2{1}(5,7)=0;
			d2fdq2{1}(6,1)=0;
			d2fdq2{1}(6,2)=0;
			d2fdq2{1}(6,3)=0;
			d2fdq2{1}(6,4)=0;
			d2fdq2{1}(6,5)=0;
			d2fdq2{1}(6,6)=0;
			d2fdq2{1}(6,7)=0;
			d2fdq2{1}(7,1)=0;
			d2fdq2{1}(7,2)=0;
			d2fdq2{1}(7,3)=0;
			d2fdq2{1}(7,4)=0;
			d2fdq2{1}(7,5)=0;
			d2fdq2{1}(7,6)=0;
			d2fdq2{1}(7,7)=0;
		else
			d2fdq2{1}(1)=[0];
		end
		%{
		if requestedoutput(7)==1
		dfdinput{1}(1,1)=sigmall^2/(4*fcl*ftl^2);
		dfdinput{1}(2,1)=-sigmarr/ftr^2;
		dfdinput{1}(3,1)=0;
		dfdinput{1}(4,1)=sigmall^2/(4*fcl^2*ftl);
		dfdinput{1}(5,1)=0;
		dfdinput{1}(6,1)=-sigmatt^2/fct^3;
		dfdinput{1}(7,1)=-sigmart^2/fvrt^3;
		dfdinput{1}(8,1)=-(33*sigmarl^2)/(50*fvrl^3);
		dfdinput{1}(9,1)=-(33*sigmatl^2)/(50*fvtl^3);
		else
		dfdinput{1}(1,1)=[0];
		end
		%}
	end
	if requestedfacesarr(2)==1
		if requestedoutput(1)==1
			f{2}=0+q2 + sigmarr/fcr + (2*sigmatt^2)/(5*fct^2) + (33*sigmarl^2)/(100*fvrl^2) + (2*sigmart^2)/(5*fvrt^2) + (33*sigmatl^2)/(100*fvtl^2) - sigmall^2/(4*fcl*ftl) - 1;
		else
			f{2}=[0];
		end
		if requestedoutput(2)==1
			dfdsigma{2}(1,1)=1/fcr;
			dfdsigma{2}(2,1)=(4*sigmatt)/(5*fct^2);
			dfdsigma{2}(3,1)=-sigmall/(2*fcl*ftl);
			dfdsigma{2}(4,1)=(4*sigmart)/(5*fvrt^2);
			dfdsigma{2}(5,1)=(33*sigmatl)/(50*fvtl^2);
			dfdsigma{2}(6,1)=(33*sigmarl)/(50*fvrl^2);
		else
			dfdsigma{2}(1,1)=[0];
		end
		if requestedoutput(3)==1
			dfdq{2}(1,1)=0;
			dfdq{2}(2,1)=1;
			dfdq{2}(3,1)=0;
			dfdq{2}(4,1)=0;
			dfdq{2}(5,1)=0;
			dfdq{2}(6,1)=0;
			dfdq{2}(7,1)=0;
		else
			dfdq{2}(1,1)=[0];
		end
		if requestedoutput(4)==1
			d2fdsigma2{2}(1,1)=0;
			d2fdsigma2{2}(1,2)=0;
			d2fdsigma2{2}(1,3)=0;
			d2fdsigma2{2}(1,4)=0;
			d2fdsigma2{2}(1,5)=0;
			d2fdsigma2{2}(1,6)=0;
			d2fdsigma2{2}(2,1)=0;
			d2fdsigma2{2}(2,2)=4/(5*fct^2);
			d2fdsigma2{2}(2,3)=0;
			d2fdsigma2{2}(2,4)=0;
			d2fdsigma2{2}(2,5)=0;
			d2fdsigma2{2}(2,6)=0;
			d2fdsigma2{2}(3,1)=0;
			d2fdsigma2{2}(3,2)=0;
			d2fdsigma2{2}(3,3)=-1/(2*fcl*ftl);
			d2fdsigma2{2}(3,4)=0;
			d2fdsigma2{2}(3,5)=0;
			d2fdsigma2{2}(3,6)=0;
			d2fdsigma2{2}(4,1)=0;
			d2fdsigma2{2}(4,2)=0;
			d2fdsigma2{2}(4,3)=0;
			d2fdsigma2{2}(4,4)=4/(5*fvrt^2);
			d2fdsigma2{2}(4,5)=0;
			d2fdsigma2{2}(4,6)=0;
			d2fdsigma2{2}(5,1)=0;
			d2fdsigma2{2}(5,2)=0;
			d2fdsigma2{2}(5,3)=0;
			d2fdsigma2{2}(5,4)=0;
			d2fdsigma2{2}(5,5)=33/(50*fvtl^2);
			d2fdsigma2{2}(5,6)=0;
			d2fdsigma2{2}(6,1)=0;
			d2fdsigma2{2}(6,2)=0;
			d2fdsigma2{2}(6,3)=0;
			d2fdsigma2{2}(6,4)=0;
			d2fdsigma2{2}(6,5)=0;
			d2fdsigma2{2}(6,6)=33/(50*fvrl^2);
		else
			d2fdsigma2{2}(1,1)=[0];
		end
		if requestedoutput(5)==1
			d2fdsigmadq{2}(1,1)=0;
			d2fdsigmadq{2}(1,2)=0;
			d2fdsigmadq{2}(1,3)=0;
			d2fdsigmadq{2}(1,4)=0;
			d2fdsigmadq{2}(1,5)=0;
			d2fdsigmadq{2}(1,6)=0;
			d2fdsigmadq{2}(1,7)=0;
			d2fdsigmadq{2}(2,1)=0;
			d2fdsigmadq{2}(2,2)=0;
			d2fdsigmadq{2}(2,3)=0;
			d2fdsigmadq{2}(2,4)=0;
			d2fdsigmadq{2}(2,5)=0;
			d2fdsigmadq{2}(2,6)=0;
			d2fdsigmadq{2}(2,7)=0;
			d2fdsigmadq{2}(3,1)=0;
			d2fdsigmadq{2}(3,2)=0;
			d2fdsigmadq{2}(3,3)=0;
			d2fdsigmadq{2}(3,4)=0;
			d2fdsigmadq{2}(3,5)=0;
			d2fdsigmadq{2}(3,6)=0;
			d2fdsigmadq{2}(3,7)=0;
			d2fdsigmadq{2}(4,1)=0;
			d2fdsigmadq{2}(4,2)=0;
			d2fdsigmadq{2}(4,3)=0;
			d2fdsigmadq{2}(4,4)=0;
			d2fdsigmadq{2}(4,5)=0;
			d2fdsigmadq{2}(4,6)=0;
			d2fdsigmadq{2}(4,7)=0;
			d2fdsigmadq{2}(5,1)=0;
			d2fdsigmadq{2}(5,2)=0;
			d2fdsigmadq{2}(5,3)=0;
			d2fdsigmadq{2}(5,4)=0;
			d2fdsigmadq{2}(5,5)=0;
			d2fdsigmadq{2}(5,6)=0;
			d2fdsigmadq{2}(5,7)=0;
			d2fdsigmadq{2}(6,1)=0;
			d2fdsigmadq{2}(6,2)=0;
			d2fdsigmadq{2}(6,3)=0;
			d2fdsigmadq{2}(6,4)=0;
			d2fdsigmadq{2}(6,5)=0;
			d2fdsigmadq{2}(6,6)=0;
			d2fdsigmadq{2}(6,7)=0;
		else
			d2fdsigmadq{2}(1,1)=[0];
		end
		if requestedoutput(6)==1
			d2fdq2{2}(1,1)=0;
			d2fdq2{2}(1,2)=0;
			d2fdq2{2}(1,3)=0;
			d2fdq2{2}(1,4)=0;
			d2fdq2{2}(1,5)=0;
			d2fdq2{2}(1,6)=0;
			d2fdq2{2}(1,7)=0;
			d2fdq2{2}(2,1)=0;
			d2fdq2{2}(2,2)=0;
			d2fdq2{2}(2,3)=0;
			d2fdq2{2}(2,4)=0;
			d2fdq2{2}(2,5)=0;
			d2fdq2{2}(2,6)=0;
			d2fdq2{2}(2,7)=0;
			d2fdq2{2}(3,1)=0;
			d2fdq2{2}(3,2)=0;
			d2fdq2{2}(3,3)=0;
			d2fdq2{2}(3,4)=0;
			d2fdq2{2}(3,5)=0;
			d2fdq2{2}(3,6)=0;
			d2fdq2{2}(3,7)=0;
			d2fdq2{2}(4,1)=0;
			d2fdq2{2}(4,2)=0;
			d2fdq2{2}(4,3)=0;
			d2fdq2{2}(4,4)=0;
			d2fdq2{2}(4,5)=0;
			d2fdq2{2}(4,6)=0;
			d2fdq2{2}(4,7)=0;
			d2fdq2{2}(5,1)=0;
			d2fdq2{2}(5,2)=0;
			d2fdq2{2}(5,3)=0;
			d2fdq2{2}(5,4)=0;
			d2fdq2{2}(5,5)=0;
			d2fdq2{2}(5,6)=0;
			d2fdq2{2}(5,7)=0;
			d2fdq2{2}(6,1)=0;
			d2fdq2{2}(6,2)=0;
			d2fdq2{2}(6,3)=0;
			d2fdq2{2}(6,4)=0;
			d2fdq2{2}(6,5)=0;
			d2fdq2{2}(6,6)=0;
			d2fdq2{2}(6,7)=0;
			d2fdq2{2}(7,1)=0;
			d2fdq2{2}(7,2)=0;
			d2fdq2{2}(7,3)=0;
			d2fdq2{2}(7,4)=0;
			d2fdq2{2}(7,5)=0;
			d2fdq2{2}(7,6)=0;
			d2fdq2{2}(7,7)=0;
		else
			d2fdq2{2}(1)=[0];
		end
		%{
		if requestedoutput(7)==1
		dfdinput{2}(1,1)=sigmall^2/(4*fcl*ftl^2);
		dfdinput{2}(2,1)=0;
		dfdinput{2}(3,1)=0;
		dfdinput{2}(4,1)=sigmall^2/(4*fcl^2*ftl);
		dfdinput{2}(5,1)=-sigmarr/fcr^2;
		dfdinput{2}(6,1)=-(4*sigmatt^2)/(5*fct^3);
		dfdinput{2}(7,1)=-(4*sigmart^2)/(5*fvrt^3);
		dfdinput{2}(8,1)=-(33*sigmarl^2)/(50*fvrl^3);
		dfdinput{2}(9,1)=-(33*sigmatl^2)/(50*fvtl^3);
		else
		dfdinput{2}(1,1)=[0];
		end
		%}
	end
	if requestedfacesarr(3)==1
		if requestedoutput(1)==1
			f{3}=0+q3 + sigmatt/ftt + sigmarr^2/(2*fcr^2) + (33*sigmarl^2)/(100*fvrl^2) + (2*sigmart^2)/(5*fvrt^2) + (33*sigmatl^2)/(100*fvtl^2) - sigmall^2/(4*fcl*ftl) - 1;
		else
			f{3}=[0];
		end
		if requestedoutput(2)==1
			dfdsigma{3}(1,1)=sigmarr/fcr^2;
			dfdsigma{3}(2,1)=1/ftt;
			dfdsigma{3}(3,1)=-sigmall/(2*fcl*ftl);
			dfdsigma{3}(4,1)=(4*sigmart)/(5*fvrt^2);
			dfdsigma{3}(5,1)=(33*sigmatl)/(50*fvtl^2);
			dfdsigma{3}(6,1)=(33*sigmarl)/(50*fvrl^2);
		else
			dfdsigma{3}(1,1)=[0];
		end
		if requestedoutput(3)==1
			dfdq{3}(1,1)=0;
			dfdq{3}(2,1)=0;
			dfdq{3}(3,1)=1;
			dfdq{3}(4,1)=0;
			dfdq{3}(5,1)=0;
			dfdq{3}(6,1)=0;
			dfdq{3}(7,1)=0;
		else
			dfdq{3}(1,1)=[0];
		end
		if requestedoutput(4)==1
			d2fdsigma2{3}(1,1)=1/fcr^2;
			d2fdsigma2{3}(1,2)=0;
			d2fdsigma2{3}(1,3)=0;
			d2fdsigma2{3}(1,4)=0;
			d2fdsigma2{3}(1,5)=0;
			d2fdsigma2{3}(1,6)=0;
			d2fdsigma2{3}(2,1)=0;
			d2fdsigma2{3}(2,2)=0;
			d2fdsigma2{3}(2,3)=0;
			d2fdsigma2{3}(2,4)=0;
			d2fdsigma2{3}(2,5)=0;
			d2fdsigma2{3}(2,6)=0;
			d2fdsigma2{3}(3,1)=0;
			d2fdsigma2{3}(3,2)=0;
			d2fdsigma2{3}(3,3)=-1/(2*fcl*ftl);
			d2fdsigma2{3}(3,4)=0;
			d2fdsigma2{3}(3,5)=0;
			d2fdsigma2{3}(3,6)=0;
			d2fdsigma2{3}(4,1)=0;
			d2fdsigma2{3}(4,2)=0;
			d2fdsigma2{3}(4,3)=0;
			d2fdsigma2{3}(4,4)=4/(5*fvrt^2);
			d2fdsigma2{3}(4,5)=0;
			d2fdsigma2{3}(4,6)=0;
			d2fdsigma2{3}(5,1)=0;
			d2fdsigma2{3}(5,2)=0;
			d2fdsigma2{3}(5,3)=0;
			d2fdsigma2{3}(5,4)=0;
			d2fdsigma2{3}(5,5)=33/(50*fvtl^2);
			d2fdsigma2{3}(5,6)=0;
			d2fdsigma2{3}(6,1)=0;
			d2fdsigma2{3}(6,2)=0;
			d2fdsigma2{3}(6,3)=0;
			d2fdsigma2{3}(6,4)=0;
			d2fdsigma2{3}(6,5)=0;
			d2fdsigma2{3}(6,6)=33/(50*fvrl^2);
		else
			d2fdsigma2{3}(1,1)=[0];
		end
		if requestedoutput(5)==1
			d2fdsigmadq{3}(1,1)=0;
			d2fdsigmadq{3}(1,2)=0;
			d2fdsigmadq{3}(1,3)=0;
			d2fdsigmadq{3}(1,4)=0;
			d2fdsigmadq{3}(1,5)=0;
			d2fdsigmadq{3}(1,6)=0;
			d2fdsigmadq{3}(1,7)=0;
			d2fdsigmadq{3}(2,1)=0;
			d2fdsigmadq{3}(2,2)=0;
			d2fdsigmadq{3}(2,3)=0;
			d2fdsigmadq{3}(2,4)=0;
			d2fdsigmadq{3}(2,5)=0;
			d2fdsigmadq{3}(2,6)=0;
			d2fdsigmadq{3}(2,7)=0;
			d2fdsigmadq{3}(3,1)=0;
			d2fdsigmadq{3}(3,2)=0;
			d2fdsigmadq{3}(3,3)=0;
			d2fdsigmadq{3}(3,4)=0;
			d2fdsigmadq{3}(3,5)=0;
			d2fdsigmadq{3}(3,6)=0;
			d2fdsigmadq{3}(3,7)=0;
			d2fdsigmadq{3}(4,1)=0;
			d2fdsigmadq{3}(4,2)=0;
			d2fdsigmadq{3}(4,3)=0;
			d2fdsigmadq{3}(4,4)=0;
			d2fdsigmadq{3}(4,5)=0;
			d2fdsigmadq{3}(4,6)=0;
			d2fdsigmadq{3}(4,7)=0;
			d2fdsigmadq{3}(5,1)=0;
			d2fdsigmadq{3}(5,2)=0;
			d2fdsigmadq{3}(5,3)=0;
			d2fdsigmadq{3}(5,4)=0;
			d2fdsigmadq{3}(5,5)=0;
			d2fdsigmadq{3}(5,6)=0;
			d2fdsigmadq{3}(5,7)=0;
			d2fdsigmadq{3}(6,1)=0;
			d2fdsigmadq{3}(6,2)=0;
			d2fdsigmadq{3}(6,3)=0;
			d2fdsigmadq{3}(6,4)=0;
			d2fdsigmadq{3}(6,5)=0;
			d2fdsigmadq{3}(6,6)=0;
			d2fdsigmadq{3}(6,7)=0;
		else
			d2fdsigmadq{3}(1,1)=[0];
		end
		if requestedoutput(6)==1
			d2fdq2{3}(1,1)=0;
			d2fdq2{3}(1,2)=0;
			d2fdq2{3}(1,3)=0;
			d2fdq2{3}(1,4)=0;
			d2fdq2{3}(1,5)=0;
			d2fdq2{3}(1,6)=0;
			d2fdq2{3}(1,7)=0;
			d2fdq2{3}(2,1)=0;
			d2fdq2{3}(2,2)=0;
			d2fdq2{3}(2,3)=0;
			d2fdq2{3}(2,4)=0;
			d2fdq2{3}(2,5)=0;
			d2fdq2{3}(2,6)=0;
			d2fdq2{3}(2,7)=0;
			d2fdq2{3}(3,1)=0;
			d2fdq2{3}(3,2)=0;
			d2fdq2{3}(3,3)=0;
			d2fdq2{3}(3,4)=0;
			d2fdq2{3}(3,5)=0;
			d2fdq2{3}(3,6)=0;
			d2fdq2{3}(3,7)=0;
			d2fdq2{3}(4,1)=0;
			d2fdq2{3}(4,2)=0;
			d2fdq2{3}(4,3)=0;
			d2fdq2{3}(4,4)=0;
			d2fdq2{3}(4,5)=0;
			d2fdq2{3}(4,6)=0;
			d2fdq2{3}(4,7)=0;
			d2fdq2{3}(5,1)=0;
			d2fdq2{3}(5,2)=0;
			d2fdq2{3}(5,3)=0;
			d2fdq2{3}(5,4)=0;
			d2fdq2{3}(5,5)=0;
			d2fdq2{3}(5,6)=0;
			d2fdq2{3}(5,7)=0;
			d2fdq2{3}(6,1)=0;
			d2fdq2{3}(6,2)=0;
			d2fdq2{3}(6,3)=0;
			d2fdq2{3}(6,4)=0;
			d2fdq2{3}(6,5)=0;
			d2fdq2{3}(6,6)=0;
			d2fdq2{3}(6,7)=0;
			d2fdq2{3}(7,1)=0;
			d2fdq2{3}(7,2)=0;
			d2fdq2{3}(7,3)=0;
			d2fdq2{3}(7,4)=0;
			d2fdq2{3}(7,5)=0;
			d2fdq2{3}(7,6)=0;
			d2fdq2{3}(7,7)=0;
		else
			d2fdq2{3}(1)=[0];
		end
		%{
		if requestedoutput(7)==1
		dfdinput{3}(1,1)=sigmall^2/(4*fcl*ftl^2);
		dfdinput{3}(2,1)=0;
		dfdinput{3}(3,1)=-sigmatt/ftt^2;
		dfdinput{3}(4,1)=sigmall^2/(4*fcl^2*ftl);
		dfdinput{3}(5,1)=-sigmarr^2/fcr^3;
		dfdinput{3}(6,1)=0;
		dfdinput{3}(7,1)=-(4*sigmart^2)/(5*fvrt^3);
		dfdinput{3}(8,1)=-(33*sigmarl^2)/(50*fvrl^3);
		dfdinput{3}(9,1)=-(33*sigmatl^2)/(50*fvtl^3);
		else
		dfdinput{3}(1,1)=[0];
		end
		%}
	end
	if requestedfacesarr(4)==1
		if requestedoutput(1)==1
			f{4}=0+q4 + sigmatt/fct + (2*sigmarr^2)/(5*fcr^2) + (33*sigmarl^2)/(100*fvrl^2) + (2*sigmart^2)/(5*fvrt^2) + (33*sigmatl^2)/(100*fvtl^2) - sigmall^2/(4*fcl*ftl) - 1;
		else
			f{4}=[0];
		end
		if requestedoutput(2)==1
			dfdsigma{4}(1,1)=(4*sigmarr)/(5*fcr^2);
			dfdsigma{4}(2,1)=1/fct;
			dfdsigma{4}(3,1)=-sigmall/(2*fcl*ftl);
			dfdsigma{4}(4,1)=(4*sigmart)/(5*fvrt^2);
			dfdsigma{4}(5,1)=(33*sigmatl)/(50*fvtl^2);
			dfdsigma{4}(6,1)=(33*sigmarl)/(50*fvrl^2);
		else
			dfdsigma{4}(1,1)=[0];
		end
		if requestedoutput(3)==1
			dfdq{4}(1,1)=0;
			dfdq{4}(2,1)=0;
			dfdq{4}(3,1)=0;
			dfdq{4}(4,1)=1;
			dfdq{4}(5,1)=0;
			dfdq{4}(6,1)=0;
			dfdq{4}(7,1)=0;
		else
			dfdq{4}(1,1)=[0];
		end
		if requestedoutput(4)==1
			d2fdsigma2{4}(1,1)=4/(5*fcr^2);
			d2fdsigma2{4}(1,2)=0;
			d2fdsigma2{4}(1,3)=0;
			d2fdsigma2{4}(1,4)=0;
			d2fdsigma2{4}(1,5)=0;
			d2fdsigma2{4}(1,6)=0;
			d2fdsigma2{4}(2,1)=0;
			d2fdsigma2{4}(2,2)=0;
			d2fdsigma2{4}(2,3)=0;
			d2fdsigma2{4}(2,4)=0;
			d2fdsigma2{4}(2,5)=0;
			d2fdsigma2{4}(2,6)=0;
			d2fdsigma2{4}(3,1)=0;
			d2fdsigma2{4}(3,2)=0;
			d2fdsigma2{4}(3,3)=-1/(2*fcl*ftl);
			d2fdsigma2{4}(3,4)=0;
			d2fdsigma2{4}(3,5)=0;
			d2fdsigma2{4}(3,6)=0;
			d2fdsigma2{4}(4,1)=0;
			d2fdsigma2{4}(4,2)=0;
			d2fdsigma2{4}(4,3)=0;
			d2fdsigma2{4}(4,4)=4/(5*fvrt^2);
			d2fdsigma2{4}(4,5)=0;
			d2fdsigma2{4}(4,6)=0;
			d2fdsigma2{4}(5,1)=0;
			d2fdsigma2{4}(5,2)=0;
			d2fdsigma2{4}(5,3)=0;
			d2fdsigma2{4}(5,4)=0;
			d2fdsigma2{4}(5,5)=33/(50*fvtl^2);
			d2fdsigma2{4}(5,6)=0;
			d2fdsigma2{4}(6,1)=0;
			d2fdsigma2{4}(6,2)=0;
			d2fdsigma2{4}(6,3)=0;
			d2fdsigma2{4}(6,4)=0;
			d2fdsigma2{4}(6,5)=0;
			d2fdsigma2{4}(6,6)=33/(50*fvrl^2);
		else
			d2fdsigma2{4}(1,1)=[0];
		end
		if requestedoutput(5)==1
			d2fdsigmadq{4}(1,1)=0;
			d2fdsigmadq{4}(1,2)=0;
			d2fdsigmadq{4}(1,3)=0;
			d2fdsigmadq{4}(1,4)=0;
			d2fdsigmadq{4}(1,5)=0;
			d2fdsigmadq{4}(1,6)=0;
			d2fdsigmadq{4}(1,7)=0;
			d2fdsigmadq{4}(2,1)=0;
			d2fdsigmadq{4}(2,2)=0;
			d2fdsigmadq{4}(2,3)=0;
			d2fdsigmadq{4}(2,4)=0;
			d2fdsigmadq{4}(2,5)=0;
			d2fdsigmadq{4}(2,6)=0;
			d2fdsigmadq{4}(2,7)=0;
			d2fdsigmadq{4}(3,1)=0;
			d2fdsigmadq{4}(3,2)=0;
			d2fdsigmadq{4}(3,3)=0;
			d2fdsigmadq{4}(3,4)=0;
			d2fdsigmadq{4}(3,5)=0;
			d2fdsigmadq{4}(3,6)=0;
			d2fdsigmadq{4}(3,7)=0;
			d2fdsigmadq{4}(4,1)=0;
			d2fdsigmadq{4}(4,2)=0;
			d2fdsigmadq{4}(4,3)=0;
			d2fdsigmadq{4}(4,4)=0;
			d2fdsigmadq{4}(4,5)=0;
			d2fdsigmadq{4}(4,6)=0;
			d2fdsigmadq{4}(4,7)=0;
			d2fdsigmadq{4}(5,1)=0;
			d2fdsigmadq{4}(5,2)=0;
			d2fdsigmadq{4}(5,3)=0;
			d2fdsigmadq{4}(5,4)=0;
			d2fdsigmadq{4}(5,5)=0;
			d2fdsigmadq{4}(5,6)=0;
			d2fdsigmadq{4}(5,7)=0;
			d2fdsigmadq{4}(6,1)=0;
			d2fdsigmadq{4}(6,2)=0;
			d2fdsigmadq{4}(6,3)=0;
			d2fdsigmadq{4}(6,4)=0;
			d2fdsigmadq{4}(6,5)=0;
			d2fdsigmadq{4}(6,6)=0;
			d2fdsigmadq{4}(6,7)=0;
		else
			d2fdsigmadq{4}(1,1)=[0];
		end
		if requestedoutput(6)==1
			d2fdq2{4}(1,1)=0;
			d2fdq2{4}(1,2)=0;
			d2fdq2{4}(1,3)=0;
			d2fdq2{4}(1,4)=0;
			d2fdq2{4}(1,5)=0;
			d2fdq2{4}(1,6)=0;
			d2fdq2{4}(1,7)=0;
			d2fdq2{4}(2,1)=0;
			d2fdq2{4}(2,2)=0;
			d2fdq2{4}(2,3)=0;
			d2fdq2{4}(2,4)=0;
			d2fdq2{4}(2,5)=0;
			d2fdq2{4}(2,6)=0;
			d2fdq2{4}(2,7)=0;
			d2fdq2{4}(3,1)=0;
			d2fdq2{4}(3,2)=0;
			d2fdq2{4}(3,3)=0;
			d2fdq2{4}(3,4)=0;
			d2fdq2{4}(3,5)=0;
			d2fdq2{4}(3,6)=0;
			d2fdq2{4}(3,7)=0;
			d2fdq2{4}(4,1)=0;
			d2fdq2{4}(4,2)=0;
			d2fdq2{4}(4,3)=0;
			d2fdq2{4}(4,4)=0;
			d2fdq2{4}(4,5)=0;
			d2fdq2{4}(4,6)=0;
			d2fdq2{4}(4,7)=0;
			d2fdq2{4}(5,1)=0;
			d2fdq2{4}(5,2)=0;
			d2fdq2{4}(5,3)=0;
			d2fdq2{4}(5,4)=0;
			d2fdq2{4}(5,5)=0;
			d2fdq2{4}(5,6)=0;
			d2fdq2{4}(5,7)=0;
			d2fdq2{4}(6,1)=0;
			d2fdq2{4}(6,2)=0;
			d2fdq2{4}(6,3)=0;
			d2fdq2{4}(6,4)=0;
			d2fdq2{4}(6,5)=0;
			d2fdq2{4}(6,6)=0;
			d2fdq2{4}(6,7)=0;
			d2fdq2{4}(7,1)=0;
			d2fdq2{4}(7,2)=0;
			d2fdq2{4}(7,3)=0;
			d2fdq2{4}(7,4)=0;
			d2fdq2{4}(7,5)=0;
			d2fdq2{4}(7,6)=0;
			d2fdq2{4}(7,7)=0;
		else
			d2fdq2{4}(1)=[0];
		end
		%{
		if requestedoutput(7)==1
		dfdinput{4}(1,1)=sigmall^2/(4*fcl*ftl^2);
		dfdinput{4}(2,1)=0;
		dfdinput{4}(3,1)=0;
		dfdinput{4}(4,1)=sigmall^2/(4*fcl^2*ftl);
		dfdinput{4}(5,1)=-(4*sigmarr^2)/(5*fcr^3);
		dfdinput{4}(6,1)=-sigmatt/fct^2;
		dfdinput{4}(7,1)=-(4*sigmart^2)/(5*fvrt^3);
		dfdinput{4}(8,1)=-(33*sigmarl^2)/(50*fvrl^3);
		dfdinput{4}(9,1)=-(33*sigmatl^2)/(50*fvtl^3);
		else
		dfdinput{4}(1,1)=[0];
		end
		%}
	end
	if requestedfacesarr(5)==1
		if requestedoutput(1)==1
			f{5}=0+q5 + sigmall/ftl + sigmarr^2/(5*fcr^2) + sigmatt^2/(5*fct^2) + sigmarl^2/(10*fvrl^2) + sigmart^2/(10*fvrt^2) + sigmatl^2/(10*fvtl^2) - 1;
		else
			f{5}=[0];
		end
		if requestedoutput(2)==1
			dfdsigma{5}(1,1)=(2*sigmarr)/(5*fcr^2);
			dfdsigma{5}(2,1)=(2*sigmatt)/(5*fct^2);
			dfdsigma{5}(3,1)=1/ftl;
			dfdsigma{5}(4,1)=sigmart/(5*fvrt^2);
			dfdsigma{5}(5,1)=sigmatl/(5*fvtl^2);
			dfdsigma{5}(6,1)=sigmarl/(5*fvrl^2);
		else
			dfdsigma{5}(1,1)=[0];
		end
		if requestedoutput(3)==1
			dfdq{5}(1,1)=0;
			dfdq{5}(2,1)=0;
			dfdq{5}(3,1)=0;
			dfdq{5}(4,1)=0;
			dfdq{5}(5,1)=1;
			dfdq{5}(6,1)=0;
			dfdq{5}(7,1)=0;
		else
			dfdq{5}(1,1)=[0];
		end
		if requestedoutput(4)==1
			d2fdsigma2{5}(1,1)=2/(5*fcr^2);
			d2fdsigma2{5}(1,2)=0;
			d2fdsigma2{5}(1,3)=0;
			d2fdsigma2{5}(1,4)=0;
			d2fdsigma2{5}(1,5)=0;
			d2fdsigma2{5}(1,6)=0;
			d2fdsigma2{5}(2,1)=0;
			d2fdsigma2{5}(2,2)=2/(5*fct^2);
			d2fdsigma2{5}(2,3)=0;
			d2fdsigma2{5}(2,4)=0;
			d2fdsigma2{5}(2,5)=0;
			d2fdsigma2{5}(2,6)=0;
			d2fdsigma2{5}(3,1)=0;
			d2fdsigma2{5}(3,2)=0;
			d2fdsigma2{5}(3,3)=0;
			d2fdsigma2{5}(3,4)=0;
			d2fdsigma2{5}(3,5)=0;
			d2fdsigma2{5}(3,6)=0;
			d2fdsigma2{5}(4,1)=0;
			d2fdsigma2{5}(4,2)=0;
			d2fdsigma2{5}(4,3)=0;
			d2fdsigma2{5}(4,4)=1/(5*fvrt^2);
			d2fdsigma2{5}(4,5)=0;
			d2fdsigma2{5}(4,6)=0;
			d2fdsigma2{5}(5,1)=0;
			d2fdsigma2{5}(5,2)=0;
			d2fdsigma2{5}(5,3)=0;
			d2fdsigma2{5}(5,4)=0;
			d2fdsigma2{5}(5,5)=1/(5*fvtl^2);
			d2fdsigma2{5}(5,6)=0;
			d2fdsigma2{5}(6,1)=0;
			d2fdsigma2{5}(6,2)=0;
			d2fdsigma2{5}(6,3)=0;
			d2fdsigma2{5}(6,4)=0;
			d2fdsigma2{5}(6,5)=0;
			d2fdsigma2{5}(6,6)=1/(5*fvrl^2);
		else
			d2fdsigma2{5}(1,1)=[0];
		end
		if requestedoutput(5)==1
			d2fdsigmadq{5}(1,1)=0;
			d2fdsigmadq{5}(1,2)=0;
			d2fdsigmadq{5}(1,3)=0;
			d2fdsigmadq{5}(1,4)=0;
			d2fdsigmadq{5}(1,5)=0;
			d2fdsigmadq{5}(1,6)=0;
			d2fdsigmadq{5}(1,7)=0;
			d2fdsigmadq{5}(2,1)=0;
			d2fdsigmadq{5}(2,2)=0;
			d2fdsigmadq{5}(2,3)=0;
			d2fdsigmadq{5}(2,4)=0;
			d2fdsigmadq{5}(2,5)=0;
			d2fdsigmadq{5}(2,6)=0;
			d2fdsigmadq{5}(2,7)=0;
			d2fdsigmadq{5}(3,1)=0;
			d2fdsigmadq{5}(3,2)=0;
			d2fdsigmadq{5}(3,3)=0;
			d2fdsigmadq{5}(3,4)=0;
			d2fdsigmadq{5}(3,5)=0;
			d2fdsigmadq{5}(3,6)=0;
			d2fdsigmadq{5}(3,7)=0;
			d2fdsigmadq{5}(4,1)=0;
			d2fdsigmadq{5}(4,2)=0;
			d2fdsigmadq{5}(4,3)=0;
			d2fdsigmadq{5}(4,4)=0;
			d2fdsigmadq{5}(4,5)=0;
			d2fdsigmadq{5}(4,6)=0;
			d2fdsigmadq{5}(4,7)=0;
			d2fdsigmadq{5}(5,1)=0;
			d2fdsigmadq{5}(5,2)=0;
			d2fdsigmadq{5}(5,3)=0;
			d2fdsigmadq{5}(5,4)=0;
			d2fdsigmadq{5}(5,5)=0;
			d2fdsigmadq{5}(5,6)=0;
			d2fdsigmadq{5}(5,7)=0;
			d2fdsigmadq{5}(6,1)=0;
			d2fdsigmadq{5}(6,2)=0;
			d2fdsigmadq{5}(6,3)=0;
			d2fdsigmadq{5}(6,4)=0;
			d2fdsigmadq{5}(6,5)=0;
			d2fdsigmadq{5}(6,6)=0;
			d2fdsigmadq{5}(6,7)=0;
		else
			d2fdsigmadq{5}(1,1)=[0];
		end
		if requestedoutput(6)==1
			d2fdq2{5}(1,1)=0;
			d2fdq2{5}(1,2)=0;
			d2fdq2{5}(1,3)=0;
			d2fdq2{5}(1,4)=0;
			d2fdq2{5}(1,5)=0;
			d2fdq2{5}(1,6)=0;
			d2fdq2{5}(1,7)=0;
			d2fdq2{5}(2,1)=0;
			d2fdq2{5}(2,2)=0;
			d2fdq2{5}(2,3)=0;
			d2fdq2{5}(2,4)=0;
			d2fdq2{5}(2,5)=0;
			d2fdq2{5}(2,6)=0;
			d2fdq2{5}(2,7)=0;
			d2fdq2{5}(3,1)=0;
			d2fdq2{5}(3,2)=0;
			d2fdq2{5}(3,3)=0;
			d2fdq2{5}(3,4)=0;
			d2fdq2{5}(3,5)=0;
			d2fdq2{5}(3,6)=0;
			d2fdq2{5}(3,7)=0;
			d2fdq2{5}(4,1)=0;
			d2fdq2{5}(4,2)=0;
			d2fdq2{5}(4,3)=0;
			d2fdq2{5}(4,4)=0;
			d2fdq2{5}(4,5)=0;
			d2fdq2{5}(4,6)=0;
			d2fdq2{5}(4,7)=0;
			d2fdq2{5}(5,1)=0;
			d2fdq2{5}(5,2)=0;
			d2fdq2{5}(5,3)=0;
			d2fdq2{5}(5,4)=0;
			d2fdq2{5}(5,5)=0;
			d2fdq2{5}(5,6)=0;
			d2fdq2{5}(5,7)=0;
			d2fdq2{5}(6,1)=0;
			d2fdq2{5}(6,2)=0;
			d2fdq2{5}(6,3)=0;
			d2fdq2{5}(6,4)=0;
			d2fdq2{5}(6,5)=0;
			d2fdq2{5}(6,6)=0;
			d2fdq2{5}(6,7)=0;
			d2fdq2{5}(7,1)=0;
			d2fdq2{5}(7,2)=0;
			d2fdq2{5}(7,3)=0;
			d2fdq2{5}(7,4)=0;
			d2fdq2{5}(7,5)=0;
			d2fdq2{5}(7,6)=0;
			d2fdq2{5}(7,7)=0;
		else
			d2fdq2{5}(1)=[0];
		end
		%{
		if requestedoutput(7)==1
		dfdinput{5}(1,1)=-sigmall/ftl^2;
		dfdinput{5}(2,1)=0;
		dfdinput{5}(3,1)=0;
		dfdinput{5}(4,1)=0;
		dfdinput{5}(5,1)=-(2*sigmarr^2)/(5*fcr^3);
		dfdinput{5}(6,1)=-(2*sigmatt^2)/(5*fct^3);
		dfdinput{5}(7,1)=-sigmart^2/(5*fvrt^3);
		dfdinput{5}(8,1)=-sigmarl^2/(5*fvrl^3);
		dfdinput{5}(9,1)=-sigmatl^2/(5*fvtl^3);
		else
		dfdinput{5}(1,1)=[0];
		end
		%}
	end
	if requestedfacesarr(6)==1
		if requestedoutput(1)==1
			f{6}=0+q6 + sigmall/fcl + (33*sigmarr^2)/(100*fcr^2) + (33*sigmatt^2)/(100*fct^2) + sigmarl^2/(4*fvrl^2) + sigmart^2/(4*fvrt^2) + sigmatl^2/(4*fvtl^2) - 1;
		else
			f{6}=[0];
		end
		if requestedoutput(2)==1
			dfdsigma{6}(1,1)=(33*sigmarr)/(50*fcr^2);
			dfdsigma{6}(2,1)=(33*sigmatt)/(50*fct^2);
			dfdsigma{6}(3,1)=1/fcl;
			dfdsigma{6}(4,1)=sigmart/(2*fvrt^2);
			dfdsigma{6}(5,1)=sigmatl/(2*fvtl^2);
			dfdsigma{6}(6,1)=sigmarl/(2*fvrl^2);
		else
			dfdsigma{6}(1,1)=[0];
		end
		if requestedoutput(3)==1
			dfdq{6}(1,1)=0;
			dfdq{6}(2,1)=0;
			dfdq{6}(3,1)=0;
			dfdq{6}(4,1)=0;
			dfdq{6}(5,1)=0;
			dfdq{6}(6,1)=1;
			dfdq{6}(7,1)=0;
		else
			dfdq{6}(1,1)=[0];
		end
		if requestedoutput(4)==1
			d2fdsigma2{6}(1,1)=33/(50*fcr^2);
			d2fdsigma2{6}(1,2)=0;
			d2fdsigma2{6}(1,3)=0;
			d2fdsigma2{6}(1,4)=0;
			d2fdsigma2{6}(1,5)=0;
			d2fdsigma2{6}(1,6)=0;
			d2fdsigma2{6}(2,1)=0;
			d2fdsigma2{6}(2,2)=33/(50*fct^2);
			d2fdsigma2{6}(2,3)=0;
			d2fdsigma2{6}(2,4)=0;
			d2fdsigma2{6}(2,5)=0;
			d2fdsigma2{6}(2,6)=0;
			d2fdsigma2{6}(3,1)=0;
			d2fdsigma2{6}(3,2)=0;
			d2fdsigma2{6}(3,3)=0;
			d2fdsigma2{6}(3,4)=0;
			d2fdsigma2{6}(3,5)=0;
			d2fdsigma2{6}(3,6)=0;
			d2fdsigma2{6}(4,1)=0;
			d2fdsigma2{6}(4,2)=0;
			d2fdsigma2{6}(4,3)=0;
			d2fdsigma2{6}(4,4)=1/(2*fvrt^2);
			d2fdsigma2{6}(4,5)=0;
			d2fdsigma2{6}(4,6)=0;
			d2fdsigma2{6}(5,1)=0;
			d2fdsigma2{6}(5,2)=0;
			d2fdsigma2{6}(5,3)=0;
			d2fdsigma2{6}(5,4)=0;
			d2fdsigma2{6}(5,5)=1/(2*fvtl^2);
			d2fdsigma2{6}(5,6)=0;
			d2fdsigma2{6}(6,1)=0;
			d2fdsigma2{6}(6,2)=0;
			d2fdsigma2{6}(6,3)=0;
			d2fdsigma2{6}(6,4)=0;
			d2fdsigma2{6}(6,5)=0;
			d2fdsigma2{6}(6,6)=1/(2*fvrl^2);
		else
			d2fdsigma2{6}(1,1)=[0];
		end
		if requestedoutput(5)==1
			d2fdsigmadq{6}(1,1)=0;
			d2fdsigmadq{6}(1,2)=0;
			d2fdsigmadq{6}(1,3)=0;
			d2fdsigmadq{6}(1,4)=0;
			d2fdsigmadq{6}(1,5)=0;
			d2fdsigmadq{6}(1,6)=0;
			d2fdsigmadq{6}(1,7)=0;
			d2fdsigmadq{6}(2,1)=0;
			d2fdsigmadq{6}(2,2)=0;
			d2fdsigmadq{6}(2,3)=0;
			d2fdsigmadq{6}(2,4)=0;
			d2fdsigmadq{6}(2,5)=0;
			d2fdsigmadq{6}(2,6)=0;
			d2fdsigmadq{6}(2,7)=0;
			d2fdsigmadq{6}(3,1)=0;
			d2fdsigmadq{6}(3,2)=0;
			d2fdsigmadq{6}(3,3)=0;
			d2fdsigmadq{6}(3,4)=0;
			d2fdsigmadq{6}(3,5)=0;
			d2fdsigmadq{6}(3,6)=0;
			d2fdsigmadq{6}(3,7)=0;
			d2fdsigmadq{6}(4,1)=0;
			d2fdsigmadq{6}(4,2)=0;
			d2fdsigmadq{6}(4,3)=0;
			d2fdsigmadq{6}(4,4)=0;
			d2fdsigmadq{6}(4,5)=0;
			d2fdsigmadq{6}(4,6)=0;
			d2fdsigmadq{6}(4,7)=0;
			d2fdsigmadq{6}(5,1)=0;
			d2fdsigmadq{6}(5,2)=0;
			d2fdsigmadq{6}(5,3)=0;
			d2fdsigmadq{6}(5,4)=0;
			d2fdsigmadq{6}(5,5)=0;
			d2fdsigmadq{6}(5,6)=0;
			d2fdsigmadq{6}(5,7)=0;
			d2fdsigmadq{6}(6,1)=0;
			d2fdsigmadq{6}(6,2)=0;
			d2fdsigmadq{6}(6,3)=0;
			d2fdsigmadq{6}(6,4)=0;
			d2fdsigmadq{6}(6,5)=0;
			d2fdsigmadq{6}(6,6)=0;
			d2fdsigmadq{6}(6,7)=0;
		else
			d2fdsigmadq{6}(1,1)=[0];
		end
		if requestedoutput(6)==1
			d2fdq2{6}(1,1)=0;
			d2fdq2{6}(1,2)=0;
			d2fdq2{6}(1,3)=0;
			d2fdq2{6}(1,4)=0;
			d2fdq2{6}(1,5)=0;
			d2fdq2{6}(1,6)=0;
			d2fdq2{6}(1,7)=0;
			d2fdq2{6}(2,1)=0;
			d2fdq2{6}(2,2)=0;
			d2fdq2{6}(2,3)=0;
			d2fdq2{6}(2,4)=0;
			d2fdq2{6}(2,5)=0;
			d2fdq2{6}(2,6)=0;
			d2fdq2{6}(2,7)=0;
			d2fdq2{6}(3,1)=0;
			d2fdq2{6}(3,2)=0;
			d2fdq2{6}(3,3)=0;
			d2fdq2{6}(3,4)=0;
			d2fdq2{6}(3,5)=0;
			d2fdq2{6}(3,6)=0;
			d2fdq2{6}(3,7)=0;
			d2fdq2{6}(4,1)=0;
			d2fdq2{6}(4,2)=0;
			d2fdq2{6}(4,3)=0;
			d2fdq2{6}(4,4)=0;
			d2fdq2{6}(4,5)=0;
			d2fdq2{6}(4,6)=0;
			d2fdq2{6}(4,7)=0;
			d2fdq2{6}(5,1)=0;
			d2fdq2{6}(5,2)=0;
			d2fdq2{6}(5,3)=0;
			d2fdq2{6}(5,4)=0;
			d2fdq2{6}(5,5)=0;
			d2fdq2{6}(5,6)=0;
			d2fdq2{6}(5,7)=0;
			d2fdq2{6}(6,1)=0;
			d2fdq2{6}(6,2)=0;
			d2fdq2{6}(6,3)=0;
			d2fdq2{6}(6,4)=0;
			d2fdq2{6}(6,5)=0;
			d2fdq2{6}(6,6)=0;
			d2fdq2{6}(6,7)=0;
			d2fdq2{6}(7,1)=0;
			d2fdq2{6}(7,2)=0;
			d2fdq2{6}(7,3)=0;
			d2fdq2{6}(7,4)=0;
			d2fdq2{6}(7,5)=0;
			d2fdq2{6}(7,6)=0;
			d2fdq2{6}(7,7)=0;
		else
			d2fdq2{6}(1)=[0];
		end
		%{
		if requestedoutput(7)==1
		dfdinput{6}(1,1)=0;
		dfdinput{6}(2,1)=0;
		dfdinput{6}(3,1)=0;
		dfdinput{6}(4,1)=-sigmall/fcl^2;
		dfdinput{6}(5,1)=-(33*sigmarr^2)/(50*fcr^3);
		dfdinput{6}(6,1)=-(33*sigmatt^2)/(50*fct^3);
		dfdinput{6}(7,1)=-sigmart^2/(2*fvrt^3);
		dfdinput{6}(8,1)=-sigmarl^2/(2*fvrl^3);
		dfdinput{6}(9,1)=-sigmatl^2/(2*fvtl^3);
		else
		dfdinput{6}(1,1)=[0];
		end
		%}
	end
	if requestedfacesarr(7)==1
		if requestedoutput(1)==1
			f{7}=q7 - sigmall/(20*fcl) - sigmarr/(5*fcr) - sigmatt/(5*fct) + sigmarr^2/(4*fcr^2) + sigmatt^2/(4*fct^2) + sigmarl^2/fvrl^2 + sigmart^2/fvrt^2 + sigmatl^2/fvtl^2 - sigmall^2/(10*fcl*ftl) - 1;
		else
			f{7}=[0];
		end
		if requestedoutput(2)==1
			dfdsigma{7}(1,1)=-(2*fcr - 5*sigmarr)/(10*fcr^2);
			dfdsigma{7}(2,1)=-(2*fct - 5*sigmatt)/(10*fct^2);
			dfdsigma{7}(3,1)=-(ftl + 4*sigmall)/(20*fcl*ftl);
			dfdsigma{7}(4,1)=(2*sigmart)/fvrt^2;
			dfdsigma{7}(5,1)=(2*sigmatl)/fvtl^2;
			dfdsigma{7}(6,1)=(2*sigmarl)/fvrl^2;
		else
			dfdsigma{7}(1,1)=[0];
		end
		if requestedoutput(3)==1
			dfdq{7}(1,1)=0;
			dfdq{7}(2,1)=0;
			dfdq{7}(3,1)=0;
			dfdq{7}(4,1)=0;
			dfdq{7}(5,1)=0;
			dfdq{7}(6,1)=0;
			dfdq{7}(7,1)=1;
		else
			dfdq{7}(1,1)=[0];
		end
		if requestedoutput(4)==1
			d2fdsigma2{7}(1,1)=1/(2*fcr^2);
			d2fdsigma2{7}(1,2)=0;
			d2fdsigma2{7}(1,3)=0;
			d2fdsigma2{7}(1,4)=0;
			d2fdsigma2{7}(1,5)=0;
			d2fdsigma2{7}(1,6)=0;
			d2fdsigma2{7}(2,1)=0;
			d2fdsigma2{7}(2,2)=1/(2*fct^2);
			d2fdsigma2{7}(2,3)=0;
			d2fdsigma2{7}(2,4)=0;
			d2fdsigma2{7}(2,5)=0;
			d2fdsigma2{7}(2,6)=0;
			d2fdsigma2{7}(3,1)=0;
			d2fdsigma2{7}(3,2)=0;
			d2fdsigma2{7}(3,3)=-1/(5*fcl*ftl);
			d2fdsigma2{7}(3,4)=0;
			d2fdsigma2{7}(3,5)=0;
			d2fdsigma2{7}(3,6)=0;
			d2fdsigma2{7}(4,1)=0;
			d2fdsigma2{7}(4,2)=0;
			d2fdsigma2{7}(4,3)=0;
			d2fdsigma2{7}(4,4)=2/fvrt^2;
			d2fdsigma2{7}(4,5)=0;
			d2fdsigma2{7}(4,6)=0;
			d2fdsigma2{7}(5,1)=0;
			d2fdsigma2{7}(5,2)=0;
			d2fdsigma2{7}(5,3)=0;
			d2fdsigma2{7}(5,4)=0;
			d2fdsigma2{7}(5,5)=2/fvtl^2;
			d2fdsigma2{7}(5,6)=0;
			d2fdsigma2{7}(6,1)=0;
			d2fdsigma2{7}(6,2)=0;
			d2fdsigma2{7}(6,3)=0;
			d2fdsigma2{7}(6,4)=0;
			d2fdsigma2{7}(6,5)=0;
			d2fdsigma2{7}(6,6)=2/fvrl^2;
		else
			d2fdsigma2{7}(1,1)=[0];
		end
		if requestedoutput(5)==1
			d2fdsigmadq{7}(1,1)=0;
			d2fdsigmadq{7}(1,2)=0;
			d2fdsigmadq{7}(1,3)=0;
			d2fdsigmadq{7}(1,4)=0;
			d2fdsigmadq{7}(1,5)=0;
			d2fdsigmadq{7}(1,6)=0;
			d2fdsigmadq{7}(1,7)=0;
			d2fdsigmadq{7}(2,1)=0;
			d2fdsigmadq{7}(2,2)=0;
			d2fdsigmadq{7}(2,3)=0;
			d2fdsigmadq{7}(2,4)=0;
			d2fdsigmadq{7}(2,5)=0;
			d2fdsigmadq{7}(2,6)=0;
			d2fdsigmadq{7}(2,7)=0;
			d2fdsigmadq{7}(3,1)=0;
			d2fdsigmadq{7}(3,2)=0;
			d2fdsigmadq{7}(3,3)=0;
			d2fdsigmadq{7}(3,4)=0;
			d2fdsigmadq{7}(3,5)=0;
			d2fdsigmadq{7}(3,6)=0;
			d2fdsigmadq{7}(3,7)=0;
			d2fdsigmadq{7}(4,1)=0;
			d2fdsigmadq{7}(4,2)=0;
			d2fdsigmadq{7}(4,3)=0;
			d2fdsigmadq{7}(4,4)=0;
			d2fdsigmadq{7}(4,5)=0;
			d2fdsigmadq{7}(4,6)=0;
			d2fdsigmadq{7}(4,7)=0;
			d2fdsigmadq{7}(5,1)=0;
			d2fdsigmadq{7}(5,2)=0;
			d2fdsigmadq{7}(5,3)=0;
			d2fdsigmadq{7}(5,4)=0;
			d2fdsigmadq{7}(5,5)=0;
			d2fdsigmadq{7}(5,6)=0;
			d2fdsigmadq{7}(5,7)=0;
			d2fdsigmadq{7}(6,1)=0;
			d2fdsigmadq{7}(6,2)=0;
			d2fdsigmadq{7}(6,3)=0;
			d2fdsigmadq{7}(6,4)=0;
			d2fdsigmadq{7}(6,5)=0;
			d2fdsigmadq{7}(6,6)=0;
			d2fdsigmadq{7}(6,7)=0;
		else
			d2fdsigmadq{7}(1,1)=[0];
		end
		if requestedoutput(6)==1
			d2fdq2{7}(1,1)=0;
			d2fdq2{7}(1,2)=0;
			d2fdq2{7}(1,3)=0;
			d2fdq2{7}(1,4)=0;
			d2fdq2{7}(1,5)=0;
			d2fdq2{7}(1,6)=0;
			d2fdq2{7}(1,7)=0;
			d2fdq2{7}(2,1)=0;
			d2fdq2{7}(2,2)=0;
			d2fdq2{7}(2,3)=0;
			d2fdq2{7}(2,4)=0;
			d2fdq2{7}(2,5)=0;
			d2fdq2{7}(2,6)=0;
			d2fdq2{7}(2,7)=0;
			d2fdq2{7}(3,1)=0;
			d2fdq2{7}(3,2)=0;
			d2fdq2{7}(3,3)=0;
			d2fdq2{7}(3,4)=0;
			d2fdq2{7}(3,5)=0;
			d2fdq2{7}(3,6)=0;
			d2fdq2{7}(3,7)=0;
			d2fdq2{7}(4,1)=0;
			d2fdq2{7}(4,2)=0;
			d2fdq2{7}(4,3)=0;
			d2fdq2{7}(4,4)=0;
			d2fdq2{7}(4,5)=0;
			d2fdq2{7}(4,6)=0;
			d2fdq2{7}(4,7)=0;
			d2fdq2{7}(5,1)=0;
			d2fdq2{7}(5,2)=0;
			d2fdq2{7}(5,3)=0;
			d2fdq2{7}(5,4)=0;
			d2fdq2{7}(5,5)=0;
			d2fdq2{7}(5,6)=0;
			d2fdq2{7}(5,7)=0;
			d2fdq2{7}(6,1)=0;
			d2fdq2{7}(6,2)=0;
			d2fdq2{7}(6,3)=0;
			d2fdq2{7}(6,4)=0;
			d2fdq2{7}(6,5)=0;
			d2fdq2{7}(6,6)=0;
			d2fdq2{7}(6,7)=0;
			d2fdq2{7}(7,1)=0;
			d2fdq2{7}(7,2)=0;
			d2fdq2{7}(7,3)=0;
			d2fdq2{7}(7,4)=0;
			d2fdq2{7}(7,5)=0;
			d2fdq2{7}(7,6)=0;
			d2fdq2{7}(7,7)=0;
		else
			d2fdq2{7}(1)=[0];
		end
		%{
		if requestedoutput(7)==1
		dfdinput{7}(1,1)=sigmall^2/(10*fcl*ftl^2);
		dfdinput{7}(2,1)=0;
		dfdinput{7}(3,1)=0;
		dfdinput{7}(4,1)=(sigmall*(ftl + 2*sigmall))/(20*fcl^2*ftl);
		dfdinput{7}(5,1)=(sigmarr*(2*fcr - 5*sigmarr))/(10*fcr^3);
		dfdinput{7}(6,1)=(sigmatt*(2*fct - 5*sigmatt))/(10*fct^3);
		dfdinput{7}(7,1)=-(2*sigmart^2)/fvrt^3;
		dfdinput{7}(8,1)=-(2*sigmarl^2)/fvrl^3;
		dfdinput{7}(9,1)=-(2*sigmatl^2)/fvtl^3;
		else
		dfdinput{7}(1,1)=[0];
		end
		%}
	end
	
	% end of sym paste
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [q,dqdalpha,d2qdalpha2]=qandDfromalpha2(alphahp,ftl,ftr,ftt,fcl,fcr,fct,fvrt,fvrl,fvtl,Er,Et,El,kappa1,kappa2,kappa3,kappa4,kappa5,kappa6,kappa7,Gftl,Gfcl,Gftr,Gftt,Gfcr,Gfct,GII,Hld,Hrd,Htd,lc,alpha2dnounit,alpha2maxnounit,alpha4dnounit,alpha4maxnounit,alpha6dnounit,alpha6maxnounit,alpha7dnounit,alpha7maxnounit)

q=zeros(1,7);
dqdalpha=zeros(1,7);
d2qdalpha2=zeros(1,7);

alpha1=alphahp(1);
alpha2=alphahp(2);
alpha3=alphahp(3);
alpha4=alphahp(4);
alpha5=alphahp(5);
alpha6=alphahp(6);
alpha7=alphahp(7);


%{
beta0tl=65;
beta0cl=49.9;
beta0tr=4.5;
beta0cr=beta0tr/beta0tl*beta0cl;
beta0tt=beta0tr;
beta0ct=beta0cr;
%}

beta0tl=abs(ftl);
beta0cl=abs(fcl);
beta0tr=abs(ftr);
beta0cr=abs(fcr);
beta0tt=abs(ftt);
beta0ct=abs(fct);

zeta2=Hrd/beta0cr^2;
zeta4=Htd/beta0ct^2;
zeta6=Hld/beta0cl^2;
zeta7=zeta2;


alpha2d=alpha2dnounit*abs(fcr);
alpha2max=alpha2maxnounit*abs(fcr);
alpha4d=alpha4dnounit*abs(fct);
alpha4max=alpha4maxnounit*abs(fct);
alpha6d=alpha6dnounit*abs(fcl);
alpha6max=alpha6maxnounit*abs(fcl);
alpha7d=alpha7dnounit*abs(1/3*(fvrt+fvrl+fvtl));
alpha7max=alpha7maxnounit*abs(1/3*(fvrt+fvrl+fvtl));

% Start of Sym Results, paste here!
q(1)=(exp(-(alpha1*abs(lc))/abs(Gftr)) - 1)*(kappa1 - 1);
if alpha2<=alpha2d
q(2)=(exp(-(alpha2*abs(lc))/abs(Gfcr)) - 1)*(kappa2 - 1);
else
q(2)=(exp(-(alpha2*abs(lc))/abs(Gfcr)) - 1)*(kappa2 - 1) + (zeta2*(alpha2 - alpha2d)^2)/(alpha2 - alpha2max);
end
q(3)=(exp(-(alpha3*abs(lc))/abs(Gftt)) - 1)*(kappa3 - 1);
if alpha4<=alpha4d
q(4)=(exp(-(alpha4*abs(lc))/abs(Gfct)) - 1)*(kappa4 - 1);
else
q(4)=(exp(-(alpha4*abs(lc))/abs(Gfct)) - 1)*(kappa4 - 1) + (zeta4*(alpha4 - alpha4d)^2)/(alpha4 - alpha4max);
end
q(5)=(exp(-(alpha5*abs(lc))/abs(Gftl)) - 1)*(kappa5 - 1);
if alpha6<=alpha6d
q(6)=(exp(-(alpha6*abs(lc))/abs(Gfcl)) - 1)*(kappa6 - 1);
else
q(6)=(exp(-(alpha6*abs(lc))/abs(Gfcl)) - 1)*(kappa6 - 1) + (zeta6*(alpha6 - alpha6d)^2)/(alpha6 - alpha6max);
end
if alpha7<=alpha7d
q(7)=(exp(-(alpha7*abs(lc))/abs(GII)) - 1)*(kappa7 - 1);
else
q(7)=(exp(-(alpha7*abs(lc))/abs(GII)) - 1)*(kappa7 - 1) + (zeta7*(alpha7 - alpha7d)^2)/(alpha7 - alpha7max);
end
dqdalpha(1)=-(exp(-(alpha1*abs(lc))/abs(Gftr))*abs(lc)*(kappa1 - 1))/abs(Gftr);
if alpha2<=alpha2d
dqdalpha(2)=-(exp(-(alpha2*abs(lc))/abs(Gfcr))*abs(lc)*(kappa2 - 1))/abs(Gfcr);
else
dqdalpha(2)=(zeta2*(2*alpha2 - 2*alpha2d))/(alpha2 - alpha2max) - (zeta2*(alpha2 - alpha2d)^2)/(alpha2 - alpha2max)^2 - (exp(-(alpha2*abs(lc))/abs(Gfcr))*abs(lc)*(kappa2 - 1))/abs(Gfcr);
end
dqdalpha(3)=-(exp(-(alpha3*abs(lc))/abs(Gftt))*abs(lc)*(kappa3 - 1))/abs(Gftt);
if alpha4<=alpha4d
dqdalpha(4)=-(exp(-(alpha4*abs(lc))/abs(Gfct))*abs(lc)*(kappa4 - 1))/abs(Gfct);
else
dqdalpha(4)=(zeta4*(2*alpha4 - 2*alpha4d))/(alpha4 - alpha4max) - (zeta4*(alpha4 - alpha4d)^2)/(alpha4 - alpha4max)^2 - (exp(-(alpha4*abs(lc))/abs(Gfct))*abs(lc)*(kappa4 - 1))/abs(Gfct);
end
dqdalpha(5)=-(exp(-(alpha5*abs(lc))/abs(Gftl))*abs(lc)*(kappa5 - 1))/abs(Gftl);
if alpha6<=alpha6d
dqdalpha(6)=-(exp(-(alpha6*abs(lc))/abs(Gfcl))*abs(lc)*(kappa6 - 1))/abs(Gfcl);
else
dqdalpha(6)=(zeta6*(2*alpha6 - 2*alpha6d))/(alpha6 - alpha6max) - (zeta6*(alpha6 - alpha6d)^2)/(alpha6 - alpha6max)^2 - (exp(-(alpha6*abs(lc))/abs(Gfcl))*abs(lc)*(kappa6 - 1))/abs(Gfcl);
end
if alpha7<=alpha7d
dqdalpha(7)=-(exp(-(alpha7*abs(lc))/abs(GII))*abs(lc)*(kappa7 - 1))/abs(GII);
else
dqdalpha(7)=(zeta7*(2*alpha7 - 2*alpha7d))/(alpha7 - alpha7max) - (zeta7*(alpha7 - alpha7d)^2)/(alpha7 - alpha7max)^2 - (exp(-(alpha7*abs(lc))/abs(GII))*abs(lc)*(kappa7 - 1))/abs(GII);
end
d2qdalpha2(1)=(exp(-(alpha1*abs(lc))/abs(Gftr))*abs(lc)^2*(kappa1 - 1))/abs(Gftr)^2;
if alpha2<=alpha2d
d2qdalpha2(2)=(exp(-(alpha2*abs(lc))/abs(Gfcr))*abs(lc)^2*(kappa2 - 1))/abs(Gfcr)^2;
else
d2qdalpha2(2)=(2*zeta2)/(alpha2 - alpha2max) - (2*zeta2*(2*alpha2 - 2*alpha2d))/(alpha2 - alpha2max)^2 + (2*zeta2*(alpha2 - alpha2d)^2)/(alpha2 - alpha2max)^3 + (exp(-(alpha2*abs(lc))/abs(Gfcr))*abs(lc)^2*(kappa2 - 1))/abs(Gfcr)^2;
end
d2qdalpha2(3)=(exp(-(alpha3*abs(lc))/abs(Gftt))*abs(lc)^2*(kappa3 - 1))/abs(Gftt)^2;
if alpha4<=alpha4d
d2qdalpha2(4)=(exp(-(alpha4*abs(lc))/abs(Gfct))*abs(lc)^2*(kappa4 - 1))/abs(Gfct)^2;
else
d2qdalpha2(4)=(2*zeta4)/(alpha4 - alpha4max) - (2*zeta4*(2*alpha4 - 2*alpha4d))/(alpha4 - alpha4max)^2 + (2*zeta4*(alpha4 - alpha4d)^2)/(alpha4 - alpha4max)^3 + (exp(-(alpha4*abs(lc))/abs(Gfct))*abs(lc)^2*(kappa4 - 1))/abs(Gfct)^2;
end
d2qdalpha2(5)=(exp(-(alpha5*abs(lc))/abs(Gftl))*abs(lc)^2*(kappa5 - 1))/abs(Gftl)^2;
if alpha6<=alpha6d
d2qdalpha2(6)=(exp(-(alpha6*abs(lc))/abs(Gfcl))*abs(lc)^2*(kappa6 - 1))/abs(Gfcl)^2;
else
d2qdalpha2(6)=(2*zeta6)/(alpha6 - alpha6max) - (2*zeta6*(2*alpha6 - 2*alpha6d))/(alpha6 - alpha6max)^2 + (2*zeta6*(alpha6 - alpha6d)^2)/(alpha6 - alpha6max)^3 + (exp(-(alpha6*abs(lc))/abs(Gfcl))*abs(lc)^2*(kappa6 - 1))/abs(Gfcl)^2;
end
if alpha7<=alpha7d
d2qdalpha2(7)=(exp(-(alpha7*abs(lc))/abs(GII))*abs(lc)^2*(kappa7 - 1))/abs(GII)^2;
else
d2qdalpha2(7)=(2*zeta7)/(alpha7 - alpha7max) - (2*zeta7*(2*alpha7 - 2*alpha7d))/(alpha7 - alpha7max)^2 + (2*zeta7*(alpha7 - alpha7d)^2)/(alpha7 - alpha7max)^3 + (exp(-(alpha7*abs(lc))/abs(GII))*abs(lc)^2*(kappa7 - 1))/abs(GII)^2;
end

% End of Sym Results

%{
Dcut=[];
for i=1:length(hardeningsurfaces)
	%qcut(i)=q(hardeningsurfaces(i));
	for j=1:length(hardeningsurfaces)
		Dcut(i,j)=D(hardeningsurfaces(i),hardeningsurfaces(j));
	end
end
%}
%for i=1:7
%	q(i)=q(i)-1e99;
%end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [maxvalue,maxnum]=CellMax(cell11in)
maxnum=1;
maxvalue=cell11in{1};
for i=2:length(cell11in)
	if cell11in{i}>maxvalue
		maxvalue=cell11in{i};
		maxnum=i;
	end
end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [s_sp]=Linear_elastic(dESP,s_sp,E,nu)
	
	% de_sp	               = zeros(spCount,3);                     % Strain increment
	% e_sp	                = zeros(spCount,3);                     % Strain tensor
	% ds_sp	               = zeros(spCount,3);                     % Stress increment
	
	de_sp	               = zeros(1,3);                     % Strain increment
	
	
	%D = [E/(1-nu.^2) E*nu/(1-nu.^2) 0; E*nu/(1-nu.^2) E/(1-nu.^2) 0; 0 0 E/(1-nu)];
	D=E/((1+nu)*(1-2*nu))*[1-nu nu 0;nu 1-nu 0;0 0 (1-2*nu)];
	
	% THis is the linear elastic model
			de_sp(1) = dESP(1,1);
			de_sp(2) = dESP(2,2);
			de_sp(3) = dESP(2,1);
			
			ds_sp = D * de_sp';
	%		e_sp(spid,:)  =  e_sp(spid,:)+de_sp(spid,:);
			s_sp = s_sp + ds_sp';
			
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [sse_sp,s_sp]=Linear_elastic_se(dESP,s_sp,E,nu)
	
	% de_sp	               = zeros(spCount,3);                     % Strain increment
	% e_sp	                = zeros(spCount,3);                     % Strain tensor
	% ds_sp	               = zeros(spCount,3);                     % Stress increment
	
	de_sp	               = zeros(1,3);                     % Strain increment
	e_sp=zeros(3,1);
	sse_sp=zeros(1,1);
	
	%D = [E/(1-nu.^2) E*nu/(1-nu.^2) 0; E*nu/(1-nu.^2) E/(1-nu.^2) 0; 0 0 E/(1-nu)];
	D=E/((1+nu)*(1-2*nu))*[1-nu nu 0;nu 1-nu 0;0 0 (1-2*nu)];
	
	% THis is the linear elastic model
	de_sp(1) = dESP(1,1);
	de_sp(2) = dESP(2,2);
	de_sp(3) = dESP(2,1);
	
	ds_sp = D * de_sp';
	%e_sp(spid,:)  =  e_sp(spid,:)+de_sp(spid,:);
	s_sp = s_sp + ds_sp';
	
	e_sp=(D^-1)*s_sp';
	
	sse_sp=0.5*(e_sp(1)*s_sp(1)+e_sp(2)*s_sp(2)+2*e_sp(3)*s_sp(3));
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [s_sp]=Neo_Hookean_elastic(F_sp,E,nu)
	
	% This is the hyper-elastic Neo-Hookean model
	
	s_sp=zeros(1,3);
	J=det(F_sp);
	
	Lambda = E*nu/(1+nu)/(1-2*nu);
	Mu	 = E/2/(1+nu);

	SSP = Lambda*log(J)/J*eye(2,2) + Mu/J*(F_sp*F_sp'-eye(2,2));
			s_sp(1,1) = SSP(1,1);
			s_sp(1,2) = SSP(2,2);
			s_sp(1,3) = SSP(1,2);
			
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [s_sp]=Linear_elastic_orthotropic(dESP,s_sp,Ebase,Ex,Ey,nu)
	
	% de_sp	               = zeros(spCount,3);                     % Strain increment
	% e_sp	                = zeros(spCount,3);                     % Strain tensor
	% ds_sp	               = zeros(spCount,3);                     % Stress increment
	de_sp	                 = zeros(1,3);                           % Strain increment
	
	
	%{
	Comp=[1/Er -nurt/Et -nurl/El 0 0 0;
		-nurt/Et 1/Et -nutl/El 0 0 0;
		-nurl/El -nutl/El 1/El 0 0 0;
		0 0 0 1/Grt 0 0;
		0 0 0 0 1/Gtl 0;
		0 0 0 0 0 1/Grl];
	%}
	
	nuxy=nu;
	nuxz=nu;
	nuyz=nu;
	Gbase=Ebase/(2*(1+nu));
	Gxy=Gbase;
	Gxz=Gbase;
	Gyz=Gbase;
	Ez=Ebase;
	E=Ebase;
	
	%D = [E/(1-nu.^2) E*nu/(1-nu.^2) 0; E*nu/(1-nu.^2) E/(1-nu.^2) 0; 0 0 E/(1-nu)];
	
	%{
	D3D=[	   -(Ex*Ey*(- Ey*nuyz^2 + Ez))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2), -(Ex*Ey*(Ez*nuxy + Ey*nuxz*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),    -(Ex*Ey*Ez*(nuxz + nuxy*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),   0,   0,   0;
	 -(Ex*Ey*(Ez*nuxy + Ey*nuxz*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),	    -(Ey^2*(- Ex*nuxz^2 + Ez))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2), -(Ey*Ez*(Ey*nuyz + Ex*nuxy*nuxz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),   0,   0,   0;
		-(Ex*Ey*Ez*(nuxz + nuxy*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2), -(Ey*Ez*(Ey*nuyz + Ex*nuxy*nuxz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),	    -(Ez^2*(- Ex*nuxy^2 + Ey))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),   0,   0,   0;
																												  0,	                                                                                                          0,                                                                                                              0, Gxy,   0,   0;
																												  0,	                                                                                                          0,                                                                                                              0,   0, Gyz,   0;
																												  0,	                                                                                                          0,                                                                                                              0,   0,   0, Gxz];

	D=[D3D(1:2,1:2) D3D(1:2,4);
		D3D(4,1:2) D3D(4,4)];
	%}
	
	D = [Ex/(1-nu.^2) E*nu/(1-nu.^2) 0; E*nu/(1-nu.^2) E/(1-nu.^2) 0; 0 0 E/(1-nu)];
	
	% THis is the linear elastic model
			de_sp(1) = dESP(1,1);
			de_sp(2) = dESP(2,2);
			de_sp(3) = dESP(2,1);
			
			ds_sp = D * de_sp';
	%	     e_sp(spid,:)  =  e_sp(spid,:)+de_sp(spid,:);
			s_sp = s_sp + ds_sp';
			
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [s_sp]=Linear_elastic_orthotropic_2(dESP,s_sp,Ex,Ey,Ez,Gxy,Gyz,Gxz,nuxy,nuyz,nuxz)

% de_sp	               = zeros(spCount,3);                     % Strain increment
% e_sp	                = zeros(spCount,3);                     % Strain tensor
% ds_sp	               = zeros(spCount,3);                     % Stress increment

%{
Comp=[1/Er -nurt/Et -nurl/El 0 0 0;
	-nurt/Et 1/Et -nutl/El 0 0 0;
	-nurl/El -nutl/El 1/El 0 0 0;
	0 0 0 1/Grt 0 0;
	0 0 0 0 1/Gtl 0;
	0 0 0 0 0 1/Grl];
%}



%D = [E/(1-nu.^2) E*nu/(1-nu.^2) 0; E*nu/(1-nu.^2) E/(1-nu.^2) 0; 0 0 E/(1-nu)];


D3D=[	   -(Ex*Ey*(- Ey*nuyz^2 + Ez))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2), -(Ex*Ey*(Ez*nuxy + Ey*nuxz*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),    -(Ex*Ey*Ez*(nuxz + nuxy*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),   0,   0,   0;
 -(Ex*Ey*(Ez*nuxy + Ey*nuxz*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),	    -(Ey^2*(- Ex*nuxz^2 + Ez))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2), -(Ey*Ez*(Ey*nuyz + Ex*nuxy*nuxz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),   0,   0,   0;
	-(Ex*Ey*Ez*(nuxz + nuxy*nuyz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2), -(Ey*Ez*(Ey*nuyz + Ex*nuxy*nuxz))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),        -(Ez^2*(- Ex*nuxy^2 + Ey))/(Ey^2*nuyz^2 + 2*Ex*Ey*nuxy*nuxz*nuyz + Ex*Ey*nuxz^2 - Ez*Ey + Ex*Ez*nuxy^2),   0,   0,   0;
	                                                                                                          0,                                                                                                              0,                                                                                                              0, Gxy,   0,   0;
	                                                                                                          0,                                                                                                              0,                                                                                                              0,   0, Gyz,   0;
	                                                                                                          0,                                                                                                              0,                                                                                                              0,   0,   0, Gxz];

D=[D3D(1:2,1:2) D3D(1:2,4);
	D3D(4,1:2) D3D(4,4)];


%D = [Ex/(1-nu.^2) E*nu/(1-nu.^2) 0; E*nu/(1-nu.^2) E/(1-nu.^2) 0; 0 0 E/(1-nu)];

% THis is the linear elastic model
		de_sp=zeros(1,3);
	    de_sp(1) = dESP(1,1);
	    de_sp(2) = dESP(2,2);
	    de_sp(3) = dESP(2,1);
	    
	    ds_sp = D * de_sp';
%	     e_sp(spid,:)  =  e_sp(spid,:)+de_sp(spid,:);
	    s_sp = s_sp + ds_sp';
	    
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [r1_sp,r2_sp] = Update_topology(spCount,F_sp,r1_sp,r10_sp,r2_sp,r20_sp)

for spid=1:spCount
	    r1_sp(spid,:) = (F_sp{spid} * r10_sp(spid,:)')';
	    r2_sp(spid,:) = (F_sp{spid} * r20_sp(spid,:)')';     
end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

%[
%switchable2
function [StressProfile1]=Plot_Final2_alpha(climit,x_sp,LOC,spCount,r1_sp,r2_sp,plotignore,alphahp,surfacenum)
	
	 x_corner1	          = zeros(spCount,2);
	 x_corner2	          = zeros(spCount,2);
	 x_corner3	          = zeros(spCount,2);
	 x_corner4	          = zeros(spCount,2);
	 
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	spnum=0;
	x_sp_plot=zeros(1,2);
	splot_plot=zeros(1,1);
	for sp=1:spCount
		if plotignore(sp)
			continue;
		elseif alphahp(sp,surfacenum)==0
			continue;
		end
		spnum=spnum+1;
		x_sp_plot(spnum,:)=x_sp(sp,:);
		splot_plot(spnum)=alphahp(sp,surfacenum);
	end
	
	for sp=1:spCount
		 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	 end
	
	StressProfile1=figure;
	 set(StressProfile1, 'visible','off');
	sz = 40;
	%color = velocity;
	color = splot_plot;
	scatter(x_sp_plot(:,1),x_sp_plot(:,2),sz,color,'filled');
	hold on
	daspect([1 1 1]);
	for sp=1:spCount
		x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
		y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
		plot(x_cor,y_cor,'r')
	end
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:20:max(LOC(:,1))]);
	set(gca,'ytick',[0:20:max(LOC(:,2))]);
	h=colorbar;
	colormap(jet(256))
	set(gca,'FontSize',20)
	% set(h, 'ytick', [0:0.2:1.2]);a
	caxis(climit);
	%set(gca,'ctick',[0:8]);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Final2_f_plot(t_time,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,plotignore,f_final_vect,alphahp)
	
	 x_corner1	          = zeros(spCount,2);
	 x_corner2	          = zeros(spCount,2);
	 x_corner3	          = zeros(spCount,2);
	 x_corner4	          = zeros(spCount,2);
	 
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	spnum=0;
	x_sp_plot=zeros(1,2);
	splot_plot=zeros(1,1);
	for sp=1:spCount
		if plotignore(sp)
			continue;
		elseif max(alphahp(sp,:))==0
			continue;
		end
		spnum=spnum+1;
		x_sp_plot(spnum,:)=x_sp(sp,:);
		splot_plot(spnum)=FindMax(f_final_vect(sp,:));
	end
	
	for sp=1:spCount
		 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	 end
	
	StressProfile1=figure;
	 set(StressProfile1, 'visible','off');
	sz = 10;
	%color = velocity;
	color = splot_plot;
	scatter(x_sp_plot(:,1),x_sp_plot(:,2),sz,color,'filled');
	hold on
	daspect([1 1 1]);
	title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
	set(StressProfile1,'Position',[0 0 720 1280]);
	for sp=1:spCount
		x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
		y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
		plot(x_cor,y_cor,'r')
	end
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:20:max(LOC(:,1))]);
	set(gca,'ytick',[0:20:max(LOC(:,2))]);
	h=colorbar;
	colormap(jet(256))
	set(gca,'FontSize',20)
	% set(h, 'ytick', [0:0.2:1.2]);a
	caxis([0 7]);
	%set(gca,'ctick',[0:8]);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%function not in use
function CurrentConfig = Plot_Current_var(x_sp,LOC,LOCX,LOCY,orientationoffset,xdirletter,ydirletter,lp,F_sp)
	
	CurrentConfig=figure;
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	lp_take=sum(sum(lp))/(size(lp,1)*size(lp,2));
	for i=1:length(orientationoffset)
	    if length(xdirletter{i})==1 && xdirletter{i}=='l'
	    elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
	        orientationoffset(i)=orientationoffset(i)+pi/2;
	    elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
	    elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
	        orientationoffset(i)=orientationoffset(i)+pi/2;
	    else
	        continue
	    end
	    Rback=poldecomp(F_sp{i},0);
	    R=transpose(Rback);
	    totalangle=asin(R(1,2))+orientationoffset(i);
	    xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(totalangle);
	    xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(totalangle);
	    ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(totalangle);
	    yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(totalangle);
	    plot([xstart xend],[ystart yend],'color','red');
	end
	title('initial condition');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',LOCX);
	set(gca,'ytick',LOCY);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end
%function not in use
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function CurrentConfig = Plot_CrackDirNairn(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack,x_crack,x_cracktop,x_crackbot)
	
	CurrentConfig=figure;
	set(CurrentConfig, 'visible','off');
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	%set(CurrentConfig,'Position',[0 0 720 1280]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
	    if length(xdirletter{i})==1 && xdirletter{i}=='l'
	    elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
	        orientationoffset(i)=orientationoffset(i)+pi/2;
	    elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
	    elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
	        orientationoffset(i)=orientationoffset(i)+pi/2;
	    else
	        continue;
	    end
	    Rback=poldecomp(F_sp{i},0);
	    R=transpose(Rback);
	    %totalangle=asin(R(1,2))+orientationoffset(i);
		if isnan(thetacrack(i))
		elseif isinf(thetacrack(i))
		else
			totalangle=thetacrack(i);
			xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(totalangle);
			xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(totalangle);
			ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(totalangle);
			yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(totalangle);
			plot([xstart xend],[ystart yend],'color','red');
		end
	end
	if length(x_crack)==0
	else
	    plot(x_cracktop(:,1),x_cracktop(:,2),'o','Color','red');
	    plot(x_crack(:,1),x_crack(:,2),'o','Color','green');
	    plot(x_crackbot(:,1),x_crackbot(:,2),'o','Color','blue');
	end
	title('Proposed Crack');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function CurrentConfig = Plot_CrackDirNairn_multi(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack,x_crack,x_cracktop,x_crackbot)
	CurrentConfig=figure;
	set(CurrentConfig, 'visible','off');
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	%set(CurrentConfig,'Position',[0 0 720 1280]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
	    if length(xdirletter{i})==1 && xdirletter{i}=='l'
	    elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
	        orientationoffset(i)=orientationoffset(i)+pi/2;
	    elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
	    elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
	        orientationoffset(i)=orientationoffset(i)+pi/2;
	    else
	        continue;
	    end
	    Rback=poldecomp(F_sp{i},0);
	    R=transpose(Rback);
	    %totalangle=asin(R(1,2))+orientationoffset(i);
		if isnan(thetacrack(i))
		elseif isinf(thetacrack(i))
		else
			totalangle=thetacrack(i);
			xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(totalangle);
			xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(totalangle);
			ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(totalangle);
			yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(totalangle);
			plot([xstart xend],[ystart yend],'color','red');
		end
	end
	for icrackpath=1:length(x_crack)
	    plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'o','Color','red');
	    plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'o','Color','green');
	    plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'o','Color','blue');
	end
	title('Proposed Crack');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function CurrentConfig = Plot_CrackDirNairn_multilines(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack,x_crack,x_cracktop,x_crackbot,CasetoRun)
	CurrentConfig=figure;
	set(CurrentConfig, 'visible','off');
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	if CasetoRun==105 || CasetoRun==110
		set(CurrentConfig,'Position',[0 0 1800 1800]);
	end
	lp_take=max(lp);
	for i=1:length(orientationoffset)
	    if length(xdirletter{i})==1 && xdirletter{i}=='l'
	    elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
	        orientationoffset(i)=orientationoffset(i)+pi/2;
	    elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
	    elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
	        orientationoffset(i)=orientationoffset(i)+pi/2;
	    else
	        continue;
	    end
	    Rback=poldecomp(F_sp{i},0);
	    R=transpose(Rback);
	    %totalangle=asin(R(1,2))+orientationoffset(i);
		if isnan(thetacrack(i))
		elseif isinf(thetacrack(i))
		else
			totalangle=thetacrack(i);
			xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(totalangle);
			xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(totalangle);
			ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(totalangle);
			yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(totalangle);
			plot([xstart xend],[ystart yend],'color','red');
		end
	end
	for icrackpath=1:length(x_crack)
		if CasetoRun==117
			plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'x-','Color','red');
			plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'x-','Color','black','LineWidth',2);
			plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'x-','Color','blue');
		else
			%plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'o','Color','red');
			plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','black','LineWidth',2);
			%plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'o','Color','blue');
		end
	end
	title('Proposed Crack');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function CurrentConfig = Plot_CrackDir(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp,thetacrack)
	
	CurrentConfig=figure;
	set(CurrentConfig, 'visible','off');
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	set(CurrentConfig,'Position',[0 0 720 1280]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
	    if length(xdirletter{i})==1 && xdirletter{i}=='l'
	    elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
	        orientationoffset(i)=orientationoffset(i)+pi/2;
	    elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
	    elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
	        orientationoffset(i)=orientationoffset(i)+pi/2;
	    else
	        continue;
	    end
	    Rback=poldecomp(F_sp{i},0);
	    R=transpose(Rback);
	    %totalangle=asin(R(1,2))+orientationoffset(i);
		if isnan(thetacrack(i))
		elseif isinf(thetacrack(i))
		else
			totalangle=thetacrack(i);
			xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(totalangle);
			xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(totalangle);
			ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(totalangle);
			yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(totalangle);
			plot([xstart xend],[ystart yend],'color','red');
		end
	end
	
	title('Proposed Crack');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function CurrentConfig = Plot_Current(x_sp,LOC,orientationoffset,xdirletter,ydirletter,lp,le,F_sp)
	
	CurrentConfig=figure;
	set(CurrentConfig, 'visible','off');
	plot(x_sp(:,1),x_sp(:,2),'o');
	hold on
	daspect([1 1 1]);
	set(CurrentConfig,'Position',[0 0 720 1280]);
	lp_take=max(lp);
	for i=1:length(orientationoffset)
	    if length(xdirletter{i})==1 && xdirletter{i}=='l'
	    elseif length(ydirletter{i})==1 && ydirletter{i}=='l'
	        orientationoffset(i)=orientationoffset(i)+pi/2;
	    elseif length(xdirletter{i})==1 && xdirletter{i}=='t'
	    elseif length(ydirletter{i})==1 && ydirletter{i}=='t'
	        orientationoffset(i)=orientationoffset(i)+pi/2;
	    else
	        continue;
	    end
	    Rback=poldecomp(F_sp{i},0);
	    R=transpose(Rback);
	    totalangle=asin(R(1,2))+orientationoffset(i);
	    xstart=x_sp(i,1)-lp_take*sqrt(2)/2*cos(totalangle);
	    xend=x_sp(i,1)+lp_take*sqrt(2)/2*cos(totalangle);
	    ystart=x_sp(i,2)-lp_take*sqrt(2)/2*sin(totalangle);
	    yend=x_sp(i,2)+lp_take*sqrt(2)/2*sin(totalangle);
	    plot([xstart xend],[ystart yend],'color','red');
	end
	title('Current Config');
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:le(1):max(LOC(:,1))]);
	set(gca,'ytick',[0:le(2):max(LOC(:,2))]);
	% set(gca,'XTickLabel',[]);
	% set(gca,'YTickLabel',[]);
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Final2_regularclimit(t_time,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,splot,climits,plotignore)
	
	 x_corner1	          = zeros(spCount,2);
	 x_corner2	          = zeros(spCount,2);
	 x_corner3	          = zeros(spCount,2);
	 x_corner4	          = zeros(spCount,2);
	 
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	for sp=1:spCount
	%	 displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	 strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	spnum=0;
	x_sp_plot=zeros(spCount-sum(plotignore),2);
	splot_plot=zeros(spCount-sum(plotignore),1);
	for sp=1:spCount
		if plotignore(sp)
			continue;
		end
		spnum=spnum+1;
		x_sp_plot(spnum,:)=x_sp(sp,:);
		splot_plot(spnum)=splot(sp);
	end
	
	for sp=1:spCount
	   
		 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	 end
	
	StressProfile1=figure;
	 set(StressProfile1, 'visible','off');
	sz = 40;
	%color = velocity;
	color = splot_plot;
	scatter(x_sp_plot(:,1),x_sp_plot(:,2),sz,color,'filled');
	hold on
	daspect([1 1 1]);
	title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
	%set(StressProfile1,'Position',[0 0 720 1280]);
	for sp=1:spCount
		x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
		y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
		plot(x_cor,y_cor,'r')
	end
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:20:max(LOC(:,1))]);
	set(gca,'ytick',[0:20:max(LOC(:,2))]);
	h=colorbar;
	colormap(jet(256))
	set(gca,'FontSize',20)
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1);
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Final2_regularclimit_multiline(t_time,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,splot,climits,plotignore)
	 x_corner1	          = zeros(spCount,2);
	 x_corner2	          = zeros(spCount,2);
	 x_corner3	          = zeros(spCount,2);
	 x_corner4	          = zeros(spCount,2);
	 
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	for sp=1:spCount
	%	 displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	 strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	spnum=0;
	x_sp_plot=zeros(spCount-sum(plotignore),2);
	splot_plot=zeros(spCount-sum(plotignore),1);
	for sp=1:spCount
		if plotignore(sp)
			continue;
		end
		spnum=spnum+1;
		x_sp_plot(spnum,:)=x_sp(sp,:);
		splot_plot(spnum)=splot(sp);
	end

	for sp=1:spCount
	   
		 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	 end

	StressProfile1=figure;
	 set(StressProfile1, 'visible','off');
	sz = 40;
	%color = velocity;
	color = splot_plot;
	scatter(x_sp_plot(:,1),x_sp_plot(:,2),sz,color,'filled');
	hold on
	daspect([1 1 1]);
	title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
	%set(StressProfile1,'Position',[0 0 720 1280]);
	for sp=1:spCount
		x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
		y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
		plot(x_cor,y_cor,'r')
	end
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:20:max(LOC(:,1))]);
	set(gca,'ytick',[0:20:max(LOC(:,2))]);
	h=colorbar;
	colormap(jet(256))
	set(gca,'FontSize',20)
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1);
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Final2_regularclimit_black(t_time,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,splot,climits,plotignore,CasetoRun)
	
	 x_corner1	          = zeros(spCount,2);
	 x_corner2	          = zeros(spCount,2);
	 x_corner3	          = zeros(spCount,2);
	 x_corner4	          = zeros(spCount,2);
	 
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	for sp=1:spCount
	%	 displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	 strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	spnum=0;
	x_sp_plot=zeros(spCount-sum(plotignore),2);
	splot_plot=zeros(spCount-sum(plotignore),1);
	for sp=1:spCount
		if plotignore(sp)
			continue;
		end
		spnum=spnum+1;
		x_sp_plot(spnum,:)=x_sp(sp,:);
		splot_plot(spnum)=splot(sp);
	end
	
	for sp=1:spCount
	   
		 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	StressProfile1=figure;
	 set(StressProfile1, 'visible','off');
	 if CasetoRun==10
		 sz = 140;
	 else
		sz = 80;
	 end
	%color = velocity;
	color = splot_plot;
	scatter(x_sp_plot(:,1),x_sp_plot(:,2),sz,color,'filled');
	hold on
	daspect([1 1 1]);
	%title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
	set(StressProfile1,'Position',[0 0 1000 1000]);
	for sp=1:spCount
		x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
		y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
		if plotignore(sp)
			x_cross1=[x_corner1(sp,1) x_corner3(sp,1)];
			y_cross1=[x_corner1(sp,2) x_corner3(sp,2)];
			x_cross2=[x_corner2(sp,1) x_corner4(sp,1)];
			y_cross2=[x_corner2(sp,2) x_corner4(sp,2)];
			plot(x_cross1,y_cross1,'r');
			plot(x_cross2,y_cross2,'r');
		end
		plot(x_cor,y_cor,'r')
	end
	grid on
	if CasetoRun==10
		axis([0,max(LOC(:,1)),0,160]);
	else
		axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	end
	set(gca,'xtick',[0:20:max(LOC(:,1))]);
	if CasetoRun==10
		set(gca,'ytick',[0:20:160]);
	else
		set(gca,'ytick',[0:20:max(LOC(:,2))]);
	end
	h=colorbar;
	currentcolormap1=jet(256);
	currentcolormap2=currentcolormap1;
	colormap(currentcolormap2)
	set(gca,'FontSize',40)
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1);
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Final2_regularnolimit(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,splot)
	
	 x_corner1	          = zeros(spCount,2);
	 x_corner2	          = zeros(spCount,2);
	 x_corner3	          = zeros(spCount,2);
	 x_corner4	          = zeros(spCount,2);
	 
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	for sp=1:spCount
	%	 displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	 strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	 for sp=1:spCount
	 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
	 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
	 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
	 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	 end
	
	StressProfile1=figure;
	 set(StressProfile1, 'visible','off');
	sz = 40;
	%color = velocity;
	color = splot;
	scatter(x_sp(:,1),x_sp(:,2),sz,color,'filled');
	hold on
	daspect([1 1 1]);
	for sp=1:spCount
		x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
		y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
		plot(x_cor,y_cor,'r')
	end
	grid on
	axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
	set(gca,'xtick',[0:20:max(LOC(:,1))]);
	set(gca,'ytick',[0:20:max(LOC(:,2))]);
	h=colorbar;
	colormap(jet(256))
	set(gca,'FontSize',20)
	% set(h, 'ytick', [0:0.2:1.2]);
	%{
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1);
				caxis(climits);
			end
		end
	end
	%}
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_ovl(t_time,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,ActuallyPlot,plotignore)
	
	 x_corner1	          = zeros(spCount,2);
	 x_corner2	          = zeros(spCount,2);
	 x_corner3	          = zeros(spCount,2);
	 x_corner4	          = zeros(spCount,2);
	 
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	
	for sp=1:spCount
	%	 displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	 strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	
	 for sp=1:spCount
	 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
	 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
	 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
	 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	 end
	
	 %%Calculating Max Princ Plast Strain
	 for sp=1:spCount
		 theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		 e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		 e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		 e_pl_max(sp)=max(e_pl_first,e_pl_second);
		 e_pl_min(sp)=min(e_pl_first,e_pl_second);
		 e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		 if plotignore(sp)
		 else
			if maxminshear==1
				if isnan(e_pl_max(sp)) || isinf(e_pl_max(sp))
					e_pl_max(sp)=0;
				end
			elseif maxminshear==2
				if isnan(e_pl_min(sp)) || isinf(e_pl_min(sp))
					e_pl_min(sp)=0;
				end
			elseif maxminshear==3
				if isnan(e_pl_shear(sp)) || isinf(e_pl_shear(sp))
					e_pl_shear(sp)=0;
				end
			else
				disp('wrong maxminshear input!');
				pause
			end
		 end
	 end
	 if ActuallyPlot==1
		StressProfile1=figure;
		 set(StressProfile1, 'visible','off');
		sz = 30;
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		scatter(x_sp(:,1),x_sp(:,2),sz,color,'filled');
		hold on
		daspect([1 1 1]);
		title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
		set(StressProfile1,'Position',[0 0 5760 10240]);
		set(gca,'color','none');
		for sp=1:spCount
			if plotignore(sp)
			else
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r','LineWidth',2)
			end
		end
		grid on
		axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
		set(gca,'xtick',[0:inf:max(LOC(:,1))]);
		set(gca,'ytick',[0:inf:max(LOC(:,2))]);
		%h=colorbar;
		colormap(jet(256))
		% set(h, 'ytick', [0:0.2:1.2]);
		set(gca,'FontSize',1)
	else
		StressProfile1=[];
	end
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end

end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_report(matmodel,CasetoRun,t_time,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,ActuallyPlot)
	
	 x_corner1	          = zeros(spCount,2);
	 x_corner2	          = zeros(spCount,2);
	 x_corner3	          = zeros(spCount,2);
	 x_corner4	          = zeros(spCount,2);
	 
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	
	for sp=1:spCount
	%	 displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	 strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	
	 for sp=1:spCount
	 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
	 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
	 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
	 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	 end
	
	 %%Calculating Max Princ Plast Strain
	 for sp=1:spCount
		 theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		 e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		 e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		 e_pl_max(sp)=max(e_pl_first,e_pl_second);
		 e_pl_min(sp)=min(e_pl_first,e_pl_second);
		 e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		 if matmodel(sp)~=1
		 else
			if maxminshear==1
				if isnan(e_pl_max(sp)) || isinf(e_pl_max(sp))
					e_pl_max(sp)=0;
				end
			elseif maxminshear==2
				if isnan(e_pl_min(sp)) || isinf(e_pl_min(sp))
					e_pl_min(sp)=0;
				end
			elseif maxminshear==3
				if isnan(e_pl_shear(sp)) || isinf(e_pl_shear(sp))
					e_pl_shear(sp)=0;
				end
			else
				disp('wrong maxminshear input!');
				pause
			end
		 end
	end
	 if ActuallyPlot==1
		StressProfile1=figure;
		 set(StressProfile1, 'visible','off');
		if CasetoRun==40 || CasetoRun==52 || CasetoRun==54
			sz = 20;
		elseif CasetoRun==61 || CasetoRun==62 || CasetoRun==63
			sz = 20;
		else
			sz = 10;
		end
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		scatter(x_sp(:,1),x_sp(:,2),sz,color,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==40 || CasetoRun==52 || CasetoRun==54
		elseif CasetoRun==61 || CasetoRun==62 || CasetoRun==63
		else
			title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
		end
		if CasetoRun==40 || CasetoRun==52 || CasetoRun==54
			set(StressProfile1,'Position',[0 0 600 960]);
		elseif CasetoRun==61 || CasetoRun==62 || CasetoRun==63
			set(StressProfile1,'Position',[0 0 600 960]);
		else
			set(StressProfile1,'Position',[0 0 720 1280]);
		end
		for sp=1:spCount
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			plot(x_cor,y_cor,'r')
		end
		grid on
		if CasetoRun==40 || CasetoRun==52 || CasetoRun==54
			axis([0,max(LOC(:,1)),0,140]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:140]);
		elseif CasetoRun==61 || CasetoRun==62 || CasetoRun==63
			axis([40,180,40,480]);
			set(gca,'xtick',[40:inf:180]);
			set(gca,'ytick',[40:inf:480]);
			axis off
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		h=colorbar;
		colormap(jet(256))
		% set(h, 'ytick', [0:0.2:1.2]);
		if CasetoRun==40 || CasetoRun==52 || CasetoRun==54
			set(gca,'FontSize',30);
		else
			set(gca,'FontSize',20);
		end
	else
		StressProfile1=[];
	end
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit(t_time,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,ActuallyPlot)
	
	 x_corner1	          = zeros(spCount,2);
	 x_corner2	          = zeros(spCount,2);
	 x_corner3	          = zeros(spCount,2);
	 x_corner4	          = zeros(spCount,2);
	 
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	
	for sp=1:spCount
	%	 displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	 strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	
	 for sp=1:spCount
	 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
	 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
	 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
	 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	 end

	 %%Calculating Max Princ Plast Strain
	 for sp=1:spCount
		 theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		 e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		 e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		 e_pl_max(sp)=max(e_pl_first,e_pl_second);
		 e_pl_min(sp)=min(e_pl_first,e_pl_second);
		 e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
	 end
	 if ActuallyPlot==1
		StressProfile1=figure;
		 set(StressProfile1, 'visible','off');
		sz = 10;
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		scatter(x_sp(:,1),x_sp(:,2),sz,color,'filled');
		hold on
		daspect([1 1 1]);
		title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
		set(StressProfile1,'Position',[0 0 720 1280]);
		for sp=1:spCount
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			plot(x_cor,y_cor,'r')
		end
		grid on
		axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
		set(gca,'xtick',[0:20:max(LOC(:,1))]);
		set(gca,'ytick',[0:20:max(LOC(:,2))]);
		h=colorbar;
		colormap(jet(256))
		% set(h, 'ytick', [0:0.2:1.2]);
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
	
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_black(t_time,tt,DispPump,x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,plotignore,ActuallyPlot,CasetoRun)
	
	 x_corner1	          = zeros(spCount,2);
	 x_corner2	          = zeros(spCount,2);
	 x_corner3	          = zeros(spCount,2);
	 x_corner4	          = zeros(spCount,2);
	 
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	
	for sp=1:spCount
	%	 displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	 strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	
	 for sp=1:spCount
	 x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
	 x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
	 x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
	 x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	 end

	 %%Calculating Max Princ Plast Strain
	 for sp=1:spCount
		 theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		 e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		 e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		 e_pl_max(sp)=max(e_pl_first,e_pl_second);
		 e_pl_min(sp)=min(e_pl_first,e_pl_second);
		 e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
	 end
	 if ActuallyPlot==1
		StressProfile1=figure;
		 set(StressProfile1, 'visible','off');
		 if CasetoRun==10
			 sz = 140;
		 else
			sz = 80;
		 end
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		scatter(x_sp(:,1),x_sp(:,2),sz,color,'filled');
		hold on
		daspect([1 1 1]);
		%title(['tt=' num2str(tt) ', d=' num2str(DispPump)]);
		set(StressProfile1,'Position',[0 0 1000 1000]);
		for sp=1:spCount
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			if plotignore(sp)
				x_cross1=[x_corner1(sp,1) x_corner3(sp,1)];
				y_cross1=[x_corner1(sp,2) x_corner3(sp,2)];
				x_cross2=[x_corner2(sp,1) x_corner4(sp,1)];
				y_cross2=[x_corner2(sp,2) x_corner4(sp,2)];
				plot(x_cross1,y_cross1,'color','red');
				plot(x_cross2,y_cross2,'color','red');
			end
			plot(x_cor,y_cor,'red')
		end
		grid on
		if CasetoRun==10
			axis([0,max(LOC(:,1)),0,160]);
			set(gca,'ytick',[0:20:160]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		set(gca,'xtick',[0:20:max(LOC(:,1))]);
		h=colorbar;
		currentcolormap1=jet(256);
		currentcolormap2=currentcolormap1;
		colormap(currentcolormap2)
		% set(h, 'ytick', [0:0.2:1.2]);
		set(gca,'FontSize',40)
	else
		StressProfile1=[];
	end
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
	
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_directions_crack(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot)
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	for sp=1:spCount
	%	 displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	 strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end

	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end
	
	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
	end
	
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		sz = 40;
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		for sp=1:spCount
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			plot(x_cor,y_cor,'r')
			if plotignore(sp)
				continue;
			end
			if maxminshear==1
				thetaplot=thetamax(sp);
			elseif maxminshear==2
				thetaplot=thetamin(sp);
			elseif maxminshear==3
				continue;
			else
				disp('MaxminShear Wrong! Put either 1, 2, or 3!')
				pause
			end
			xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
			xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
			ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
			yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
			plot([xstart xend],[ystart yend],'color','black');
		end
		if length(x_crack)==0
		else
			plot(x_cracktop(:,1),x_cracktop(:,2),'o','Color','red');
			plot(x_crack(:,1),x_crack(:,2),'o','Color','green');
			plot(x_crackbot(:,1),x_crackbot(:,2),'o','Color','blue');
		end
		grid on
		axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
		set(gca,'xtick',[0:20:max(LOC(:,1))]);
		set(gca,'ytick',[0:20:max(LOC(:,2))]);
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_directions_crackmulti(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun)
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	 
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		 
	end
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		sz = 40;
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		for sp=1:spCount
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			plot(x_cor,y_cor,'r')
			if plotignore(sp)
				continue;
			end
			if maxminshear==1
				thetaplot=thetamax(sp);
			elseif maxminshear==2
				thetaplot=thetamin(sp);
			elseif maxminshear==3
				continue;
			else
				disp('MaxminShear Wrong! Put either 1, 2, or 3!')
				pause
			end
			xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
			xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
			ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
			yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
			plot([xstart xend],[ystart yend],'color','black');
		end
		if length(x_crack)==0
		else
			for icrackpath=1:length(x_crack)
				plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'o','Color','red');
				plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'o','Color','green');
				plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'o','Color','blue');
			end
		end
		grid on
		axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
		set(gca,'xtick',[0:20:max(LOC(:,1))]);
		set(gca,'ytick',[0:20:max(LOC(:,2))]);
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_ColoredCrack(NN,le_base,x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,thevalue_crack,climits,lp,plotignore,ActuallyPlot,CasetoRun,refinementfactor)
	if ActuallyPlot==1
		StressProfile1=figure;
		axh=gca();
		set(StressProfile1, 'visible','off');
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			sz=32/refinementfactor;
		elseif CasetoRun==228
			sz=16/refinementfactor;
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			sz=10*64/refinementfactor/9;
		else
			sz = 40;
		end
		x_sp_cut=cutvector(x_sp,1,plotignore);
		
		plot(x_sp_cut(:,1),x_sp_cut(:,2),'o','MarkerSize',sz,'MarkerEdgeColor',[0.75 0.75 0.75],'MarkerFaceColor',[0.75 0.75 0.75])
		hold on
		daspect([1 1 1]);
		
		colordepth=256;
		cmap=jet(colordepth);
		colormap(axh,cmap);
		cbh=colorbar();
		caxis(climits);
		ylabel(cbh,'Opening Completion');
		set(gca,'FontSize',20)
		
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		
		if length(x_crack)==0
		else
			for icrackpath=1:length(x_crack)
				plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'Color',[1 0.8 0.8],'LineWidth',1);
				plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'Color',[0.8 0.8 1],'LineWidth',1);
				for icrackparticle=1:size(x_crack{icrackpath},1)-1
					averagevalue=sum(thevalue_crack(icrackparticle:icrackparticle+1,icrackpath))/2;
					rgbvalue=jet2rgb(colordepth,climits(1),climits(2),averagevalue);
					plot(x_crack{icrackpath}(icrackparticle:icrackparticle+1,1),x_crack{icrackpath}(icrackparticle:icrackparticle+1,2),'-','Color',rgbvalue,'LineWidth',1);
				end
			end
		end
		grid on
		if CasetoRun==192
			axis([1.8,4.2,1.8,4.2]*le_base);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==118 || CasetoRun==173
			axis([1.8,4.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:4.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			axis([1.8,6.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227
			axis([1.6,12.4,1.6,4.4]*10);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209
			axis([1.6,12.4,1.6,4.4]*10);
			set(gca,'xtick',[1.6:0.2:12.4]*10);
			set(gca,'ytick',[1.6:0.2:4.4]*10);
		elseif CasetoRun==228
			axis(le_base*[1.5,7.5,1.5,19.5]);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220
			axis(le_base*[1.5,5.5,1.5,5.5]);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==229 || CasetoRun==230
			axis(le_base*[1.5,3.5,1.5,8.5]);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==205 || CasetoRun==210 || CasetoRun==207	
			axis([2.6,9.4,3.6,10.4]*le_base);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==202
			axis([1.6,6.4,1.6,4.4]*10);
			set(gca,'xtick',[1.6:0.2:6.4]*10);
			set(gca,'ytick',[1.6:0.2:4.4]*10);
		elseif CasetoRun==211
			axis([1.6,5.4,1.6,5.4]*200);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==201
			axis([1.6,5.4,1.6,5.4]*200);
			set(gca,'xtick',[1.6:0.2:5.4]*200);
			set(gca,'ytick',[1.6:0.2:5.4]*200);
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			axis(le_base*[1.5,5.5,1.5,5.5]);
			%set(gca,'xtick',le_base*[1.5:0.25:5.5]);
			%set(gca,'ytick',le_base*[1.5:0.25:5.5]);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169
			axis([1.6,5.4,1.6,5.4]);
			set(gca,'xtick',[1.6:0.2:5.4]);
			set(gca,'ytick',[1.6:0.2:5.4]);
		elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165
			axis([1.6,6.4,1.6,4.4]);
			set(gca,'xtick',[1.6:0.2:6.4]);
			set(gca,'ytick',[1.6:0.2:4.4]);
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==130 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			axis([1.8,6.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
			axis([1.8,13.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:13.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153
			axis([0,14,0,14]);
			set(gca,'xtick',[0:1:14]);
			set(gca,'ytick',[0:1:14]);		
		elseif CasetoRun==154 || CasetoRun==161
			axis([2.5,5.5,2.5,5.5]);
			set(gca,'xtick',[2.5:0.25:5.5]);
			set(gca,'ytick',[2.5:0.25:5.5]);				
		elseif CasetoRun==138
			axis([1.8,4.2,1.8,4.2]*4.5);
			set(gca,'xtick',[1.8:0.2:4.2]*4.5);
			set(gca,'ytick',[1.8:0.2:4.2]*4.5);
		elseif CasetoRun==134 || CasetoRun==136
			axis([1.8,7.7,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:7.7]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==124
			axis([1.3,11.7,1.3,10.4]);
			set(gca,'xtick',[1.3:1.3:11.7]);
			set(gca,'ytick',[1.3:1.3:10.4]);
		elseif CasetoRun==194
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==175 || CasetoRun==180
			if refinementfactor==2
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.5:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.5:max(LOC(:,2))]);
			elseif refinementfactor==4
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.25:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.25:max(LOC(:,2))]);
			else
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:max(LOC(:,1)):max(LOC(:,1))]);
				set(gca,'ytick',[0:max(LOC(:,2)):max(LOC(:,2))]);
			end
			set(gca,'Yticklabel',[]);
			set(gca,'Xticklabel',[]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Final2_singlevalue(NN,le_base,x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,thevalue_sp,climits,lp,plotignore,ActuallyPlot,CasetoRun,refinementfactor)
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	 
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	%%Calculating Max Princ Plast Strain
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			sz=5*64/refinementfactor;
		elseif CasetoRun==228
			sz=256/refinementfactor^2;
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			sz=10*64/refinementfactor/9;
		else
			sz = 40;
		end
		color=thevalue_sp;
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		
		if length(x_crack)==0
		else
			for icrackpath=1:length(x_crack)
				plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'Color','red','LineWidth',1);
				plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','black','LineWidth',1);
				plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'Color','blue','LineWidth',1);
			end
		end
		grid on
		if CasetoRun==192
			axis([1.8,4.2,1.8,4.2]*le_base);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==118 || CasetoRun==173
			axis([1.8,4.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:4.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			axis([1.8,6.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227
			axis([1.6,12.4,1.6,4.4]*10);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209
			axis([1.6,12.4,1.6,4.4]*10);
			set(gca,'xtick',[1.6:0.2:12.4]*10);
			set(gca,'ytick',[1.6:0.2:4.4]*10);
		elseif CasetoRun==228
			axis(le_base*[1.5,7.5,1.5,19.5]);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220
			axis(le_base*[1.5,5.5,1.5,5.5]);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==229
			axis(le_base*[1.5,3.5,1.5,8.5]);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==230
			axis([0,le(1)*(NN(1)-1),0,le(2)*(NN(2)-1)]);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==205 || CasetoRun==210 || CasetoRun==207	
			axis([2.6,9.4,3.6,10.4]*le_base);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==202
			axis([1.6,6.4,1.6,4.4]*10);
			set(gca,'xtick',[1.6:0.2:6.4]*10);
			set(gca,'ytick',[1.6:0.2:4.4]*10);
		elseif CasetoRun==211
			axis([1.6,5.4,1.6,5.4]*200);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==201
			axis([1.6,5.4,1.6,5.4]*200);
			set(gca,'xtick',[1.6:0.2:5.4]*200);
			set(gca,'ytick',[1.6:0.2:5.4]*200);
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			axis(le_base*[1.5,5.5,1.5,5.5]);
			%set(gca,'xtick',le_base*[1.5:0.25:5.5]);
			%set(gca,'ytick',le_base*[1.5:0.25:5.5]);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169
			axis([1.6,5.4,1.6,5.4]);
			set(gca,'xtick',[1.6:0.2:5.4]);
			set(gca,'ytick',[1.6:0.2:5.4]);
		elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165
			axis([1.6,6.4,1.6,4.4]);
			set(gca,'xtick',[1.6:0.2:6.4]);
			set(gca,'ytick',[1.6:0.2:4.4]);
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==130 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			axis([1.8,6.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
			axis([1.8,13.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:13.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153
			axis([0,14,0,14]);
			set(gca,'xtick',[0:1:14]);
			set(gca,'ytick',[0:1:14]);		
		elseif CasetoRun==154 || CasetoRun==161
			axis([2.5,5.5,2.5,5.5]);
			set(gca,'xtick',[2.5:0.25:5.5]);
			set(gca,'ytick',[2.5:0.25:5.5]);				
		elseif CasetoRun==138
			axis([1.8,4.2,1.8,4.2]*4.5);
			set(gca,'xtick',[1.8:0.2:4.2]*4.5);
			set(gca,'ytick',[1.8:0.2:4.2]*4.5);
		elseif CasetoRun==134 || CasetoRun==136
			axis([1.8,7.7,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:7.7]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==124
			axis([1.3,11.7,1.3,10.4]);
			set(gca,'xtick',[1.3:1.3:11.7]);
			set(gca,'ytick',[1.3:1.3:10.4]);
		elseif CasetoRun==194
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==175 || CasetoRun==180
			if refinementfactor==2
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.5:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.5:max(LOC(:,2))]);
			elseif refinementfactor==4
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.25:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.25:max(LOC(:,2))]);
			else
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:max(LOC(:,1)):max(LOC(:,1))]);
				set(gca,'ytick',[0:max(LOC(:,2)):max(LOC(:,2))]);
			end
			set(gca,'Yticklabel',[]);
			set(gca,'Xticklabel',[]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_directions_crackmultiline(NN,le_base,x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun,refinementfactor)
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	 
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		if isnan(e_pl_max(sp))
			e_pl_max(sp)=0;
			e_pl_min(sp)=0;
			e_pl_shear(sp)=0;
		end
	end
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			sz=5*64/refinementfactor;
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			sz=10*64/refinementfactor/9;
		else
			sz = 40;
		end
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		if CasetoRun==118 || CasetoRun==173
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==152 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			for sp=1:spCount
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		else
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				% xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		end
		if length(x_crack)==0
		else
			for icrackpath=1:length(x_crack)
				plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'Color','red','LineWidth',1);
				plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','black','LineWidth',1);
				plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'Color','blue','LineWidth',1);
			end
		end
		grid on
		if CasetoRun==192
			axis([1.8,4.2,1.8,4.2]*le_base);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==118 || CasetoRun==173
			axis([1.8,4.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:4.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			axis([1.8,6.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227
			axis([1.6,12.4,1.6,4.4]*10);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209
			axis([1.6,12.4,1.6,4.4]*10);
			set(gca,'xtick',[1.6:0.2:12.4]*10);
			set(gca,'ytick',[1.6:0.2:4.4]*10);
		elseif CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220
			axis(le_base*[1.5,5.5,1.5,5.5]);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==229
			axis(le_base*[1.5,3.5,1.5,8.5]);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==230
			axis([0,le(1)*(NN(1)-1),0,le(2)*(NN(2)-1)]);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==205 || CasetoRun==210 || CasetoRun==207	
			axis([2.6,9.4,3.6,10.4]*le_base);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==202
			axis([1.6,6.4,1.6,4.4]*10);
			set(gca,'xtick',[1.6:0.2:6.4]*10);
			set(gca,'ytick',[1.6:0.2:4.4]*10);
		elseif CasetoRun==211
			axis([1.6,5.4,1.6,5.4]*200);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==201
			axis([1.6,5.4,1.6,5.4]*200);
			set(gca,'xtick',[1.6:0.2:5.4]*200);
			set(gca,'ytick',[1.6:0.2:5.4]*200);
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			axis(le_base*[1.5,5.5,1.5,5.5]);
			%set(gca,'xtick',le_base*[1.5:0.25:5.5]);
			%set(gca,'ytick',le_base*[1.5:0.25:5.5]);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169
			axis([1.6,5.4,1.6,5.4]);
			set(gca,'xtick',[1.6:0.2:5.4]);
			set(gca,'ytick',[1.6:0.2:5.4]);
		elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165
			axis([1.6,6.4,1.6,4.4]);
			set(gca,'xtick',[1.6:0.2:6.4]);
			set(gca,'ytick',[1.6:0.2:4.4]);
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==130 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			axis([1.8,6.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
			axis([1.8,13.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:13.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153
			axis([0,14,0,14]);
			set(gca,'xtick',[0:1:14]);
			set(gca,'ytick',[0:1:14]);		
		elseif CasetoRun==154 || CasetoRun==161
			axis([2.5,5.5,2.5,5.5]);
			set(gca,'xtick',[2.5:0.25:5.5]);
			set(gca,'ytick',[2.5:0.25:5.5]);				
		elseif CasetoRun==138
			axis([1.8,4.2,1.8,4.2]*4.5);
			set(gca,'xtick',[1.8:0.2:4.2]*4.5);
			set(gca,'ytick',[1.8:0.2:4.2]*4.5);
		elseif CasetoRun==134 || CasetoRun==136
			axis([1.8,7.7,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:7.7]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==124
			axis([1.3,11.7,1.3,10.4]);
			set(gca,'xtick',[1.3:1.3:11.7]);
			set(gca,'ytick',[1.3:1.3:10.4]);
		elseif CasetoRun==194
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==175 || CasetoRun==180
			if refinementfactor==2
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.5:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.5:max(LOC(:,2))]);
			elseif refinementfactor==4
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.25:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.25:max(LOC(:,2))]);
			else
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:max(LOC(:,1)):max(LOC(:,1))]);
				set(gca,'ytick',[0:max(LOC(:,2)):max(LOC(:,2))]);
			end
			set(gca,'Yticklabel',[]);
			set(gca,'Xticklabel',[]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Cohesive(le_base,x_crack_abs_force,x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun,refinementfactor)
	%BASED ON Plot_Final2_principalclimit_directions_crackmultiline
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		if isnan(e_pl_max(sp))
			e_pl_max(sp)=0;
			e_pl_min(sp)=0;
			e_pl_shear(sp)=0;
		end
	end
	szbridge=0;
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==192
			sz=5*64/refinementfactor;
			szbridge=sqrt(sz);
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			sz=5*64/refinementfactor;
			szbridge=sqrt(sz);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			sz=10*64/refinementfactor/9;
		else
			sz = 40;
		end
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		if CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==192 || CasetoRun==194
		else
			scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
			daspect([1 1 1]);
			hold on
		end
		
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		if CasetoRun==118 || CasetoRun==173
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if sp==1
					hold on;
					daspect([1 1 1]);
				end
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==152 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			for sp=1:spCount
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		else
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				% xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		end
		
		force.min=zeros(1,1);
		force.max=zeros(1,1);
		
		force.min=inf;
		force.max=-inf;
		
		if CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==194
			if length(x_crack)==0
			else
				for icrackpath=1:length(x_crack)
					for iparticle=1:size(x_crack{icrackpath},1)
						if x_crack_abs_force(iparticle,icrackpath)<force.min
							force.min=x_crack_abs_force(iparticle,icrackpath);
						elseif x_crack_abs_force(iparticle,icrackpath)>force.max
							force.max=x_crack_abs_force(iparticle,icrackpath);
						end
					end
				end
			end
			if exist('climits')
				if length(climits)>0
					if climits(2)>climits(1)
						climits(1)=min(climits(1),force.min);
						climits(2)=max(climits(2),force.max);
					end
				end
			end
			if exist('climits')==0 || length(climits)==0
				climits(1)=force.min;
				climits(2)=force.max;
			end
			if length(x_crack)==0
			else
				for icrackpath=1:length(x_crack)
					%plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'Color','red','LineWidth',0.5);
					plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','black','LineWidth',2);
					%plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'Color','blue','LineWidth',0.5);
					for iparticle=1:size(x_crack{icrackpath},1)
																																  
																																  
						if x_crack_abs_force(iparticle,icrackpath)>0
							plotcolor=jet2rgb(256,climits(1),climits(2),x_crack_abs_force(iparticle,icrackpath));
							x_plot=[x_cracktop{icrackpath}(iparticle,1) x_crackbot{icrackpath}(iparticle,1)];
							y_plot=[x_cracktop{icrackpath}(iparticle,2) x_crackbot{icrackpath}(iparticle,2)];
							plot(x_plot,y_plot,'Color',plotcolor,'LineWidth',1);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge+0.2,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge+0.4,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge+0.6,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge+0.8,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge-0.2,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge-0.4,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge-0.6,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge-0.8,'MarkerEdgeColor',plotcolor);
							%'MarkerFaceColor',plotcolor
						end
					end
				end
			end
		end
		grid on
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==192
			axis([1.8,4.2,1.8,4.2]*le_base);
			set(gca,'xtick',[1.8:0.2:4.2]*le_base);
			set(gca,'ytick',[1.8:0.2:4.2]*le_base);
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			axis([1.8,6.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
			axis([1.6,5.4,1.6,5.4]*200);
			set(gca,'xtick',[1.6:0.2:5.4]*200);
			set(gca,'ytick',[1.6:0.2:5.4]*200);
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			axis(le_base*[1.5,5.5,1.5,5.5]);
			%set(gca,'xtick',[1.5:0.25:5.5]);
			%set(gca,'ytick',[1.5:0.25:5.5]);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169
			axis([1.6,5.4,1.6,5.4]);
			set(gca,'xtick',[1.6:0.2:5.4]);
			set(gca,'ytick',[1.6:0.2:5.4]);
		elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165
			axis([1.6,6.4,1.6,4.4]);
			set(gca,'xtick',[1.6:0.2:6.4]);
			set(gca,'ytick',[1.6:0.2:4.4]);
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==130 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			axis([1.8,6.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
			axis([1.8,13.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:13.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153
			axis([0,14,0,14]);
			set(gca,'xtick',[0:1:14]);
			set(gca,'ytick',[0:1:14]);		
		elseif CasetoRun==154 || CasetoRun==161
			axis([2.5,5.5,2.5,5.5]);
			set(gca,'xtick',[2.5:0.25:5.5]);
			set(gca,'ytick',[2.5:0.25:5.5]);				
		elseif CasetoRun==138
			axis([1.8,4.2,1.8,4.2]*4.5);
			set(gca,'xtick',[1.8:0.2:4.2]*4.5);
			set(gca,'ytick',[1.8:0.2:4.2]*4.5);
		elseif CasetoRun==134 || CasetoRun==136
			axis([1.8,7.7,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:7.7]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==124
			axis([1.3,11.7,1.3,10.4]);
			set(gca,'xtick',[1.3:1.3:11.7]);
			set(gca,'ytick',[1.3:1.3:10.4]);
		elseif CasetoRun==194
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==175 || CasetoRun==180
			if refinementfactor==2
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.5:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.5:max(LOC(:,2))]);
			elseif refinementfactor==4
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.25:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.25:max(LOC(:,2))]);
			else
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:max(LOC(:,1)):max(LOC(:,1))]);
				set(gca,'ytick',[0:max(LOC(:,2)):max(LOC(:,2))]);
			end
			set(gca,'Yticklabel',[]);
			set(gca,'Xticklabel',[]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end


%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_CrackForce(tiprename,tt,x_crack_terminatedprop,x_crack_acctipcrackratio,x_crack_nparticles,le_base,x_crack_abs_force,x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun,refinementfactor)
	%BASED ON Plot_Final2_principalclimit_directions_crackmultiline
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end
	
	acctipratio.data=x_crack_acctipcrackratio;
	[acctipratio.rankmat acctipratio.rankindex]=rank2d(x_crack_acctipcrackratio(1:length(x_crack),:),x_crack_terminatedprop);
	acctipratio.maxtip=zeros(1,1);
	acctipratio.maxpath=zeros(1,1);
	acctipratio.maxtipnum=zeros(1,1);
	acctipratio.relratio=acctipratio.data/acctipratio.data(acctipratio.rankindex(1,1),acctipratio.rankindex(1,2));

	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		if isnan(e_pl_max(sp))
			e_pl_max(sp)=0;
			e_pl_min(sp)=0;
			e_pl_shear(sp)=0;
		end
	end
	szbridge=0;
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==192
			sz=5*64/refinementfactor;
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			sz=5*64/refinementfactor;
			szbridge=sqrt(sz);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			sz=10*64/refinementfactor/9;
		else
			sz = 40;
		end
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		if CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
		else
			%scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
			daspect([1 1 1]);
			hold on
		end
		
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		if CasetoRun==118 || CasetoRun==173
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if sp==1
					hold on;
					daspect([1 1 1]);
				end
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==152 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			for sp=1:spCount
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		else
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				% xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		end
		
		force.min=zeros(1,1);
		force.max=zeros(1,1);
		
		force.min=inf;
		force.max=-inf;
		
		if CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
			if length(x_crack)==0
			else
				for icrackpath=1:length(x_crack)
					for iparticle=1:size(x_crack{icrackpath},1)
						if x_crack_abs_force(iparticle,icrackpath)<force.min
							force.min=x_crack_abs_force(iparticle,icrackpath);
						elseif x_crack_abs_force(iparticle,icrackpath)>force.max
							force.max=x_crack_abs_force(iparticle,icrackpath);
						end
					end
				end
			end
			if exist('climits')
				if length(climits)>0
					if climits(2)>climits(1)
						climits(1)=min(climits(1),force.min);
						climits(2)=max(climits(2),force.max);
					end
	            end
	        end
			if exist('climits')==0 || length(climits)==0
				climits(1)=force.min;
				climits(2)=force.max;
			end
			
			if length(x_crack)==0
			else
				for icrackpath=1:length(x_crack)
					%plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'Color','red','LineWidth',0.5);
					plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','blue','LineWidth',2);
					
					itip=1;
					if x_crack_terminatedprop(icrackpath,itip)==1
					else
						texttoprint=[num2str(tiprename(2*(icrackpath-1)+itip)) '; ' num2str(acctipratio.data(icrackpath,itip)) '; #' num2str(acctipratio.rankmat(icrackpath,itip))  char(13) char(10) '\downarrow'];
						text(x_crack{icrackpath}(x_crack_nparticles(icrackpath),1),x_crack{icrackpath}(x_crack_nparticles(icrackpath),2),texttoprint,'HorizontalAlignment','center','VerticalAlignment','Bottom','FontName','Times New Roman','FontSize',30);
					end
					
					itip=2;
					if x_crack_terminatedprop(icrackpath,itip)==1
					else
						texttoprint=[num2str(tiprename(2*(icrackpath-1)+itip)) '; ' num2str(acctipratio.data(icrackpath,itip)) '; #' num2str(acctipratio.rankmat(icrackpath,itip))  char(13) char(10) '\downarrow'];
						text(x_crack{icrackpath}(1,1),x_crack{icrackpath}(1,2),texttoprint,'HorizontalAlignment','center','VerticalAlignment','Bottom','FontName','Times New Roman','FontSize',30);
					end
					
					%plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'Color','blue','LineWidth',0.5);
				end
				acctipratio.maxpath=acctipratio.rankindex(1,1);
				acctipratio.maxtip=acctipratio.rankindex(1,2);
				acctipratio.maxtipnum=tiprename(2*(acctipratio.maxpath-1)+acctipratio.maxtip);
				text(le_base*5.5,le_base*5.5,['tip w/ max. force: ' num2str(acctipratio.maxtipnum)],'HorizontalAlignment','right','VerticalAlignment','Top','FontName','Times New Roman','FontSize',45);
				text(le_base*1.5,le_base*1.5,['numbers above the crack tips:' char(13) char(10) 'tip number; relative crack force (crack force / material strength); relative crack force order'],'HorizontalAlignment','left','VerticalAlignment','Bottom','FontName','Times New Roman','FontSize',20);
				text(le_base*1.5,le_base*5.5,['timestep: ' num2str(tt)],'HorizontalAlignment','left','VerticalAlignment','Top','FontName','Times New Roman','FontSize',45);
			end
		end
		grid on;
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==192
			axis([1.8,4.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:4.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			axis([1.8,6.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
			axis([1.6,5.4,1.6,5.4]*200);
			set(gca,'xtick',[1.6:0.2:5.4]*200);
			set(gca,'ytick',[1.6:0.2:5.4]*200);
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			axis(le_base*[1.5,5.5,1.5,5.5]);
			%set(gca,'xtick',[1.5:0.25:5.5]);
			%set(gca,'ytick',[1.5:0.25:5.5]);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169
			axis([1.6,5.4,1.6,5.4]);
			set(gca,'xtick',[1.6:0.2:5.4]);
			set(gca,'ytick',[1.6:0.2:5.4]);
		elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165
			axis([1.6,6.4,1.6,4.4]);
			set(gca,'xtick',[1.6:0.2:6.4]);
			set(gca,'ytick',[1.6:0.2:4.4]);
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==130 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			axis([1.8,6.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
			axis([1.8,13.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:13.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153
			axis([0,14,0,14]);
			set(gca,'xtick',[0:1:14]);
			set(gca,'ytick',[0:1:14]);		
		elseif CasetoRun==154 || CasetoRun==161
			axis([2.5,5.5,2.5,5.5]);
			set(gca,'xtick',[2.5:0.25:5.5]);
			set(gca,'ytick',[2.5:0.25:5.5]);				
		elseif CasetoRun==138
			axis([1.8,4.2,1.8,4.2]*4.5);
			set(gca,'xtick',[1.8:0.2:4.2]*4.5);
			set(gca,'ytick',[1.8:0.2:4.2]*4.5);
		elseif CasetoRun==134 || CasetoRun==136
			axis([1.8,7.7,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:7.7]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==124
			axis([1.3,11.7,1.3,10.4]);
			set(gca,'xtick',[1.3:1.3:11.7]);
			set(gca,'ytick',[1.3:1.3:10.4]);
		elseif CasetoRun==175 || CasetoRun==194 || CasetoRun==180
			if refinementfactor==2
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.5:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.5:max(LOC(:,2))]);
			elseif refinementfactor==4
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.25:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.25:max(LOC(:,2))]);
			else
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:max(LOC(:,1)):max(LOC(:,1))]);
				set(gca,'ytick',[0:max(LOC(:,2)):max(LOC(:,2))]);
			end
			set(gca,'Yticklabel',[]);
			set(gca,'Xticklabel',[]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Sequence(x_crack_sequence_merge,x_crack_sequence_tipreg,x_crack_nparticles,le_base,x_crack_abs_force,x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun,refinementfactor)
	%BASED ON Plot_Final2_principalclimit_directions_crackmultiline
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		if isnan(e_pl_max(sp))
			e_pl_max(sp)=0;
			e_pl_min(sp)=0;
			e_pl_shear(sp)=0;
		end
	end
	szbridge=0;
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==192
			sz=5*64/refinementfactor;
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			sz=5*64/refinementfactor;
			szbridge=sqrt(sz);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			sz=10*64/refinementfactor/9;
		else
			sz = 40;
		end
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		if CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
		else
			%scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
			daspect([1 1 1]);
			hold on
		end
		
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		if CasetoRun==118 || CasetoRun==173
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if sp==1
					hold on;
					daspect([1 1 1]);
				end
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==152 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			for sp=1:spCount
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		else
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				% xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		end
		
		force.min=zeros(1,1);
		force.max=zeros(1,1);
		
		force.min=inf;
		force.max=-inf;
		
		if CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
			if length(x_crack)==0
			else
				for icrackpath=1:length(x_crack)
					for iparticle=1:size(x_crack{icrackpath},1)
						if x_crack_abs_force(iparticle,icrackpath)<force.min
							force.min=x_crack_abs_force(iparticle,icrackpath);
						elseif x_crack_abs_force(iparticle,icrackpath)>force.max
							force.max=x_crack_abs_force(iparticle,icrackpath);
						end
					end
				end
			end
			if exist('climits')
				if length(climits)>0
					if climits(2)>climits(1)
						climits(1)=min(climits(1),force.min);
						climits(2)=max(climits(2),force.max);
					end
	            end
	        end
			if exist('climits')==0 || length(climits)==0
				climits(1)=force.min;
				climits(2)=force.max;
			end
			
			if length(x_crack)==0
			else
				for icrackpath=1:length(x_crack)
					%plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'Color','red','LineWidth',0.5);
					plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','blue','LineWidth',2);
					if x_crack_sequence_merge(icrackpath,1)>0
						text(x_crack{icrackpath}(x_crack_nparticles(icrackpath),1),x_crack{icrackpath}(x_crack_nparticles(icrackpath),2),[num2str(2*(icrackpath-1)+1) '->' num2str(2*(x_crack_sequence_merge(icrackpath,1)-1)+1) '-' num2str(2*(x_crack_sequence_merge(icrackpath,1)-1)+2) char(13) char(10) '\downarrow'],'HorizontalAlignment','center','VerticalAlignment','Bottom','FontName','Times New Roman','FontSize',15);
					elseif x_crack_sequence_tipreg(icrackpath,1)==1
						text(x_crack{icrackpath}(x_crack_nparticles(icrackpath),1),x_crack{icrackpath}(x_crack_nparticles(icrackpath),2),['<-' num2str(2*(icrackpath-1)+1) '->' char(13) char(10) '\downarrow'],'HorizontalAlignment','center','VerticalAlignment','Bottom','FontName','Times New Roman','FontSize',15);
					else
						text(x_crack{icrackpath}(x_crack_nparticles(icrackpath),1),x_crack{icrackpath}(x_crack_nparticles(icrackpath),2),[num2str(2*(icrackpath-1)+1) char(13) char(10) '\downarrow'],'HorizontalAlignment','center','VerticalAlignment','Bottom','FontName','Times New Roman','FontSize',15);
					end
					if x_crack_sequence_merge(icrackpath,2)>0
						text(x_crack{icrackpath}(1,1),x_crack{icrackpath}(1,2),[num2str(2*(icrackpath-1)+2) '->' num2str(2*(x_crack_sequence_merge(icrackpath,2)-1)+1) '-' num2str(2*(x_crack_sequence_merge(icrackpath,2)-1)+2) char(13) char(10) '\downarrow'],'HorizontalAlignment','center','VerticalAlignment','Bottom','FontName','Times New Roman','FontSize',15);
					elseif x_crack_sequence_tipreg(icrackpath,2)==1
						text(x_crack{icrackpath}(1,1),x_crack{icrackpath}(1,2),['<-' num2str(2*(icrackpath-1)+2) '->' char(13) char(10) '\downarrow'],'HorizontalAlignment','center','VerticalAlignment','Bottom','FontName','Times New Roman','FontSize',15);
					else
						text(x_crack{icrackpath}(1,1),x_crack{icrackpath}(1,2),[num2str(2*(icrackpath-1)+2) char(13) char(10) '\downarrow'],'HorizontalAlignment','center','VerticalAlignment','Bottom','FontName','Times New Roman','FontSize',15);
					end

					%plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'Color','blue','LineWidth',0.5);
				end
			end
		end
		grid on
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==192
			axis([1.8,4.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:4.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			axis([1.8,6.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
			axis([1.6,5.4,1.6,5.4]*200);
			set(gca,'xtick',[1.6:0.2:5.4]*200);
			set(gca,'ytick',[1.6:0.2:5.4]*200);
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			axis(le_base*[1.5,5.5,1.5,5.5]);
			%set(gca,'xtick',[1.5:0.25:5.5]);
			%set(gca,'ytick',[1.5:0.25:5.5]);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169
			axis([1.6,5.4,1.6,5.4]);
			set(gca,'xtick',[1.6:0.2:5.4]);
			set(gca,'ytick',[1.6:0.2:5.4]);
		elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165
			axis([1.6,6.4,1.6,4.4]);
			set(gca,'xtick',[1.6:0.2:6.4]);
			set(gca,'ytick',[1.6:0.2:4.4]);
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==130 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			axis([1.8,6.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
			axis([1.8,13.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:13.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153
			axis([0,14,0,14]);
			set(gca,'xtick',[0:1:14]);
			set(gca,'ytick',[0:1:14]);		
		elseif CasetoRun==154 || CasetoRun==161
			axis([2.5,5.5,2.5,5.5]);
			set(gca,'xtick',[2.5:0.25:5.5]);
			set(gca,'ytick',[2.5:0.25:5.5]);				
		elseif CasetoRun==138
			axis([1.8,4.2,1.8,4.2]*4.5);
			set(gca,'xtick',[1.8:0.2:4.2]*4.5);
			set(gca,'ytick',[1.8:0.2:4.2]*4.5);
		elseif CasetoRun==134 || CasetoRun==136
			axis([1.8,7.7,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:7.7]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==124
			axis([1.3,11.7,1.3,10.4]);
			set(gca,'xtick',[1.3:1.3:11.7]);
			set(gca,'ytick',[1.3:1.3:10.4]);
		elseif CasetoRun==175 || CasetoRun==194 || CasetoRun==180
			if refinementfactor==2
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.5:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.5:max(LOC(:,2))]);
			elseif refinementfactor==4
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.25:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.25:max(LOC(:,2))]);
			else
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:max(LOC(:,1)):max(LOC(:,1))]);
				set(gca,'ytick',[0:max(LOC(:,2)):max(LOC(:,2))]);
			end
			set(gca,'Yticklabel',[]);
			set(gca,'Xticklabel',[]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end


%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_directions_crackmultiline_small(le_base,x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun,refinementfactor)
	%based on Plot_Final2_principalclimit_directions_crackmultiline
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	 
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		if isnan(e_pl_max(sp))
			e_pl_max(sp)=0;
			e_pl_min(sp)=0;
			e_pl_shear(sp)=0;
		end
	end
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			sz=5*64/refinementfactor;
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			sz=10*64/refinementfactor/9;
		else
			sz = 40;
		end
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			set(StressProfile1,'Position',[0 0 1000 800]);
		end
		if CasetoRun==118 || CasetoRun==173
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==152 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			for sp=1:spCount
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		else
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				% xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		end
		if length(x_crack)==0
		else
			for icrackpath=1:length(x_crack)
				plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'Color','red','LineWidth',1);
				plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','black','LineWidth',1);
				plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'Color','blue','LineWidth',1);
			end
		end
		grid on
		if CasetoRun==192
			axis([1.8,4.2,1.8,4.2]*le_base);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==118 || CasetoRun==173
			axis([1.8,4.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:4.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			axis([1.8,6.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
			axis([1.6,5.4,1.6,5.4]*200);
			set(gca,'xtick',[1.6:0.2:5.4]*200);
			set(gca,'ytick',[1.6:0.2:5.4]*200);
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			axis(le_base*[1.5,5.5,1.5,5.5]);
			%set(gca,'xtick',le_base*[1.5:0.25:5.5]);
			%set(gca,'ytick',le_base*[1.5:0.25:5.5]);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
			set(gca,'XColor','white')
			set(gca,'YColor','white')
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169
			axis([1.6,5.4,1.6,5.4]);
			set(gca,'xtick',[1.6:0.2:5.4]);
			set(gca,'ytick',[1.6:0.2:5.4]);
		elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165
			axis([1.6,6.4,1.6,4.4]);
			set(gca,'xtick',[1.6:0.2:6.4]);
			set(gca,'ytick',[1.6:0.2:4.4]);
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==130 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			axis([1.8,6.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
			axis([1.8,13.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:13.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153
			axis([0,14,0,14]);
			set(gca,'xtick',[0:1:14]);
			set(gca,'ytick',[0:1:14]);		
		elseif CasetoRun==154 || CasetoRun==161
			axis([2.5,5.5,2.5,5.5]);
			set(gca,'xtick',[2.5:0.25:5.5]);
			set(gca,'ytick',[2.5:0.25:5.5]);				
		elseif CasetoRun==138
			axis([1.8,4.2,1.8,4.2]*4.5);
			set(gca,'xtick',[1.8:0.2:4.2]*4.5);
			set(gca,'ytick',[1.8:0.2:4.2]*4.5);
		elseif CasetoRun==134 || CasetoRun==136
			axis([1.8,7.7,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:7.7]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==124
			axis([1.3,11.7,1.3,10.4]);
			set(gca,'xtick',[1.3:1.3:11.7]);
			set(gca,'ytick',[1.3:1.3:10.4]);
		elseif CasetoRun==194
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[]);
			set(gca,'ytick',[]);
		elseif CasetoRun==175 || CasetoRun==180
			if refinementfactor==2
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.5:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.5:max(LOC(:,2))]);
			elseif refinementfactor==4
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.25:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.25:max(LOC(:,2))]);
			else
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:max(LOC(:,1)):max(LOC(:,1))]);
				set(gca,'ytick',[0:max(LOC(:,2)):max(LOC(:,2))]);
			end
			set(gca,'Yticklabel',[]);
			set(gca,'Xticklabel',[]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		h=colorbar;
		ylabel(h,'Max. Principal Stress (MPa)');
		colormap(jet(256));
	    adjustpos.old=h.Position;
	    adjustpos.new=adjustpos.old;
	    adjustpos.height=adjustpos.old(4);
	    adjustpos.new(4)=adjustpos.old(4)-adjustpos.height/10;
	    adjustpos.new(2)=adjustpos.old(2)+adjustpos.height/20;
	    adjustpos.new(1)=1-4*adjustpos.old(3);
	    h.Position=adjustpos.new;
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end


%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1]=Plot_Cohesive_dispi(x_crack_abs_force,x_crack_bridge_absdeltaxmaxi,x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun,refinementfactor)
	%BASED ON Plot_Final2_principalclimit_directions_crackmultiline
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		if isnan(e_pl_max(sp))
			e_pl_max(sp)=0;
			e_pl_min(sp)=0;
			e_pl_shear(sp)=0;
		end
	end
	szbridge=0;
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==192
			sz=5*64/refinementfactor;
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			sz=5*64/refinementfactor;
			szbridge=sqrt(sz);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			sz=10*64/refinementfactor/9;
		else
			sz = 40;
		end
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		if CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
		else
			scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
			daspect([1 1 1]);
			hold on
		end
		
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		if CasetoRun==118 || CasetoRun==173
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if sp==1
					hold on;
					daspect([1 1 1]);
				end
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==152 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			for sp=1:spCount
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		else
			for sp=1:spCount
				x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
				y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(sp)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(sp);
				elseif maxminshear==2
					thetaplot=thetamin(sp);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				% xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		end
		
		force.min=zeros(1,1);
		force.max=zeros(1,1);
		
		force.min=inf;
		force.max=-inf;
		
		if CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189
			if length(x_crack)==0
			else
				for icrackpath=1:length(x_crack)
					for iparticle=1:size(x_crack{icrackpath},1)
						if x_crack_bridge_absdeltaxmaxi(iparticle,icrackpath)<force.min
							force.min=x_crack_bridge_absdeltaxmaxi(iparticle,icrackpath);
						elseif x_crack_bridge_absdeltaxmaxi(iparticle,icrackpath)>force.max
							force.max=x_crack_bridge_absdeltaxmaxi(iparticle,icrackpath);
						end
					end
				end
			end
			if exist('climits')
				if length(climits)>0
					if climits(2)>climits(1)
						climits(1)=min(climits(1),force.min);
						climits(2)=max(climits(2),force.max);
					end
	            end
	        end
			if exist('climits')==0 || length(climits)==0
				climits(1)=force.min;
				climits(2)=force.max;
			end
			if length(x_crack)==0
			else
				for icrackpath=1:length(x_crack)
					%plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'Color','red','LineWidth',0.5);
					plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','black','LineWidth',2);
					%plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'Color','blue','LineWidth',0.5);
					for iparticle=1:size(x_crack{icrackpath},1)
																																  
																																  
						if x_crack_bridge_absdeltaxmaxi(iparticle,icrackpath)>0 || x_crack_abs_force(iparticle,icrackpath)>0
							plotcolor=jet2rgb(256,climits(1),climits(2),x_crack_bridge_absdeltaxmaxi(iparticle,icrackpath));
							x_plot=[x_cracktop{icrackpath}(iparticle,1) x_crackbot{icrackpath}(iparticle,1)];
							y_plot=[x_cracktop{icrackpath}(iparticle,2) x_crackbot{icrackpath}(iparticle,2)];
							plot(x_plot,y_plot,'Color',plotcolor,'LineWidth',1);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge+0.2,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge+0.4,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge+0.6,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge+0.8,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge-0.2,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge-0.4,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge-0.6,'MarkerEdgeColor',plotcolor);
							plot(sum(x_plot)/2,sum(y_plot)/2,'o','MarkerSize',szbridge-0.8,'MarkerEdgeColor',plotcolor);
							%'MarkerFaceColor',plotcolor
						end
					end
				end
			end
		end
		grid on
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==192
			axis([1.8,4.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:4.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			axis([1.8,6.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201
			axis([1.6,5.4,1.6,5.4]*200);
			set(gca,'xtick',[1.6:0.2:5.4]*200);
			set(gca,'ytick',[1.6:0.2:5.4]*200);
		elseif CasetoRun==229
			axis(le_base*[1.5,3.5,1.5,8.5]);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==230
			axis(le_base*[0,NN(1)-1,0,NN(2)-1]);
			set(gca,'xtick',[0:le(1):(NN(1)-1)*le(1)]);
			set(gca,'ytick',[0:le(2):(NN(2)-1)*le(2)]);
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			axis([1.5,5.5,1.5,5.5]);
			set(gca,'xtick',[1.5:0.25:5.5]);
			set(gca,'ytick',[1.5:0.25:5.5]);
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==178 || CasetoRun==169
			axis([1.6,5.4,1.6,5.4]);
			set(gca,'xtick',[1.6:0.2:5.4]);
			set(gca,'ytick',[1.6:0.2:5.4]);
		elseif CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165
			axis([1.6,6.4,1.6,4.4]);
			set(gca,'xtick',[1.6:0.2:6.4]);
			set(gca,'ytick',[1.6:0.2:4.4]);
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==130 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			axis([1.8,6.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
			axis([1.8,13.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:13.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153
			axis([0,14,0,14]);
			set(gca,'xtick',[0:1:14]);
			set(gca,'ytick',[0:1:14]);		
		elseif CasetoRun==154 || CasetoRun==161
			axis([2.5,5.5,2.5,5.5]);
			set(gca,'xtick',[2.5:0.25:5.5]);
			set(gca,'ytick',[2.5:0.25:5.5]);				
		elseif CasetoRun==138
			axis([1.8,4.2,1.8,4.2]*4.5);
			set(gca,'xtick',[1.8:0.2:4.2]*4.5);
			set(gca,'ytick',[1.8:0.2:4.2]*4.5);
		elseif CasetoRun==134 || CasetoRun==136
			axis([1.8,7.7,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:7.7]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==124
			axis([1.3,11.7,1.3,10.4]);
			set(gca,'xtick',[1.3:1.3:11.7]);
			set(gca,'ytick',[1.3:1.3:10.4]);
		elseif CasetoRun==175 || CasetoRun==194 || CasetoRun==180
			if refinementfactor==2
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.5:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.5:max(LOC(:,2))]);
			elseif refinementfactor==4
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:0.25:max(LOC(:,1))]);
				set(gca,'ytick',[0:0.25:max(LOC(:,2))]);
			else
				axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
				set(gca,'xtick',[0:max(LOC(:,1)):max(LOC(:,1))]);
				set(gca,'ytick',[0:max(LOC(:,2)):max(LOC(:,2))]);
			end
			set(gca,'Yticklabel',[]);
			set(gca,'Xticklabel',[]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function thergb=jet2rgb(colordepth,value_min,value_max,value_cur);
	%value_cur is a vector
	rgblist=jet(colordepth);
	value_cur_relative=zeros(1,length(value_cur));
	thergb=zeros(length(value_cur),3);
	for idata=1:length(value_cur)
		if value_cur(idata)<value_min
			value_cur_relative(idata)=0;
		elseif value_cur(idata)>value_max
			value_cur_relative(idata)=1;
		else
			value_cur_relative(idata)=(value_cur(idata)-value_min)/(value_max-value_min);
		end
		for idepth=1:colordepth
			if value_cur_relative(idata)<=idepth/colordepth
				thergb(idata,:)=rgblist(idepth,:);
				break;
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,vgtensor_ni_x,vgtensor_ni_y,vgtensor_ni_xy]=Plot_Final2_xyz_node(x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,niCount,r1_sp,r2_sp,E_acc,vgtensor_ni,climits,xyshear,ActuallyPlot,CasetoRun,refinementfactor)
	%{
	x_corner1	          = zeros(niCount,2);
	x_corner2	          = zeros(niCount,2);
	x_corner3	          = zeros(niCount,2);
	x_corner4	          = zeros(niCount,2);
	%}
	%displacement = zeros(niCount,1);
	%velocity = zeros(niCount,1);
	%strain = zeros(niCount,1);
	%{
	for sp=1:niCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	%}
	%{
	for sp=1:niCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end
	%}
	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,niCount);
	thetamin=zeros(1,niCount);
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==130 || CasetoRun==124
			sz=10*512/refinementfactor^2;
		elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			sz=10*128/refinementfactor^2;
		else
			sz=40;
		end
		vgtensor_ni_x=vgtensor_ni(:,1);
		vgtensor_ni_y=vgtensor_ni(:,2);
		vgtensor_ni_xy=vgtensor_ni(:,3);
		%color = velocity;
		if xyshear==1
			color = vgtensor_ni(:,1);
		elseif xyshear==2
			color = vgtensor_ni(:,2);
		elseif xyshear==3
			color = vgtensor_ni(:,3);
		else
			disp('wrong xyshear input!');
			pause
		end
		scatter(LOC(:,1),LOC(:,2),sz,color,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end

		if length(x_crack)==0
		else
			for icrackpath=1:length(x_crack)
				%plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'o','Color','red');
				plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','black','LineWidth',2);
				%plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'o','Color','blue');
			end
		end
		grid on
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==192
			axis([1.8,4.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:4.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169
			axis([1.8,5.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:5.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			axis([1.8,6.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==130
			axis([1.8,6.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==138
			axis([1.8,4.2,1.8,4.2]*4.5);
			set(gca,'xtick',[1.8:0.2:4.2]*4.5);
			set(gca,'ytick',[1.8:0.2:4.2]*4.5);
		elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			axis([1.8,10.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:10.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145
			axis([1.8,13.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:13.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==134 || CasetoRun==136
			axis([1.8,7.7,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:7.7]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==124
			axis([1.3,11.7,1.3,10.4]);
			set(gca,'xtick',[1.3:1.3:11.7]);
			set(gca,'ytick',[1.3:1.3:10.4]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,vgvector_sp_x,vgvector_sp_y,vgtensor_ni_xy]=Plot_Final2_xyz_particle(x_crack,x_cracktop,x_crackbot,x_sp,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,vgvector_sp,climits,x_or_y,ActuallyPlot,CasetoRun,refinementfactor)
	%{
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	%}
	%displacement = zeros(spCount,1);
	%velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	%{
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	%}
	%{
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end
	%}
	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==130 || CasetoRun==124 || CasetoRun==192
			sz=10*512/refinementfactor^2;
		elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==146 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			sz=10*128/refinementfactor^2/25;
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			sz=5*64/refinementfactor;
		else
			sz=40;
		end
		vgvector_sp_x=vgvector_sp(:,1);
		vgvector_sp_y=vgvector_sp(:,2);
		%color = velocity;
		if x_or_y==1
			color = vgvector_sp(:,1);
		elseif x_or_y==2
			color = vgvector_sp(:,2);
		elseif x_or_y==3
			color = vgvector_sp(:,3);
		else
			disp('wrong x_or_y input!');
			pause
		end
		scatter(x_sp(:,1),x_sp(:,2),sz,color,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==146 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124 || CasetoRun==192
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		
		if length(x_crack)==0
		else
			for icrackpath=1:length(x_crack)
				plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'o','Color','red');
				plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','black','LineWidth',2);
				plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'o','Color','blue');
			end
		end
		grid on
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==192
			axis([1.8,4.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:4.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==123 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			axis([1.8,6.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==130
			axis([1.8,6.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==138
			axis([1.8,4.2,1.8,4.2]*4.5);
			set(gca,'xtick',[1.8:0.2:4.2]*4.5);
			set(gca,'ytick',[1.8:0.2:4.2]*4.5);
		elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			axis([1.8,10.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:10.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==144 || CasetoRun==146 || CasetoRun==145
			axis([1.8,13.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.4:13.2]);
			set(gca,'ytick',[1.8:0.4:5.2]);
		elseif CasetoRun==134 || CasetoRun==136
			axis([1.8,7.7,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:7.7]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==124
			axis([1.3,11.7,1.3,10.4]);
			set(gca,'xtick',[1.3:1.3:11.7]);
			set(gca,'ytick',[1.3:1.3:10.4]);
		elseif CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189
			axis([1.5,5.5,1.5,5.5]);
			set(gca,'xtick',[1.5:0.25:5.5]);
			set(gca,'ytick',[1.5:0.25:5.5]);
		else
			axis([0,max(x_sp(:,1)),0,max(x_sp(:,2))]);
			set(gca,'xtick',[0:20:max(x_sp(:,1))]);
			set(gca,'ytick',[0:20:max(x_sp(:,2))]);
		end
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,principal_max,principal_min,principal_shear]=Plot_Final2_principalclimit_directions_node(x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,niCount,r1_sp,r2_sp,E_acc,vgtensor_ni,climits,maxminshear,ActuallyPlot,CasetoRun,refinementfactor)
	%{
	x_corner1	          = zeros(niCount,2);
	x_corner2	          = zeros(niCount,2);
	x_corner3	          = zeros(niCount,2);
	x_corner4	          = zeros(niCount,2);
	%}
	%displacement = zeros(niCount,1);
	%velocity = zeros(niCount,1);
	%strain = zeros(niCount,1);
	%{
	for sp=1:niCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	%}
	%{
	for sp=1:niCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end
	%}
	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,niCount);
	thetamin=zeros(1,niCount);
	for io=1:niCount
		theta=1/2*atan(2*vgtensor_ni(io,3)/(vgtensor_ni(io,1)-vgtensor_ni(io,2)));
		principal_first=(vgtensor_ni(io,1)+vgtensor_ni(io,2))/2+(vgtensor_ni(io,1)-vgtensor_ni(io,2))/2*cos(2*theta)+vgtensor_ni(io,3)*sin(2*theta);
		principal_second=(vgtensor_ni(io,1)+vgtensor_ni(io,2))/2-(vgtensor_ni(io,1)-vgtensor_ni(io,2))/2*cos(2*theta)-vgtensor_ni(io,3)*sin(2*theta);
		if principal_first>principal_second
			thetamax(io)=theta;
			thetamin(io)=theta+pi/2;
		else
			thetamax(io)=theta+pi/2;
			thetamin(io)=theta;
		end
		principal_max(io)=max(principal_first,principal_second);
		principal_min(io)=min(principal_first,principal_second);
		principal_shear(io)=(principal_max(io)-principal_min(io))/2; %yes it's not the right name but easy to understand right?
	end
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==130 || CasetoRun==124 || CasetoRun==192
			sz=10*1024/refinementfactor^2;
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169
			sz=10*512/refinementfactor^2;		
		elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			sz=10*128/refinementfactor^2;
		else
			sz=40;
		end
		%color = velocity;
		if maxminshear==1
			color = principal_max;
		elseif maxminshear==2
			color = principal_min;
		elseif maxminshear==3
			color = principal_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		scatter(LOC(:,1),LOC(:,2),sz,color,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			for io=1:niCount
				if maxminshear==1
					thetaplot=thetamax(io);
				elseif maxminshear==2
					thetaplot=thetamin(io);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=LOC(io,1)-le(1)*sqrt(2)/2*cos(thetaplot);
				xend=LOC(io,1)+le(1)*sqrt(2)/2*cos(thetaplot);
				ystart=LOC(io,2)-le(1)*sqrt(2)/2*sin(thetaplot);
				yend=LOC(io,2)+le(1)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		else
			for io=1:niCount
				x_cor = [x_corner1(io,1) x_corner2(io,1) x_corner3(io,1) x_corner4(io,1) x_corner1(io,1)];
				y_cor = [x_corner1(io,2) x_corner2(io,2) x_corner3(io,2) x_corner4(io,2) x_corner1(io,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(io)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(io);
				elseif maxminshear==2
					thetaplot=thetamin(io);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(io,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(io,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(io,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(io,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		end
		if length(x_crack)==0
		else
			for icrackpath=1:length(x_crack)
				%plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'o','Color','red');
				plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','black','LineWidth',2);
				%plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'o','Color','blue');
			end
		end
		grid on
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==192
			axis([1.8,4.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:4.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169
			axis([1.8,5.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:5.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			axis([1.8,6.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==130
			axis([1.8,6.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==138
			axis([1.8,4.2,1.8,4.2]*4.5);
			set(gca,'xtick',[1.8:0.2:4.2]*4.5);
			set(gca,'ytick',[1.8:0.2:4.2]*4.5);
		elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			axis([1.6,10.2,1.8,4.45]);
			set(gca,'xtick',[1.6:0.2:10.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==147 || CasetoRun==145
			axis([1.8,13.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:13.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161
			axis([0,14,0,14]);
			set(gca,'xtick',[0:1:14]);
			set(gca,'ytick',[0:1:14]);
		elseif CasetoRun==134 || CasetoRun==136
			axis([1.8,7.7,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:7.7]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==124
			axis([1.3,11.7,1.3,10.4]);
			set(gca,'xtick',[1.3:1.3:11.7]);
			set(gca,'ytick',[1.3:1.3:10.4]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,principal_max,principal_min,principal_shear]=Plot_principaldirs_node_proppath(x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,niCount,r1_sp,r2_sp,E_acc,vgtensor_ni,climits,maxminshear,ActuallyPlot,CasetoRun,refinementfactor,x_tip_dump,r_propdirweighted_dump)
	%{
	x_corner1	          = zeros(niCount,2);
	x_corner2	          = zeros(niCount,2);
	x_corner3	          = zeros(niCount,2);
	x_corner4	          = zeros(niCount,2);
	%}
	%displacement = zeros(niCount,1);
	%velocity = zeros(niCount,1);
	%strain = zeros(niCount,1);
	%{
	for sp=1:niCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	%}
	%{
	for sp=1:niCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end
	%}
	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,niCount);
	thetamin=zeros(1,niCount);
	for io=1:niCount
		theta=1/2*atan(2*vgtensor_ni(io,3)/(vgtensor_ni(io,1)-vgtensor_ni(io,2)));
		principal_first=(vgtensor_ni(io,1)+vgtensor_ni(io,2))/2+(vgtensor_ni(io,1)-vgtensor_ni(io,2))/2*cos(2*theta)+vgtensor_ni(io,3)*sin(2*theta);
		principal_second=(vgtensor_ni(io,1)+vgtensor_ni(io,2))/2-(vgtensor_ni(io,1)-vgtensor_ni(io,2))/2*cos(2*theta)-vgtensor_ni(io,3)*sin(2*theta);
		if principal_first>principal_second
			thetamax(io)=theta;
			thetamin(io)=theta+pi/2;
		else
			thetamax(io)=theta+pi/2;
			thetamin(io)=theta;
		end
		principal_max(io)=max(principal_first,principal_second);
		principal_min(io)=min(principal_first,principal_second);
		principal_shear(io)=(principal_max(io)-principal_min(io))/2; %yes it's not the right name but easy to understand right?
	end
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==130 || CasetoRun==124
			sz=10*512/refinementfactor^2;
		elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			sz=10*128/refinementfactor^2;
		else
			sz=40;
		end
		%color = velocity;
		if maxminshear==1
			color = principal_max;
		elseif maxminshear==2
			color = principal_min;
		elseif maxminshear==3
			color = principal_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		scatter(LOC(:,1),LOC(:,2),sz,color,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		elseif CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			for io=1:niCount
				if maxminshear==1
					thetaplot=thetamax(io);
				elseif maxminshear==2
					thetaplot=thetamin(io);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=LOC(io,1)-le(1)*sqrt(2)/2*cos(thetaplot);
				xend=LOC(io,1)+le(1)*sqrt(2)/2*cos(thetaplot);
				ystart=LOC(io,2)-le(1)*sqrt(2)/2*sin(thetaplot);
				yend=LOC(io,2)+le(1)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		else
			for io=1:niCount
				x_cor = [x_corner1(io,1) x_corner2(io,1) x_corner3(io,1) x_corner4(io,1) x_corner1(io,1)];
				y_cor = [x_corner1(io,2) x_corner2(io,2) x_corner3(io,2) x_corner4(io,2) x_corner1(io,2)];
				plot(x_cor,y_cor,'r')
				if plotignore(io)
					continue;
				end
				if maxminshear==1
					thetaplot=thetamax(io);
				elseif maxminshear==2
					thetaplot=thetamin(io);
				elseif maxminshear==3
					continue;
				else
					disp('MaxminShear Wrong! Put either 1, 2, or 3!')
					pause
				end
				xstart=x_sp(io,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
				xend=x_sp(io,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
				ystart=x_sp(io,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
				yend=x_sp(io,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
				plot([xstart xend],[ystart yend],'color','black');
			end
		end
		if length(x_crack)==0
		else
			for icrackpath=1:length(x_crack)
				%plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'o','Color','red');
				plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','black','LineWidth',2);
				%plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'o','Color','blue');
			end
		end
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==192 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128 || CasetoRun==129 || CasetoRun==138 || CasetoRun==132 || CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==134 || CasetoRun==136 || CasetoRun==140 || CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142 || CasetoRun==130 || CasetoRun==124
			for itipdump=1:size(x_tip_dump,1)
				xstart=x_tip_dump(itipdump,1);
				ystart=x_tip_dump(itipdump,2);
				xend=xstart+r_propdirweighted_dump(itipdump,1)*le(1);
				yend=ystart+r_propdirweighted_dump(itipdump,2)*le(1);
				theangle=reliableatan(r_propdirweighted_dump(itipdump,1),r_propdirweighted_dump(itipdump,2));
				xendarrow1=xend+cos(theangle+3/4*pi)*le(1)/2;
				yendarrow1=yend+sin(theangle+3/4*pi)*le(1)/2;
				xendarrow2=xend+cos(theangle-3/4*pi)*le(1)/2;
				yendarrow2=yend+sin(theangle-3/4*pi)*le(1)/2;
				plot([xstart xend],[ystart yend],'color','red','LineWidth',1.5);
				plot([xend xendarrow1],[yend yendarrow1],'color','red','LineWidth',1.5);
				plot([xend xendarrow2],[yend yendarrow2],'color','red','LineWidth',1.5);
			end
		else
		end
		grid on
		if CasetoRun==118 || CasetoRun==173 || CasetoRun==192
			axis([1.8,4.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:4.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==167 || CasetoRun==176 || CasetoRun==168 || CasetoRun==181 || CasetoRun==184 || CasetoRun==185 || CasetoRun==186 || CasetoRun==193 || CasetoRun==187 || CasetoRun==190 || CasetoRun==188 || CasetoRun==191 || CasetoRun==212 || CasetoRun==198 || CasetoRun==196 || CasetoRun==197 || CasetoRun==195 || CasetoRun==189 || CasetoRun==183 || CasetoRun==182 || CasetoRun==177 || CasetoRun==179 || CasetoRun==199 || CasetoRun==200 || CasetoRun==203 || CasetoRun==211 || CasetoRun==202 || CasetoRun==204 || CasetoRun==208 || CasetoRun==206 || CasetoRun==209 || CasetoRun==205 || CasetoRun==210 || CasetoRun==219 || CasetoRun==224 || CasetoRun==223 || CasetoRun==226 || CasetoRun==227 || CasetoRun==213 || CasetoRun==215 || CasetoRun==216 || CasetoRun==218 || CasetoRun==217 || CasetoRun==229 || CasetoRun==230 || CasetoRun==228 || CasetoRun==214 || CasetoRun==221 || CasetoRun==222 || CasetoRun==225 || CasetoRun==220 || CasetoRun==207 || CasetoRun==201 || CasetoRun==178 || CasetoRun==169
			axis([1.8,5.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:5.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==123 || CasetoRun==151 || CasetoRun==163 || CasetoRun==170 || CasetoRun==171 || CasetoRun==166 || CasetoRun==165 || CasetoRun==125 || CasetoRun==126 || CasetoRun==127 || CasetoRun==128
			axis([1.8,6.2,1.8,4.2]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.2]);
		elseif CasetoRun==129 || CasetoRun==132 || CasetoRun==130
			axis([1.8,6.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:6.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==138
			axis([1.8,4.2,1.8,4.2]*4.5);
			set(gca,'xtick',[1.8:0.2:4.2]*4.5);
			set(gca,'ytick',[1.8:0.2:4.2]*4.5);
		elseif CasetoRun==131 || CasetoRun==133 || CasetoRun==139 || CasetoRun==135 || CasetoRun==140 || CasetoRun==143 || CasetoRun==141 || CasetoRun==142
			axis([1.8,10.2,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:10.2]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==144 || CasetoRun==148 || CasetoRun==146 || CasetoRun==149 || CasetoRun==150 || CasetoRun==155 || CasetoRun==158 || CasetoRun==157 || CasetoRun==160 || CasetoRun==175 || CasetoRun==194 || CasetoRun==180 || CasetoRun==156 || CasetoRun==159 || CasetoRun==162 || CasetoRun==164 || CasetoRun==172 || CasetoRun==174 || CasetoRun==152 || CasetoRun==153 || CasetoRun==154 || CasetoRun==161 || CasetoRun==147 || CasetoRun==145
			axis([1.8,13.2,1.8,5.2]);
			set(gca,'xtick',[1.8:0.2:13.2]);
			set(gca,'ytick',[1.8:0.2:5.2]);
		elseif CasetoRun==134 || CasetoRun==136
			axis([1.8,7.7,1.8,4.45]);
			set(gca,'xtick',[1.8:0.2:7.7]);
			set(gca,'ytick',[1.8:0.2:4.45]);
		elseif CasetoRun==124
			axis([1.3,11.7,1.3,10.4]);
			set(gca,'xtick',[1.3:1.3:11.7]);
			set(gca,'ytick',[1.3:1.3:10.4]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'xtick',[0:20:max(LOC(:,1))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_principal_crackmulti_pforce(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun,pforce_sp)
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	 
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		 
	end
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		sz = 40;
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		for sp=1:spCount
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			plot(x_cor,y_cor,'r')
			if plotignore(sp)
				continue;
			end
			if maxminshear==1
				thetaplot=thetamax(sp);
			elseif maxminshear==2
				thetaplot=thetamin(sp);
			elseif maxminshear==3
				continue;
			else
				disp('MaxminShear Wrong! Put either 1, 2, or 3!')
				pause
			end
			xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
			xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
			ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
			yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
			%plot([xstart xend],[ystart yend],'color','black');
		end
		if length(x_crack)==0
		else
			for icrackpath=1:length(x_crack)
				%plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'o','Color','red');
				plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','black','LineWidth',2);
				%plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'o','Color','blue');
			end
		end
		domainsizevect=[max(LOC(:,1))-min(LOC(:,1)) max(LOC(:,2))-min(LOC(:,2))];
		domainsize=sqrt(dot(domainsizevect,domainsizevect));
		pforce_magnitude=zeros(spCount,1);
		for sp=1:spCount
			pforce_magnitude(sp,1)=sqrt(dot(pforce_sp(sp,:),pforce_sp(sp,:)));
		end
		pforce_maxmagnitude=max(pforce_magnitude);
		title(['pforce_maxmagnitude=' num2str(pforce_maxmagnitude)]);
		if pforce_maxmagnitude>0
			maxlinesize=domainsize/10;
			pforcetolinescale=maxlinesize/pforce_maxmagnitude;
			for sp=1:spCount
				if pforce_magnitude(sp,1)>0
					pforce_angle=reliableatan(pforce_sp(sp,1),pforce_sp(sp,2));
					linelength=pforce_magnitude(sp,1)*pforcetolinescale;
					plot([x_sp(sp,1) x_sp(sp,1)+linelength*cos(pforce_angle)],[x_sp(sp,2) x_sp(sp,2)+linelength*sin(pforce_angle)],'color','red','LineWidth',1.5);
				end
			end
		end
		grid on
		axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
		set(gca,'xtick',[0:20:max(LOC(:,1))]);
		set(gca,'ytick',[0:20:max(LOC(:,2))]);
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_principal_crackmulti_ntforce(x_sp,x_crack,x_cracktop,x_crackbot,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun,ntforce_si)
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	 
	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
	%	displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end

	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		 
	end
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		sz = 40;
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		for sp=1:spCount
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			plot(x_cor,y_cor,'r')
			if plotignore(sp)
				continue;
			end
			if maxminshear==1
				thetaplot=thetamax(sp);
			elseif maxminshear==2
				thetaplot=thetamin(sp);
			elseif maxminshear==3
				continue;
			else
				disp('MaxminShear Wrong! Put either 1, 2, or 3!')
				pause
			end
			xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
			xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
			ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
			yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
			%plot([xstart xend],[ystart yend],'color','black');
		end
		if length(x_crack)==0
		else
			for icrackpath=1:length(x_crack)
				%plot(x_cracktop{icrackpath}(:,1),x_cracktop{icrackpath}(:,2),'o','Color','red');
				plot(x_crack{icrackpath}(:,1),x_crack{icrackpath}(:,2),'-','Color','black','LineWidth',2);
				%plot(x_crackbot{icrackpath}(:,1),x_crackbot{icrackpath}(:,2),'o','Color','blue');
			end
		end
		domainsizevect=[max(LOC(:,1))-min(LOC(:,1)) max(LOC(:,2))-min(LOC(:,2))];
		domainsize=sqrt(dot(domainsizevect,domainsizevect));
		ntforce_si_magnitude=zeros(spCount,1);
		for ni=1:size(LOC,1)
			ntforce_si_magnitude(ni,1)=sqrt(dot(ntforce_si(ni,:),ntforce_si(ni,:)));
		end
		ntforce_si_maxmagnitude=max(ntforce_si_magnitude);
		if ntforce_si_maxmagnitude>0
			maxlinesize=domainsize/10;
			ntforce_si_tolinescale=maxlinesize/ntforce_si_magnitude;
			for ni=1:size(LOC,1)
				if ntforce_si_magnitude(ni,1)>0
					ntforce_si_angle=reliableatan(ntforce_si(ni,1),ntforce_si(ni,2));
					linelength=ntforce_si_magnitude(ni,1)*ntforce_si_tolinescale;
					if linelength>0
						linelength
						ntforce_si_angle
					end
					plot([LOC(ni,1) LOC(ni,1)+linelength*cos(ntforce_si_angle)],[LOC(ni,2) LOC(ni,2)+linelength*sin(ntforce_si_angle)],'color','red','LineWidth',1.5);
				end
			end
		end
		grid on
		axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
		set(gca,'xtick',[0:20:max(LOC(:,1))]);
		set(gca,'ytick',[0:20:max(LOC(:,2))]);
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_directions(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun)
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);
	
	% displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	% strain = zeros(spCount,1);
	for sp=1:spCount
	%	 displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
	%	 strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end
	
	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		
	end
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		sz = 40;
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		if CasetoRun==105 || CasetoRun==110
			set(StressProfile1,'Position',[0 0 1800 1800]);
		end
		for sp=1:spCount
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			plot(x_cor,y_cor,'r')
			if plotignore(sp)
				continue;
			end
			if maxminshear==1
				thetaplot=thetamax(sp);
			elseif maxminshear==2
				thetaplot=thetamin(sp);
			elseif maxminshear==3
				continue;
			else
				disp('MaxminShear Wrong! Put either 1, 2, or 3!')
				pause
			end
			xstart=x_sp(sp,1)-lp(1)*sqrt(2)/2*cos(thetaplot);
			xend=x_sp(sp,1)+lp(1)*sqrt(2)/2*cos(thetaplot);
			ystart=x_sp(sp,2)-lp(2)*sqrt(2)/2*sin(thetaplot);
			yend=x_sp(sp,2)+lp(2)*sqrt(2)/2*sin(thetaplot);
			plot([xstart xend],[ystart yend],'color','black');
		end
		grid on
		axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
		%set(gca,'xtick',[0:20:max(LOC(:,1))]);
		set(gca,'xtick',[]);
		%set(gca,'ytick',[0:20:max(LOC(:,2))]);
		set(gca,'ytick',[]);
		h=colorbar;
		colormap(jet(256))
		set(gca,'FontSize',20)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	if exist('climits')
		if length(climits)>0
			if climits(2)>climits(1)
				caxis(climits);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [StressProfile1,e_pl_max,e_pl_min,e_pl_shear]=Plot_Final2_principalclimit_directions_black(x_sp,LOC,le,d_sp,e_sp,v_ssp,spCount,r1_sp,r2_sp,E_acc,e_pl_sp,climits,maxminshear,lp,plotignore,ActuallyPlot,CasetoRun)
	
	x_corner1	          = zeros(spCount,2);
	x_corner2	          = zeros(spCount,2);
	x_corner3	          = zeros(spCount,2);
	x_corner4	          = zeros(spCount,2);

	%displacement = zeros(spCount,1);
	velocity = zeros(spCount,1);
	%strain = zeros(spCount,1);
	for sp=1:spCount
		%displacement(sp) = sqrt(d_sp(sp,1)^2+d_sp(sp,2)^2);
		velocity(sp) = sqrt(v_ssp(sp,1)^2+v_ssp(sp,2)^2);
		%strain(sp) = sqrt(e_sp(sp,1)^2+e_sp(sp,2)^2);
	end
	
	for sp=1:spCount
		x_corner1(sp,:) = x_sp(sp,:) - r1_sp(sp,:) - r2_sp(sp,:);	  % Position of corner 1
		x_corner2(sp,:) = x_sp(sp,:) + r1_sp(sp,:) - r2_sp(sp,:);
		x_corner3(sp,:) = x_sp(sp,:) + r1_sp(sp,:) + r2_sp(sp,:);
		x_corner4(sp,:) = x_sp(sp,:) - r1_sp(sp,:) + r2_sp(sp,:);
	end
	
	%%Calculating Max Princ Plast Strain
	thetamax=zeros(1,spCount);
	thetamin=zeros(1,spCount);
	for sp=1:spCount
		theta=1/2*atan(2*e_pl_sp(sp,3)/(e_pl_sp(sp,1)-e_pl_sp(sp,2)));
		e_pl_first=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2+(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)+e_pl_sp(sp,3)*sin(2*theta);
		e_pl_second=(e_pl_sp(sp,1)+e_pl_sp(sp,2))/2-(e_pl_sp(sp,1)-e_pl_sp(sp,2))/2*cos(2*theta)-e_pl_sp(sp,3)*sin(2*theta);
		if plotignore(sp)==0
			if e_pl_first>e_pl_second
				thetamax(sp)=theta;
				thetamin(sp)=theta+pi/2;
			else
				thetamax(sp)=theta+pi/2;
				thetamin(sp)=theta;
			end
		end
		e_pl_max(sp)=max(e_pl_first,e_pl_second);
		e_pl_min(sp)=min(e_pl_first,e_pl_second);
		e_pl_shear(sp)=(e_pl_max(sp)-e_pl_min(sp))/2;
		
	end
	if ActuallyPlot==1
		StressProfile1=figure;
		set(StressProfile1, 'visible','off');
		sz = 30;
		%color = velocity;
		if maxminshear==1
			color = e_pl_max;
		elseif maxminshear==2
			color = e_pl_min;
		elseif maxminshear==3
			color = e_pl_shear;
		else
			disp('wrong maxminshear input!');
			pause
		end
		color_cut=cutvector(color,0,plotignore);
		
		if maxminshear==1
			maxvalue=max(color_cut);
		elseif maxminshear==2
			maxvalue=min(color_cut);
		elseif maxminshear==3
			maxvalue=max(color_cut);
		end
		TheDisplayName=['0 to ' num2str(abs(maxvalue)) ' MPa' ];
		
		if maxminshear==1
			TheDisplayName=[TheDisplayName ' (tension)'];
		elseif maxminshear==2
			TheDisplayName=[TheDisplayName ' (compression)'];
		elseif maxminshear==3
			TheDisplayName=[TheDisplayName ' (shear)'];
		end
		x_sp_cut=cutvector(x_sp,1,plotignore);
		scatter(x_sp_cut(:,1),x_sp_cut(:,2),sz,color_cut,'filled');
		hold on
		daspect([1 1 1]);
		set(StressProfile1,'Position',[0 0 1000 1000]);
		for sp=1:spCount
			if abs(x_sp(sp,1)-min(x_sp(:,1)))<lp(1)/2 && abs(x_sp(sp,2)-min(x_sp(:,2)))<lp(2)/2
				1;
			end
			x_cor = [x_corner1(sp,1) x_corner2(sp,1) x_corner3(sp,1) x_corner4(sp,1) x_corner1(sp,1)];
			y_cor = [x_corner1(sp,2) x_corner2(sp,2) x_corner3(sp,2) x_corner4(sp,2) x_corner1(sp,2)];
			if plotignore(sp)
				x_cross1=[x_corner1(sp,1) x_corner3(sp,1)];
				y_cross1=[x_corner1(sp,2) x_corner3(sp,2)];
				x_cross2=[x_corner2(sp,1) x_corner4(sp,1)];
				y_cross2=[x_corner2(sp,2) x_corner4(sp,2)];
				plot(x_cross1,y_cross1,'color','red','HandleVisibility','off');
				plot(x_cross2,y_cross2,'color','red','HandleVisibility','off');
			end
			if sp==1
				plot(x_cor,y_cor,'r','DisplayName',TheDisplayName)
			else
				plot(x_cor,y_cor,'r','HandleVisibility','off')
			end
			%if sp==1
				%hold on;
				%daspect([1 1 1]);
			%end
			if plotignore(sp)
				continue;
			end
			if maxminshear==1
				thetaplot=thetamax(sp);
				relativelength=max(color(sp),0)/maxvalue;
			elseif maxminshear==2
				thetaplot=thetamin(sp);
				relativelength=min(color(sp),0)/maxvalue;
			elseif maxminshear==3
				continue;
			else
				disp('MaxminShear Wrong! Put either 1, 2, or 3!')
				pause
			end
			relativelength=1;
			xstart=x_sp(sp,1)-lp(1)*relativelength*sqrt(2)/2*cos(thetaplot);
			xend=x_sp(sp,1)+lp(1)*relativelength*sqrt(2)/2*cos(thetaplot);
			ystart=x_sp(sp,2)-lp(2)*relativelength*sqrt(2)/2*sin(thetaplot);
			yend=x_sp(sp,2)+lp(2)*relativelength*sqrt(2)/2*sin(thetaplot);
			plot([xstart xend],[ystart yend],'color','black','HandleVisibility','off');
		end
		grid on
		if CasetoRun==10
			axis([0,max(LOC(:,1)),0,160]);
			set(gca,'ytick',[0:20:160]);
		else
			axis([0,max(LOC(:,1)),0,max(LOC(:,2))]);
			set(gca,'ytick',[0:20:max(LOC(:,2))]);
		end
		set(gca,'xtick',[0:20:max(LOC(:,1))]);
		%title(TheDisplayName);
		%legend show
		h=colorbar;
		colormap(jet(256));
		set(gca,'FontSize',40)
	else
		StressProfile1=[];
	end
	% set(h, 'ytick', [0:0.2:1.2]);
	%if exist('climits')
	%	if length(climits)>0
	%	    if climits(2)>climits(1)
	%	        caxis(climits);
	%	    end
	%	end
	%end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%]
%switchable2

function directionnum = RTLtranslator(directionstr)
	%RTLTRANSLATOR Summary of this function goes here
	%   Detailed explanation goes here
	directionnum=0;
	errorswitch=0;
	if length(directionstr)==1
		if directionstr=='r'
			directionnum=1;
		elseif directionstr=='t'
			directionnum=2;
		elseif directionstr=='l'
			directionnum=3;
		else
			errorswitch=1;
		end
	elseif length(directionstr)==2
		if directionstr=='rt'
			directionnum=4;
		elseif directionstr=='tr'
			directionnum=4;
		elseif directionstr=='tl'
			directionnum=5;
		elseif directionstr=='lt'
			directionnum=5;
		elseif directionstr=='rl'
			directionnum=6;
		elseif directionstr=='lr'
			directionnum=6;
		else
			errorswitch=1;
		end
	else
		errorswitch=1;
	end
	if errorswitch==1
		fprintf('%s',['direction error' char(10)]);
		pause
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%{
%switchable1
function printvector(thevector,vectorname,indexes)
	if exist('indexes')
		texttodisplay=[vectorname '=['];
		for i=1:length(indexes)
			if i>1
				texttodisplay=[texttodisplay ','];
			end
			texttodisplay=[texttodisplay float2txt(5,thevector(indexes(i)))];
		end
		texttodisplay=[texttodisplay ']'];
		fprintf('%s',[texttodisplay chr(10)]);
	else
		texttodisplay=[vectorname '=['];
		for i=1:length(thevector)
			if i>1
				texttodisplay=[texttodisplay ','];
			end
			texttodisplay=[texttodisplay float2txt(5,thevector(i))];
		end
		texttodisplay=[texttodisplay ']'];
		fprintf('%s',[texttodisplay chr(10)]);
	end
end
%}
%switchable1

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MatOut=MatReorder(MatIn,Order)
	MatOut=zeros(size(MatIn));
	for i=1:size(MatOut,1)
	    for j=1:size(MatOut,2)
	        MatOut(i,j)=MatIn(Order(i),Order(j));
	    end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

%{
%switchable1
function soundplay
	amp=1 ;
	fs=48000;  % sampling frequency
	duration=0.25;
	freq=1000;
	values=0:1/fs:16*duration;
	a=zeros(1,length(values));
	for i=1:length(values)
	    if values(i)<=duration
	        a(i)=amp*sin(2*pi* freq*values(i));
	    elseif values(i)<=2*duration
	        a(i)=0;
	    elseif values(i)<=3*duration
	        a(i)=amp*sin(2*pi* freq*values(i));
	    elseif values(i)<=4*duration
	        a(i)=0;
	    elseif values(i)<=5*duration
	        a(i)=amp*sin(2*pi* freq*values(i));
	    elseif values(i)<=6*duration
	        a(i)=0;
	    elseif values(i)<=7*duration
	        a(i)=amp*sin(2*pi* freq*values(i));
	    elseif values(i)<=8*duration
	        a(i)=0;
	    elseif values(i)<=9*duration
	        a(i)=amp*sin(2*pi* freq*values(i));
	    elseif values(i)<=10*duration
	        a(i)=0;
	    elseif values(i)<=11*duration
	        a(i)=amp*sin(2*pi* freq*values(i));
	    elseif values(i)<=12*duration
	        a(i)=0;
	    elseif values(i)<=13*duration
	        a(i)=amp*sin(2*pi* freq*values(i));
	    elseif values(i)<=14*duration
	        a(i)=0;
	    elseif values(i)<=15*duration
	        a(i)=amp*sin(2*pi* freq*values(i));
	    elseif values(i)<=16*duration
	        a(i)=0;
	    elseif values(i)<=17*duration
	        a(i)=amp*sin(2*pi* freq*values(i));
	    elseif values(i)<=18*duration
	        a(i)=0;
	    elseif values(i)<=19*duration
	        a(i)=amp*sin(2*pi* freq*values(i));
	    elseif values(i)<=20*duration
	        a(i)=0;
	    end
	end
	sound(a,fs);
end
%}
%switchable1

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function vectorout=cutvector(vectorin,listdirection,ignorelist)
	%{
	example:
	x(sp,1:2), listdirection=1
	x(1:2,sp), listdirection=2
	%}
	if listdirection==0
		if size(vectorin,1)>size(vectorin,2)
			listdirection=1;
		elseif size(vectorin,2)>size(vectorin,1)
			listdirection=2;
		else
			fprintf('%s',['vectorin is a square matrix!' char(10)]);
			pause;
		end
	end
	if listdirection==1
		vectorout=zeros(size(vectorin,1)-sum(ignorelist),size(vectorin,2));
	elseif listdirection==2
		vectorout=zeros(size(vectorin,1),size(vectorin,2)-sum(ignorelist));
	else
		fprintf('%s',['incorrect list direction input!' char(10)]);
		pause;
	end
	newnumbering=0;
	for i=1:size(vectorin,listdirection)
		if ignorelist(i)
			continue;
		end
		newnumbering=newnumbering+1;
		if listdirection==1
			vectorout(newnumbering,:)=vectorin(i,:);
		elseif listdirection==2
			vectorout(:,newnumbering)=vectorin(:,i);
		else
			fprintf('%s',['incorrect list direction input!' char(10)]);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function outputangle=reliableatan(deltax,deltay)
	outputangle=0;
	if deltax==0
		if deltay==0
			outputangle=0;
		elseif deltay>0
			outputangle=pi/2;
		elseif deltay<0
			outputangle=-pi/2;
		end
	elseif deltax>0
		outputangle=atan(deltay/deltax);
	elseif deltay>0
		outputangle=atan(deltay/deltax)+pi;
	elseif deltay<0
		outputangle=atan(deltay/deltax)-pi;
	elseif deltay==0
		outputangle=pi;
	else
		outputangle=0;
		%fprintf('%s',['scenario not considered!' char(10)]);
		%pause;
		%1;
	end
	%outputangle=outputangle*180/pi;
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MinNum=FindMin(VectorIn)
	MinVal=VectorIn(1);
	MinNum=1;
	for i=2:length(VectorIn)
		if VectorIn(i)<MinVal
			MinVal=VectorIn(i);
			MinNum=i;
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MinNum=FindMinMatrix(MatrixIn)
	MinNum=zeros(1,2);
	MinVal=MatrixIn(1,1);
	MinNum(2)=1;
	MinNum(1)=1;
	for i=1:size(MatrixIn,1)
		for j=1:size(MatrixIn,2)
			if MatrixIn(i,j)<MinVal
				MinVal=MatrixIn(i,j);
				MinNum(1)=i;
				MinNum(2)=j;
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MaxNum=FindMax(VectorIn)
	MaxVal=VectorIn(1);
	MaxNum=1;
	for i=2:length(VectorIn)
		if VectorIn(i)>MaxVal
			MaxVal=VectorIn(i);
			MaxNum=i;
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MaxVal=FindMaxVal(VectorIn)
	MaxVal=VectorIn(1);
	for i=2:length(VectorIn)
		if VectorIn(i)>MaxVal
			MaxVal=VectorIn(i);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MaxVal=FindMaxVal3DMatrix(MatrixIn3D)
	MaxVal=MatrixIn3D(1,1,1);
	for i=1:size(MatrixIn3D,1)
		for j=1:size(MatrixIn3D,2)
			for k=1:size(MatrixIn3D,3)
				if MatrixIn3D(i,j,k)>MaxVal
					MaxVal=MatrixIn3D(i,j,k);
				end
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function MaxVal=FindMaxValMatrix(MatrixIn)
	MaxVal=MatrixIn(1,1);
	for i=1:size(MatrixIn,1)
		for j=1:size(MatrixIn,2)
			if MatrixIn(i,j)>MaxVal
				MaxVal=MatrixIn(i,j);
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [R U V] = poldecomp(F,UVrequest)
	%POLDECOMP  Performs the polar decomposition of a regular square matrix.
	%   [R U V] = POLDECOMP(F) factorizes a non-singular square matrix F such
	%   that F=R*U and F=V*R, where
	%   U and V are symmetric, positive definite matrices and
	%   R is a rotational matrix
	%
	%   See also EIG, DIAG, REPMAT


	% This kind of decomposition is often used in continuum mechanics so it is
	% convenient to comment the code that way. From now, we use the matrix 
	% formalism of tensors. C is the right Cauchy-Green deformation tensor, 
	% F is the deformation tensor, lambda is the stretch.

	% Check input
	[m n] = size(F);
	if m ~= n
		error('Matrix must be square.');
	end

	C = F'*F;
	[Q0 lambdasquare] = eig(C);
	lambda = sqrt(diag((lambdasquare))); % extract the components
	% Uinv is the inverse of U and is constructed with the help of Q0. Uinv is
	% produced in the same base as F not in the base of its eigenvectors.
	Uinv = repmat(1./lambda',size(F,1),1).*Q0*Q0';
	% Using the definition, R, U and V can now be calculated
	R = F*Uinv;
	if UVrequest==1
		U = R'*F;
		V = F*R';
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function TexttoPrint=PrintMatrixVectorized(MatrixInput,MatrixName,DisplayKah)
	TexttoPrint=[MatrixName '=['];
	for i=1:size(MatrixInput,1)
		if i>1
			TexttoPrint=[TexttoPrint ';'];
		end
		for j=1:size(MatrixInput,2)
			if j>1
				TexttoPrint=[TexttoPrint ','];
			end
			TexttoPrint=[TexttoPrint float2txt(5,MatrixInput(i,j))];
		end
	end
	TexttoPrint=[TexttoPrint ']; det(' MatrixName ')=' float2txt(5,det(MatrixInput))];
	if DisplayKah==1
		fprintf('%s',[TexttoPrint char(10)]);
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function Result=CompareTexts(Text1,Text2)
	Result=0;
	if length(Text1)==length(Text2)
		if Text1==Text2
			Result=1;
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%{
%switchable1
function TheVerdict=CloseEnough2(val1,val2,val2tolerance,absoluteput1_relativeput2)
	if exist('absoluteput1_relativeput2')
	else
		absoluteput1_relativeput2=2;
	end
	if exist('val2tolerance')
	else
		val2tolerance=1e-10;
	end
	TheVerdict=0;
	if absoluteput1_relativeput2==1
		if val1>=val2-abs(val2tolerance/2) && val1<=val2+abs(val2tolerance/2)
			TheVerdict=1;
		end
	elseif absoluteput1_relativeput2==2
		if val2>0
			if val1>=val2*(1-abs(val2tolerance/2)) && val1<=val2*(1+abs(val2tolerance/2))
				TheVerdict=1;
			end
		else
			if val1<=val2*(1-abs(val2tolerance/2)) && val1>=val2*(1+abs(val2tolerance/2))
				TheVerdict=1;
			end
		end
	else
		fprintf('%s',['wrong input!' char(10)]);
		pause
		1;
	end
end
%}
%switchable1
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function TheVerdict=CloseEnough(val1,val2,val2tolerance,absoluteput1_relativeput2)
%{
	if exist('absoluteput1_relativeput2')
	else
		absoluteput1_relativeput2=2;
	end
	if exist('val2tolerance')
	else
		val2tolerance=1e-10;
	end
%}
	TheVerdict=0;
	if absoluteput1_relativeput2==1
		if val1>=val2-abs(val2tolerance/2) && val1<=val2+abs(val2tolerance/2)
			TheVerdict=1;
		end
	elseif absoluteput1_relativeput2==2
		if val2>0
			if val1>=val2*(1-abs(val2tolerance/2)) && val1<=val2*(1+abs(val2tolerance/2))
				TheVerdict=1;
			end
		else
			if val1<=val2*(1-abs(val2tolerance/2)) && val1>=val2*(1+abs(val2tolerance/2))
				TheVerdict=1;
			end
		end
	else
		fprintf('%s',['wrong input!' char(10)]);
		pause
		1;
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%{
%switchable1
function [affectedvector sortedvector]=affectsort(toaffectvector,tosortvector,direction)
	%direction=0: ascending
	%direction=1: descending
	sortedvector=tosortvector;
	affectedvector=toaffectvector;
	
	if exist('direction')==0
		direction=0;
	end
	
	for j=1:length(tosortvector)^2
		allsorted=1;
		for i=1:length(tosortvector)-1
			if direction==0
				if sortedvector(i)>sortedvector(i+1)
					allsorted=0;
					dummy=sortedvector(i);
					sortedvector(i)=sortedvector(i+1);
					sortedvector(i+1)=dummy;
					
					dummy=affectedvector(i);
					affectedvector(i)=affectedvector(i+1);
					affectedvector(i+1)=dummy;
				end
			elseif direction==1
				if sortedvector(i)<sortedvector(i+1)
					allsorted=0;
					dummy=sortedvector(i);
					sortedvector(i)=sortedvector(i+1);
					sortedvector(i+1)=dummy;
					
					dummy=affectedvector(i);
					affectedvector(i)=affectedvector(i+1);
					affectedvector(i+1)=dummy;
				end
			else
				fprintf('%s',['direction input error!' char(10)]);
				pause;
				1;
			end
		end
		if allsorted
			break;
		end
	end
end
%}
%switchable1
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%{
%switchable1
function secspassed = clockallsec()
	dateinput=clock;
	month(1)=31;
	if mod(dateinput(1),4)==0
		month(2)=29;
	else
		month(2)=28;
	end
	month(3)=31;
	month(4)=30;
	month(5)=31;
	month(6)=30;
	month(7)=31;
	month(8)=31;
	month(9)=30;
	month(10)=31;
	month(11)=30;
	month(12)=31;
	
	dayspassed=floor((dateinput(1)-1)/4)*4*365.25+(dateinput(1)-1-floor((dateinput(1)-1)/4)*4)*365;
	for i=1:dateinput(2)-1
		dayspassed=dayspassed+month(i);
	end
	dayspassed=dayspassed+dateinput(3)-1;
	hourspassed=dayspassed*24+dateinput(4);
	minutespassed=hourspassed*60+dateinput(5);
	secspassed=minutespassed*60+dateinput(6);
end
%}
%switchable1
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function angletaken=gerhardangles(xstart,ystart,xtrial_global,ytrial_global)
	xtrial=xtrial_global-xstart;
	ytrial=ytrial_global-ystart;
	if ytrial<0 || ytrial>150
		angletaken=-inf;
		fprintf('%s',['wrong y trial! pausing...' char(10)]);
		pause;
		1;
		return
	end
	positions=[	3	6	11	13.5	18.5	22.5	27.5	35	42.3	47.5	60	87.5	101.5	107	112	118.3	122.5	;
	    2.5	6.5	10.5	13.5	18.5	23	27.5	35	42.5	47.5	60.5	87.5	101.5	107	112	118.5	122.5	;
	    2.5	6.5	10.5	13.5	18.5	23.5	28	35	42.5	47	59.5	87.8	101.5	107	112	119	122	;
	    2.4	5.5	10	12.2	18.5	23.5	28.4	35.5	42.5	47.4	59.5	88.2	101.5	107.3	112.1	119.1	122.5	;
	    1.8	5.5	9.5	12.5	18.1	23.1	28	35	42.5	47	59	88.5	101.5	107.3	112.5	118.6	122.5	;
	    1.5	5.5	9.5	12.5	18	23.6	28	35	42	47	58.5	88.5	102	107.5	114	119	123	;
	    1.5	6.5	9.8	13	18	23	27.7	35	42	47	58.5	89	102.5	107.7	114.6	119.4	123	;
	    1.4	5.4	9.7	12.6	17.8	23.4	27.7	35	42.1	47	57.6	89.5	102.6	108	115.4	119.6	123.5	;
	    1.2	5.3	9.7	12.8	17.7	22.6	28	34.8	41.6	46.8	57.5	89.5	103.5	108.4	115.5	120	123.8	;
	    1	4.6	9.5	12.5	17.5	22.5	27.7	34.6	41.5	47	56.5	90.5	104	108.5	116.5	120.5	124.5	;
	    1	4	9.5	12.5	17	22.5	27.5	34.5	41.5	47.2	55.5	91.4	104.5	108.7	116.6	121.5	126	;
	    0.8	3.4	9.1	12.4	16.9	21.7	27.4	33.8	41.5	46.5	55.2	92.5	104.5	109.5	117	122	126.5	;
	    -1	3.2	8.8	11.5	16.7	21.1	27.1	33.5	41.5	46.4	56	93.7	104.9	109.6	117.1	122.5	127	;
	    -2	3.1	8.5	11.2	16.5	20.1	26.5	33	40.9	45.6	57.5	93.4	105	110.1	116.9	122.5	127.3	;
	    -3	2.5	7.9	10.5	16.5	19.5	25	32.5	39.2	45.1	59	93.5	105.5	110.5	117.1	122.8	127.7	;
	    -3.4	1.9	7.5	10.4	16.3	19.6	24.4	32.1	38	44.6	59.5	93.6	105.6	110.6	117.3	122.9	127.9	;
	    -3.9	1.6	7.1	9.8	15.4	18.6	23.5	30.8	35.5	44.5	59.5	93.5	105.6	110.6	117	122.6	127.9	;
	    -4.1	1	6.5	9.4	14.5	18	21.5	29	33.5	46.7	59.8	93.4	105.6	110.8	117.3	122.7	127.8	;
	    -4.5	0.5	5.7	8.5	14	17.2	19.5	25.5	31.5	47.5	60	92.6	105.8	111.3	117.4	123	127.9	;
	    -4.9	-0.6	4.6	8.4	13.1	16	17.8	22	28.5	47.9	60	92.1	105.9	111.4	117.5	123.5	127.9	;
	    -5.2	-1.1	3.8	8	12	14	16.6	20	24.5	47.8	59.5	91.5	106.5	111	117.4	123.4	127.8	;
	    -5.6	-1.7	2.8	7.4	10.5	12.5	14.5	16.8	19.8	47.6	59.4	91.1	106.5	110.5	117.1	123.5	127.8	;
	    -5.7	-1.9	2.3	7	9.2	11.4	13.5	15.4	17.4	47.5	58.6	90.6	105.7	110.4	116.9	123.4	127.7	;
	    -5.8	-2	1.6	7	9	10.6	12.8	14.5	15.8	46.4	58.8	90.6	105.6	110	116.6	123.2	127.6	;
	    -5.9	-2	1.4	6.8	9.1	10.6	12.7	14.1	15.6	45.5	58.5	90.1	105.4	109.6	116.6	123	127.3	;
	    -5.9	-2.1	1.5	6.6	9.9	11.8	13.5	14.6	16.4	44	59	89.6	104.8	109.1	116.5	123	127	;
	    -5.9	-2.1	1.5	6.8	11.4	13.4	15.1	16.4	18.9	42.4	59.6	89.6	104.3	108.5	116.5	122.6	126.6	;
	    -5.9	-2	1.6	7.4	12.4	15.1	17.2	22.5	35	45.1	60.5	89.5	104	108.1	116.4	122.1	126	;
	    -5.8	-1.9	1.7	7.4	13.1	16.4	19.5	30.1	39.5	46.4	61	89.1	103.4	107.4	115.8	121.4	124.9	;
	    -5.7	-1.9	1.8	7.7	14.4	18.4	22.6	34.1	42.4	48.3	61.5	88.9	102.9	107.5	115.4	120.8	124.5	;
	    -5.6	-1.8	1.9	8	15.4	19.6	24.5	36.1	43.6	49.2	61.9	88.8	102.5	107.6	114.5	120.5	124.2	;
	    -5.4	-1	2.6	9.1	16.6	21.4	27.5	37.8	45.2	51.1	62.6	88.1	101.7	107.6	113.6	120.4	124	;
	    -5.1	-0.1	4.8	10.5	18.1	22.4	28.7	39.2	46	52.1	63.4	88.7	101.5	107.5	113.3	119.8	123.4	;
	    -4.2	1.2	7.1	11.6	18.7	23.4	29.7	39.6	46.1	52.8	63.1	88.5	101.5	107.5	113.4	119.5	123.4	;
	    -3.4	2.1	9.4	12.6	19.5	24.1	30.5	40	46.4	53	63	88.4	101.5	107.5	113.4	119.4	123	;
	    -2.1	2.7	10	12.8	20	24.6	31.4	40.1	46.7	52.8	62.8	88.4	102.3	107.5	113.6	119.4	123.4	;
	    -0.8	3.6	10.1	13.4	20.6	25.1	31.5	40.4	46.4	52.8	62.6	88.6	102.6	107.5	113.8	119.5	123.4	;
	    0.9	4.1	10	13.7	20.7	25.4	31.5	40.4	46.4	52.5	62.4	89.6	102.8	107.5	114.1	119.5	123.5	;
	    0.9	4.5	10	13.8	20.8	25.4	31.5	40	46.1	52.6	62.7	89.6	102.8	107.6	114.3	119.5	123.5	];

	verticals=[	0	...
	    5	...
	    10	...
	    15	...
	    20	...
	    25	...
	    30	...
	    35	...
	    40	...
	    45	...
	    50	...
	    55	...
	    60	...
	    65	...
	    70	...
	    72.5	...
	    75	...
	    77.5	...
	    80	...
	    82.5	...
	    85	...
	    87.5	...
	    90	...
	    92.5	...
	    95	...
	    97.5	...
	    100	...
	    102.5	...
	    105	...
	    107.5	...
	    110	...
	    115	...
	    120	...
	    125	...
	    130	...
	    135	...
	    140	...
	    145	...
	    150	];


	%xtrial=45;
	%ytrial=85;

	for i=1:length(verticals)-1
		if ((ytrial>=verticals(i) && ytrial<=verticals(i+1)) || (ytrial<=verticals(i) && ytrial>=verticals(i+1)))
			vernumberbefore=i;
			yextrafactor=(ytrial-verticals(vernumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
			break;
		end
	end
	for i=1:size(positions,2)-1
		xbefore=positions(vernumberbefore,i)+(ytrial-verticals(vernumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore))*(positions(vernumberbefore+1,i)-positions(vernumberbefore,i));
		xafter=positions(vernumberbefore,i+1)+(ytrial-verticals(vernumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore))*(positions(vernumberbefore+1,i+1)-positions(vernumberbefore,i+1));
		if i==1 && xtrial<xbefore
			oneovergradient=(positions(vernumberbefore+1,i)-positions(vernumberbefore,i))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
			angletaken=atan(1/oneovergradient);
			if angletaken<0
				angletaken=angletaken+pi;
			end
			break;
		elseif i==(size(positions,2)-1) && xtrial>xafter
			oneovergradient=(positions(vernumberbefore+1,i+1)-positions(vernumberbefore,i+1))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
			angletaken=atan(1/oneovergradient);
			if angletaken<0
				angletaken=angletaken+pi;
			end
			break;
		elseif ((xtrial>=xbefore && xtrial<=xafter) || (xtrial<=xbefore && xtrial>=xafter))
			hornumberbefore=i;
			xextrafactor=(xtrial-xbefore)/(xafter-xbefore);
			oneovergradientbefore=(positions(vernumberbefore+1,hornumberbefore)-positions(vernumberbefore,hornumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
			anglebefore=atan(1/oneovergradientbefore);
			if anglebefore<0
				anglebefore=anglebefore+pi;
			end
			oneovergradientafter=(positions(vernumberbefore+1,hornumberbefore+1)-positions(vernumberbefore,hornumberbefore+1))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
			angleafter=atan(1/oneovergradientafter);
			if angleafter<0
				angleafter=angleafter+pi;
			end
			angletaken=anglebefore+xextrafactor*(angleafter-anglebefore);
			break;
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function angletaken=gerhardanglesellipseonly(xtrial,ytrial,knot_x,knot_y,knot_rx,knot_ry,knot_theta)
	%if ytrial<0 || ytrial>150
	%    angletaken=-inf;
	%    disp('wrong y trial! pausing...');
	%    pause;
	%    1;
	%    return
	%end
	knotnum=2;
	angletaken=mod(pi/2 + atan(((2*cos(knot_theta(knotnum))*(cos(knot_theta(knotnum))*(knot_y(knotnum) - ytrial) - sin(knot_theta(knotnum))*(knot_x(knotnum) - xtrial)))/knot_ry(knotnum)^2 + (2*sin(knot_theta(knotnum))*(cos(knot_theta(knotnum))*(knot_x(knotnum) - xtrial) + sin(knot_theta(knotnum))*(knot_y(knotnum) - ytrial)))/knot_rx(knotnum)^2)/((2*cos(knot_theta(knotnum))*(cos(knot_theta(knotnum))*(knot_x(knotnum) - xtrial) + sin(knot_theta(knotnum))*(knot_y(knotnum) - ytrial)))/knot_rx(knotnum)^2 - (2*sin(knot_theta(knotnum))*(cos(knot_theta(knotnum))*(knot_y(knotnum) - ytrial) - sin(knot_theta(knotnum))*(knot_x(knotnum) - xtrial)))/knot_ry(knotnum)^2)), pi);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function angletaken=gerhardanglescombined(xstart,ystart,xtrial_global,ytrial_global,knot_x,knot_y,knot_rx,knot_ry,knot_theta,CasetoRunortheway_value,CasetoRunortheway_active)
	%if CasetoRunortheway_active=1, then CasetoRunortheway_value takes CasetoRun
	%if CasetoRunortheway_active=2, then CasetoRunortheway_value takes theway
	vernumberbefore=zeros(1,1);
	angletaken1=zeros(1,1);
	angletaken2=zeros(1,1);
	angletaken=zeros(1,1);
	anglefactor=zeros(1,1);
	flimit1=zeros(1,1);
	flimit2=zeros(1,1);
	f=zeros(1,1);
	xtrial=xtrial_global-xstart;
	ytrial=ytrial_global-ystart;
	option=1;
	if CasetoRunortheway_active==1
		if CasetoRunortheway_value==36 || CasetoRunortheway_value==37 || CasetoRunortheway_value==56 || CasetoRunortheway_value==60 || CasetoRunortheway_value==63
			option=1;
		else
			option=2;
		end
	else%if CasetoRunortheway_active==2
		if CasetoRunortheway_value==3
			option=1;
		else%if CasetoRunortheway_value==1 || CasetoRunortheway_value==2
			option=2;
		end
	end
	if ytrial<0 || ytrial>150
		angletaken1=-inf;
		fprintf('%s',['wrong y trial! pausing...' char(10)]);
		pause;
		1;
		return
	end
	positions=[	3	6	11	13.5	18.5	22.5	27.5	35	42.3	47.5	60	87.5	101.5	107	112	118.3	122.5	;
		2.5	6.5	10.5	13.5	18.5	23	27.5	35	42.5	47.5	60.5	87.5	101.5	107	112	118.5	122.5	;
		2.5	6.5	10.5	13.5	18.5	23.5	28	35	42.5	47	59.5	87.8	101.5	107	112	119	122	;
		2.4	5.5	10	12.2	18.5	23.5	28.4	35.5	42.5	47.4	59.5	88.2	101.5	107.3	112.1	119.1	122.5	;
		1.8	5.5	9.5	12.5	18.1	23.1	28	35	42.5	47	59	88.5	101.5	107.3	112.5	118.6	122.5	;
		1.5	5.5	9.5	12.5	18	23.6	28	35	42	47	58.5	88.5	102	107.5	114	119	123	;
		1.5	6.5	9.8	13	18	23	27.7	35	42	47	58.5	89	102.5	107.7	114.6	119.4	123	;
		1.4	5.4	9.7	12.6	17.8	23.4	27.7	35	42.1	47	57.6	89.5	102.6	108	115.4	119.6	123.5	;
		1.2	5.3	9.7	12.8	17.7	22.6	28	34.8	41.6	46.8	57.5	89.5	103.5	108.4	115.5	120	123.8	;
		1	4.6	9.5	12.5	17.5	22.5	27.7	34.6	41.5	47	56.5	90.5	104	108.5	116.5	120.5	124.5	;
		1	4	9.5	12.5	17	22.5	27.5	34.5	41.5	47.2	55.5	91.4	104.5	108.7	116.6	121.5	126	;
		0.8	3.4	9.1	12.4	16.9	21.7	27.4	33.8	41.5	46.5	55.2	92.5	104.5	109.5	117	122	126.5	;
		-1	3.2	8.8	11.5	16.7	21.1	27.1	33.5	41.5	46.4	56	93.7	104.9	109.6	117.1	122.5	127	;
		-2	3.1	8.5	11.2	16.5	20.1	26.5	33	40.9	45.6	57.5	93.4	105	110.1	116.9	122.5	127.3	;
		-3	2.5	7.9	10.5	16.5	19.5	25	32.5	39.2	45.1	59	93.5	105.5	110.5	117.1	122.8	127.7	;
		-3.4	1.9	7.5	10.4	16.3	19.6	24.4	32.1	38	44.6	59.5	93.6	105.6	110.6	117.3	122.9	127.9	;
		-3.9	1.6	7.1	9.8	15.4	18.6	23.5	30.8	35.5	44.5	59.5	93.5	105.6	110.6	117	122.6	127.9	;
		-4.1	1	6.5	9.4	14.5	18	21.5	29	33.5	46.7	59.8	93.4	105.6	110.8	117.3	122.7	127.8	;
		-4.5	0.5	5.7	8.5	14	17.2	19.5	25.5	31.5	47.5	60	92.6	105.8	111.3	117.4	123	127.9	;
		-4.9	-0.6	4.6	8.4	13.1	16	17.8	22	28.5	47.9	60	92.1	105.9	111.4	117.5	123.5	127.9	;
		-5.2	-1.1	3.8	8	12	14	16.6	20	24.5	47.8	59.5	91.5	106.5	111	117.4	123.4	127.8	;
		-5.6	-1.7	2.8	7.4	10.5	12.5	14.5	16.8	19.8	47.6	59.4	91.1	106.5	110.5	117.1	123.5	127.8	;
		-5.7	-1.9	2.3	7	9.2	11.4	13.5	15.4	17.4	47.5	58.6	90.6	105.7	110.4	116.9	123.4	127.7	;
		-5.8	-2	1.6	7	9	10.6	12.8	14.5	15.8	46.4	58.8	90.6	105.6	110	116.6	123.2	127.6	;
		-5.9	-2	1.4	6.8	9.1	10.6	12.7	14.1	15.6	45.5	58.5	90.1	105.4	109.6	116.6	123	127.3	;
		-5.9	-2.1	1.5	6.6	9.9	11.8	13.5	14.6	16.4	44	59	89.6	104.8	109.1	116.5	123	127	;
		-5.9	-2.1	1.5	6.8	11.4	13.4	15.1	16.4	18.9	42.4	59.6	89.6	104.3	108.5	116.5	122.6	126.6	;
		-5.9	-2	1.6	7.4	12.4	15.1	17.2	22.5	35	45.1	60.5	89.5	104	108.1	116.4	122.1	126	;
		-5.8	-1.9	1.7	7.4	13.1	16.4	19.5	30.1	39.5	46.4	61	89.1	103.4	107.4	115.8	121.4	124.9	;
		-5.7	-1.9	1.8	7.7	14.4	18.4	22.6	34.1	42.4	48.3	61.5	88.9	102.9	107.5	115.4	120.8	124.5	;
		-5.6	-1.8	1.9	8	15.4	19.6	24.5	36.1	43.6	49.2	61.9	88.8	102.5	107.6	114.5	120.5	124.2	;
		-5.4	-1	2.6	9.1	16.6	21.4	27.5	37.8	45.2	51.1	62.6	88.1	101.7	107.6	113.6	120.4	124	;
		-5.1	-0.1	4.8	10.5	18.1	22.4	28.7	39.2	46	52.1	63.4	88.7	101.5	107.5	113.3	119.8	123.4	;
		-4.2	1.2	7.1	11.6	18.7	23.4	29.7	39.6	46.1	52.8	63.1	88.5	101.5	107.5	113.4	119.5	123.4	;
		-3.4	2.1	9.4	12.6	19.5	24.1	30.5	40	46.4	53	63	88.4	101.5	107.5	113.4	119.4	123	;
		-2.1	2.7	10	12.8	20	24.6	31.4	40.1	46.7	52.8	62.8	88.4	102.3	107.5	113.6	119.4	123.4	;
		-0.8	3.6	10.1	13.4	20.6	25.1	31.5	40.4	46.4	52.8	62.6	88.6	102.6	107.5	113.8	119.5	123.4	;
		0.9	4.1	10	13.7	20.7	25.4	31.5	40.4	46.4	52.5	62.4	89.6	102.8	107.5	114.1	119.5	123.5	;
		0.9	4.5	10	13.8	20.8	25.4	31.5	40	46.1	52.6	62.7	89.6	102.8	107.6	114.3	119.5	123.5	];

	verticals=[	0	...
		5	...
		10	...
		15	...
		20	...
		25	...
		30	...
		35	...
		40	...
		45	...
		50	...
		55	...
		60	...
		65	...
		70	...
		72.5	...
		75	...
		77.5	...
		80	...
		82.5	...
		85	...
		87.5	...
		90	...
		92.5	...
		95	...
		97.5	...
		100	...
		102.5	...
		105	...
		107.5	...
		110	...
		115	...
		120	...
		125	...
		130	...
		135	...
		140	...
		145	...
		150	];


	%xtrial=45;
	%ytrial=85;

	for i=1:length(verticals)-1
		if ((ytrial>=verticals(i) && ytrial<=verticals(i+1)) || (ytrial<=verticals(i) && ytrial>=verticals(i+1)))
			vernumberbefore=i;
			yextrafactor=(ytrial-verticals(vernumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
			break;
		end
	end
	for i=1:size(positions,2)-1
		xbefore=positions(vernumberbefore,i)+(ytrial-verticals(vernumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore))*(positions(vernumberbefore+1,i)-positions(vernumberbefore,i));
		xafter=positions(vernumberbefore,i+1)+(ytrial-verticals(vernumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore))*(positions(vernumberbefore+1,i+1)-positions(vernumberbefore,i+1));
		if i==1 && xtrial<xbefore
			oneovergradient=(positions(vernumberbefore+1,i)-positions(vernumberbefore,i))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
			angletaken1=atan(1/oneovergradient);
			if angletaken1<0
				angletaken1=angletaken1+pi;
			end
			break;
		elseif i==(size(positions,2)-1) && xtrial>xafter
			oneovergradient=(positions(vernumberbefore+1,i+1)-positions(vernumberbefore,i+1))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
			angletaken1=atan(1/oneovergradient);
			if angletaken1<0
				angletaken1=angletaken1+pi;
			end
			break;
		elseif ((xtrial>=xbefore && xtrial<=xafter) || (xtrial<=xbefore && xtrial>=xafter))
			hornumberbefore=i;
			xextrafactor=(xtrial-xbefore)/(xafter-xbefore);
			oneovergradientbefore=(positions(vernumberbefore+1,hornumberbefore)-positions(vernumberbefore,hornumberbefore))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
			anglebefore=atan(1/oneovergradientbefore);
			if anglebefore<0
				anglebefore=anglebefore+pi;
			end
			oneovergradientafter=(positions(vernumberbefore+1,hornumberbefore+1)-positions(vernumberbefore,hornumberbefore+1))/(verticals(vernumberbefore+1)-verticals(vernumberbefore));
			angleafter=atan(1/oneovergradientafter);
			if angleafter<0
				angleafter=angleafter+pi;
			end
			angletaken1=anglebefore+xextrafactor*(angleafter-anglebefore);
			break;
		end
	end
	if option==1
		angletaken=angletaken1;
		for knotnum=1:2
			f=(cos(knot_theta(knotnum))*(knot_x(knotnum) - xtrial_global) + sin(knot_theta(knotnum))*(knot_y(knotnum) - ytrial_global))^2/knot_rx(knotnum)^2 + (cos(knot_theta(knotnum))*(knot_y(knotnum) - ytrial_global) - sin(knot_theta(knotnum))*(knot_x(knotnum) - xtrial_global))^2/knot_ry(knotnum)^2 - 1;
			angletaken2=mod(pi/2 + atan(((2*cos(knot_theta(knotnum))*(cos(knot_theta(knotnum))*(knot_y(knotnum) - ytrial_global) - sin(knot_theta(knotnum))*(knot_x(knotnum) - xtrial_global)))/knot_ry(knotnum)^2 + (2*sin(knot_theta(knotnum))*(cos(knot_theta(knotnum))*(knot_x(knotnum) - xtrial_global) + sin(knot_theta(knotnum))*(knot_y(knotnum) - ytrial_global)))/knot_rx(knotnum)^2)/((2*cos(knot_theta(knotnum))*(cos(knot_theta(knotnum))*(knot_x(knotnum) - xtrial_global) + sin(knot_theta(knotnum))*(knot_y(knotnum) - ytrial_global)))/knot_rx(knotnum)^2 - (2*sin(knot_theta(knotnum))*(cos(knot_theta(knotnum))*(knot_y(knotnum) - ytrial_global) - sin(knot_theta(knotnum))*(knot_x(knotnum) - xtrial_global)))/knot_ry(knotnum)^2)), pi);
			if knotnum==1
				flimit1=1;
				flimit2=5;
			elseif knotnum==2
				flimit1=1;
				flimit2=flimit1;
			end
				
			if f<flimit1
				angletaken=angletaken2;
			elseif f<flimit2
				anglefactor=(f-flimit1)/(flimit2-flimit1);
				angletaken=angletaken2*(1-anglefactor)+angletaken*anglefactor;
			end
		end
	else%if option==2
		knotnum=1;
		f=(cos(knot_theta(knotnum))*(knot_x(knotnum) - xtrial_global) + sin(knot_theta(knotnum))*(knot_y(knotnum) - ytrial_global))^2/knot_rx(knotnum)^2 + (cos(knot_theta(knotnum))*(knot_y(knotnum) - ytrial_global) - sin(knot_theta(knotnum))*(knot_x(knotnum) - xtrial_global))^2/knot_ry(knotnum)^2 - 1;
		angletaken2=mod(pi/2 + atan(((2*cos(knot_theta(knotnum))*(cos(knot_theta(knotnum))*(knot_y(knotnum) - ytrial_global) - sin(knot_theta(knotnum))*(knot_x(knotnum) - xtrial_global)))/knot_ry(knotnum)^2 + (2*sin(knot_theta(knotnum))*(cos(knot_theta(knotnum))*(knot_x(knotnum) - xtrial_global) + sin(knot_theta(knotnum))*(knot_y(knotnum) - ytrial_global)))/knot_rx(knotnum)^2)/((2*cos(knot_theta(knotnum))*(cos(knot_theta(knotnum))*(knot_x(knotnum) - xtrial_global) + sin(knot_theta(knotnum))*(knot_y(knotnum) - ytrial_global)))/knot_rx(knotnum)^2 - (2*sin(knot_theta(knotnum))*(cos(knot_theta(knotnum))*(knot_y(knotnum) - ytrial_global) - sin(knot_theta(knotnum))*(knot_x(knotnum) - xtrial_global)))/knot_ry(knotnum)^2)), pi);
		flimit1=1;
		flimit2=5;
		if f<flimit1
			angletaken=angletaken2;
		elseif f<flimit2
			anglefactor=(f-flimit1)/(flimit2-flimit1);
			angletaken=angletaken2*(1-anglefactor)+angletaken1*anglefactor;
		else
			angletaken=angletaken1;
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [connectivity] = CrackParticleClustering(x_sp,distancelimit,justcrackedlist)
	%--------------------------Determining cenection between particles--------------------%
	nspCount=length(justcrackedlist);
	nspconnectivitylength=zeros(1,nspCount);
	nspconnectivitycounter=zeros(1,nspCount);
	coder.varsize('nspconnectivitycounter');

	for i=1:nspCount
		for j=1:nspCount
			distance=x_sp(justcrackedlist(j),:)-x_sp(justcrackedlist(i),:);
			distancemag=sqrt(dot(distance,distance));
			if distancemag<distancelimit
				nspconnectivitylength(i)=nspconnectivitylength(i)+1;
			end
		end
	end
	nspconnectivity=cell(1,nspCount);
	for i=1:nspCount
		nspconnectivity{i}=zeros(1,nspconnectivitylength(i));
	end
	%nspconnectivity_temp=cell(nspCount,1); %apparently unused
	for i=1:nspCount
		for j=1:nspCount
			distance=x_sp(justcrackedlist(j),:)-x_sp(justcrackedlist(i),:);
			distancemag=sqrt(dot(distance,distance));
			if distancemag<distancelimit
				nspconnectivitycounter(i)=nspconnectivitycounter(i)+1;
				nspconnectivity{i}(1,nspconnectivitycounter(i))=j;
			end
		end
	end
	%--------------------------------------------------------------------------------%
	%----------------------Forming velocity fields based on nspconnectivity---------------%
	stopcounter=0;	                      %inital value for the counter calculation
	stop=0;	               %inital value for the counter
	while stop<1   %These calculation countiues until number of filled rows in nspconnectivity become unchanged.
		for i=1:length (nspconnectivity)	                                            %Moving on the rows of nspconnectivity
			for j=1:length (nspconnectivity{i})	                                       %Moving on the columns of nspconnectivity
				for k=i+1:length (nspconnectivity)	                                    %Elements of next lines should be checked for finding element (i,j). Moving on the rows of nspconnectivity in next lines.
					m=1;	                                                            %Elements of next lines should be checked for finding element (i,j). Moving on the columns of nspconnectivity in next lines. 
					while m<=length (nspconnectivity{k})	                              %This check can be stooped as soon as one element is found, since founding one conection is enough. While is used to easily stop this loop.
						
						if nspconnectivity{i}(j)<nspconnectivity{k}(m)	           %If bigger than (i,j). Then there is no point in checking more.               
							m=length (nspconnectivity{k})+1;	   
						elseif nspconnectivity{i}(j)>nspconnectivity{k}(m)	            %If smaller than (i,j, then next one should be checked                                               %If not equal to (i,j)and smaller. Then go to next and check again.             
							m=m+1;	                                                
						elseif nspconnectivity{i}(j)==nspconnectivity{k}(m)	           %If  equal to (i,j). This means that all particles on i and k are connected. Therefore, all particles of k will be moved to i. This will result in repeated particle on i which will be taken care of in the end of checking row i                     
							nspconnectivity{i}=[nspconnectivity{i} nspconnectivity{k}];   
							nspconnectivity{k}=zeros(1,0);
						end	            
					end	                    
				end
			end
			if length(nspconnectivity{i})>=0
				nspconnectivity{i}=unique(nspconnectivity{i}); %This will take care of repeated particle on row i
			end
		end
		%-------------While loop control------------%
		
		%nspconnectivity=nspconnectivity(~cellfun('isempty',nspconnectivity));	              %Removing empty cells
		nspconnectivity=EliminateEmptyCells(nspconnectivity);	              %Removing empty cells, coder friendly
		if stopcounter==length(nspconnectivity);	                                  %If size of nspconnectivity is the same as the last loop. Then finish the while loop
			stop=1;
		else	                                                                   %If not, then put the stopcounter equal to size of nspconnectivity. 
			stopcounter=length(nspconnectivity);
		end
		%-------------While loop control end------------%
	end
	
	connectivity=nspconnectivity;
	for i=1:length(nspconnectivity)
		for j=1:length(nspconnectivity{i})
			connectivity{i}(j)=justcrackedlist(nspconnectivity{i}(j));
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [connectivity] = CrackParticleClustering_nodes(LOC,distancelimit,justcrackedlist)
	%--------------------------Determining cenection between particles--------------------%
	nioCount=length(justcrackedlist);
	nioconnectivitylength=zeros(1,nioCount);
	nioconnectivitycounter=zeros(1,nioCount);
	coder.varsize('nioconnectivitycounter');

	for i=1:nioCount
		for j=1:nioCount
			distance=LOC(justcrackedlist(j),:)-LOC(justcrackedlist(i),:);
			distancemag=sqrt(dot(distance,distance));
			if distancemag<distancelimit
				nioconnectivitylength(i)=nioconnectivitylength(i)+1;
			end
		end
	end
	nioconnectivity=cell(1,nioCount);
	for i=1:nioCount
		nioconnectivity{i}=zeros(1,nioconnectivitylength(i));
	end
	%nspconnectivity_temp=cell(nioCount,1); %apparently unused
	for i=1:nioCount
		for j=1:nioCount
			distance=LOC(justcrackedlist(j),:)-LOC(justcrackedlist(i),:);
			distancemag=sqrt(dot(distance,distance));
			if distancemag<distancelimit
				nioconnectivitycounter(i)=nioconnectivitycounter(i)+1;
				nioconnectivity{i}(1,nioconnectivitycounter(i))=j;
			end
		end
	end
	%--------------------------------------------------------------------------------%
	%----------------------Forming velocity fields based on nioconnectivity---------------%
	stopcounter=0;	                      %inital value for the counter calculation
	stop=0;	               %inital value for the counter
	while stop<1   %These calculation countiues until number of filled rows in nioconnectivity become unchanged.
		for i=1:length (nioconnectivity)	                                            %Moving on the rows of nioconnectivity
			for j=1:length (nioconnectivity{i})	                                       %Moving on the columns of nioconnectivity
				for k=i+1:length (nioconnectivity)	                                    %Elements of next lines should be checked for finding element (i,j). Moving on the rows of nioconnectivity in next lines.
					m=1;	                                                            %Elements of next lines should be checked for finding element (i,j). Moving on the columns of nioconnectivity in next lines. 
					while m<=length (nioconnectivity{k})	                              %This check can be stooped as soon as one element is found, since founding one conection is enough. While is used to easily stop this loop.
						
						if nioconnectivity{i}(j)<nioconnectivity{k}(m)	           %If bigger than (i,j). Then there is no point in checking more.               
							m=length (nioconnectivity{k})+1;	   
						elseif nioconnectivity{i}(j)>nioconnectivity{k}(m)	            %If smaller than (i,j, then next one should be checked                                               %If not equal to (i,j)and smaller. Then go to next and check again.             
							m=m+1;	                                                
						elseif nioconnectivity{i}(j)==nioconnectivity{k}(m)	           %If  equal to (i,j). This means that all particles on i and k are connected. Therefore, all particles of k will be moved to i. This will result in repeated particle on i which will be taken care of in the end of checking row i                     
							nioconnectivity{i}=[nioconnectivity{i} nioconnectivity{k}];   
							nioconnectivity{k}=zeros(1,0);
						end	            
					end	                    
				end
			end
			if length(nioconnectivity{i})>=0
				nioconnectivity{i}=unique(nioconnectivity{i}); %This will take care of repeated particle on row i
			end
		end
		%-------------While loop control------------%
		
		%nioconnectivity=nioconnectivity(~cellfun('isempty',nioconnectivity));	              %Removing empty cells
		nioconnectivity=EliminateEmptyCells(nioconnectivity);	              %Removing empty cells, coder friendly
		if stopcounter==length(nioconnectivity);	                                  %If size of nioconnectivity is the same as the last loop. Then finish the while loop
			stop=1;
		else	                                                                   %If not, then put the stopcounter equal to size of nioconnectivity. 
			stopcounter=length(nioconnectivity);
		end
		%-------------While loop control end------------%
	end
	
	connectivity=nioconnectivity;
	for i=1:length(nioconnectivity)
		for j=1:length(nioconnectivity{i})
			connectivity{i}(j)=justcrackedlist(nioconnectivity{i}(j));
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [connectivity] = CrackParticleClustering_nodes_nocell(LOC,distancelimit,justcrackedlist)
	%--------------------------Determining cenection between particles--------------------%
	nioCount=length(justcrackedlist);
	nioconnectivitylength=zeros(1,nioCount);
	nioconnectivitycounter=zeros(1,nioCount);
	coder.varsize('nioconnectivitycounter');

	for i=1:nioCount
		for j=1:nioCount
			distance=LOC(justcrackedlist(j),:)-LOC(justcrackedlist(i),:);
			distancemag=sqrt(dot(distance,distance));
			if distancemag<distancelimit
				nioconnectivitylength(i)=nioconnectivitylength(i)+1;
			end
		end
	end
	nioconnectivity=cell(1,nioCount);
	for i=1:nioCount
		nioconnectivity{i}=zeros(1,nioconnectivitylength(i));
	end
	%nspconnectivity_temp=cell(nioCount,1); %apparently unused
	for i=1:nioCount
		for j=1:nioCount
			distance=LOC(justcrackedlist(j),:)-LOC(justcrackedlist(i),:);
			distancemag=sqrt(dot(distance,distance));
			if distancemag<distancelimit
				nioconnectivitycounter(i)=nioconnectivitycounter(i)+1;
				nioconnectivity{i}(1,nioconnectivitycounter(i))=j;
			end
		end
	end
	%--------------------------------------------------------------------------------%
	%----------------------Forming velocity fields based on nioconnectivity---------------%
	stopcounter=0;	                      %inital value for the counter calculation
	stop=0;	               %inital value for the counter
	while stop<1   %These calculation countiues until number of filled rows in nioconnectivity become unchanged.
		for i=1:length (nioconnectivity)	                                            %Moving on the rows of nioconnectivity
			for j=1:length (nioconnectivity{i})	                                       %Moving on the columns of nioconnectivity
				for k=i+1:length (nioconnectivity)	                                    %Elements of next lines should be checked for finding element (i,j). Moving on the rows of nioconnectivity in next lines.
					m=1;	                                                            %Elements of next lines should be checked for finding element (i,j). Moving on the columns of nioconnectivity in next lines. 
					while m<=length (nioconnectivity{k})	                              %This check can be stooped as soon as one element is found, since founding one conection is enough. While is used to easily stop this loop.
						
						if nioconnectivity{i}(j)<nioconnectivity{k}(m)	           %If bigger than (i,j). Then there is no point in checking more.               
							m=length (nioconnectivity{k})+1;	   
						elseif nioconnectivity{i}(j)>nioconnectivity{k}(m)	            %If smaller than (i,j, then next one should be checked                                               %If not equal to (i,j)and smaller. Then go to next and check again.             
							m=m+1;	                                                
						elseif nioconnectivity{i}(j)==nioconnectivity{k}(m)	           %If  equal to (i,j). This means that all particles on i and k are connected. Therefore, all particles of k will be moved to i. This will result in repeated particle on i which will be taken care of in the end of checking row i                     
							nioconnectivity{i}=[nioconnectivity{i} nioconnectivity{k}];   
							nioconnectivity{k}=zeros(1,0);
						end	            
					end	                    
				end
			end
			if length(nioconnectivity{i})>=0
				nioconnectivity{i}=unique(nioconnectivity{i}); %This will take care of repeated particle on row i
			end
		end
		%-------------While loop control------------%
		
		%nioconnectivity=nioconnectivity(~cellfun('isempty',nioconnectivity));	              %Removing empty cells
		nioconnectivity=EliminateEmptyCells(nioconnectivity);	              %Removing empty cells, coder friendly
		if stopcounter==length(nioconnectivity);	                                  %If size of nioconnectivity is the same as the last loop. Then finish the while loop
			stop=1;
		else	                                                                   %If not, then put the stopcounter equal to size of nioconnectivity. 
			stopcounter=length(nioconnectivity);
		end
		%-------------While loop control end------------%
	end
	
	connectivity=nioconnectivity;
	for i=1:length(nioconnectivity)
		for j=1:length(nioconnectivity{i})
			connectivity{i}(j)=justcrackedlist(nioconnectivity{i}(j));
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit_boxcalc,maplist,maplistsize]=Base3Mapping_sp_boxcalc(TheFieldSplitBase3_sp_boxcalc,x_crack_boxcalc_active,CONNECT,maplist,maplistsize)
	%coder.varsize('maplist');
	%CONNECT, also known outside as CONNECT_crack.boxcalc
	ncrackpath=size(TheFieldSplitBase3_sp_boxcalc,5);
	
	TheFieldSplit_boxcalc=zeros(4,4,2,ncrackpath); %iro a.k.a. the relevant node number, corner number, tip number, crackpath number
	for ipath2=1:ncrackpath
	for itip=1:2
	if x_crack_boxcalc_active(ipath2,itip)==1
	for icorner=1:4
	for iro=1:4
		matchfound=0;
		for imaplist=1:maplistsize
			summaplistequal=0;
			for jmaplist=1:size(maplist,2)
				if maplist(imaplist,jmaplist)==TheFieldSplitBase3_sp_boxcalc(iro,icorner,itip,ipath2,jmaplist)
					summaplistequal=summaplistequal+1;
				end
			end
			if summaplistequal==ncrackpath
				matchfound=1;
				TheFieldSplit_boxcalc(iro,icorner,itip,ipath2)=imaplist;
				break;
			end
		end
		if matchfound==0
			maplistsize=maplistsize+1;
			TheFieldSplit_boxcalc(iro,icorner,itip,ipath2)=maplistsize;
			for ipath=1:ncrackpath
				maplist(maplistsize,ipath)=TheFieldSplitBase3_sp_boxcalc(iro,icorner,itip,ipath2,ipath);
			end
		end
	end
	end
	end
	end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit,maplist,maplistsize]=Base3Mapping_sp(TheFieldSplitBase3,CONNECT,maplist,maplistsize,niCount)
	%coder.varsize('maplist');
	spCount=size(TheFieldSplitBase3,2);
	ncrackpath=size(TheFieldSplitBase3,3);
	spSizes=zeros(1,spCount);
	for sp=1:spCount
		spSizes(sp)=length(CONNECT{sp});
	end
	TheFieldSplit=zeros(max(spSizes),spCount);
	for sp=1:spCount
		for nni=1:spSizes(sp)
			ni=CONNECT{sp}(nni);
			matchfound=0;
			for imaplist=1:maplistsize
				summaplistequal=0;
				for jmaplist=1:size(maplist,2)
					if maplist(imaplist,jmaplist)==TheFieldSplitBase3(nni,sp,jmaplist)
						summaplistequal=summaplistequal+1;
					end
				end
				if summaplistequal==ncrackpath
					matchfound=1;
					TheFieldSplit(nni,sp)=imaplist;
					break;
				end
			end
			if matchfound==0
				maplistsize=maplistsize+1;
				TheFieldSplit(nni,sp)=maplistsize;
				for j=1:ncrackpath
					maplist(maplistsize,j)=TheFieldSplitBase3(nni,sp,j);
				end
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit,maplist,maplistsize]=Base3Mapping(TheFieldSplitBase3_old,CONNECTpn,maplist,maplistsize,spCount)
	%coder.varsize('maplist');
	ncrackpath=size(TheFieldSplitBase3_old{1},2);
	TheFieldSplit=ones(length(TheFieldSplitBase3_old),spCount);
	for i=1:size(CONNECTpn,1)
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2)
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			matchfound=0;
			for imaplist=1:maplistsize
				if sum(maplist(imaplist,:)==TheFieldSplitBase3_old{i}(nsp,:))==ncrackpath;
					matchfound=1;
					TheFieldSplit(i,sp)=imaplist;
					break;
				end
			end
			if matchfound==0
				maplistsize=maplistsize+1;
				TheFieldSplit(i,sp)=maplistsize;
				for j=1:ncrackpath
					maplist(maplistsize,j)=TheFieldSplitBase3_old{i}(nsp,j);
				end
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [TheFieldSplit,maplist,maplistsize]=Base3Mapping_crack(TheFieldSplitBase3_sp,CONNECTpn,CONNECT,spSizes,maplist,maplistsize)
	spCount=size(CONNECT,1);
	ncrackpath=size(TheFieldSplitBase3_sp,3);
	TheFieldSplit=ones(size(TheFieldSplitBase3_sp,1),size(TheFieldSplitBase3_sp,2));
	for sp=1:spCount
		for nni=1:spSizes(sp)
			%i=CONNECT(sp,nni);
			matchfound=0;
			for imaplist=1:maplistsize
				summaplistequal=0;
				for jmaplist=1:size(maplist,2)
					if maplist(imaplist,jmaplist)==TheFieldSplitBase3_sp(nni,sp,jmaplist);
						summaplistequal=summaplistequal+1;
					end
				end
				if summaplistequal==ncrackpath;
					matchfound=1;
					TheFieldSplit(nni,sp)=imaplist;
					break;
				end
			end
			if matchfound==0
				maplistsize=maplistsize+1;
				TheFieldSplit(nni,sp)=maplistsize;
				for j=1:size(TheFieldSplitBase3_sp,3)
					maplist(maplistsize,j)=TheFieldSplitBase3_sp(nni,sp,j);
					%maplist=MatrixInsertion(maplist,size(maplist,1)+1,j,TheFieldSplitBase3_sp(nni,sp,j));
				end
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%{
function [TheFieldSplit,maplist,maplistsize]=Base3Mapping_crack_nocellboth(TheFieldSplitBase3_cracktop,TheFieldSplitBase3_crackbot,CONNECTpn,maplist,maplistsize)
	ncrackpath=size(TheFieldSplitBase3_cracktop,3);
	TheFieldSplit.top=ones(size(TheFieldSplitBase3_cracktop,1),size(TheFieldSplitBase3_cracktop,2));
	TheFieldSplit.bot=ones(size(TheFieldSplitBase3_crackbot,1),size(TheFieldSplitBase3_crackbot,2));
	for i=1:size(CONNECTpn,1)
		CONNECTpnLength=0;
		for j=1:size(CONNECTpn,2)
			if CONNECTpn(i,j)>0
				CONNECTpnLength=CONNECTpnLength+1;
			else
				break;
			end
		end
		for nsp=1:CONNECTpnLength
			sp=CONNECTpn(i,nsp);
			matchfound=0;
			for imaplist=1:maplistsize
				summaplistequal=0;
				for jmaplist=1:size(maplist,2)
					if maplist(imaplist,jmaplist)==TheFieldSplitBase3_cracktop(i,sp,jmaplist);
						summaplistequal=summaplistequal+1;
					end
				end
				if summaplistequal==ncrackpath;
					matchfound=1;
					TheFieldSplit(i,sp)=imaplist;
					break;
				end
			end
			if matchfound==0
				maplistsize=maplistsize+1;
				TheFieldSplit(i,sp)=maplistsize;
				for j=1:size(TheFieldSplitBase3_cracktop,3)
					maplist(maplistsize,j)=TheFieldSplitBase3_cracktop(i,sp,j);
					%maplist=MatrixInsertion(maplist,size(maplist,1)+1,j,TheFieldSplitBase3_cracktop(i,sp,j));
				end
			end
		end
	end
end
%}
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function integeroutput=integermapping(integerinput,integermapper)
	for i=1:length(integermapper)
		if integerinput==integermapper(i)
			integeroutput=i;
			break;
		end
		if i==length(integermapper)
			fprintf('%s',['integer mapping failed! code 1904201805' char(10)]);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function newtensor=rotatetensorfromold(oldtensor,oldn1)
	oldn1=oldn1/sqrt(dot(oldn1,oldn1));
	
	%newn1=newn1/sqrt(dot(newn1,newn1));
	
	oldn13d=[oldn1(1) oldn1(2) 0];
	oldn23d=cross([0 0 1],oldn13d);
	oldn2=[oldn23d(1) oldn23d(2)];
	
	%newn13d=[newn1(1) newn1(2) 0];
	%newn23d=cross([0 0 1],newn13d);
	%newn2=[newn23d(1) newn23d(2)];
	
	a=[oldn1(1) oldn2(1);
	   oldn1(2) oldn2(2)];
	
	newtensor=zeros(2,2);
	for i=1:2
		for j=1:2
			for m=1:2
				for n=1:2
					newtensor(i,j)=newtensor(i,j)+a(i,m)*a(j,n)*oldtensor(m,n);
				end
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function newtensor=rotatetensorfromoldtonew(oldtensor,oldn1,newn1)
	oldn1=oldn1/sqrt(dot(oldn1,oldn1));
	
	newn1=newn1/sqrt(dot(newn1,newn1));
	
	oldn13d=[oldn1(1) oldn1(2) 0];
	oldn23d=cross([0 0 1],oldn13d);
	oldn2=[oldn23d(1) oldn23d(2)];
	
	newn13d=[newn1(1) newn1(2) 0];
	newn23d=cross([0 0 1],newn13d);
	newn2=[newn23d(1) newn23d(2)];
	
	afromold=[oldn1(1) oldn2(1);
	   oldn1(2) oldn2(2)];
	atonew=[newn1(1) newn1(2);
	   newn2(1) newn2(2)];
	
	a=atonew*afromold;

	newtensor=zeros(2,2);
	for i=1:2
		for j=1:2
			for m=1:2
				for n=1:2
					newtensor(i,j)=newtensor(i,j)+a(i,m)*a(j,n)*oldtensor(m,n);
				end
			end
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function newtensor=rotatetensortonew(oldtensor,newn1)
	%oldn1=oldn1/sqrt(dot(oldn1,oldn1));
	
	newn1=newn1/sqrt(dot(newn1,newn1));
	
	%oldn13d=[oldn1(1) oldn1(2) 0];
	%oldn23d=cross([0 0 1],oldn13d);
	%oldn2=[oldn23d(1) oldn23d(2)];
	
	newn13d=[newn1(1) newn1(2) 0];
	newn23d=cross([0 0 1],newn13d);
	newn2=[newn23d(1) newn23d(2)];
	
	%a=[oldn1(1) oldn2(1);
	%   oldn1(2) oldn2(2)];
	a=[newn1(1) newn1(2);
	   newn2(1) newn2(2)];
	
	newtensor=zeros(2,2);
	for i=1:2
		for j=1:2
			for m=1:2
				for n=1:2
					newtensor(i,j)=newtensor(i,j)+a(i,m)*a(j,n)*oldtensor(m,n);
				end
			end
		end
	end
end



%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

%{
%switchable1
function plotsigmainfconvergence()
	%meant to be copy-pasted
	%clear all
	close all
	clc
	convergence=[transpose(spCount) transpose(sigmainf)];

	loglog(convergence(:,1),convergence(:,2),'-x');
	hold on
	xlabel('number of particles');
	ylabel('sigma inf at propagation (MPa)');
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function plotnormsigmavsparticle()
	%meant to be copy-pasted
	%clear all
	close all
	clc
	convergence=[transpose(spCount) transpose(stressnormpersigmainf)];

	loglog(convergence(:,1),convergence(:,2),'-x');
	hold on
	xlabel('number of particles');
	ylabel('stressnormpersigmainf');
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function plotnormsigmavsgridsize()
	%meant to be copy-pasted
	%clear all
	close all
	clc
	convergence=[transpose(gridsize) transpose(stressnormpersigmainf)];

	loglog(convergence(:,1),convergence(:,2),'-x','DisplayName','Varies');
	hold on
	xlabel('grid size (mm)');
	ylabel('relative stress norm');
	set(gca,'XDir','reverse')
	set(gca,'xlim',[0.1 10]);
	n=length(gridsize);
	slope=log(stressnormpersigmainf(n)/stressnormpersigmainf(n-1))/log(gridsize(n)/gridsize(n-1))
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function plotGerror()
	%meant to be copy-pasted
	%clear all
	close all
	clc
	convergence=[transpose(gridsize) transpose(Grelativeerror)];

	loglog(convergence(:,1),convergence(:,2),'-x');
	hold on
	xlabel('grid size (mm)');
	ylabel('G relative error');
	set(gca,'XDir','reverse')
	set(gca,'xlim',[0.1 10]);
	n=length(gridsize);
	slope=log(Grelativeerror(n)/Grelativeerror(n-1))/log(gridsize(n)/gridsize(n-1))
end
%}
%switchable1

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- START CADAPT FUNCTIONS -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function CellOut=ResizeCell(CellIn,NewLength)
	CellOut=zeros(1,NewLength);
	for i=1:NewLength
		CellOut{i}=CellIn{i};
	end
end

function MatrixOut=ResizeMatrix(MatrixIn,NewSize1,NewSize2)
	MatrixOut=zeros(NewSize1,NewSize2);
	if NewSize1>size(MatrixIn,1)
		LoopSize1=size(MatrixIn,1);
	else
		LoopSize1=NewSize1;
	end
	if NewSize2>size(MatrixIn,2)
		LoopSize2=size(MatrixIn,2);
	else
		Loopsize2=NewSize2;
	end
	for i=1:LoopSize1
		for j=1:LoopSize2
			MatrixOut(i,j)=MatrixIn(i,j);
		end
	end
end

function VectorOut=ResizeVector(VectorIn,NewLength)
	VectorOut=zeros(1,NewLength);
	if NewLength>length(VectorIn)
		LoopLength=length(VectorIn);
	else
		LoopLength=NewLength;
	end
	for i=1:LoopLength
		VectorOut(i)=VectorIn(i);
	end
end

function CellOut=EliminateEmptyCells(CellIn);
	OldLength=length(CellIn);
	NewLength=OldLength;
	iNew=1;
	iNewtoOld=ones(1,OldLength);
	for iOld=1:OldLength
		if length(CellIn{iOld})==0
			NewLength=NewLength-1;
		else
			iNewtoOld(iNew)=iOld;
			iNew=iNew+1;
		end
	end
	CellOut=cell(1,NewLength);
	
	% old limit
	for iNew=1:NewLength
		CellOut{iNew}=CellIn{iNewtoOld(iNew)};
	end
end

function MatrixOutput=VectorizedMatrixInsertion1(MatrixInput,index,RowVectorInput)
	Size1=size(MatrixInput,1); %old row count of MatrixInput
	Size2=size(MatrixInput,2);
	if Size2==size(RowVectorInput,2)
		if index>Size1
			MatrixOutput=zeros(index,Size2);
			MatrixOutput(1:Size1,:)=MatrixInput;
			MatrixOutput(index,:)=RowVectorInput;
		else
			MatrixOutput=MatrixInput;
			MatrixOutput(index,:)=RowVectorInput;
		end
	else
		MatrixOutput=[];
	end
end

function StringOutput=float2txt(NDigits,FloatInput)
	if length(FloatInput)==0
		StringOutput='0';
	elseif FloatInput<=0
		StringOutput='0';
	else
		integerdigits=myfloor(log10(FloatInput))+1;
		if integerdigits<0
			integerdigits=0;
		end
		decimaldigits=max(0,NDigits-integerdigits);
		if decimaldigits>0
			chararray=zeros(1,NDigits+1);
		else
			chararray=zeros(1,NDigits);
		end
		for i=1:integerdigits
			chararray(i)=mod(myfloor(FloatInput*10^-(integerdigits-i)),10)+48;
		end
		if decimaldigits>0
			chararray(integerdigits+1)=46;
		end
		for i=1:decimaldigits
			chararray(i+integerdigits+1)=mod(myfloor(FloatInput*10^-(integerdigits-integerdigits-i)),10)+48;
		end
		StringOutput=char(chararray);
	end
end

function savestring(StringInput,TextFile)
	TheData=fopen(TextFile,'w');
	for i=1:length(StringInput)
		fprintf(TheData,'%s',StringInput(i));
	end
	fclose(TheData);
end

function StringOutput=loadstring(TextFile)
	TextFileOpen=fopen(TextFile);
	StringOutput=char(fread(TextFileOpen,[1,Inf],'char'));
	fclose(TextFileOpen);
end

function chararray=int2chararray(intinput)
	if intinput<=0
		chararray=[48];
	else
		digits=myfloor(log10(intinput))+1;
		chararray=zeros(1,digits);
		for i=1:digits
			chararray(i)=mod(myfloor(intinput*10^-(digits-i)),10)+48;
		end
	end
end

function txtoutput=int2txt_debug(intinput)
	fprintf('%s',['>>line 24207 entered int2txt_debug' char(10)]);
	fprintf('%s',['>>line 24208: intinput=' float2txt(5,intinput) char(10)]);
	txtoutput='123456789';
	coder.varsize('txtoutput');
	txtoutput='';
	floored=0;
	if intinput<=0
		txtoutput='0';
		fprintf('%s',['>>line 24211: txtoutput=' txtoutput char(10)]);
	else
		fprintf('%s',['>>line 24672: log10(intinput)=' float2txt(5,log10(intinput)) char(10)]);
		fprintf('%s',['>>line 24673: floor(log10(intinput))=' float2txt(5,floor(log10(intinput))) char(10)]);
		fprintf('%s',['>>line 24674: floor(log10(intinput))+1=' float2txt(5,floor(log10(intinput))+1) char(10)]);
		digits=floor(log10(intinput))+1;
		fprintf('%s',['>>line 24214: digits=' float2txt(5,digits) char(10)]);
		chararray=zeros(1,digits);
		for i=1:length(chararray)
			fprintf('%s',['>>line 24127: chararray(i)=' float2txt(5,chararray(i)) char(10)]);
		end
		fprintf('%s',['>>line 24219 entering digits loop' char(10)]);
		for i=1:digits
			fprintf('%s',['>>line 24683: i=' float2txt(5,i) char(10)]);
			fprintf('%s',['>>line 24684: intinput=' float2txt(5,intinput) char(10)]);
			fprintf('%s',['>>line 24685: digits=' float2txt(5,digits) char(10)]);
			fprintf('%s',['>>line 24686: -(digits-i)=' float2txt(5,-(digits-i)) char(10)]);
			fprintf('%s',['>>line 24687: 10^-(digits-i)=' float2txt(5,10^-(digits-i)) char(10)]);
			fprintf('%s',['>>line 24688: intinput*10^-(digits-i)=' float2txt(5,intinput*10^-(digits-i)) char(10)]);
			tobefloored=mod(intinput*10^-(digits-i),10);
			fprintf('%s',['>>line 24688: tobefloored=' float2txt(5,tobefloored) char(10)]);
			if tobefloored<1
				fprintf('%s',['tobefloored < 1!' char(10)]);
				floored=0;
			elseif tobefloored<2
				fprintf('%s',['tobefloored < 2!' char(10)]);
				floored=1;
			elseif tobefloored<3
				fprintf('%s',['tobefloored < 3!' char(10)]);
				floored=2;
			elseif tobefloored<4
				fprintf('%s',['tobefloored < 4!' char(10)]);
				floored=3;
			elseif tobefloored<5
				fprintf('%s',['tobefloored < 5!' char(10)]);
				floored=4;
			elseif tobefloored<6
				fprintf('%s',['tobefloored < 6!' char(10)]);
				floored=5;
			elseif tobefloored<7
				fprintf('%s',['tobefloored < 7!' char(10)]);
				floored=6;
			elseif tobefloored<8
				fprintf('%s',['tobefloored < 8!' char(10)]);
				floored=7;
			elseif tobefloored<9
				fprintf('%s',['tobefloored < 9!' char(10)]);
				floored=8;
			elseif tobefloored<10
				fprintf('%s',['tobefloored < 10!' char(10)]);
				floored=9;
			else
				fprintf('%s',['Conversion Error(1)!' char(10)]);
				fprintf('%s',['Conversion Error(2)!' char(10)]);
				fprintf('%s',['Conversion Error(3)!' char(10)]);
				fprintf('%s',['Conversion Error(4)!' char(10)]);
				fprintf('%s',['Conversion Error(5)!' char(10)]);
			end
			tobefloored=intinput*10^-(digits-i);
			floored2=tobefloored-mod(tobefloored,1);
			floored3=mod(tobefloored-mod(tobefloored,1),10);
			floored4=floor(floored3);
			fprintf('%s',['>>line 24688: floored=' float2txt(5,floored) char(10)]);
			fprintf('%s',['>>line 24688: floored2=' float2txt(5,floored2) char(10)]);
			fprintf('%s',['>>line 24688: floored3=' float2txt(5,floored3) char(10)]);
			fprintf('%s',['>>line 24688: floored4=' float2txt(5,floored4) char(10)]);
			fprintf('%s',['>>line 24693: floor(intinput*10^-(digits-i))=' float2txt(5,floor(intinput*10^-(digits-i))) char(10)]);
			fprintf('%s',['>>line 24694: mod(floor(intinput*10^-(digits-i)),10)=' float2txt(5,mod(floor(intinput*10^-(digits-i)),10)) char(10)]);
			fprintf('%s',['>>line 24695: mod(floor(intinput*10^-(digits-i)),10)+48=' float2txt(5,mod(floor(intinput*10^-(digits-i)),10)+48) char(10)]);
			fprintf('%s',['>>line 24696: chararray(i)=' float2txt(5,chararray(i)) char(10)]);
			fprintf('%s',['calculating new chararray(i)...' char(10)]);
			chararray(i)=mod(floor(intinput*10^-(digits-i)),10)+48;
			fprintf('%s',['>>line 24232: chararray(i)=' float2txt(5,chararray(i)) char(10)]);
		end
		fprintf('%s',['>>line 24234 out of digits loop' char(10)]);
		for i=1:length(chararray)
			fprintf('%s',['>>line 24236: chararray(i)=' float2txt(5,chararray(i)) char(10)]);
		end
		txtoutput=char(chararray);
		fprintf('%s',['>>line 24239: txtoutput=' txtoutput char(10)]);
	end
	fprintf('%s',['>>line 24241 exitting int2txt_debug' char(10)]);
end

function floored=myfloor(numberinput);
	floored=floor(numberinput-mod(numberinput,1));
end

function txtoutput=int2txt(intinput)
	txtoutput='123456789';
	coder.varsize('txtoutput');
	txtoutput='';
	if intinput<=0
		txtoutput='0';
	else
		digits=myfloor(log10(intinput))+1;
		chararray=zeros(1,digits);
		for i=1:digits
			chararray(i)=mod(myfloor(intinput*10^-(digits-i)),10)+48;
		end
		txtoutput=char(chararray);
	end
end

function txtoutput=int2txt_original(intinput)
	txtoutput='123456789';
	coder.varsize('txtoutput');
	txtoutput='';
	if intinput<=0
		txtoutput='0';
	else
		digits=floor(log10(intinput))+1;
		chararray=zeros(1,digits);
		for i=1:digits
			chararray(i)=mod(floor(intinput*10^-(digits-i)),10)+48;
		end
		txtoutput=char(chararray);
	end
end

function savecellmatrixfloat(TheCell,TextFile)
	dummy=0;
	dummy=length(TheCell);
	dummy=dummy+1;
	TheData=fopen(TextFile,'w');
	CellLength=length(TheCell);
	for iCell=CellLength:-1:1
		if iCell<CellLength
			fprintf(TheData,char(10));
		end
		fprintf(TheData,char(123));
		fprintf(TheData,'%s',int2txt(iCell));
		fprintf(TheData,char(125));
		fprintf(TheData,'\n');
		rowsize=size(TheCell{iCell},1);
		columnsize=size(TheCell{iCell},2);
		for i=1:rowsize
			if i>1
				fprintf(TheData,'\n');
			end
			for j=1:columnsize
				if j>1
					fprintf(TheData,char(9));
				end
				fprintf(TheData,'%s',float2scitxt(16,TheCell{iCell}(i,j)));
			end
		end
	end
	fclose(TheData);
end

function savecellmatrixfloat_original(TheCell,TextFile)
	dummy=0;
	dummy=length(TheCell);
	dummy=dummy+1;
	TheData=fopen(TextFile,'w');
	CellLength=length(TheCell);
	for iCell=CellLength:-1:1
		if iCell<CellLength
			fprintf(TheData,char(10));
		end
		fprintf(TheData,char(123));
		fprintf(TheData,'%s',int2txt(iCell));
		fprintf(TheData,char(125));
		fprintf(TheData,'\n');
		rowsize=size(TheCell{iCell},1);
		columnsize=size(TheCell{iCell},2);
		for i=1:rowsize
			if i>1
				fprintf(TheData,'\n');
			end
			for j=1:columnsize
				if j>1
					fprintf(TheData,char(9));
				end
				fprintf(TheData,'%s',float2scitxt(16,TheCell{iCell}(i,j)));
			end
		end
	end
	fclose(TheData);
end

function savematrix3floatcell(TheCell,TheSizes,nCell,TextFile)
	dummy=0;
	dummy=length(TheCell);
	dummy=dummy+1;
	TheData=fopen(TextFile,'w');
	CellLength=nCell;
	for iCell=CellLength:-1:1
		if iCell<CellLength
			fprintf(TheData,char(10));
		end
		fprintf(TheData,char(123));
		fprintf(TheData,'%s',int2txt(iCell));
		fprintf(TheData,char(125));
		fprintf(TheData,'\n');
		rowsize=TheSizes(iCell);
		columnsize=size(TheCell(:,:,1),2);
		for i=1:rowsize
			if i>1
				fprintf(TheData,'\n');
			end
			for j=1:columnsize
				if j>1
					fprintf(TheData,char(9));
				end
				fprintf(TheData,'%s',float2scitxt(16,TheCell(i,j,iCell)));
			end
		end
	end
	fclose(TheData);
end

function savematrix3float(TheMatrix3,TextFile)
	dummy=0;
	dummy=size(TheMatrix3,3);
	dummy=dummy+1;
	TheData=fopen(TextFile,'w');
	nSize1=size(TheMatrix3,1);
	nSize2=size(TheMatrix3,2);
	nSize3=size(TheMatrix3,3);
	for iSize3=nSize3:-1:1
		if iSize3<nSize3
			fprintf(TheData,char(10));
		end
		fprintf(TheData,char(123));
		fprintf(TheData,'%s',int2txt(iSize3));
		fprintf(TheData,char(125));
		fprintf(TheData,'\n');
		for iSize1=1:nSize1
			if iSize1>1
				fprintf(TheData,'\n');
			end
			for iSize2=1:nSize2
				if iSize2>1
					fprintf(TheData,char(9));
				end
				fprintf(TheData,'%s',float2scitxt(16,TheMatrix3(iSize1,iSize2,iSize3)));
			end
		end
	end
	fclose(TheData);
end

function CellSizes=loadcellsizes(TextFile)
	TextFileOpen=fopen(TextFile);
	TextFileChar=fread(TextFileOpen,[1,Inf],'char');
	fclose(TextFileOpen);
	if length(TextFileChar)>0
		ReadState=0;
		CurrentCellIndex=0;
		for i=1:length(TextFileChar)
			if TextFileChar(i)==123
				ReadState=3;
			elseif TextFileChar(i)>=48 && TextFileChar(i)<=57
				CurrentDigit=TextFileChar(i)-48;
				if ReadState==3
					CurrentCellIndex=CurrentCellIndex*10+CurrentDigit;
				end
			elseif i>1 && TextFileChar(i)==10 && TextFileChar(i-1)==125
				break;
			end
		end
		CellSizes=zeros(CurrentCellIndex,2);
		firstline=1;
		EmptyCell=1;
		CurrentCellIndex=0;
		CurrentDigit=0;
		columnsize=1;
		rowsize=0;
		for i=1:length(TextFileChar)
			if TextFileChar(i)==123
				ReadState=3;
				if i>1
					if EmptyCell==0
						CellSizes(CurrentCellIndex,1)=rowsize;
						CellSizes(CurrentCellIndex,2)=columnsize;
					else
						CellSizes(CurrentCellIndex,1)=0;
						CellSizes(CurrentCellIndex,2)=0;
					end
				end
				CurrentCellIndex=0;
			elseif i>0 && TextFileChar(i)==10 && TextFileChar(i-1)==125
				ReadState=4;
				EmptyCell=1;
				columnsize=1;
				rowsize=0;
				firstline=1;
			elseif TextFileChar(i)==9
				EmptyCell=0;
				if ReadState==4 && firstline==1
					columnsize=columnsize+1;
				end
			elseif TextFileChar(i)==10
				firstline=0;
				if ReadState==4
					rowsize=rowsize+1;
				end
			elseif ReadState==3 && TextFileChar(i)>=48 && TextFileChar(i)<=57
				CurrentDigit=TextFileChar(i)-48;
				CurrentCellIndex=CurrentCellIndex*10+CurrentDigit;
			elseif i==length(TextFileChar)
				rowsize=rowsize+1;
				if EmptyCell==0
					CellSizes(CurrentCellIndex,1)=rowsize;
					CellSizes(CurrentCellIndex,2)=columnsize;
				else
					CellSizes(CurrentCellIndex,1)=0;
					CellSizes(CurrentCellIndex,2)=0;
				end
			end
		end
		1;
	else
		CellSizes=zeros(1,2);
	end
		%{
		columnsize=1;
		rowsize=1;
		firstenter=0;
		for i=1:length(TextFileChar)
			if TextFileChar(i)==char(10)
				if firstenter==0
					firstenter=i;
				end
				rowsize=rowsize+1;
			end
			if firstenter==0
				if TextFileChar(i)==char(9)
					columnsize=columnsize+1;
				end
			end
		end		
		%}
		% ReadState legend: 0: integer reading, 1: decimal reading, 2:
		% exponential reading, 3: cell index reading, 4: prealocating
		% matrix sizes at each cell
		% char(48-57): numbers 0-9 X
		% char(9): tab
		% char(32): space
		% char(10): enter X
		% char(101): e X
		% char(43): + X
		% char(45): -
		% char(46): . X
		% char(123): {
		% char(125): }
end

function Matrix3Output=loadmatrix3float(TextFile)
	CellSizesList=loadcellsizes(TextFile);
	nSize1=CellSizesList(1,1);
	nSize2=CellSizesList(1,2);
	nSize3=size(CellSizesList,1);
	CellSized=cell(1,nSize3);
	for i=1:nSize3
		CellSized{i}=zeros(CellSizesList(i,1),CellSizesList(i,2));
	end
	Matrix3Output=zeros(nSize1,nSize2,nSize3);
	TextFileOpen=fopen(TextFile);
	TextFileChar=fread(TextFileOpen,[1,Inf],'char');
	fclose(TextFileOpen);
	if length(TextFileChar)>0
		% ReadState legend: 0: integer reading, 1: decimal reading, 2:
		% exponential reading, 3: cell index reading, 4: prealocating
		% matrix sizes at each cell
		% char(48-57): numbers 0-9 X
		% char(9): tab
		% char(32): space
		% char(10): enter X
		% char(101): e X
		% char(43): + X
		% char(45): -
		% char(46): . X
		% char(123): {
		% char(125): }
		
		ReadState=0;
		CurrentColumn=1;
		CurrentRow=1;
		CurrentNumber=0;
		CurrentExponent=0;
		CurrentDigit=0;
		NegativeSignNumber=0;
		NegativeSignExponent=0;
		DecimalDistance=0;
		CurrentCellIndex=0;
		EmptyCell=1;
		for i=1:length(TextFileChar)
			if CurrentCellIndex==2
				1;
			end
			if TextFileChar(i)==123
				ReadState=3;
				CurrentCellIndex=0;
			elseif i>1 && TextFileChar(i)==10 && TextFileChar(i-1)==125
				ReadState=0;
				CurrentColumn=1;
				CurrentRow=1;
				CurrentNumber=0;
				CurrentExponent=0;
				CurrentDigit=0;
				NegativeSignNumber=0;
				NegativeSignExponent=0;
				DecimalDistance=0;
				EmptyCell=1;
			elseif TextFileChar(i)==9 || TextFileChar(i)==10
				if EmptyCell==0
					Matrix3Output(CurrentRow,CurrentColumn,CurrentCellIndex)=((-1)^(NegativeSignNumber))*CurrentNumber*(10^(((-1)^(NegativeSignExponent))*(CurrentExponent)));
				end
				ReadState=0;
				CurrentNumber=0;
				CurrentExponent=0;
				NegativeSignNumber=0;
				NegativeSignExponent=0;
				if TextFileChar(i)==9
					CurrentColumn=CurrentColumn+1;
				elseif TextFileChar(i)==10
					CurrentColumn=1;
					CurrentRow=CurrentRow+1;
				end
			elseif TextFileChar(i)==46
				ReadState=1;
				DecimalDistance=1;
			elseif TextFileChar(i)==101
				ReadState=2;
				NegativeSignExponent=0;
				CurrentExponent=0;
			elseif TextFileChar(i)==43
				if ReadState==2
					NegativeSignExponent=0;
				else
					NegativeSignNumber=0;
				end
			elseif TextFileChar(i)==45
				if ReadState==2
					NegativeSignExponent=1;
				else
					NegativeSignNumber=1;
				end
			elseif TextFileChar(i)>=48 && TextFileChar(i)<=57
				EmptyCell=0;
				CurrentDigit=TextFileChar(i)-48;
				if ReadState==0
					CurrentNumber=CurrentNumber*10+CurrentDigit;
				elseif ReadState==1
					CurrentNumber=CurrentNumber+CurrentDigit/(10^DecimalDistance);
					DecimalDistance=DecimalDistance+1;
				elseif ReadState==2
					CurrentExponent=CurrentExponent*10+CurrentDigit;
				elseif ReadState==3
					CurrentCellIndex=CurrentCellIndex*10+CurrentDigit;
				end				
			end
		end
		if EmptyCell==0
			Matrix3Output(CurrentRow,CurrentColumn,CurrentCellIndex)=((-1)^(NegativeSignNumber))*CurrentNumber*(10^(((-1)^(NegativeSignExponent))*(CurrentExponent)));
		end
	end
end

function CellOutput=loadcellmatrixfloat(TextFile)
	CellSizesList=loadcellsizes(TextFile);
	CellSize=size(CellSizesList,1);
	CellSized=cell(1,CellSize);
	for i=1:CellSize
		CellSized{i}=zeros(CellSizesList(i,1),CellSizesList(i,2));
	end
	CellOutput=CellSized;
	TextFileOpen=fopen(TextFile);
	TextFileChar=fread(TextFileOpen,[1,Inf],'char');
	fclose(TextFileOpen);
	if length(TextFileChar)>0
		% ReadState legend: 0: integer reading, 1: decimal reading, 2:
		% exponential reading, 3: cell index reading, 4: prealocating
		% matrix sizes at each cell
		% char(48-57): numbers 0-9 X
		% char(9): tab
		% char(32): space
		% char(10): enter X
		% char(101): e X
		% char(43): + X
		% char(45): -
		% char(46): . X
		% char(123): {
		% char(125): }
		
		ReadState=0;
		CurrentColumn=1;
		CurrentRow=1;
		CurrentNumber=0;
		CurrentExponent=0;
		CurrentDigit=0;
		NegativeSignNumber=0;
		NegativeSignExponent=0;
		DecimalDistance=0;
		CurrentCellIndex=0;
		EmptyCell=1;
		for i=1:length(TextFileChar)
			if CurrentCellIndex==2
				1;
			end
			if TextFileChar(i)==123
				ReadState=3;
				CurrentCellIndex=0;
			elseif i>1 && TextFileChar(i)==10 && TextFileChar(i-1)==125
				ReadState=0;
				CurrentColumn=1;
				CurrentRow=1;
				CurrentNumber=0;
				CurrentExponent=0;
				CurrentDigit=0;
				NegativeSignNumber=0;
				NegativeSignExponent=0;
				DecimalDistance=0;
				EmptyCell=1;
			elseif TextFileChar(i)==9 || TextFileChar(i)==10
				if EmptyCell==0
					CellOutput{CurrentCellIndex}(CurrentRow,CurrentColumn)=((-1)^(NegativeSignNumber))*CurrentNumber*(10^(((-1)^(NegativeSignExponent))*(CurrentExponent)));
				end
				ReadState=0;
				CurrentNumber=0;
				CurrentExponent=0;
				NegativeSignNumber=0;
				NegativeSignExponent=0;
				if TextFileChar(i)==9
					CurrentColumn=CurrentColumn+1;
				elseif TextFileChar(i)==10
					CurrentColumn=1;
					CurrentRow=CurrentRow+1;
				end
			elseif TextFileChar(i)==46
				ReadState=1;
				DecimalDistance=1;
			elseif TextFileChar(i)==101
				ReadState=2;
				NegativeSignExponent=0;
				CurrentExponent=0;
			elseif TextFileChar(i)==43
				if ReadState==2
					NegativeSignExponent=0;
				else
					NegativeSignNumber=0;
				end
			elseif TextFileChar(i)==45
				if ReadState==2
					NegativeSignExponent=1;
				else
					NegativeSignNumber=1;
				end
			elseif TextFileChar(i)>=48 && TextFileChar(i)<=57
				EmptyCell=0;
				CurrentDigit=TextFileChar(i)-48;
				if ReadState==0
					CurrentNumber=CurrentNumber*10+CurrentDigit;
				elseif ReadState==1
					CurrentNumber=CurrentNumber+CurrentDigit/(10^DecimalDistance);
					DecimalDistance=DecimalDistance+1;
				elseif ReadState==2
					CurrentExponent=CurrentExponent*10+CurrentDigit;
				elseif ReadState==3
					CurrentCellIndex=CurrentCellIndex*10+CurrentDigit;
				end				
			end
		end
		if EmptyCell==0
			CellOutput{CurrentCellIndex}(CurrentRow,CurrentColumn)=((-1)^(NegativeSignNumber))*CurrentNumber*(10^(((-1)^(NegativeSignExponent))*(CurrentExponent)));
		end
	end
end

function OutputCell=CellInsertion(TheCell,index,ValueorMatrix)
	if index>length(TheCell)
		OutputCell=cell(1,index);
		for i=1:length(TheCell)
			OutputCell{i}=TheCell{i};
		end
		OutputCell{index}=ValueorMatrix;
	else
		OutputCell=TheCell;
		OutputCell{index}=ValueorMatrix;
	end
end

%{
function OutputCell=DoubleCellInsertion(TheCell,index1,index2,ValueorMatrix)
	if index1>length(TheCell)
		OutputCell=cell(1,index1);
		OutputCell{index1}=cell(1,index2);
		for i=1:length(TheCell)
			OutputCell{i}=TheCell{i};
		end
	else
		
	end
	if index2>length(TheCell{index1})
		OutputCell{index1}=cell(1,index2);
		for i=1:length(TheCell{index1})
			OutputCell{index1}{i}=TheCell{index1}{i};
		end
		OutputCell{index1}{index2}=ValueorMatrix;
	else
		OutputCell{index1}=TheCell{index1};
		OutputCell{index1}{index2}=ValueorMatrix;
	end
end
%}

function OutputMatrix=MatrixInsertion(InputMatrix,Row,Column,Value);
	OldRowSize=size(InputMatrix,1);
	OldColumnSize=size(InputMatrix,2);
	if Row>OldRowSize || Column>OldColumnSize
		NewRowSize=max(Row,OldRowSize);
		NewColumnSize=max(Column,OldColumnSize);
		OutputMatrix=zeros(NewRowSize,NewColumnSize);
		for i=1:OldRowSize
			for j=1:OldColumnSize
				OutputMatrix(i,j)=InputMatrix(i,j);
			end
		end
	else
		OutputMatrix=InputMatrix;
	end
	OutputMatrix(Row,Column)=Value;
end

function OutputMatrix=Matrix3Insertion(InputMatrix,Index1,Index2,Index3,Value);
	OldSize=zeros(1,3);
	OldSize=size(InputMatrix);
	NewSize=zeros(1,3);
	NewIndex=zeros(1,3);
	NewIndex=[Index1 Index2 Index3];
	KeepOldSize=1;
	for i=1:3
		if NewIndex(i)>OldSize(i)
			KeepOldSize=0;
			NewSize(i)=NewIndex(i);
		else
			NewSize(i)=OldSize(i);
		end
	end
	if KeepOldSize
		OutputMatrix=InputMatrix;
	else
		OutputMatrix=zeros(NewSize);
		for i=1:OldSize(1)
			for j=1:OldSize(2)
				for k=1:OldSize(3)
					OutputMatrix(i,j,k)=InputMatrix(i,j,k);
				end
			end
		end
	end
	OutputMatrix(Index1,Index2,Index3)=Value;
end

function OutputVector=VectorInsertion(TheVector,index,value)
	if index>length(TheVector)
		OutputVector=zeros(1,index);
		%for i=1:length(TheVector)
		%	OutputVector(i)=TheVector(i);
		%end
		OutputVector(1:length(TheVector))=TheVector;
		OutputVector(index)=value;
	else
		OutputVector=TheVector;
		OutputVector(index)=value;
	end
end

function ValueOutput=loadsinglelong(TextFile)
	TextFileOpen=fopen(TextFile);
	TextFileChar=fread(TextFileOpen,[1,Inf],'char');
	fclose(TextFileOpen);
	if length(TextFileChar)>0
		% ReadState legend: 0: integer reading, 1: decimal reading, 2: exponential reading
		% char(48-57): numbers 0-9 X
		% char(9): tab
		% char(32): space
		% char(10): enter X
		% char(101): e X
		% char(43): + X
		% char(45): -
		% char(46): . X
		
		ReadState=0;
		CurrentNumber=0;
		CurrentDigit=0;
		NegativeSignNumber=0;
		DecimalDistance=0;
		for i=1:length(TextFileChar)
			if TextFileChar(i)==9 || TextFileChar(i)==10
				ValueOutput=((-1)^(NegativeSignNumber))*CurrentNumber;
				ReadState=0;
				CurrentNumber=0;
				CurrentExponent=0;
				NegativeSignNumber=0;
				NegativeSignExponent=0;
			elseif TextFileChar(i)==46
				ReadState=1;
				DecimalDistance=1;
			elseif TextFileChar(i)==43
				NegativeSignNumber=0;
			elseif TextFileChar(i)==45
				NegativeSignNumber=1;
			elseif TextFileChar(i)>=48 && TextFileChar(i)<=57
				CurrentDigit=TextFileChar(i)-48;
				if ReadState==0
					CurrentNumber=CurrentNumber*10+CurrentDigit;
				elseif ReadState==1
					CurrentNumber=CurrentNumber+CurrentDigit/(10^DecimalDistance);
					DecimalDistance=DecimalDistance+1;
				end				
			end
		end
		ValueOutput=((-1)^(NegativeSignNumber))*CurrentNumber;
	else
		ValueOutput=0;
	end
end

function savesinglelong(TheValue,TextFile)
	TheData=fopen(TextFile,'w');
	fprintf(TheData,'%10.0f',TheValue);
	fclose(TheData);
end

function MatrixOutput=loadmatrixlong(TextFile)
	TextFileOpen=fopen(TextFile);
	TextFileChar=fread(TextFileOpen,[1,Inf],'char');
	fclose(TextFileOpen);
	if length(TextFileChar)>0
		columnsize=1;
		rowsize=1;
		firstenter=0;
		for i=1:length(TextFileChar)
			if TextFileChar(i)==char(10)
				if firstenter==0
					firstenter=i;
				end
				rowsize=rowsize+1;
			end
			if firstenter==0 && TextFileChar(i)==char(9)
				columnsize=columnsize+1;
			end
		end
		MatrixOutput=zeros(rowsize,columnsize);
		% ReadState legend: 0: integer reading, 1: decimal reading, 2: exponential reading
		% char(48-57): numbers 0-9 X
		% char(9): tab
		% char(32): space
		% char(10): enter X
		% char(101): e X
		% char(43): + X
		% char(45): -
		% char(46): . X
		
		ReadState=0;
		CurrentColumn=1;
		CurrentRow=1;
		CurrentNumber=0;
		CurrentDigit=0;
		NegativeSignNumber=0;
		DecimalDistance=0;
		for i=1:length(TextFileChar)
			if TextFileChar(i)==9 || TextFileChar(i)==10
				MatrixOutput(CurrentRow,CurrentColumn)=((-1)^(NegativeSignNumber))*CurrentNumber;
				ReadState=0;
				CurrentNumber=0;
				CurrentExponent=0;
				NegativeSignNumber=0;
				NegativeSignExponent=0;
				if TextFileChar(i)==9
					CurrentColumn=CurrentColumn+1;
				elseif TextFileChar(i)==10
					CurrentColumn=1;
					CurrentRow=CurrentRow+1;
				end
			elseif TextFileChar(i)==46
				ReadState=1;
				DecimalDistance=1;
			elseif TextFileChar(i)==43
				NegativeSignNumber=0;
			elseif TextFileChar(i)==45
				NegativeSignNumber=1;
			elseif TextFileChar(i)>=48 && TextFileChar(i)<=57
				CurrentDigit=TextFileChar(i)-48;
				if ReadState==0
					CurrentNumber=CurrentNumber*10+CurrentDigit;
				elseif ReadState==1
					CurrentNumber=CurrentNumber+CurrentDigit/(10^DecimalDistance);
					DecimalDistance=DecimalDistance+1;
				end
			end
		end
		MatrixOutput(CurrentRow,CurrentColumn)=((-1)^(NegativeSignNumber))*CurrentNumber;
	else
		MatrixOutput=[];
	end
end

function savematrixlong(TheMatrix,TextFile)
	rowsize=size(TheMatrix,1);
	columnsize=size(TheMatrix,2);
	TheData=fopen(TextFile,'w');
	for i=1:rowsize
		if i>1
			fprintf(TheData,'\n');
		end
		for j=1:columnsize
			if j>1
				fprintf(TheData,char(9));
			end
			fprintf(TheData,'%10.0f',TheMatrix(i,j));
		end
	end
	fclose(TheData);
end

function savematrixfloat(TheMatrix,TextFile)
	rowsize=size(TheMatrix,1);
	columnsize=size(TheMatrix,2);
	TheData=fopen(TextFile,'w');
	for i=1:rowsize
		if i>1
			fprintf(TheData,'\n');
		end
		for j=1:columnsize
			if j>1
				fprintf(TheData,char(9));
			end
			fprintf(TheData,'%s',float2scitxt(16,TheMatrix(i,j)));
		end
	end
	fclose(TheData);
end

function [rowsize,columnsize]=sizematrixfloat(TextFile)
	TextFileOpen=fopen(TextFile);
	TextFileChar=fread(TextFileOpen,[1,Inf],'char');
	fclose(TextFileOpen);
	rowsize=0;
	columnsize=0;
	if length(TextFileChar)>0
		columnsize=1;
		rowsize=1;
		firstenter=0;
		for i=1:length(TextFileChar)
			if TextFileChar(i)==char(10) && i<length(TextFileChar)
				if firstenter==0
					firstenter=i;
				end
				rowsize=rowsize+1;
			end
			if firstenter==0
				if TextFileChar(i)==char(9)
					columnsize=columnsize+1;
				end
			end
		end
	end
end

function MatrixOutput=loadmatrixfloat(TextFile)
	TextFileOpen=fopen(TextFile);
	TextFileChar=fread(TextFileOpen,[1,Inf],'char');
	fclose(TextFileOpen);
	if length(TextFileChar)>0
		columnsize=1;
		rowsize=1;
		firstenter=0;
		for i=1:length(TextFileChar)
			if TextFileChar(i)==char(10) && i<length(TextFileChar)
				if firstenter==0
					firstenter=i;
				end
				rowsize=rowsize+1;
			end
			if firstenter==0
				if TextFileChar(i)==char(9)
					columnsize=columnsize+1;
				end
			end
		end
		MatrixOutput=zeros(rowsize,columnsize);
		% ReadState legend: 0: integer reading, 1: decimal reading, 2: exponential reading
		% char(48-57): numbers 0-9 X
		% char(9): tab
		% char(32): space
		% char(10): enter X
		% char(101): e X
		 % char(69): E X
		% char(43): + X
		% char(45): -
		% char(46): . X
		
		ReadState=0;
		CurrentColumn=1;
		CurrentRow=1;
		CurrentNumber=0;
		CurrentExponent=0;
		CurrentDigit=0;
		NegativeSignNumber=0;
		NegativeSignExponent=0;
		DecimalDistance=0;
		for i=1:length(TextFileChar)
			if TextFileChar(i)==9 || TextFileChar(i)==10
				MatrixOutput(CurrentRow,CurrentColumn)=((-1)^(NegativeSignNumber))*CurrentNumber*(10^(((-1)^(NegativeSignExponent))*(CurrentExponent)));
				ReadState=0;
				CurrentNumber=0;
				CurrentExponent=0;
				NegativeSignNumber=0;
				NegativeSignExponent=0;
				if TextFileChar(i)==9
					CurrentColumn=CurrentColumn+1;
				elseif TextFileChar(i)==10
					CurrentColumn=1;
					CurrentRow=CurrentRow+1;
				end
			elseif TextFileChar(i)==46
				ReadState=1;
				DecimalDistance=1;
			elseif TextFileChar(i)==101 || TextFileChar(i)==69
				ReadState=2;
				NegativeSignExponent=0;
				CurrentExponent=0;
			elseif TextFileChar(i)==43
				if ReadState==2
					NegativeSignExponent=0;
				else
					NegativeSignNumber=0;
				end
			elseif TextFileChar(i)==45
				if ReadState==2
					NegativeSignExponent=1;
				else
					NegativeSignNumber=1;
				end
			elseif TextFileChar(i)>=48 && TextFileChar(i)<=57
				CurrentDigit=TextFileChar(i)-48;
				if ReadState==0
					CurrentNumber=CurrentNumber*10+CurrentDigit;
				elseif ReadState==1
					CurrentNumber=CurrentNumber+CurrentDigit/(10^DecimalDistance);
					DecimalDistance=DecimalDistance+1;
				elseif ReadState==2
					CurrentExponent=CurrentExponent*10+CurrentDigit;
				end				
			end
		end
		if CurrentRow<=rowsize && CurrentColumn<=columnsize
			MatrixOutput(CurrentRow,CurrentColumn)=((-1)^(NegativeSignNumber))*CurrentNumber*(10^(((-1)^(NegativeSignExponent))*(CurrentExponent)));
		end
	else
		MatrixOutput=[];
	end
end

function TheOutput = int2txt2(n)
   if n < 10
	  TheOutput = [char(48+n)];
   else
	  TheOutput = [int2txt(myfloor(n/10)), char(48+mod(n,10))];
   end
end

function savesinglefloat(TheValue,TextFile)
	TheData=fopen(TextFile,'w');
	fprintf(TheData,'%s',float2scitxt(16,TheValue));
	fclose(TheData);
end

function ValueOutput=loadsinglefloat(TextFile)
	TextFileOpen=fopen(TextFile);
	TextFileChar=fread(TextFileOpen,[1,Inf],'char');
	fclose(TextFileOpen);
	if length(TextFileChar)>0
		% ReadState legend: 0: integer reading, 1: decimal reading, 2: exponential reading
		% char(48-57): numbers 0-9 X
		% char(9): tab
		% char(32): space
		% char(10): enter X
		% char(101): e X
		% char(43): + X
		% char(45): -
		% char(46): . X
		
		ReadState=0;
		CurrentNumber=0;
		CurrentExponent=0;
		CurrentDigit=0;
		NegativeSignNumber=0;
		NegativeSignExponent=0;
		DecimalDistance=0;
		for i=1:length(TextFileChar)
			if TextFileChar(i)==46
				ReadState=1;
				DecimalDistance=1;
			elseif TextFileChar(i)==101
				ReadState=2;
				NegativeSignExponent=0;
				CurrentExponent=0;
			elseif TextFileChar(i)==43
				if ReadState==2
					NegativeSignExponent=0;
				else
					NegativeSignNumber=0;
				end
			elseif TextFileChar(i)==45
				if ReadState==2
					NegativeSignExponent=1;
				else
					NegativeSignNumber=1;
				end
			elseif TextFileChar(i)>=48 && TextFileChar(i)<=57
				CurrentDigit=TextFileChar(i)-48;
				if ReadState==0
					CurrentNumber=CurrentNumber*10+CurrentDigit;
				elseif ReadState==1
					CurrentNumber=CurrentNumber+CurrentDigit/(10^DecimalDistance);
					DecimalDistance=DecimalDistance+1;
				elseif ReadState==2
					CurrentExponent=CurrentExponent*10+CurrentDigit;
				end				
			end
		end
		ValueOutput=((-1)^(NegativeSignNumber))*CurrentNumber*(10^(((-1)^(NegativeSignExponent))*(CurrentExponent)));
	else
		ValueOutput=0;
	end	
end

function Gradient=ManualLinReg(x,y)
	n=length(x);
	sigmax=0;
	sigmay=0;
	sigmaxsquared=0;
	sigmaxy=0;
	if n==length(y)
		for i=1:n
			sigmaxy=sigmaxy+x(i)*y(i);
			sigmax=sigmax+x(i);
			sigmay=sigmay+y(i);
			sigmaxsquared=sigmaxsquared+x(i)^2;
		end
		Gradient=((n*sigmaxy)-(sigmax*sigmay))/((n*sigmaxsquared)-(sigmax^2));
	else
		Gradient=0;
		fprintf('%s',['x and y has to be the same length' char(10)]);
	end
end

function TextOutput=float2scitxt(TotalDigits,TheNumber)
	chararray=zeros(1,7+TotalDigits);
	charindex=0;
	if length(TheNumber)==0
		charindex=charindex+1;
		chararray(charindex)=43;
		charindex=charindex+1;
		chararray(charindex)=48;
		charindex=charindex+1;
		chararray(charindex)=46;
		for i=1:TotalDigits-1
			charindex=charindex+1;
			chararray(charindex)=48;
		end
		charindex=charindex+1;
		chararray(charindex)=101;
		charindex=charindex+1;
		chararray(charindex)=43;
		for i=1:3
			charindex=charindex+1;
			chararray(charindex)=48;
		end
	else
		%coder.varsize('chararray')
		if TheNumber<0
			charindex=charindex+1;
			chararray(charindex)=45;
			ThePower=myfloor(log10(-TheNumber));
		else
			charindex=charindex+1;
			chararray(charindex)=43;
			if TheNumber>0
				ThePower=myfloor(log10(TheNumber));
			else
				ThePower=0;
			end
		end
		for i=1:TotalDigits
			charindex=charindex+1;
			if TheNumber<0
				chararray(charindex)=mod(myfloor((-TheNumber)*10^-(ThePower+1-i)),10)+48;
			else
				chararray(charindex)=mod(myfloor((TheNumber)*10^-(ThePower+1-i)),10)+48;
			end
			if i==1
				charindex=charindex+1;
				chararray(charindex)=46;
			end
		end
		charindex=charindex+1;
		chararray(charindex)=101;
		if ThePower<0
			charindex=charindex+1;
			chararray(charindex)=45;
			ThePowerDigits=myfloor(log10(-ThePower))+1;
		else
			charindex=charindex+1;
			chararray(charindex)=43;
			if ThePower>0
				ThePowerDigits=myfloor(log10(ThePower))+1;
			else
				ThePowerDigits=0;
			end
		end
		for i=1:3-ThePowerDigits;
			charindex=charindex+1;
			chararray(charindex)=48;
		end
		for i=1:ThePowerDigits
			charindex=charindex+1;
			if ThePower<0
				chararray(charindex)=mod(myfloor((-ThePower)*10^-(ThePowerDigits-i)),10)+48;
			else
				chararray(charindex)=mod(myfloor(ThePower*10^-(ThePowerDigits-i)),10)+48;
			end
		end
	end
	TextOutput=char(chararray);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- END CADAPT LOAD FUNCTIONS-----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function LWOut=LWRequest(x_request,y_request,x_min,y_min,x_max,y_max)
	[ndotx,ndoty]=sizematrixfloat('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\EWLW\\LW.txt');
	
	LW=zeros(ndotx,ndoty);
	LW=loadmatrixlong('C:\\Users\\Tito\\Documents\\Run Data Repository 2\\EWLW\\LW.txt');
	
	idotx=ceil((x_request-x_min)/(x_max-x_min)*ndotx);
	if idotx==0
		idotx=1;
	end
	idoty=ceil((y_request-y_min)/(y_max-y_min)*ndoty);
	if idoty==0
		idoty=1;
	end
	
	LWOut=LW(idotx,idoty);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [xy W]=GaussQuadCircle(diameter)
	xyW_standard=[	0.002826114	0.002826069	0.000110742	;
					0.036715186	0.002818485	0.000685881	;
					0.142478702	0.002708944	0.001461138	;
					0.309741132	0.00221853	0.001446592	;
					0.457879042	0.001135335	0.000440357	;
					0.002826114	0.036714599	0.000687727	;
					0.036715186	0.036616068	0.004259454	;
					0.142478702	0.035192981	0.009073948	;
					0.309741132	0.028821812	0.008983611	;
					0.457879042	0.014749598	0.002734699	;
					0.002826114	0.142476426	0.001524313	;
					0.036715186	0.142094059	0.009440868	;
					0.142478702	0.136571561	0.020111952	;
					0.309741132	0.111847299	0.019911726	;
					0.457879042	0.057237994	0.006061324	;
					0.002826114	0.309736184	0.001842738	;
					0.036715186	0.308904938	0.011413041	;
					0.142478702	0.296899321	0.024313287	;
					0.309741132	0.243150088	0.024071235	;
					0.457879042	0.124432359	0.007327519	;
					0.002826114	0.457871727	0.001096133	;
					0.036715186	0.456642927	0.006788925	;
					0.142478702	0.438895459	0.014462499	;
					0.309741132	0.359439925	0.014318516	;
					0.457879042	0.183943827	0.004358696	];
	
	nPointsStd=size(xyW_standard,1);
	nPointsAll=4*nPointsStd;
	xy=zeros(nPointsAll,2);
	W=zeros(nPointsAll);
	xymultiplier=[1 1];
	for iRep=1:4
		if iRep==1
			xymultiplier=[1 1];
		elseif iRep==2
			xymultiplier=[1 -1];
		elseif iRep==3
			xymultiplier=[-1 1];
		elseif iRep==4
			xymultiplier=[-1 -1];
		end
		for iPointsStd=1:nPointsStd
			for dim=1:2
				xy(nPointsStd*(iRep-1)+iPointsStd,dim)=xyW_standard(iPointsStd,dim)*xymultiplier(dim)*diameter;
				%disp(['xy(' num2str(nPointsStd*(iRep-1)+iPointsStd) ',' num2str(dim) ')=' num2str(xy(4*(iRep-1)+iPointsStd,dim))]);
				%1;
			end
			W(nPointsStd*(iRep-1)+iPointsStd)=xyW_standard(iPointsStd,3)*diameter^2;
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

%{
tt=loadsinglelong([TimeStampedName '-Slave-' 'tt' '-' int2txt(tt) '.txt']);
t_time=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(tt) '.txt']);
v_ssp=loadmatrixfloat([TimeStampedName '-Slave-' 'v_ssp' '-' int2txt(tt) '.txt']);
x_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'x_sp' '-' int2txt(tt) '.txt']);
F_sp=loadcellmatrixfloat([TimeStampedName '-Slave-' 'F_sp' '-' int2txt(tt) '.txt']);
A_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'A_sp' '-' int2txt(tt) '.txt']);
t_sp=loadmatrixfloat([TimeStampedName '-Slave-' 't_sp' '-' int2txt(tt) '.txt']);
s_sp=loadmatrixfloat([TimeStampedName '-Slave-' 's_sp' '-' int2txt(tt) '.txt']);
p_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'p_sp' '-' int2txt(tt) '.txt']);
r1_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r1_sp' '-' int2txt(tt) '.txt']);
r2_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'r2_sp' '-' int2txt(tt) '.txt']);
F_rollerX=loadmatrixfloat([TimeStampedName '-Slave-' 'F_rollerX' '-' int2txt(tt) '.txt']);
F_rollerY=loadmatrixfloat([TimeStampedName '-Slave-' 'F_rollerY' '-' int2txt(tt) '.txt']);
E_acc=loadmatrixfloat([TimeStampedName '-Slave-' 'E_acc' '-' int2txt(tt) '.txt']);
e_pl_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'e_pl_sp' '-' int2txt(tt) '.txt']);
sigma_global_big=loadmatrixfloat([TimeStampedName '-Slave-' 'sigma_global_big' '-' int2txt(tt) '.txt']);
e_t_global_big=loadmatrixfloat([TimeStampedName '-Slave-' 'e_t_global_big' '-' int2txt(tt) '.txt']);
e_pl_global_big=loadmatrixfloat([TimeStampedName '-Slave-' 'e_pl_global_big' '-' int2txt(tt) '.txt']);
alphahp=loadmatrixfloat([TimeStampedName '-Slave-' 'alphahp' '-' int2txt(tt) '.txt']);
f_final_vect=loadmatrixfloat([TimeStampedName '-Slave-' 'f_final_vect' '-' int2txt(tt) '.txt']);
surfacewithfmax=loadmatrixfloat([TimeStampedName '-Slave-' 'surfacewithfmax' '-' int2txt(tt) '.txt']);
sigma_local_big=loadmatrixfloat([TimeStampedName '-Slave-' 'sigma_local_big' '-' int2txt(tt) '.txt']);
DispPump=loadsinglefloat([TimeStampedName '-Slave-' 'DispPump' '-' int2txt(tt) '.txt']);
evaltimes=loadmatrixfloat([TimeStampedName '-Slave-' 'evaltimes' '-' int2txt(tt) '.txt']);
stackvars=loadmatrixfloat([TimeStampedName '-Slave-' 'stackvars' '-' int2txt(tt) '.txt']);
duration=loadmatrixfloat([TimeStampedName '-Slave-' 'duration' '-' int2txt(tt) '.txt']);
x_crack=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crack' '-' int2txt(tt) '.txt']);
x_cracktop=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_cracktop' '-' int2txt(tt) '.txt']);
x_crackbot=loadcellmatrixfloat([TimeStampedName '-Slave-' 'x_crackbot' '-' int2txt(tt) '.txt']);
dudx_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'dudx_sp' '-' int2txt(tt) '.txt']);
W_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'W_sp' '-' int2txt(tt) '.txt']);
thetacrackrtl=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrackrtl' '-' int2txt(tt) '.txt']);
thetacrack=loadmatrixfloat([TimeStampedName '-Slave-' 'thetacrack' '-' int2txt(tt) '.txt']);
pforce_sp=loadmatrixfloat([TimeStampedName '-Slave-' 'pforce_sp' '-' int2txt(tt) '.txt']);
sigmainf=loadsinglefloat([TimeStampedName '-Slave-' 'sigmainf' '-' int2txt(tt) '.txt']);
G=loadsinglefloat([TimeStampedName '-Slave-' 'G' '-' int2txt(tt) '.txt']);
Ga=loadsinglefloat([TimeStampedName '-Slave-' 'Ga' '-' int2txt(tt) '.txt']);
Grelativeerror=loadsinglefloat([TimeStampedName '-Slave-' 'Grelativeerror' '-' int2txt(tt) '.txt']);
ntforce_si=loadmatrixfloat([TimeStampedName '-Slave-' 'ntforce_si' '-' int2txt(tt) '.txt']);
%asdf=loadmatrixfloat([TimeStampedName '-Slave-' 'asdf' '-' int2txt(tt) '.txt']);
%asdf=loadmatrixfloat([TimeStampedName char(47) 'asdf' '-' int2txt(tt) '.txt']);
%}

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%------------------------------------------------------------------------ START - ALTMANY EXPORT FIG - START ---------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%{
%switchable1
function [imageData, alpha] = export_fig(varargin) %#ok<*STRCL1>
%EXPORT_FIG  Exports figures in a publication-quality format
%
% Examples:
%   imageData = export_fig
%   [imageData, alpha] = export_fig
%   export_fig filename
%   export_fig filename -format1 -format2
%   export_fig ... -nocrop
%   export_fig ... -c[<val>,<val>,<val>,<val>]
%   export_fig ... -transparent
%   export_fig ... -native
%   export_fig ... -m<val>
%   export_fig ... -r<val>
%   export_fig ... -a<val>
%   export_fig ... -q<val>
%   export_fig ... -p<val>
%   export_fig ... -d<gs_option>
%   export_fig ... -depsc
%   export_fig ... -<renderer>
%   export_fig ... -<colorspace>
%   export_fig ... -append
%   export_fig ... -bookmark
%   export_fig ... -clipboard
%   export_fig ... -update
%   export_fig ... -nofontswap
%   export_fig ... -font_space <char>
%   export_fig ... -linecaps
%   export_fig ... -noinvert
%   export_fig(..., handle)
%
% This function saves a figure or single axes to one or more vector and/or
% bitmap file formats, and/or outputs a rasterized version to the workspace,
% with the following properties:
%   - Figure/axes reproduced as it appears on screen
%   - Cropped borders (optional)
%   - Embedded fonts (vector formats)
%   - Improved line and grid line styles
%   - Anti-aliased graphics (bitmap formats)
%   - Render images at native resolution (optional for bitmap formats)
%   - Transparent background supported (pdf, eps, png, tiff)
%   - Semi-transparent patch objects supported (png, tiff)
%   - RGB, CMYK or grayscale output (CMYK only with pdf, eps, tiff)
%   - Variable image compression, including lossless (pdf, eps, jpg)
%   - Optional rounded line-caps (pdf, eps)
%   - Optionally append to file (pdf, tiff)
%   - Vector formats: pdf, eps
%   - Bitmap formats: png, tiff, jpg, bmp, export to workspace
%
% This function is especially suited to exporting figures for use in
% publications and presentations, because of the high quality and
% portability of media produced.
%
% Note that the background color and figure dimensions are reproduced
% (the latter approximately, and ignoring cropping & magnification) in the
% output file. For transparent background (and semi-transparent patch
% objects), use the -transparent option or set the figure 'Color' property
% to 'none'. To make axes transparent set the axes 'Color' property to
% 'none'. PDF, EPS, TIF & PNG are the only formats that support a transparent
% background; only TIF & PNG formats support transparency of patch objects.
%
% The choice of renderer (opengl, zbuffer or painters) has a large impact
% on the quality of output. The default value (opengl for bitmaps, painters
% for vector formats) generally gives good results, but if you aren't
% satisfied then try another renderer.  Notes: 1) For vector formats (EPS,
% PDF), only painters generates vector graphics. 2) For bitmaps, only
% opengl can render transparent patch objects correctly. 3) For bitmaps,
% only painters will correctly scale line dash and dot lengths when
% magnifying or anti-aliasing. 4) Fonts may be substitued with Courier when
% using painters.
%
% When exporting to vector format (PDF & EPS) and bitmap format using the
% painters renderer, this function requires that ghostscript is installed
% on your system. You can download this from:
%   http://www.ghostscript.com
% When exporting to eps it additionally requires pdftops, from the Xpdf
% suite of functions. You can download this from: http://xpdfreader.com
%
% Inputs:
%   filename - string containing the name (optionally including full or
%	          relative path) of the file the figure is to be saved as. If
%	          a path is not specified, the figure is saved in the current
%	          directory. If no name and no output arguments are specified,
%	          the default name, 'export_fig_out', is used. If neither a
%	          file extension nor a format are specified, a ".png" is added
%	          and the figure saved in that format.
%   -format1, -format2, etc. - strings containing the extensions of the
%	                          file formats the figure is to be saved as.
%	                          Valid options are: '-pdf', '-eps', '-png',
%	                          '-tif', '-jpg' and '-bmp'. All combinations
%	                          of formats are valid.
%   -nocrop - option indicating that the borders of the output are not to
%	         be cropped.
%   -c[<val>,<val>,<val>,<val>] - option indicating crop amounts. Must be
%	         a 4-element vector of numeric values: [top,right,bottom,left]
%	         where NaN/Inf indicate auto-cropping, 0 means no cropping,
%	         and any other value mean cropping in pixel amounts.
%   -transparent - option indicating that the figure background is to be
%	              made transparent (png, pdf, tif and eps output only).
%   -m<val> - option where val indicates the factor to magnify the
%	         on-screen figure pixel dimensions by when generating bitmap
%	         outputs (does not affect vector formats). Default: '-m1'.
%   -r<val> - option val indicates the resolution (in pixels per inch) to
%	         export bitmap and vector outputs at, keeping the dimensions
%	         of the on-screen figure. Default: '-r864' (for vector output
%	         only). Note that the -m option overides the -r option for
%	         bitmap outputs only.
%   -native - option indicating that the output resolution (when outputting
%	         a bitmap format) should be such that the vertical resolution
%	         of the first suitable image found in the figure is at the
%	         native resolution of that image. To specify a particular
%	         image to use, give it the tag 'export_fig_native'. Notes:
%	         This overrides any value set with the -m and -r options. It
%	         also assumes that the image is displayed front-to-parallel
%	         with the screen. The output resolution is approximate and
%	         should not be relied upon. Anti-aliasing can have adverse
%	         effects on image quality (disable with the -a1 option).
%   -a1, -a2, -a3, -a4 - option indicating the amount of anti-aliasing to
%	                    use for bitmap outputs. '-a1' means no anti-
%	                    aliasing; '-a4' is the maximum amount (default).
%   -<renderer> - option to force a particular renderer (painters, opengl or
%	             zbuffer). Default value: opengl for bitmap formats or
%	             figures with patches and/or transparent annotations;
%	             painters for vector formats without patches/transparencies.
%   -<colorspace> - option indicating which colorspace color figures should
%	               be saved in: RGB (default), CMYK or gray. CMYK is only
%	               supported in pdf, eps and tiff output.
%   -q<val> - option to vary bitmap image quality (in pdf, eps and jpg
%	         files only).  Larger val, in the range 0-100, gives higher
%	         quality/lower compression. val > 100 gives lossless
%	         compression. Default: '-q95' for jpg, ghostscript prepress
%	         default for pdf & eps. Note: lossless compression can
%	         sometimes give a smaller file size than the default lossy
%	         compression, depending on the type of images.
%   -p<val> - option to pad a border of width val to exported files, where
%	         val is either a relative size with respect to cropped image
%	         size (i.e. p=0.01 adds a 1% border). For EPS & PDF formats,
%	         val can also be integer in units of 1/72" points (abs(val)>1).
%	         val can be positive (padding) or negative (extra cropping).
%	         If used, the -nocrop flag will be ignored, i.e. the image will
%	         always be cropped and then padded. Default: 0 (i.e. no padding).
%   -append - option indicating that if the file (pdfs only) already
%	         exists, the figure is to be appended as a new page, instead
%	         of being overwritten (default).
%   -bookmark - option to indicate that a bookmark with the name of the
%	           figure is to be created in the output file (pdf only).
%   -clipboard - option to save output as an image on the system clipboard.
%	            Note: background transparency is not preserved in clipboard
%   -d<gs_option> - option to indicate a ghostscript setting. For example,
%	               -dMaxBitmap=0 or -dNoOutputFonts (Ghostscript 9.15+).
%   -depsc -  option to use EPS level-3 rather than the default level-2 print
%	         device. This solves some bugs with Matlab's default -depsc2 device
%	         such as discolored subplot lines on images (vector formats only).
%   -update - option to download and install the latest version of export_fig
%   -nofontswap - option to avoid font swapping. Font swapping is automatically
%	         done in vector formats (only): 11 standard Matlab fonts are
%	         replaced by the original figure fonts. This option prevents this.
%   -font_space <char> - option to set a spacer character for font-names that
%	         contain spaces, used by EPS/PDF. Default: ''
%   -linecaps - option to create rounded line-caps (vector formats only).
%   -noinvert - option to avoid setting figure's InvertHardcopy property to
%	         'off' during output (this solves some problems of empty outputs).
%   handle -  The handle of the figure, axes or uipanels (can be an array of
%	         handles, but the objects must be in the same figure) to be
%	         saved. Default: gcf.
%
% Outputs:
%   imageData - MxNxC uint8 image array of the exported image.
%   alpha	 - MxN single array of alphamatte values in the range [0,1],
%	           for the case when the background is transparent.
%
%   Some helpful examples and tips can be found at:
%	  https://github.com/altmany/export_fig
%
%   See also PRINT, SAVEAS, ScreenCapture (on the Matlab File Exchange)

%{
% Copyright (C) Oliver Woodford 2008-2014, Yair Altman 2015-

% The idea of using ghostscript is inspired by Peder Axensten's SAVEFIG
% (fex id: 10889) which is itself inspired by EPS2PDF (fex id: 5782).
% The idea for using pdftops came from the MATLAB newsgroup (id: 168171).
% The idea of editing the EPS file to change line styles comes from Jiro
% Doke's FIXPSLINESTYLE (fex id: 17928).
% The idea of changing dash length with line width came from comments on
% fex id: 5743, but the implementation is mine :)
% The idea of anti-aliasing bitmaps came from Anders Brun's MYAA (fex id:
% 20979).
% The idea of appending figures in pdfs came from Matt C in comments on the
% FEX (id: 23629)

% Thanks to Roland Martin for pointing out the colour MATLAB
% bug/feature with colorbar axes and transparent backgrounds.
% Thanks also to Andrew Matthews for describing a bug to do with the figure
% size changing in -nodisplay mode. I couldn't reproduce it, but included a
% fix anyway.
% Thanks to Tammy Threadgill for reporting a bug where an axes is not
% isolated from gui objects.
%}
%{
% 23/02/12: Ensure that axes limits don't change during printing
% 14/03/12: Fix bug in fixing the axes limits (thanks to Tobias Lamour for reporting it).
% 02/05/12: Incorporate patch of Petr Nechaev (many thanks), enabling bookmarking of figures in pdf files.
% 09/05/12: Incorporate patch of Arcelia Arrieta (many thanks), to keep tick marks fixed.
% 12/12/12: Add support for isolating uipanels. Thanks to michael for suggesting it.
% 25/09/13: Add support for changing resolution in vector formats. Thanks to Jan Jaap Meijer for suggesting it.
% 07/05/14: Add support for '~' at start of path. Thanks to Sally Warner for suggesting it.
% 24/02/15: Fix Matlab R2014b bug (issue #34): plot markers are not displayed when ZLimMode='manual'
% 25/02/15: Fix issue #4 (using HG2 on R2014a and earlier)
% 25/02/15: Fix issue #21 (bold TeX axes labels/titles in R2014b)
% 26/02/15: If temp dir is not writable, use the user-specified folder for temporary EPS/PDF files (Javier Paredes)
% 27/02/15: Modified repository URL from github.com/ojwoodford to /altmany
%	       Indented main function
%	       Added top-level try-catch block to display useful workarounds
% 28/02/15: Enable users to specify optional ghostscript options (issue #36)
% 06/03/15: Improved image padding & cropping thanks to Oscar Hartogensis
% 26/03/15: Fixed issue #49 (bug with transparent grayscale images); fixed out-of-memory issue
% 26/03/15: Fixed issue #42: non-normalized annotations on HG1
% 26/03/15: Fixed issue #46: Ghostscript crash if figure units <> pixels
% 27/03/15: Fixed issue #39: bad export of transparent annotations/patches
% 28/03/15: Fixed issue #50: error on some Matlab versions with the fix for issue #42
% 29/03/15: Fixed issue #33: bugs in Matlab's print() function with -cmyk
% 29/03/15: Improved processing of input args (accept space between param name & value, related to issue #51)
% 30/03/15: When exporting *.fig files, then saveas *.fig if figure is open, otherwise export the specified fig file
% 30/03/15: Fixed edge case bug introduced yesterday (commit #ae1755bd2e11dc4e99b95a7681f6e211b3fa9358)
% 09/04/15: Consolidated header comment sections; initialize output vars only if requested (nargout>0)
% 14/04/15: Workaround for issue #45: lines in image subplots are exported in invalid color
% 15/04/15: Fixed edge-case in parsing input parameters; fixed help section to show the -depsc option (issue #45)
% 21/04/15: Bug fix: Ghostscript croaks on % chars in output PDF file (reported by Sven on FEX page, 15-Jul-2014)
% 22/04/15: Bug fix: Pdftops croaks on relative paths (reported by Tintin Milou on FEX page, 19-Jan-2015)
% 04/05/15: Merged fix #63 (Kevin Mattheus Moerman): prevent tick-label changes during export
% 07/05/15: Partial fix for issue #65: PDF export used painters rather than opengl renderer (thanks Nguyenr)
% 08/05/15: Fixed issue #65: bad PDF append since commit #e9f3cdf 21/04/15 (thanks Robert Nguyen)
% 12/05/15: Fixed issue #67: exponent labels cropped in export, since fix #63 (04/05/15)
% 28/05/15: Fixed issue #69: set non-bold label font only if the string contains symbols (\beta etc.), followup to issue #21
% 29/05/15: Added informative error message in case user requested SVG output (issue #72)
% 09/06/15: Fixed issue #58: -transparent removed anti-aliasing when exporting to PNG
% 19/06/15: Added -update option to download and install the latest version of export_fig
% 07/07/15: Added -nofontswap option to avoid font-swapping in EPS/PDF
% 16/07/15: Fixed problem with anti-aliasing on old Matlab releases
% 11/09/15: Fixed issue #103: magnification must never become negative; also fixed reported error msg in parsing input params
% 26/09/15: Alert if trying to export transparent patches/areas to non-PNG outputs (issue #108)
% 04/10/15: Do not suggest workarounds for certain errors that have already been handled previously
% 01/11/15: Fixed issue #112: use same renderer in print2eps as export_fig (thanks to Jes?estana Puerta)
% 10/11/15: Custom GS installation webpage for MacOS. Thanks to Andy Hueni via FEX
% 19/11/15: Fixed clipboard export in R2015b (thanks to Dan K via FEX)
% 21/02/16: Added -c option for indicating specific crop amounts (idea by Cedric Noordam on FEX)
% 08/05/16: Added message about possible error reason when groot.Units~=pixels (issue #149)
% 17/05/16: Fixed case of image YData containing more than 2 elements (issue #151)
% 08/08/16: Enabled exporting transparency to TIF, in addition to PNG/PDF (issue #168)
% 11/12/16: Added alert in case of error creating output PDF/EPS file (issue #179)
% 13/12/16: Minor fix to the commit for issue #179 from 2 days ago
% 22/03/17: Fixed issue #187: only set manual ticks when no exponent is present
% 09/04/17: Added -linecaps option (idea by Baron Finer, issue #192)
% 15/09/17: Fixed issue #205: incorrect tick-labels when Ticks number don't match the TickLabels number
% 15/09/17: Fixed issue #210: initialize alpha map to ones instead of zeros when -transparent is not used
% 18/09/17: Added -font_space option to replace font-name spaces in EPS/PDF (workaround for issue #194)
% 18/09/17: Added -noinvert option to solve some export problems with some graphic cards (workaround for issue #197)
% 08/11/17: Fixed issue #220: axes exponent is removed in HG1 when TickMode is 'manual' (internal Matlab bug)
% 08/11/17: Fixed issue #221: alert if the requested folder does not exist
% 19/11/17: Workaround for issue #207: alert when trying to use transparent bgcolor with -opengl
% 29/11/17: Workaround for issue #206: warn if exporting PDF/EPS for a figure that contains an image
% 11/12/17: Fixed issue #230: use OpenGL renderer when exported image contains transparency (also see issue #206)
% 30/01/18: Updated SVG message to point to https://github.com/kupiqu/plot2svg and display user-selected filename if available
% 27/02/18: Fixed issue #236: axes exponent cropped from output if on right-hand axes
% 29/05/18: Fixed issue #245: process "string" inputs just like 'char' inputs
% 13/08/18: Fixed issue #249: correct black axes color to off-black to avoid extra cropping with -transparent
% 27/08/18: Added a possible file-open reason in EPS/PDF write-error message (suggested by "craq" on FEX page)
% 22/09/18: Xpdf website changed to xpdfreader.com
% 23/09/18: Fixed issue #243: only set non-bold font (workaround for issue #69) in R2015b or earlier; warn if changing font
% 23/09/18: Workaround for issue #241: don't use -r864 in EPS/PDF outputs when -native is requested (solves black lines problem)
% 18/11/18: Issue #261: Added informative alert when trying to export a uifigure (which is not currently supported)
% 13/12/18: Issue #261: Fixed last commit for cases of specifying axes/panel handle as input, rather than a figure handle
%}

	if nargout
	    [imageData, alpha] = deal([]);
	end
	hadError = false;
	displaySuggestedWorkarounds = true;

	% Ensure the figure is rendered correctly _now_ so that properties like axes limits are up-to-date
	drawnow;
	pause(0.05);  % this solves timing issues with Java Swing's EDT (http://undocumentedmatlab.com/blog/solving-a-matlab-hang-problem)

	% Parse the input arguments
	fig = get(0, 'CurrentFigure');
	[fig, options] = parse_args(nargout, fig, varargin{:});

	% Ensure that we have a figure handle
	if isequal(fig,-1)
	    return;  % silent bail-out
	elseif isempty(fig)
	    error('No figure found');
	else
	    oldWarn = warning('off','MATLAB:HandleGraphics:ObsoletedProperty:JavaFrame');
	    try jf = get(handle(ancestor(fig,'figure')),'JavaFrame'); catch, jf=1; end
	    warning(oldWarn);
	    if isempty(jf)
	        error('Figures created using the uifigure command or App Designer are not supported by export_fig. See <a href="https://github.com/altmany/export_fig/issues/261">issue #261</a> for details.');
	    end
	end

	% Isolate the subplot, if it is one
	cls = all(ismember(get(fig, 'Type'), {'axes', 'uipanel'}));
	if cls
	    % Given handles of one or more axes, so isolate them from the rest
	    fig = isolate_axes(fig);
	else
	    % Check we have a figure
	    if ~isequal(get(fig, 'Type'), 'figure')
	        error('Handle must be that of a figure, axes or uipanel');
	    end
	    % Get the old InvertHardcopy mode
	    old_mode = get(fig, 'InvertHardcopy');
	end

	% Hack the font units where necessary (due to a font rendering bug in print?).
	% This may not work perfectly in all cases.
	% Also it can change the figure layout if reverted, so use a copy.
	magnify = options.magnify * options.aa_factor;
	if isbitmap(options) && magnify ~= 1
	    fontu = findall(fig, 'FontUnits', 'normalized');
	    if ~isempty(fontu)
	        % Some normalized font units found
	        if ~cls
	            fig = copyfig(fig);
	            set(fig, 'Visible', 'off');
	            fontu = findall(fig, 'FontUnits', 'normalized');
	            cls = true;
	        end
	        set(fontu, 'FontUnits', 'points');
	    end
	end

	try
	    % MATLAB "feature": axes limits and tick marks can change when printing
	    Hlims = findall(fig, 'Type', 'axes');
	    if ~cls
	        % Record the old axes limit and tick modes
	        Xlims = make_cell(get(Hlims, 'XLimMode'));
	        Ylims = make_cell(get(Hlims, 'YLimMode'));
	        Zlims = make_cell(get(Hlims, 'ZLimMode'));
	        Xtick = make_cell(get(Hlims, 'XTickMode'));
	        Ytick = make_cell(get(Hlims, 'YTickMode'));
	        Ztick = make_cell(get(Hlims, 'ZTickMode'));
	        Xlabel = make_cell(get(Hlims, 'XTickLabelMode')); 
	        Ylabel = make_cell(get(Hlims, 'YTickLabelMode')); 
	        Zlabel = make_cell(get(Hlims, 'ZTickLabelMode')); 
	    end

	    % Set all axes limit and tick modes to manual, so the limits and ticks can't change
	    % Fix Matlab R2014b bug (issue #34): plot markers are not displayed when ZLimMode='manual'
	    set(Hlims, 'XLimMode', 'manual', 'YLimMode', 'manual');
	    set_tick_mode(Hlims, 'X');
	    set_tick_mode(Hlims, 'Y');
	    if ~using_hg2(fig)
	        set(Hlims,'ZLimMode', 'manual');
	        set_tick_mode(Hlims, 'Z');
	    end
	catch
	    % ignore - fix issue #4 (using HG2 on R2014a and earlier)
	end

	% Fix issue #21 (bold TeX axes labels/titles in R2014b when exporting to EPS/PDF)
	try
	    if using_hg2(fig) && isvector(options)
	        % Set the FontWeight of axes labels/titles to 'normal'
	        % Fix issue #69: set non-bold font only if the string contains symbols (\beta etc.)
	        % Issue #243: only set non-bold font (workaround for issue #69) in R2015b or earlier
	        try isPreR2016a = verLessThan('matlab','8.7'); catch, isPreR2016a = true; end
	        if isPreR2016a
	            texLabels = findall(fig, 'type','text', 'FontWeight','bold');
	            symbolIdx = ~cellfun('isempty',strfind({texLabels.String},'\'));
	            if ~isempty(symbolIdx)
	                set(texLabels(symbolIdx), 'FontWeight','normal');
	                warning('export_fig:BoldTexLabels', 'Bold labels with Tex symbols converted into non-bold in export_fig (fix for issue #69)');
	            end
	        end
	    end
	catch
	    % ignore
	end

	% Fix issue #42: non-normalized annotations on HG1 (internal Matlab bug)
	annotationHandles = [];
	try
	    if ~using_hg2(fig)
	        annotationHandles = findall(fig,'Type','hggroup','-and','-property','Units','-and','-not','Units','norm');
	        try  % suggested by Jes?estana Puerta (jespestana) 30/9/2015
	            originalUnits = get(annotationHandles,'Units');
	            set(annotationHandles,'Units','norm');
	        catch
	        end
	    end
	catch
	    % should never happen, but ignore in any case - issue #50
	end

	% Fix issue #46: Ghostscript crash if figure units <> pixels
	oldFigUnits = get(fig,'Units');
	set(fig,'Units','pixels');

	% Set to print exactly what is there
	if options.invert_hardcopy
	    try set(fig, 'InvertHardcopy', 'off'); catch, end  % fail silently in uifigures
	end

	% Set the renderer
	switch options.renderer
	    case 1
	        renderer = '-opengl';
	    case 2
	        renderer = '-zbuffer';
	    case 3
	        renderer = '-painters';
	    otherwise
	        renderer = '-opengl'; % Default for bitmaps
	end

	hImages = findall(fig,'type','image');

	% Handle transparent patches
	hasTransparency = ~isempty(findall(fig,'-property','FaceAlpha','-and','-not','FaceAlpha',1));
	hasPatches      = ~isempty(findall(fig,'type','patch'));
	if hasTransparency
	    % Alert if trying to export transparent patches/areas to non-supported outputs (issue #108)
	    % http://www.mathworks.com/matlabcentral/answers/265265-can-export_fig-or-else-draw-vector-graphics-with-transparent-surfaces
	    % TODO - use transparency when exporting to PDF by not passing via print2eps
	    msg = 'export_fig currently supports transparent patches/areas only in PNG output. ';
	    if options.pdf
	        warning('export_fig:transparency', '%s\nTo export transparent patches/areas to PDF, use the print command:\n print(gcf, ''-dpdf'', ''%s.pdf'');', msg, options.name);
	    elseif ~options.png && ~options.tif  % issue #168
	        warning('export_fig:transparency', '%s\nTo export the transparency correctly, try using the ScreenCapture utility on the Matlab File Exchange: http://bit.ly/1QFrBip', msg);
	    end
	elseif ~isempty(hImages)
	    % Fix for issue #230: use OpenGL renderer when exported image contains transparency
	    for idx = 1 : numel(hImages)
	        cdata = get(hImages(idx),'CData');
	        if any(isnan(cdata(:)))
	            hasTransparency = true;
	            break
	        end
	    end
	end

	try
	    % Do the bitmap formats first
	    if isbitmap(options)
	        if abs(options.bb_padding) > 1
	            displaySuggestedWorkarounds = false;
	            error('For bitmap output (png,jpg,tif,bmp) the padding value (-p) must be between -1<p<1')
	        end
	        % Get the background colour
	        if options.transparent && (options.png || options.alpha)
	            % Get out an alpha channel
	            % MATLAB "feature": black colorbar axes can change to white and vice versa!
	            hCB = findall(fig, 'Type','axes', 'Tag','Colorbar');
	            if isempty(hCB)
	                yCol = [];
	                xCol = [];
	            else
	                yCol = get(hCB, 'YColor');
	                xCol = get(hCB, 'XColor');
	                if iscell(yCol)
	                    yCol = cell2mat(yCol);
	                    xCol = cell2mat(xCol);
	                end
	                yCol = sum(yCol, 2);
	                xCol = sum(xCol, 2);
	            end
	            % MATLAB "feature": apparently figure size can change when changing
	            % colour in -nodisplay mode
	            pos = get(fig, 'Position');
	            % Set the background colour to black, and set size in case it was
	            % changed internally
	            tcol = get(fig, 'Color');
	            set(fig, 'Color', 'k', 'Position', pos);
	            % Correct the colorbar axes colours
	            set(hCB(yCol==0), 'YColor', [0 0 0]);
	            set(hCB(xCol==0), 'XColor', [0 0 0]);
	            % Correct black axes color to off-black (issue #249)
	            hAxes = findall(fig, 'Type','axes');
	            hXs = fixBlackAxle(hAxes, 'XColor');
	            hYs = fixBlackAxle(hAxes, 'YColor');
	            hZs = fixBlackAxle(hAxes, 'ZColor');

	            % The following code might cause out-of-memory errors
	            try
	                % Print large version to array
	                B = print2array(fig, magnify, renderer);
	                % Downscale the image
	                B = downsize(single(B), options.aa_factor);
	            catch
	                % This is more conservative in memory, but kills transparency (issue #58)
	                B = single(print2array(fig, magnify/options.aa_factor, renderer));
	            end

	            % Set background to white (and set size)
	            set(fig, 'Color', 'w', 'Position', pos);
	            % Correct the colorbar axes colours
	            set(hCB(yCol==3), 'YColor', [1 1 1]);
	            set(hCB(xCol==3), 'XColor', [1 1 1]);
	            % Revert the black axes colors
	            set(hXs, 'XColor', [0,0,0]);
	            set(hYs, 'YColor', [0,0,0]);
	            set(hZs, 'ZColor', [0,0,0]);

	            % The following code might cause out-of-memory errors
	            try
	                % Print large version to array
	                A = print2array(fig, magnify, renderer);
	                % Downscale the image
	                A = downsize(single(A), options.aa_factor);
	            catch
	                % This is more conservative in memory, but kills transparency (issue #58)
	                A = single(print2array(fig, magnify/options.aa_factor, renderer));
	            end

	            % Set the background colour (and size) back to normal
	            set(fig, 'Color', tcol, 'Position', pos);
	            % Compute the alpha map
	            alpha = round(sum(B - A, 3)) / (255 * 3) + 1;
	            A = alpha;
	            A(A==0) = 1;
	            A = B ./ A(:,:,[1 1 1]);
	            clear B
	            % Convert to greyscale
	            if options.colourspace == 2
	                A = rgb2grey(A);
	            end
	            A = uint8(A);
	            % Crop the background
	            if options.crop
	                %[alpha, v] = crop_borders(alpha, 0, 1, options.crop_amounts);
	                %A = A(v(1):v(2),v(3):v(4),:);
	                [alpha, vA, vB] = crop_borders(alpha, 0, options.bb_padding, options.crop_amounts);
	                if ~any(isnan(vB)) % positive padding
	                    B = repmat(uint8(zeros(1,1,size(A,3))),size(alpha));
	                    B(vB(1):vB(2), vB(3):vB(4), :) = A(vA(1):vA(2), vA(3):vA(4), :); % ADDED BY OH
	                    A = B;
	                else  % negative padding
	                    A = A(vA(1):vA(2), vA(3):vA(4), :);
	                end
	            end
	            if options.png
	                % Compute the resolution
	                res = options.magnify * get(0, 'ScreenPixelsPerInch') / 25.4e-3;
	                % Save the png
	                imwrite(A, [options.name '.png'], 'Alpha', double(alpha), 'ResolutionUnit', 'meter', 'XResolution', res, 'YResolution', res);
	                % Clear the png bit
	                options.png = false;
	            end
	            % Return only one channel for greyscale
	            if isbitmap(options)
	                A = check_greyscale(A);
	            end
	            if options.alpha
	                % Store the image
	                imageData = A;
	                % Clear the alpha bit
	                options.alpha = false;
	            end
	            % Get the non-alpha image
	            if isbitmap(options)
	                alph = alpha(:,:,ones(1, size(A, 3)));
	                A = uint8(single(A) .* alph + 255 * (1 - alph));
	                clear alph
	            end
	            if options.im
	                % Store the new image
	                imageData = A;
	            end
	        else
	            % Print large version to array
	            if options.transparent
	                % MATLAB "feature": apparently figure size can change when changing
	                % colour in -nodisplay mode
	                pos = get(fig, 'Position');
	                tcol = get(fig, 'Color');
	                set(fig, 'Color', 'w', 'Position', pos);
	                A = print2array(fig, magnify, renderer);
	                set(fig, 'Color', tcol, 'Position', pos);
	                tcol = 255;
	            else
	                [A, tcol] = print2array(fig, magnify, renderer);
	            end
	            % Crop the background
	            if options.crop
	                A = crop_borders(A, tcol, options.bb_padding, options.crop_amounts);
	            end
	            % Downscale the image
	            A = downsize(A, options.aa_factor);
	            if options.colourspace == 2
	                % Convert to greyscale
	                A = rgb2grey(A);
	            else
	                % Return only one channel for greyscale
	                A = check_greyscale(A);
	            end
	            % Outputs
	            if options.im
	                imageData = A;
	            end
	            if options.alpha
	                imageData = A;
	                alpha = ones(size(A, 1), size(A, 2), 'single');
	            end
	        end
	        % Save the images
	        if options.png
	            res = options.magnify * get(0, 'ScreenPixelsPerInch') / 25.4e-3;
	            imwrite(A, [options.name '.png'], 'ResolutionUnit', 'meter', 'XResolution', res, 'YResolution', res);
	        end
	        if options.bmp
	            imwrite(A, [options.name '.bmp']);
	        end
	        % Save jpeg with given quality
	        if options.jpg
	            quality = options.quality;
	            if isempty(quality)
	                quality = 95;
	            end
	            if quality > 100
	                imwrite(A, [options.name '.jpg'], 'Mode', 'lossless');
	            else
	                imwrite(A, [options.name '.jpg'], 'Quality', quality);
	            end
	        end
	        % Save tif images in cmyk if wanted (and possible)
	        if options.tif
	            if options.colourspace == 1 && size(A, 3) == 3
	                A = double(255 - A);
	                K = min(A, [], 3);
	                K_ = 255 ./ max(255 - K, 1);
	                C = (A(:,:,1) - K) .* K_;
	                M = (A(:,:,2) - K) .* K_;
	                Y = (A(:,:,3) - K) .* K_;
	                A = uint8(cat(3, C, M, Y, K));
	                clear C M Y K K_
	            end
	            append_mode = {'overwrite', 'append'};
	            imwrite(A, [options.name '.tif'], 'Resolution', options.magnify*get(0, 'ScreenPixelsPerInch'), 'WriteMode', append_mode{options.append+1});
	        end
	    end

	    % Now do the vector formats
	    if isvector(options)
	        % Set the default renderer to painters
	        if ~options.renderer
	            if hasTransparency || hasPatches
	                % This is *MUCH* slower, but more accurate for patches and transparent annotations (issue #39)
	                renderer = '-opengl';
	            else
	                renderer = '-painters';
	            end
	        end
	        options.rendererStr = renderer;  % fix for issue #112
	        % Generate some filenames
	        tmp_nam = [tempname '.eps'];
	        try
	            % Ensure that the temp dir is writable (Javier Paredes 30/1/15)
	            fid = fopen(tmp_nam,'w');
	            fwrite(fid,1);
	            fclose(fid);
	            delete(tmp_nam);
	            isTempDirOk = true;
	        catch
	            % Temp dir is not writable, so use the user-specified folder
	            [dummy,fname,fext] = fileparts(tmp_nam); %#ok<ASGLU>
	            fpath = fileparts(options.name);
	            tmp_nam = fullfile(fpath,[fname fext]);
	            isTempDirOk = false;
	        end
	        if isTempDirOk
	            pdf_nam_tmp = [tempname '.pdf'];
	        else
	            pdf_nam_tmp = fullfile(fpath,[fname '.pdf']);
	        end
	        if options.pdf
	            pdf_nam = [options.name '.pdf'];
	            try copyfile(pdf_nam, pdf_nam_tmp, 'f'); catch, end  % fix for issue #65
	        else
	            pdf_nam = pdf_nam_tmp;
	        end
	        % Generate the options for print
	        p2eArgs = {renderer};
	        if ~isempty(options.resolution)  % issue #241
	            p2eArgs{end+1} = sprintf('-r%d', options.resolution);
	        end
	        if options.colourspace == 1  % CMYK
	            % Issue #33: due to internal bugs in Matlab's print() function, we can't use its -cmyk option
	            %p2eArgs{end+1} = '-cmyk';
	        end
	        if ~options.crop
	            % Issue #56: due to internal bugs in Matlab's print() function, we can't use its internal cropping mechanism,
	            % therefore we always use '-loose' (in print2eps.m) and do our own cropping (in crop_borders)
	            %p2eArgs{end+1} = '-loose';
	        end
	        if any(strcmpi(varargin,'-depsc'))
	            % Issue #45: lines in image subplots are exported in invalid color.
	            % The workaround is to use the -depsc parameter instead of the default -depsc2
	            p2eArgs{end+1} = '-depsc';
	        end
	        try
	            % Remove background if requested (issue #207)
	            [hXs, hYs, hZs] = deal([]);
	            if options.transparent %&& ~isequal(get(fig, 'Color'), 'none')
	                if options.renderer == 1  % OpenGL
	                    warning('export_fig:openglTransparentBG', '-opengl sometimes fails to produce transparent backgrounds; try -painters instead');
	                else
	                    originalBgColor = get(fig, 'Color');
	                    set(fig,'Color','none');

	                    % Correct black axes color to off-black (issue #249)
	                    hAxes = findall(fig, 'Type','axes');
	                    hXs = fixBlackAxle(hAxes, 'XColor');
	                    hYs = fixBlackAxle(hAxes, 'YColor');
	                    hZs = fixBlackAxle(hAxes, 'ZColor');
	                end
	            end
	            % Generate an eps
	            print2eps(tmp_nam, fig, options, p2eArgs{:});
	            %{
	            % Remove the background, if desired
	            if options.transparent %&& ~isequal(get(fig, 'Color'), 'none')
	                eps_remove_background(tmp_nam, 1 + using_hg2(fig));

	                % Revert the black axes colors
	                set(hXs, 'XColor', [0,0,0]);
	                set(hYs, 'YColor', [0,0,0]);
	                set(hZs, 'ZColor', [0,0,0]);
	            end
	            %}
	            % Restore the figure's previous background color (if modified)
	            try set(fig,'Color',originalBgColor); drawnow; catch, end
	            % Fix colorspace to CMYK, if requested (workaround for issue #33)
	            if options.colourspace == 1  % CMYK
	                % Issue #33: due to internal bugs in Matlab's print() function, we can't use its -cmyk option
	                change_rgb_to_cmyk(tmp_nam);
	            end
	            % Add a bookmark to the PDF if desired
	            if options.bookmark
	                fig_nam = get(fig, 'Name');
	                if isempty(fig_nam)
	                    warning('export_fig:EmptyBookmark', 'Bookmark requested for figure with no name. Bookmark will be empty.');
	                end
	                add_bookmark(tmp_nam, fig_nam);
	            end
	            % Generate a pdf
	            eps2pdf(tmp_nam, pdf_nam_tmp, 1, options.append, options.colourspace==2, options.quality, options.gs_options);
	            % Ghostscript croaks on % chars in the output PDF file, so use tempname and then rename the file
	            try
	                % Rename the file (except if it is already the same)
	                % Abbie K's comment on the commit for issue #179 (#commitcomment-20173476)
	                if ~isequal(pdf_nam_tmp, pdf_nam)
	                    movefile(pdf_nam_tmp, pdf_nam, 'f');
	                end
	            catch
	                % Alert in case of error creating output PDF/EPS file (issue #179)
	                if exist(pdf_nam_tmp, 'file')
	                    errMsg = ['Could not create ' pdf_nam ' - perhaps the folder does not exist, or you do not have write permissions, or the file is open in another application'];
	                    error(errMsg);
	                else
	                    error('Could not generate the intermediary EPS file.');
	                end
	            end
	        catch ex
	            % Delete the eps
	            delete(tmp_nam);
	            rethrow(ex);
	        end
	        % Delete the eps
	        delete(tmp_nam);
	        if options.eps || options.linecaps
	            try
	                % Generate an eps from the pdf
	                % since pdftops can't handle relative paths (e.g., '..\'), use a temp file
	                eps_nam_tmp = strrep(pdf_nam_tmp,'.pdf','.eps');
	                pdf2eps(pdf_nam, eps_nam_tmp);

	                % Issue #192: enable rounded line-caps
	                if options.linecaps
	                    fstrm = read_write_entire_textfile(eps_nam_tmp);
	                    fstrm = regexprep(fstrm, '[02] J', '1 J');
	                    read_write_entire_textfile(eps_nam_tmp, fstrm);
	                    if options.pdf
	                        eps2pdf(eps_nam_tmp, pdf_nam, 1, options.append, options.colourspace==2, options.quality, options.gs_options);
	                    end
	                end

	                if options.eps
	                    movefile(eps_nam_tmp, [options.name '.eps'], 'f');
	                else  % if options.pdf
	                    try delete(eps_nam_tmp); catch, end
	                end
	            catch ex
	                if ~options.pdf
	                    % Delete the pdf
	                    delete(pdf_nam);
	                end
	                try delete(eps_nam_tmp); catch, end
	                rethrow(ex);
	            end
	            if ~options.pdf
	                % Delete the pdf
	                delete(pdf_nam);
	            end
	        end
	        % Issue #206: warn if the figure contains an image
	        if ~isempty(hImages) && strcmpi(renderer,'-opengl')  % see addendum to issue #206
	            warnMsg = ['exporting images to PDF/EPS may result in blurry images on some viewers. ' ...
	                       'If so, try to change viewer, or increase the image''s CData resolution, or use -opengl renderer, or export via the print function. ' ...
	                       'See <a href="matlab:web(''https://github.com/altmany/export_fig/issues/206'',''-browser'');">issue #206</a> for details.'];
	            warning('export_fig:pdf_eps:blurry_image', warnMsg);
	        end
	    end

	    % Revert the figure or close it (if requested)
	    if cls || options.closeFig
	        % Close the created figure
	        close(fig);
	    else
	        % Reset the hardcopy mode
	        try set(fig, 'InvertHardcopy', old_mode); catch, end  % fail silently in uifigures
	        % Reset the axes limit and tick modes
	        for a = 1:numel(Hlims)
	            try
	                set(Hlims(a), 'XLimMode', Xlims{a}, 'YLimMode', Ylims{a}, 'ZLimMode', Zlims{a},... 
	                              'XTickMode', Xtick{a}, 'YTickMode', Ytick{a}, 'ZTickMode', Ztick{a},...
	                              'XTickLabelMode', Xlabel{a}, 'YTickLabelMode', Ylabel{a}, 'ZTickLabelMode', Zlabel{a}); 
	            catch
	                % ignore - fix issue #4 (using HG2 on R2014a and earlier)
	            end
	        end
	        % Revert the tex-labels font weights
	        try set(texLabels, 'FontWeight','bold'); catch, end
	        % Revert annotation units
	        for handleIdx = 1 : numel(annotationHandles)
	            try
	                oldUnits = originalUnits{handleIdx};
	            catch
	                oldUnits = originalUnits;
	            end
	            try set(annotationHandles(handleIdx),'Units',oldUnits); catch, end
	        end
	        % Revert figure units
	        set(fig,'Units',oldFigUnits);
	    end

	    % Output to clipboard (if requested)
	    if options.clipboard
	        % Delete the output file if unchanged from the default name ('export_fig_out.png')
	        if strcmpi(options.name,'export_fig_out')
	            try
	                fileInfo = dir('export_fig_out.png');
	                if ~isempty(fileInfo)
	                    timediff = now - fileInfo.datenum;
	                    ONE_SEC = 1/24/60/60;
	                    if timediff < ONE_SEC
	                        delete('export_fig_out.png');
	                    end
	                end
	            catch
	                % never mind...
	            end
	        end

	        % Save the image in the system clipboard
	        % credit: Jiro Doke's IMCLIPBOARD: http://www.mathworks.com/matlabcentral/fileexchange/28708-imclipboard
	        try
	            error(javachk('awt', 'export_fig -clipboard output'));
	        catch
	            warning('export_fig:clipboardJava', 'export_fig -clipboard output failed: requires Java to work');
	            return;
	        end
	        try
	            % Import necessary Java classes
	            import java.awt.Toolkit
	            import java.awt.image.BufferedImage
	            import java.awt.datatransfer.DataFlavor

	            % Get System Clipboard object (java.awt.Toolkit)
	            cb = Toolkit.getDefaultToolkit.getSystemClipboard();

	            % Add java class (ImageSelection) to the path
	            if ~exist('ImageSelection', 'class')
	                javaaddpath(fileparts(which(mfilename)), '-end');
	            end

	            % Get image size
	            ht = size(imageData, 1);
	            wd = size(imageData, 2);

	            % Convert to Blue-Green-Red format
	            try
	                imageData2 = imageData(:, :, [3 2 1]);
	            catch
	                % Probably gray-scaled image (2D, without the 3rd [RGB] dimension)
	                imageData2 = imageData(:, :, [1 1 1]);
	            end

	            % Convert to 3xWxH format
	            imageData2 = permute(imageData2, [3, 2, 1]);

	            % Append Alpha data (unused - transparency is not supported in clipboard copy)
	            alphaData2 = uint8(permute(255*alpha,[3,2,1])); %=255*ones(1,wd,ht,'uint8')
	            imageData2 = cat(1, imageData2, alphaData2);

	            % Create image buffer
	            imBuffer = BufferedImage(wd, ht, BufferedImage.TYPE_INT_RGB);
	            imBuffer.setRGB(0, 0, wd, ht, typecast(imageData2(:), 'int32'), 0, wd);

	            % Create ImageSelection object from the image buffer
	            imSelection = ImageSelection(imBuffer);

	            % Set clipboard content to the image
	            cb.setContents(imSelection, []);
	        catch
	            warning('export_fig:clipboardFailed', 'export_fig -clipboard output failed: %s', lasterr); %#ok<LERR>
	        end
	    end

	    % Don't output the data to console unless requested
	    if ~nargout
	        clear imageData alpha
	    end
	catch err
	    % Display possible workarounds before the error message
	    if displaySuggestedWorkarounds && ~strcmpi(err.message,'export_fig error')
	        if ~hadError,  fprintf(2, 'export_fig error. ');  end
	        fprintf(2, 'Please ensure:\n');
	        fprintf(2, '  that you are using the <a href="https://github.com/altmany/export_fig/archive/master.zip">latest version</a> of export_fig\n');
	        if ismac
	            fprintf(2, '  and that you have <a href="http://pages.uoregon.edu/koch">Ghostscript</a> installed\n');
	        else
	            fprintf(2, '  and that you have <a href="http://www.ghostscript.com">Ghostscript</a> installed\n');
	        end
	        try
	            if options.eps
	                fprintf(2, '  and that you have <a href="http://xpdfreader.com/download.html">pdftops</a> installed\n');
	            end
	        catch
	            % ignore - probably an error in parse_args
	        end
	        fprintf(2, '  and that you do not have <a href="matlab:which export_fig -all">multiple versions</a> of export_fig installed by mistake\n');
	        fprintf(2, '  and that you did not made a mistake in the <a href="matlab:help export_fig">expected input arguments</a>\n');
	        try
	            % Alert per issue #149
	            if ~strncmpi(get(0,'Units'),'pixel',5)
	                fprintf(2, '  or try to set groot''s Units property back to its default value of ''pixels'' (<a href="matlab:web(''https://github.com/altmany/export_fig/issues/149'',''-browser'');">details</a>)\n');
	            end
	        catch
	            % ignore - maybe an old MAtlab release
	        end
	        fprintf(2, '\nIf the problem persists, then please <a href="https://github.com/altmany/export_fig/issues">report a new issue</a>.\n\n');
	    end
	    rethrow(err)
	end
end

function options = default_options()
	% Default options used by export_fig
	options = struct(...
	    'name',         'export_fig_out', ...
	    'crop',         true, ...
	    'crop_amounts', nan(1,4), ...  % auto-crop all 4 image sides
	    'transparent',  false, ...
	    'renderer',     0, ...         % 0: default, 1: OpenGL, 2: ZBuffer, 3: Painters
	    'pdf',          false, ...
	    'eps',          false, ...
	    'png',          false, ...
	    'tif',          false, ...
	    'jpg',          false, ...
	    'bmp',          false, ...
	    'clipboard',    false, ...
	    'colourspace',  0, ...         % 0: RGB/gray, 1: CMYK, 2: gray
	    'append',       false, ...
	    'im',           false, ...
	    'alpha',        false, ...
	    'aa_factor',    0, ...
	    'bb_padding',   0, ...
	    'magnify',      [], ...
	    'resolution',   [], ...
	    'bookmark',     false, ...
	    'closeFig',     false, ...
	    'quality',      [], ...
	    'update',       false, ...
	    'fontswap',     true, ...
	    'font_space',   '', ...
	    'linecaps',     false, ...
	    'invert_hardcopy', true, ...
	    'gs_options',   {{}});
end

function [fig, options] = parse_args(nout, fig, varargin)
	% Parse the input arguments

	% Convert strings => chars
	varargin = cellfun(@str2char,varargin,'un',false);

	% Set the defaults
	native = false; % Set resolution to native of an image
	options = default_options();
	options.im =    (nout == 1);  % user requested imageData output
	options.alpha = (nout == 2);  % user requested alpha output

	% Go through the other arguments
	skipNext = false;
	for a = 1:nargin-2
	    if skipNext
	        skipNext = false;
	        continue;
	    end
	    if all(ishandle(varargin{a}))
	        fig = varargin{a};
	    elseif ischar(varargin{a}) && ~isempty(varargin{a})
	        if varargin{a}(1) == '-'
	            switch lower(varargin{a}(2:end))
	                case 'nocrop'
	                    options.crop = false;
	                    options.crop_amounts = [0,0,0,0];
	                case {'trans', 'transparent'}
	                    options.transparent = true;
	                case 'opengl'
	                    options.renderer = 1;
	                case 'zbuffer'
	                    options.renderer = 2;
	                case 'painters'
	                    options.renderer = 3;
	                case 'pdf'
	                    options.pdf = true;
	                case 'eps'
	                    options.eps = true;
	                case 'png'
	                    options.png = true;
	                case {'tif', 'tiff'}
	                    options.tif = true;
	                case {'jpg', 'jpeg'}
	                    options.jpg = true;
	                case 'bmp'
	                    options.bmp = true;
	                case 'rgb'
	                    options.colourspace = 0;
	                case 'cmyk'
	                    options.colourspace = 1;
	                case {'gray', 'grey'}
	                    options.colourspace = 2;
	                case {'a1', 'a2', 'a3', 'a4'}
	                    options.aa_factor = str2double(varargin{a}(3));
	                case 'append'
	                    options.append = true;
	                case 'bookmark'
	                    options.bookmark = true;
	                case 'native'
	                    native = true;
	                case 'clipboard'
	                    options.clipboard = true;
	                    options.im = true;
	                    options.alpha = true;
	                case 'svg'
	                    filename = strrep(options.name,'export_fig_out','filename');
	                    msg = ['SVG output is not supported by export_fig. Use one of the following alternatives:\n' ...
	                           '  1. saveas(gcf,''' filename '.svg'')\n' ...
	                           '  2. plot2svg utility: https://github.com/kupiqu/plot2svg\n' ...  % Note: replaced defunct https://github.com/jschwizer99/plot2svg with up-to-date fork on https://github.com/kupiqu/plot2svg
	                           '  3. export_fig to EPS/PDF, then convert to SVG using generic (non-Matlab) tools\n'];
	                    error(sprintf(msg)); %#ok<SPERR>
	                case 'update'
	                    % Download the latest version of export_fig into the export_fig folder
	                    try
	                        zipFileName = 'https://github.com/altmany/export_fig/archive/master.zip';
	                        folderName = fileparts(which(mfilename('fullpath')));
	                        targetFileName = fullfile(folderName, datestr(now,'yyyy-mm-dd.zip'));
	                        urlwrite(zipFileName,targetFileName);
	                    catch
	                        error('Could not download %s into %s\n',zipFileName,targetFileName);
	                    end

	                    % Unzip the downloaded zip file in the export_fig folder
	                    try
	                        unzip(targetFileName,folderName);
	                    catch
	                        error('Could not unzip %s\n',targetFileName);
	                    end
	                case 'nofontswap'
	                    options.fontswap = false;
	                case 'font_space'
	                    options.font_space = varargin{a+1};
	                    skipNext = true;
	                case 'linecaps'
	                    options.linecaps = true;
	                case 'noinvert'
	                    options.invert_hardcopy = false;
	                otherwise
	                    try
	                        wasError = false;
	                        if strcmpi(varargin{a}(1:2),'-d')
	                            varargin{a}(2) = 'd';  % ensure lowercase 'd'
	                            options.gs_options{end+1} = varargin{a};
	                        elseif strcmpi(varargin{a}(1:2),'-c')
	                            if numel(varargin{a})==2
	                                skipNext = true;
	                                vals = str2num(varargin{a+1}); %#ok<ST2NM>
	                            else
	                                vals = str2num(varargin{a}(3:end)); %#ok<ST2NM>
	                            end
	                            if numel(vals)~=4
	                                wasError = true;
	                                error('option -c cannot be parsed: must be a 4-element numeric vector');
	                            end
	                            options.crop_amounts = vals;
	                            options.crop = true;
	                        else  % scalar parameter value
	                            val = str2double(regexp(varargin{a}, '(?<=-(m|M|r|R|q|Q|p|P))-?\d*.?\d+', 'match'));
	                            if isempty(val) || isnan(val)
	                                % Issue #51: improved processing of input args (accept space between param name & value)
	                                val = str2double(varargin{a+1});
	                                if isscalar(val) && ~isnan(val)
	                                    skipNext = true;
	                                end
	                            end
	                            if ~isscalar(val) || isnan(val)
	                                wasError = true;
	                                error('option %s is not recognised or cannot be parsed', varargin{a});
	                            end
	                            switch lower(varargin{a}(2))
	                                case 'm'
	                                    % Magnification may never be negative
	                                    if val <= 0
	                                        wasError = true;
	                                        error('Bad magnification value: %g (must be positive)', val);
	                                    end
	                                    options.magnify = val;
	                                case 'r'
	                                    options.resolution = val;
	                                case 'q'
	                                    options.quality = max(val, 0);
	                                case 'p'
	                                    options.bb_padding = val;
	                            end
	                        end
	                    catch err
	                        % We might have reached here by raising an intentional error
	                        if wasError  % intentional raise
	                            rethrow(err)
	                        else  % unintentional
	                            error(['Unrecognized export_fig input option: ''' varargin{a} '''']);
	                        end
	                    end
	            end
	        else
	            [p, options.name, ext] = fileparts(varargin{a});
	            if ~isempty(p)
	                % Issue #221: alert if the requested folder does not exist
	                if ~exist(p,'dir'),  error(['Folder ' p ' does not exist!']);  end
	                options.name = [p filesep options.name];
	            end
	            switch lower(ext)
	                case {'.tif', '.tiff'}
	                    options.tif = true;
	                case {'.jpg', '.jpeg'}
	                    options.jpg = true;
	                case '.png'
	                    options.png = true;
	                case '.bmp'
	                    options.bmp = true;
	                case '.eps'
	                    options.eps = true;
	                case '.pdf'
	                    options.pdf = true;
	                case '.fig'
	                    % If no open figure, then load the specified .fig file and continue
	                    if isempty(fig)
	                        fig = openfig(varargin{a},'invisible');
	                        varargin{a} = fig;
	                        options.closeFig = true;
	                    else
	                        % save the current figure as the specified .fig file and exit
	                        saveas(fig(1),varargin{a});
	                        fig = -1;
	                        return
	                    end
	                case '.svg'
	                    filename = strrep(options.name,'export_fig_out','filename');
	                    msg = ['SVG output is not supported by export_fig. Use one of the following alternatives:\n' ...
	                           '  1. saveas(gcf,''' filename '.svg'')\n' ...
	                           '  2. plot2svg utility: https://github.com/kupiqu/plot2svg\n' ...  % Note: replaced defunct https://github.com/jschwizer99/plot2svg with up-to-date fork on https://github.com/kupiqu/plot2svg
	                           '  3. export_fig to EPS/PDF, then convert to SVG using generic (non-Matlab) tools\n'];
	                    error(sprintf(msg)); %#ok<SPERR>
	                otherwise
	                    options.name = varargin{a};
	            end
	        end
	    end
	end

	% Quick bail-out if no figure found
	if isempty(fig),  return;  end

	% Do border padding with repsect to a cropped image
	if options.bb_padding
	    options.crop = true;
	end

	% Set default anti-aliasing now we know the renderer
	if options.aa_factor == 0
	    try isAA = strcmp(get(ancestor(fig, 'figure'), 'GraphicsSmoothing'), 'on'); catch, isAA = false; end
	    options.aa_factor = 1 + 2 * (~(using_hg2(fig) && isAA) | (options.renderer == 3));
	end

	% Convert user dir '~' to full path
	if numel(options.name) > 2 && options.name(1) == '~' && (options.name(2) == '/' || options.name(2) == '\')
	    options.name = fullfile(char(java.lang.System.getProperty('user.home')), options.name(2:end));
	end

	% Compute the magnification and resolution
	if isempty(options.magnify)
	    if isempty(options.resolution)
	        options.magnify = 1;
	        options.resolution = 864;
	    else
	        options.magnify = options.resolution ./ get(0, 'ScreenPixelsPerInch');
	    end
	elseif isempty(options.resolution)
	    options.resolution = 864;
	end

	% Set the default format
	if ~isvector(options) && ~isbitmap(options)
	    options.png = true;
	end

	% Check whether transparent background is wanted (old way)
	if isequal(get(ancestor(fig(1), 'figure'), 'Color'), 'none')
	    options.transparent = true;
	end

	% If requested, set the resolution to the native vertical resolution of the
	% first suitable image found
	if native
	    if isbitmap(options)
	        % Find a suitable image
	        list = findall(fig, 'Type','image', 'Tag','export_fig_native');
	        if isempty(list)
	            list = findall(fig, 'Type','image', 'Visible','on');
	        end
	        for hIm = list(:)'
	            % Check height is >= 2
	            height = size(get(hIm, 'CData'), 1);
	            if height < 2
	                continue
	            end
	            % Account for the image filling only part of the axes, or vice versa
	            yl = get(hIm, 'YData');
	            if isscalar(yl)
	                yl = [yl(1)-0.5 yl(1)+height+0.5];
	            else
	                yl = [min(yl), max(yl)];  % fix issue #151 (case of yl containing more than 2 elements)
	                if ~diff(yl)
	                    continue
	                end
	                yl = yl + [-0.5 0.5] * (diff(yl) / (height - 1));
	            end
	            hAx = get(hIm, 'Parent');
	            yl2 = get(hAx, 'YLim');
	            % Find the pixel height of the axes
	            oldUnits = get(hAx, 'Units');
	            set(hAx, 'Units', 'pixels');
	            pos = get(hAx, 'Position');
	            set(hAx, 'Units', oldUnits);
	            if ~pos(4)
	                continue
	            end
	            % Found a suitable image
	            % Account for stretch-to-fill being disabled
	            pbar = get(hAx, 'PlotBoxAspectRatio');
	            pos = min(pos(4), pbar(2)*pos(3)/pbar(1));
	            % Set the magnification to give native resolution
	            options.magnify = abs((height * diff(yl2)) / (pos * diff(yl)));  % magnification must never be negative: issue #103
	            break
	        end
	    elseif options.resolution == 864  % don't use -r864 in vector mode if user asked for -native
	        options.resolution = []; % issue #241 (internal Matlab bug produces black lines with -r864)
	    end
	end
end

% Convert a possible string => char (issue #245)
function value = str2char(value)
	if isa(value,'string')
	    value = char(value);
	end
end

function A = downsize(A, factor)
	% Downsample an image
	if factor == 1
	    % Nothing to do
	    return
	end
	try
	    % Faster, but requires image processing toolbox
	    A = imresize(A, 1/factor, 'bilinear');
	catch
	    % No image processing toolbox - resize manually
	    % Lowpass filter - use Gaussian as is separable, so faster
	    % Compute the 1d Gaussian filter
	    filt = (-factor-1:factor+1) / (factor * 0.6);
	    filt = exp(-filt .* filt);
	    % Normalize the filter
	    filt = single(filt / sum(filt));
	    % Filter the image
	    padding = floor(numel(filt) / 2);
	    for a = 1:size(A, 3)
	        A(:,:,a) = conv2(filt, filt', single(A([ones(1, padding) 1:end repmat(end, 1, padding)],[ones(1, padding) 1:end repmat(end, 1, padding)],a)), 'valid');
	    end
	    % Subsample
	    A = A(1+floor(mod(end-1, factor)/2):factor:end,1+floor(mod(end-1, factor)/2):factor:end,:);
	end
end

function A = rgb2grey(A)
	A = cast(reshape(reshape(single(A), [], 3) * single([0.299; 0.587; 0.114]), size(A, 1), size(A, 2)), class(A)); % #ok<ZEROLIKE>
end

function A = check_greyscale(A)
	% Check if the image is greyscale
	if size(A, 3) == 3 && ...
	        all(reshape(A(:,:,1) == A(:,:,2), [], 1)) && ...
	        all(reshape(A(:,:,2) == A(:,:,3), [], 1))
	    A = A(:,:,1); % Save only one channel for 8-bit output
	end
end

function eps_remove_background(fname, count)
	% Remove the background of an eps file
	% Open the file
	fh = fopen(fname, 'r+');
	if fh == -1
	    error('Not able to open file %s.', fname);
	end
	% Read the file line by line
	while count
	    % Get the next line
	    l = fgets(fh);
	    if isequal(l, -1)
	        break; % Quit, no rectangle found
	    end
	    % Check if the line contains the background rectangle
	    if isequal(regexp(l, ' *0 +0 +\d+ +\d+ +r[fe] *[\n\r]+', 'start'), 1)
	        % Set the line to whitespace and quit
	        l(1:regexp(l, '[\n\r]', 'start', 'once')-1) = ' ';
	        fseek(fh, -numel(l), 0);
	        fprintf(fh, l);
	        % Reduce the count
	        count = count - 1;
	    end
	end
	% Close the file
	fclose(fh);
end

function b = isvector(options)
	b = options.pdf || options.eps;
end

function b = isbitmap(options)
	b = options.png || options.tif || options.jpg || options.bmp || options.im || options.alpha;
end

% Helper function
function A = make_cell(A)
	if ~iscell(A)
	    A = {A};
	end
end

function add_bookmark(fname, bookmark_text)
	% Adds a bookmark to the temporary EPS file after %%EndPageSetup
	% Read in the file
	fh = fopen(fname, 'r');
	if fh == -1
	    error('File %s not found.', fname);
	end
	try
	    fstrm = fread(fh, '*char')';
	catch ex
	    fclose(fh);
	    rethrow(ex);
	end
	fclose(fh);

	% Include standard pdfmark prolog to maximize compatibility
	fstrm = strrep(fstrm, '%%BeginProlog', sprintf('%%%%BeginProlog\n/pdfmark where {pop} {userdict /pdfmark /cleartomark load put} ifelse'));
	% Add page bookmark
	fstrm = strrep(fstrm, '%%EndPageSetup', sprintf('%%%%EndPageSetup\n[ /Title (%s) /OUT pdfmark',bookmark_text));

	% Write out the updated file
	fh = fopen(fname, 'w');
	if fh == -1
	    error('Unable to open %s for writing.', fname);
	end
	try
	    fwrite(fh, fstrm, 'char*1');
	catch ex
	    fclose(fh);
	    rethrow(ex);
	end
	fclose(fh);
end

function set_tick_mode(Hlims, ax)
	% Set the tick mode of linear axes to manual
	% Leave log axes alone as these are tricky
	M = get(Hlims, [ax 'Scale']);
	if ~iscell(M)
	    M = {M};
	end
	%idx = cellfun(@(c) strcmp(c, 'linear'), M);
	idx = find(strcmp(M,'linear'));
	%set(Hlims(idx), [ax 'TickMode'], 'manual');  % issue #187
	%set(Hlims(idx), [ax 'TickLabelMode'], 'manual');  % this hides exponent label in HG2!
	for idx2 = 1 : numel(idx)
	    try
	        % Fix for issue #187 - only set manual ticks when no exponent is present
	        hAxes = Hlims(idx(idx2));
	        props = {[ax 'TickMode'],'manual', [ax 'TickLabelMode'],'manual'};
	        tickVals = get(hAxes,[ax 'Tick']);
	        tickStrs = get(hAxes,[ax 'TickLabel']);
	        try % Fix issue #236
	            exponents = [hAxes.([ax 'Axis']).SecondaryLabel];
	        catch
	            exponents = [hAxes.([ax 'Ruler']).SecondaryLabel];
	        end
	        if isempty([exponents.String])
	            % Fix for issue #205 - only set manual ticks when the Ticks number match the TickLabels number
	            if numel(tickVals) == numel(tickStrs)
	                set(hAxes, props{:});  % no exponent and matching ticks, so update both ticks and tick labels to manual
	            end
	        end
	    catch  % probably HG1
	        % Fix for issue #220 - exponent is removed in HG1 when TickMode is 'manual' (internal Matlab bug)
	        if isequal(tickVals, str2num(tickStrs)') %#ok<ST2NM>
	            set(hAxes, props{:});  % revert back to old behavior
	        end
	    end
	end
end

function change_rgb_to_cmyk(fname)  % convert RGB => CMYK within an EPS file
	% Do post-processing on the eps file
	try
	    % Read the EPS file into memory
	    fstrm = read_write_entire_textfile(fname);

	    % Replace all gray-scale colors
	    fstrm = regexprep(fstrm, '\n([\d.]+) +GC\n', '\n0 0 0 ${num2str(1-str2num($1))} CC\n');
	    
	    % Replace all RGB colors
	    fstrm = regexprep(fstrm, '\n[0.]+ +[0.]+ +[0.]+ +RC\n', '\n0 0 0 1 CC\n');  % pure black
	    fstrm = regexprep(fstrm, '\n([\d.]+) +([\d.]+) +([\d.]+) +RC\n', '\n${sprintf(''%.4g '',[1-[str2num($1),str2num($2),str2num($3)]/max([str2num($1),str2num($2),str2num($3)]),1-max([str2num($1),str2num($2),str2num($3)])])} CC\n');

	    % Overwrite the file with the modified contents
	    read_write_entire_textfile(fname, fstrm);
	catch
	    % never mind - leave as is...
	end
end

function hBlackAxles = fixBlackAxle(hAxes, axleName)
	hBlackAxles = [];
	for idx = 1 : numel(hAxes)
	    ax = hAxes(idx);
	    axleColor = get(ax, axleName);
	    if isequal(axleColor,[0,0,0]) || isequal(axleColor,'k')
	        hBlackAxles(end+1) = ax; %#ok<AGROW>
	    end
	end
	set(hBlackAxles, axleName, [0,0,0.01]);  % off-black
end

%APPEND_PDFS Appends/concatenates multiple PDF files
%
% Example:
%   append_pdfs(output, input1, input2, ...)
%   append_pdfs(output, input_list{:})
%   append_pdfs test.pdf temp1.pdf temp2.pdf
%
% This function appends multiple PDF files to an existing PDF file, or
% concatenates them into a PDF file if the output file doesn't yet exist.
%
% This function requires that you have ghostscript installed on your
% system. Ghostscript can be downloaded from: http://www.ghostscript.com
%
% IN:
%	output - string of output file name (including the extension, .pdf).
%	         If it exists it is appended to; if not, it is created.
%	input1 - string of an input file name (including the extension, .pdf).
%	         All input files are appended in order.
%	input_list - cell array list of input file name strings. All input
%	             files are appended in order.

% Copyright: Oliver Woodford, 2011

% Thanks to Reinhard Knoll for pointing out that appending multiple pdfs in
% one go is much faster than appending them one at a time.

% Thanks to Michael Teo for reporting the issue of a too long command line.
% Issue resolved on 5/5/2011, by passing gs a command file.

% Thanks to Martin Wittmann for pointing out the quality issue when
% appending multiple bitmaps.
% Issue resolved (to best of my ability) 1/6/2011, using the prepress
% setting

% 26/02/15: If temp dir is not writable, use the output folder for temp
%	       files when appending (Javier Paredes); sanity check of inputs
% 24/01/18: Fixed error in case of existing output file (append mode)
% 24/01/18: Fixed issue #213: non-ASCII characters in folder names on Windows
% 06/12/18: Avoid an "invalid escape-char" warning upon error

function append_pdfs(varargin)

	if nargin < 2,  return;  end  % sanity check

	% Are we appending or creating a new file
	append = exist(varargin{1}, 'file') == 2;
	output = [tempname '.pdf'];
	try
	    % Ensure that the temp dir is writable (Javier Paredes 26/2/15)
	    fid = fopen(output,'w');
	    fwrite(fid,1);
	    fclose(fid);
	    delete(output);
	    isTempDirOk = true;
	catch
	    % Temp dir is not writable, so use the output folder
	    [dummy,fname,fext] = fileparts(output); %#ok<ASGLU>
	    fpath = fileparts(varargin{1});
	    output = fullfile(fpath,[fname fext]);
	    isTempDirOk = false;
	end
	if ~append
	    output = varargin{1};
	    varargin = varargin(2:end);
	end

	% Create the command file
	if isTempDirOk
	    cmdfile = [tempname '.txt'];
	else
	    cmdfile = fullfile(fpath,[fname '.txt']);
	end
	prepareCmdFile(cmdfile, output, varargin{:});

	% Call ghostscript
	[status, errMsg] = ghostscript(['@"' cmdfile '"']);

	% Check for ghostscript execution errors
	if status && ~isempty(strfind(errMsg,'undefinedfile')) && ispc %#ok<STREMP>
	    % Fix issue #213: non-ASCII characters in folder names on Windows
	    for fileIdx = 2 : numel(varargin)
	        [fpath,fname,fext] = fileparts(varargin{fileIdx});
	        varargin{fileIdx} = fullfile(normalizePath(fpath),[fname fext]);
	    end
	    % Rerun ghostscript with the normalized folder names
	    prepareCmdFile(cmdfile, output, varargin{:});
	    [status, errMsg] = ghostscript(['@"' cmdfile '"']);
	end

	% Delete the command file
	delete(cmdfile);

	% Check for ghostscript execution errors
	if status
	    errMsg = strrep(errMsg,'\','\\');  % Avoid an "invalid escape-char" warning
	    error('YMA:export_fig:append_pdf',errMsg);
	end

	% Rename the file if needed
	if append
	    movefile(output, varargin{1}, 'f');
	end
end

% Prepare a text file with ghostscript directives
function prepareCmdFile(cmdfile, output, varargin)
	fh = fopen(cmdfile, 'w');
	fprintf(fh, '-q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -dPDFSETTINGS=/prepress -sOutputFile="%s" -f', output);
	fprintf(fh, ' "%s"', varargin{:});
	fclose(fh);
end

% Convert long/non-ASCII folder names into their short ASCII equivalents
function pathStr = normalizePath(pathStr)
	[fpath,fname,fext] = fileparts(pathStr);
	if isempty(fpath) || strcmpi(fpath,pathStr), return, end
	dirOutput = evalc(['system(''dir /X /AD "' pathStr '*"'')']);
	shortName = strtrim(regexprep(dirOutput,{'.*> *',[fname fext '.*']},''));
	if isempty(shortName)
	    shortName = [fname fext];
	end
	fpath = normalizePath(fpath);  %recursive until entire fpath is processed
	pathStr = fullfile(fpath, shortName);
end

function fh = copyfig(fh)
%COPYFIG Create a copy of a figure, without changing the figure
%
% Examples:
%   fh_new = copyfig(fh_old)
%
% This function will create a copy of a figure, but not change the figure,
% as copyobj sometimes does, e.g. by changing legends.
%
% IN:
%	fh_old - The handle of the figure to be copied. Default: gcf.
%
% OUT:
%	fh_new - The handle of the created figure.

% Copyright (C) Oliver Woodford 2012, Yair Altman 2015

% 26/02/15: If temp dir is not writable, use the dest folder for temp
%	       destination files (Javier Paredes)
% 15/04/15: Suppress warnings during copyobj (Dun Kirk comment on FEX page 2013-10-02)
% 09/09/18: Fix issue #252: Workaround for cases where copyobj() fails for any reason

	% Set the default
	if nargin == 0
	    fh = gcf;
	end
	% Is there a legend?
	useCopyobj = isempty(findall(fh, 'Type', 'axes', 'Tag', 'legend'));
	if useCopyobj
	    % Safe to copy using copyobj
	    oldWarn = warning('off'); %Suppress warnings during copyobj (Dun Kirk comment on FEX page 2013-10-02)
	    try
	        fh = copyobj(fh, 0);
	    catch
	        % Fix issue #252: Workaround for cases where copyobj() fails for any reason
	        useCopyobj = false;  % if copyobj() croaks, use file save/load below
	    end
	    warning(oldWarn);
	end
	if ~useCopyobj
	    % copyobj will change the figure, so save and then load it instead
	    tmp_nam = [tempname '.fig'];
	    try
	        % Ensure that the temp dir is writable (Javier Paredes 26/2/15)
	        fid = fopen(tmp_nam,'w');
	        fwrite(fid,1);
	        fclose(fid);
	        delete(tmp_nam);  % cleanup
	    catch
	        % Temp dir is not writable, so use the current folder
	        [dummy,fname,fext] = fileparts(tmp_nam); %#ok<ASGLU>
	        fpath = pwd;
	        tmp_nam = fullfile(fpath,[fname fext]);
	    end
	    hgsave(fh, tmp_nam);
	    fh = hgload(tmp_nam);
	    delete(tmp_nam);
	end
end

function [A, vA, vB, bb_rel] = crop_borders(A, bcol, padding, crop_amounts)
%CROP_BORDERS Crop the borders of an image or stack of images
%
%   [B, vA, vB, bb_rel] = crop_borders(A, bcol, [padding])
%
%IN:
%   A - HxWxCxN stack of images.
%   bcol - Cx1 background colour vector.
%   padding - scalar indicating how much padding to have in relation to
%	         the cropped-image-size (0<=padding<=1). Default: 0
%   crop_amounts - 4-element vector of crop amounts: [top,right,bottom,left]
%	         where NaN/Inf indicate auto-cropping, 0 means no cropping,
%	         and any other value mean cropping in pixel amounts.
%
%OUT:
%   B - JxKxCxN cropped stack of images.
%   vA	 - coordinates in A that contain the cropped image
%   vB	 - coordinates in B where the cropped version of A is placed
%   bb_rel - relative bounding box (used for eps-cropping)

%{
% 06/03/15: Improved image cropping thanks to Oscar Hartogensis
% 08/06/15: Fixed issue #76: case of transparent figure bgcolor
% 21/02/16: Enabled specifying non-automated crop amounts
% 04/04/16: Fix per Luiz Carvalho for old Matlab releases
% 23/10/16: Fixed issue #175: there used to be a 1px minimal padding in case of crop, now removed
%}

	if nargin < 3
	    padding = 0;
	end
	if nargin < 4
	    crop_amounts = nan(1,4);  % =auto-cropping
	end
	crop_amounts(end+1:4) = NaN;  % fill missing values with NaN

	[h, w, c, n] = size(A);
	if isempty(bcol)  % case of transparent bgcolor
	    bcol = A(ceil(end/2),1,:,1);
	end
	if isscalar(bcol)
	    bcol = bcol(ones(c, 1));
	end

	% Crop margin from left
	if ~isfinite(crop_amounts(4))
	    bail = false;
	    for l = 1:w
	        for a = 1:c
	            if ~all(col(A(:,l,a,:)) == bcol(a))
	                bail = true;
	                break;
	            end
	        end
	        if bail
	            break;
	        end
	    end
	else
	    l = 1 + abs(crop_amounts(4));
	end

	% Crop margin from right
	if ~isfinite(crop_amounts(2))
	    bcol = A(ceil(end/2),w,:,1);
	    bail = false;
	    for r = w:-1:l
	        for a = 1:c
	            if ~all(col(A(:,r,a,:)) == bcol(a))
	                bail = true;
	                break;
	            end
	        end
	        if bail
	            break;
	        end
	    end
	else
	    r = w - abs(crop_amounts(2));
	end

	% Crop margin from top
	if ~isfinite(crop_amounts(1))
	    bcol = A(1,ceil(end/2),:,1);
	    bail = false;
	    for t = 1:h
	        for a = 1:c
	            if ~all(col(A(t,:,a,:)) == bcol(a))
	                bail = true;
	                break;
	            end
	        end
	        if bail
	            break;
	        end
	    end
	else
	    t = 1 + abs(crop_amounts(1));
	end

	% Crop margin from bottom
	bcol = A(h,ceil(end/2),:,1);
	if ~isfinite(crop_amounts(3))
	    bail = false;
	    for b = h:-1:t
	        for a = 1:c
	            if ~all(col(A(b,:,a,:)) == bcol(a))
	                bail = true;
	                break;
	            end
	        end
	        if bail
	            break;
	        end
	    end
	else
	    b = h - abs(crop_amounts(3));
	end

	if padding == 0  % no padding
	    % Issue #175: there used to be a 1px minimal padding in case of crop, now removed
	    %{
	    if ~isequal([t b l r], [1 h 1 w]) % Check if we're actually croppping
	        padding = 1; % Leave one boundary pixel to avoid bleeding on resize
	        bcol(:) = nan;  % make the 1px padding transparent
	    end
	    %}
	elseif abs(padding) < 1  % pad value is a relative fraction of image size
	    padding = sign(padding)*round(mean([b-t r-l])*abs(padding)); % ADJUST PADDING
	else  % pad value is in units of 1/72" points
	    padding = round(padding);  % fix cases of non-integer pad value
	end

	if padding > 0  % extra padding
	    % Create an empty image, containing the background color, that has the
	    % cropped image size plus the padded border
	    B = repmat(bcol,[(b-t)+1+padding*2,(r-l)+1+padding*2,1,n]);  % Fix per Luiz Carvalho
	    % vA - coordinates in A that contain the cropped image
	    vA = [t b l r];
	    % vB - coordinates in B where the cropped version of A will be placed
	    vB = [padding+1, (b-t)+1+padding, padding+1, (r-l)+1+padding];
	    % Place the original image in the empty image
	    B(vB(1):vB(2), vB(3):vB(4), :, :) = A(vA(1):vA(2), vA(3):vA(4), :, :);
	    A = B;
	else  % extra cropping
	    vA = [t-padding b+padding l-padding r+padding];
	    A = A(vA(1):vA(2), vA(3):vA(4), :, :);
	    vB = [NaN NaN NaN NaN];
	end

	% For EPS cropping, determine the relative BoundingBox - bb_rel
	bb_rel = [l-1 h-b-1 r+1 h-t+1]./[w h w h];
end

function A = col(A)
	A = A(:);
end

function eps2pdf(source, dest, crop, append, gray, quality, gs_options)
%EPS2PDF  Convert an eps file to pdf format using ghostscript
%
% Examples:
%   eps2pdf source dest
%   eps2pdf(source, dest, crop)
%   eps2pdf(source, dest, crop, append)
%   eps2pdf(source, dest, crop, append, gray)
%   eps2pdf(source, dest, crop, append, gray, quality)
%   eps2pdf(source, dest, crop, append, gray, quality, gs_options)
%
% This function converts an eps file to pdf format. The output can be
% optionally cropped and also converted to grayscale. If the output pdf
% file already exists then the eps file can optionally be appended as a new
% page on the end of the eps file. The level of bitmap compression can also
% optionally be set.
%
% This function requires that you have ghostscript installed on your
% system. Ghostscript can be downloaded from: http://www.ghostscript.com
%
% Inputs:
%   source  - filename of the source eps file to convert. The filename is
%	         assumed to already have the extension ".eps".
%   dest	- filename of the destination pdf file. The filename is assumed
%	         to already have the extension ".pdf".
%   crop	- boolean indicating whether to crop the borders off the pdf.
%	         Default: true.
%   append  - boolean indicating whether the eps should be appended to the
%	         end of the pdf as a new page (if the pdf exists already).
%	         Default: false.
%   gray	- boolean indicating whether the output pdf should be grayscale
%	         or not. Default: false.
%   quality - scalar indicating the level of image bitmap quality to
%	         output. A larger value gives a higher quality. quality > 100
%	         gives lossless output. Default: ghostscript prepress default.
%   gs_options - optional ghostscript options (e.g.: '-dNoOutputFonts'). If
%	            multiple options are needed, enclose in call array: {'-a','-b'}

% Copyright (C) Oliver Woodford 2009-2014, Yair Altman 2015-

% Suggestion of appending pdf files provided by Matt C at:
% http://www.mathworks.com/matlabcentral/fileexchange/23629

% Thank you to Fabio Viola for pointing out compression artifacts, leading
% to the quality setting.
% Thank you to Scott for pointing out the subsampling of very small images,
% which was fixed for lossless compression settings.

% 09/12/11: Pass font path to ghostscript
% 26/02/15: If temp dir is not writable, use the dest folder for temp
%	       destination files (Javier Paredes)
% 28/02/15: Enable users to specify optional ghostscript options (issue #36)
% 01/03/15: Upon GS error, retry without the -sFONTPATH= option (this might solve
%	       some /findfont errors according to James Rankin, FEX Comment 23/01/15)
% 23/06/15: Added extra debug info in case of ghostscript error; code indentation
% 04/10/15: Suggest a workaround for issue #41 (missing font path; thanks Mariia Fedotenkova)
% 22/02/16: Bug fix from latest release of this file (workaround for issue #41)
% 20/03/17: Added informational message in case of GS croak (issue #186)
% 16/01/18: Improved appending of multiple EPS files into single PDF (issue #233; thanks @shartjen)

	% Intialise the options string for ghostscript
	options = ['-q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -dPDFSETTINGS=/prepress -sOutputFile="' dest '"'];
	% Set crop option
	if nargin < 3 || crop
	    options = [options ' -dEPSCrop'];
	end
	% Set the font path
	fp = font_path();
	if ~isempty(fp)
	    options = [options ' -sFONTPATH="' fp '"'];
	end
	% Set the grayscale option
	if nargin > 4 && gray
	    options = [options ' -sColorConversionStrategy=Gray -dProcessColorModel=/DeviceGray'];
	end
	% Set the bitmap quality
	if nargin > 5 && ~isempty(quality)
	    options = [options ' -dAutoFilterColorImages=false -dAutoFilterGrayImages=false'];
	    if quality > 100
	        options = [options ' -dColorImageFilter=/FlateEncode -dGrayImageFilter=/FlateEncode -c ".setpdfwrite << /ColorImageDownsampleThreshold 10 /GrayImageDownsampleThreshold 10 >> setdistillerparams"'];
	    else
	        options = [options ' -dColorImageFilter=/DCTEncode -dGrayImageFilter=/DCTEncode'];
	        v = 1 + (quality < 80);
	        quality = 1 - quality / 100;
	        s = sprintf('<< /QFactor %.2f /Blend 1 /HSample [%d 1 1 %d] /VSample [%d 1 1 %d] >>', quality, v, v, v, v);
	        options = sprintf('%s -c ".setpdfwrite << /ColorImageDict %s /GrayImageDict %s >> setdistillerparams"', options, s, s);
	    end
	end
	% Enable users to specify optional ghostscript options (issue #36)
	if nargin > 6 && ~isempty(gs_options)
	    if iscell(gs_options)
	        gs_options = sprintf(' %s',gs_options{:});
	    elseif ~ischar(gs_options)
	        error('gs_options input argument must be a string or cell-array of strings');
	    else
	        gs_options = [' ' gs_options];
	    end
	    options = [options gs_options];
	end
	% Check if the output file exists
	if nargin > 3 && append && exist(dest, 'file') == 2
	    % File exists - append current figure to the end
	    tmp_nam = [tempname '.pdf'];
	    [fpath,fname,fext] = fileparts(tmp_nam);
	    try
	        % Ensure that the temp dir is writable (Javier Paredes 26/2/15)
	        fid = fopen(tmp_nam,'w');
	        fwrite(fid,1);
	        fclose(fid);
	        delete(tmp_nam);
	    catch
	        % Temp dir is not writable, so use the dest folder
	        fpath = fileparts(dest);
	        tmp_nam = fullfile(fpath,[fname fext]);
	    end
	    % Copy the existing (dest) pdf file to temporary folder
	    copyfile(dest, tmp_nam);
	    % Produce an interim pdf of the source eps, rather than adding the eps directly (issue #233)
	    ghostscript([options ' -f "' source '"']);
	    [~,fname] = fileparts(tempname);
	    tmp_nam2 = fullfile(fpath,[fname fext]); % ensure using a writable folder (not necessarily tempdir)
	    copyfile(dest, tmp_nam2);
	    % Add the existing pdf and interim pdf as inputs to ghostscript
	    %options = [options ' -f "' tmp_nam '" "' source '"'];  % append the source eps to dest pdf
	    options = [options ' -f "' tmp_nam '" "' tmp_nam2 '"']; % append the interim pdf to dest pdf
	    try
	        % Convert to pdf using ghostscript
	        [status, message] = ghostscript(options);
	    catch me
	        % Delete the intermediate files and rethrow the error
	        delete(tmp_nam);
	        delete(tmp_nam2);
	        rethrow(me);
	    end
	    % Delete the intermediate (temporary) files
	    delete(tmp_nam);
	    delete(tmp_nam2);
	else
	    % File doesn't exist or should be over-written
	    % Add the source eps file as input to ghostscript
	    options = [options ' -f "' source '"'];
	    % Convert to pdf using ghostscript
	    [status, message] = ghostscript(options);
	end
	% Check for error
	if status
	    % Retry without the -sFONTPATH= option (this might solve some GS
	    % /findfont errors according to James Rankin, FEX Comment 23/01/15)
	    orig_options = options;
	    if ~isempty(fp)
	        options = regexprep(options, ' -sFONTPATH=[^ ]+ ',' ');
	        status = ghostscript(options);
	        if ~status, return; end  % hurray! (no error)
	    end
	    % Report error
	    if isempty(message)
	        error('Unable to generate pdf. Check destination directory is writable.');
	    elseif ~isempty(strfind(message,'/typecheck in /findfont'))
	        % Suggest a workaround for issue #41 (missing font path)
	        font_name = strtrim(regexprep(message,'.*Operand stack:\s*(.*)\s*Execution.*','$1'));
	        fprintf(2, 'Ghostscript error: could not find the following font(s): %s\n', font_name);
	        fpath = fileparts(mfilename('fullpath'));
	        gs_fonts_file = fullfile(fpath, '.ignore', 'gs_font_path.txt');
	        fprintf(2, '  try to add the font''s folder to your %s file\n\n', gs_fonts_file);
	        error('export_fig error');
	    else
	        fprintf(2, '\nGhostscript error: perhaps %s is open by another application\n', dest);
	        if ~isempty(gs_options)
	            fprintf(2, '  or maybe the%s option(s) are not accepted by your GS version\n', gs_options);
	        end
	        fprintf(2, '  or maybe you have another gs executable in your system''s path\n');
	        fprintf(2, 'Ghostscript options: %s\n\n', orig_options);
	        error(message);
	    end
	end
end

% Function to return (and create, where necessary) the font path
function fp = font_path()
	fp = user_string('gs_font_path');
	if ~isempty(fp)
	    return
	end
	% Create the path
	% Start with the default path
	fp = getenv('GS_FONTPATH');
	% Add on the typical directories for a given OS
	if ispc
	    if ~isempty(fp)
	        fp = [fp ';'];
	    end
	    fp = [fp getenv('WINDIR') filesep 'Fonts'];
	else
	    if ~isempty(fp)
	        fp = [fp ':'];
	    end
	    fp = [fp '/usr/share/fonts:/usr/local/share/fonts:/usr/share/fonts/X11:/usr/local/share/fonts/X11:/usr/share/fonts/truetype:/usr/local/share/fonts/truetype'];
	end
	user_string('gs_font_path', fp);
end

%FIX_LINES  Improves the line style of eps files generated by print
%
% Examples:
%   fix_lines fname
%   fix_lines fname fname2
%   fstrm_out = fixlines(fstrm_in)
%
% This function improves the style of lines in eps files generated by
% MATLAB's print function, making them more similar to those seen on
% screen. Grid lines are also changed from a dashed style to a dotted
% style, for greater differentiation from dashed lines.
% 
% The function also places embedded fonts after the postscript header, in
% versions of MATLAB which place the fonts first (R2006b and earlier), in
% order to allow programs such as Ghostscript to find the bounding box
% information.
%
%IN:
%   fname - Name or path of source eps file.
%   fname2 - Name or path of destination eps file. Default: same as fname.
%   fstrm_in - File contents of a MATLAB-generated eps file.
%
%OUT:
%   fstrm_out - Contents of the eps file with line styles fixed.

% Copyright: (C) Oliver Woodford, 2008-2014

% The idea of editing the EPS file to change line styles comes from Jiro
% Doke's FIXPSLINESTYLE (fex id: 17928)
% The idea of changing dash length with line width came from comments on
% fex id: 5743, but the implementation is mine :)

% Thank you to Sylvain Favrot for bringing the embedded font/bounding box
% interaction in older versions of MATLAB to my attention.
% Thank you to D Ko for bringing an error with eps files with tiff previews
% to my attention.
% Thank you to Laurence K for suggesting the check to see if the file was
% opened.

% 01/03/15: Issue #20: warn users if using this function in HG2 (R2014b+)
% 27/03/15: Fixed out of memory issue with enormous EPS files (generated by print() with OpenGL renderer), related to issue #39

function fstrm = fix_lines(fstrm, fname2)

% Issue #20: warn users if using this function in HG2 (R2014b+)
if using_hg2
	warning('export_fig:hg2','The fix_lines function should not be used in this Matlab version.');
end
	
if nargout == 0 || nargin > 1
	if nargin < 2
	    % Overwrite the input file
	    fname2 = fstrm;
	end
	% Read in the file
	fstrm = read_write_entire_textfile(fstrm);
end

% Move any embedded fonts after the postscript header
if strcmp(fstrm(1:15), '%!PS-AdobeFont-')
	% Find the start and end of the header
	ind = regexp(fstrm, '[\n\r]%!PS-Adobe-');
	[ind2, ind2] = regexp(fstrm, '[\n\r]%%EndComments[\n\r]+');
	% Put the header first
	if ~isempty(ind) && ~isempty(ind2) && ind(1) < ind2(1)
	    fstrm = fstrm([ind(1)+1:ind2(1) 1:ind(1) ind2(1)+1:end]);
	end
end

% Make sure all line width commands come before the line style definitions,
% so that dash lengths can be based on the correct widths
% Find all line style sections
ind = [regexp(fstrm, '[\n\r]SO[\n\r]'),... % This needs to be here even though it doesn't have dots/dashes!
	   regexp(fstrm, '[\n\r]DO[\n\r]'),...
	   regexp(fstrm, '[\n\r]DA[\n\r]'),...
	   regexp(fstrm, '[\n\r]DD[\n\r]')];
ind = sort(ind);
% Find line width commands
[ind2, ind3] = regexp(fstrm, '[\n\r]\d* w[\n\r]');
% Go through each line style section and swap with any line width commands
% near by
b = 1;
m = numel(ind);
n = numel(ind2);
for a = 1:m
	% Go forwards width commands until we pass the current line style
	while b <= n && ind2(b) < ind(a)
	    b = b + 1;
	end
	if b > n
	    % No more width commands
	    break;
	end
	% Check we haven't gone past another line style (including SO!)
	if a < m && ind2(b) > ind(a+1)
	    continue;
	end
	% Are the commands close enough to be confident we can swap them?
	if (ind2(b) - ind(a)) > 8
	    continue;
	end
	% Move the line style command below the line width command
	fstrm(ind(a)+1:ind3(b)) = [fstrm(ind(a)+4:ind3(b)) fstrm(ind(a)+1:ind(a)+3)];
	b = b + 1;
end

% Find any grid line definitions and change to GR format
% Find the DO sections again as they may have moved
ind = int32(regexp(fstrm, '[\n\r]DO[\n\r]'));
if ~isempty(ind)
	% Find all occurrences of what are believed to be axes and grid lines
	ind2 = int32(regexp(fstrm, '[\n\r] *\d* *\d* *mt *\d* *\d* *L[\n\r]'));
	if ~isempty(ind2)
	    % Now see which DO sections come just before axes and grid lines
	    ind2 = repmat(ind2', [1 numel(ind)]) - repmat(ind, [numel(ind2) 1]);
	    ind2 = any(ind2 > 0 & ind2 < 12); % 12 chars seems about right
	    ind = ind(ind2);
	    % Change any regions we believe to be grid lines to GR
	    fstrm(ind+1) = 'G';
	    fstrm(ind+2) = 'R';
	end
end

% Define the new styles, including the new GR format
% Dot and dash lengths have two parts: a constant amount plus a line width
% variable amount. The constant amount comes after dpi2point, and the
% variable amount comes after currentlinewidth. If you want to change
% dot/dash lengths for a one particular line style only, edit the numbers
% in the /DO (dotted lines), /DA (dashed lines), /DD (dot dash lines) and
% /GR (grid lines) lines for the style you want to change.
new_style = {'/dom { dpi2point 1 currentlinewidth 0.08 mul add mul mul } bdef',... % Dot length macro based on line width
	         '/dam { dpi2point 2 currentlinewidth 0.04 mul add mul mul } bdef',... % Dash length macro based on line width
	         '/SO { [] 0 setdash 0 setlinecap } bdef',... % Solid lines
	         '/DO { [1 dom 1.2 dom] 0 setdash 0 setlinecap } bdef',... % Dotted lines
	         '/DA { [4 dam 1.5 dam] 0 setdash 0 setlinecap } bdef',... % Dashed lines
	         '/DD { [1 dom 1.2 dom 4 dam 1.2 dom] 0 setdash 0 setlinecap } bdef',... % Dot dash lines
	         '/GR { [0 dpi2point mul 4 dpi2point mul] 0 setdash 1 setlinecap } bdef'}; % Grid lines - dot spacing remains constant

% Construct the output
% This is the original (memory-intensive) code:
%first_sec = strfind(fstrm, '% line types:'); % Isolate line style definition section
%[second_sec, remaining] = strtok(fstrm(first_sec+1:end), '/');
%[remaining, remaining] = strtok(remaining, '%');
%fstrm = [fstrm(1:first_sec) second_sec sprintf('%s\r', new_style{:}) remaining];
fstrm = regexprep(fstrm,'(% line types:.+?)/.+?%',['$1',sprintf('%s\r',new_style{:}),'%']);

% Write the output file
if nargout == 0 || nargin > 1
	read_write_entire_textfile(fname2, fstrm);
end
end

function varargout = ghostscript(cmd)
%GHOSTSCRIPT  Calls a local GhostScript executable with the input command
%
% Example:
%   [status result] = ghostscript(cmd)
%
% Attempts to locate a ghostscript executable, finally asking the user to
% specify the directory ghostcript was installed into. The resulting path
% is stored for future reference.
% 
% Once found, the executable is called with the input command string.
%
% This function requires that you have Ghostscript installed on your
% system. You can download this from: http://www.ghostscript.com
%
% IN:
%   cmd - Command string to be passed into ghostscript.
%
% OUT:
%   status - 0 iff command ran without problem.
%   result - Output from ghostscript.

% Copyright: Oliver Woodford, 2009-2015, Yair Altman 2015-
%{
% Thanks to Jonas Dorn for the fix for the title of the uigetdir window on Mac OS.
% Thanks to Nathan Childress for the fix to default location on 64-bit Windows systems.
% 27/04/11 - Find 64-bit Ghostscript on Windows. Thanks to Paul Durack and
%	        Shaun Kline for pointing out the issue
% 04/05/11 - Thanks to David Chorlian for pointing out an alternative
%	        location for gs on linux.
% 12/12/12 - Add extra executable name on Windows. Thanks to Ratish
%	        Punnoose for highlighting the issue.
% 28/06/13 - Fix error using GS 9.07 in Linux. Many thanks to Jannick
%	        Steinbring for proposing the fix.
% 24/10/13 - Fix error using GS 9.07 in Linux. Many thanks to Johannes 
%	        for the fix.
% 23/01/14 - Add full path to ghostscript.txt in warning. Thanks to Koen
%	        Vermeer for raising the issue.
% 27/02/15 - If Ghostscript croaks, display suggested workarounds
% 30/03/15 - Improved performance by caching status of GS path check, if ok
% 14/05/15 - Clarified warning message in case GS path could not be saved
% 29/05/15 - Avoid cryptic error in case the ghostscipt path cannot be saved (issue #74)
% 10/11/15 - Custom GS installation webpage for MacOS. Thanks to Andy Hueni via FEX
%}

	try
	    % Call ghostscript
	    [varargout{1:nargout}] = system([gs_command(gs_path()) cmd]);
	catch err
	    % Display possible workarounds for Ghostscript croaks
	    url1 = 'https://github.com/altmany/export_fig/issues/12#issuecomment-61467998';  % issue #12
	    url2 = 'https://github.com/altmany/export_fig/issues/20#issuecomment-63826270';  % issue #20
	    hg2_str = ''; if using_hg2, hg2_str = ' or Matlab R2014a'; end
	    fprintf(2, 'Ghostscript error. Rolling back to GS 9.10%s may possibly solve this:\n * <a href="%s">%s</a> ',hg2_str,url1,url1);
	    if using_hg2
	        fprintf(2, '(GS 9.10)\n * <a href="%s">%s</a> (R2014a)',url2,url2);
	    end
	    fprintf('\n\n');
	    if ismac || isunix
	        url3 = 'https://github.com/altmany/export_fig/issues/27';  % issue #27
	        fprintf(2, 'Alternatively, this may possibly be due to a font path issue:\n * <a href="%s">%s</a>\n\n',url3,url3);
	        % issue #20
	        fpath = which(mfilename);
	        if isempty(fpath), fpath = [mfilename('fullpath') '.m']; end
	        fprintf(2, 'Alternatively, if you are using csh, modify shell_cmd from "export..." to "setenv ..."\nat the bottom of <a href="matlab:opentoline(''%s'',174)">%s</a>\n\n',fpath,fpath);
	    end
	    rethrow(err);
	end
end

function path_ = gs_path
	% Return a valid path
	% Start with the currently set path
	path_ = user_string('ghostscript');
	% Check the path works
	if check_gs_path(path_)
	    return
	end
	% Check whether the binary is on the path
	if ispc
	    bin = {'gswin32c.exe', 'gswin64c.exe', 'gs'};
	else
	    bin = {'gs'};
	end
	for a = 1:numel(bin)
	    path_ = bin{a};
	    if check_store_gs_path(path_)
	        return
	    end
	end
	% Search the obvious places
	if ispc
	    default_location = 'C:\Program Files\gs\';
	    dir_list = dir(default_location);
	    if isempty(dir_list)
	        default_location = 'C:\Program Files (x86)\gs\'; % Possible location on 64-bit systems
	        dir_list = dir(default_location);
	    end
	    executable = {'\bin\gswin32c.exe', '\bin\gswin64c.exe'};
	    ver_num = 0;
	    % If there are multiple versions, use the newest
	    for a = 1:numel(dir_list)
	        ver_num2 = sscanf(dir_list(a).name, 'gs%g');
	        if ~isempty(ver_num2) && ver_num2 > ver_num
	            for b = 1:numel(executable)
	                path2 = [default_location dir_list(a).name executable{b}];
	                if exist(path2, 'file') == 2
	                    path_ = path2;
	                    ver_num = ver_num2;
	                end
	            end
	        end
	    end
	    if check_store_gs_path(path_)
	        return
	    end
	else
	    executable = {'/usr/bin/gs', '/usr/local/bin/gs'};
	    for a = 1:numel(executable)
	        path_ = executable{a};
	        if check_store_gs_path(path_)
	            return
	        end
	    end
	end
	% Ask the user to enter the path
	while true
	    if strncmp(computer, 'MAC', 3) % Is a Mac
	        % Give separate warning as the uigetdir dialogue box doesn't have a
	        % title
	        uiwait(warndlg('Ghostscript not found. Please locate the program.'))
	    end
	    base = uigetdir('/', 'Ghostcript not found. Please locate the program.');
	    if isequal(base, 0)
	        % User hit cancel or closed window
	        break;
	    end
	    base = [base filesep]; %#ok<AGROW>
	    bin_dir = {'', ['bin' filesep], ['lib' filesep]};
	    for a = 1:numel(bin_dir)
	        for b = 1:numel(bin)
	            path_ = [base bin_dir{a} bin{b}];
	            if exist(path_, 'file') == 2
	                if check_store_gs_path(path_)
	                    return
	                end
	            end
	        end
	    end
	end
	if ismac
	    error('Ghostscript not found. Have you installed it (http://pages.uoregon.edu/koch)?');
	else
	    error('Ghostscript not found. Have you installed it from www.ghostscript.com?');
	end
end

function good = check_store_gs_path(path_)
	% Check the path is valid
	good = check_gs_path(path_);
	if ~good
	    return
	end
	% Update the current default path to the path found
	if ~user_string('ghostscript', path_)
	    filename = fullfile(fileparts(which('user_string.m')), '.ignore', 'ghostscript.txt');
	    warning('Path to ghostscript installation could not be saved in %s (perhaps a permissions issue). You can manually create this file and set its contents to %s, to improve performance in future invocations (this warning is safe to ignore).', filename, path_);
	    return
	end
end

function good = check_gs_path(path_)
	persistent isOk
	if isempty(path_)
	    isOk = false;
	elseif ~isequal(isOk,true)
	    % Check whether the path is valid
	    [status, message] = system([gs_command(path_) '-h']); %#ok<ASGLU>
	    isOk = status == 0;
	end
	good = isOk;
end

function cmd = gs_command(path_)
	% Initialize any required system calls before calling ghostscript
	% TODO: in Unix/Mac, find a way to determine whether to use "export" (bash) or "setenv" (csh/tcsh)
	shell_cmd = '';
	if isunix
	    shell_cmd = 'export LD_LIBRARY_PATH=""; '; % Avoids an error on Linux with GS 9.07
	end
	if ismac
	    shell_cmd = 'export DYLD_LIBRARY_PATH=""; ';  % Avoids an error on Mac with GS 9.07
	end
	% Construct the command string
	cmd = sprintf('%s"%s" ', shell_cmd, path_);
end

%IM2GIF Convert a multiframe image to an animated GIF file
%
% Examples:
%   im2gif infile
%   im2gif infile outfile
%   im2gif(A, outfile)
%   im2gif(..., '-nocrop')
%   im2gif(..., '-nodither')
%   im2gif(..., '-ncolors', n)
%   im2gif(..., '-loops', n)
%   im2gif(..., '-delay', n) 
%   
% This function converts a multiframe image to an animated GIF.
%
% To create an animation from a series of figures, export to a multiframe
% TIFF file using export_fig, then convert to a GIF, as follows:
%
%	for a = 2 .^ (3:6)
%	   peaks(a);
%	   export_fig test.tif -nocrop -append
%	end
%	im2gif('test.tif', '-delay', 0.5);
%
%IN:
%   infile - string containing the name of the input image.
%   outfile - string containing the name of the output image (must have the
%	         .gif extension). Default: infile, with .gif extension.
%   A - HxWxCxN array of input images, stacked along fourth dimension, to
%	   be converted to gif.
%   -nocrop - option indicating that the borders of the output are not to
%	         be cropped.
%   -nodither - option indicating that dithering is not to be used when
%	           converting the image.
%   -ncolors - option pair, the value of which indicates the maximum number
%	          of colors the GIF can have. This can also be a quantization
%	          tolerance, between 0 and 1. Default/maximum: 256.
%   -loops - option pair, the value of which gives the number of times the
%	        animation is to be looped. Default: 65535.
%   -delay - option pair, the value of which gives the time, in seconds,
%	        between frames. Default: 1/15.

% Copyright (C) Oliver Woodford 2011

%{
% 14/02/18: Merged issue #235: reduced memory usage, improved performance (thanks to @numb7rs)
%}

function im2gif(A, varargin)

% Parse the input arguments
[A, options] = parse_args_im2gif(A, varargin{:});

if options.crop ~= 0
	% Crop
	A = crop_borders(A, A(ceil(end/2),1,:,1));
end

% Convert to indexed image
[h, w, c, n] = size(A);

% Issue #235: Using unique(A,'rows') on the whole image stack at once causes
% massive memory usage when dealing with large images (at least on Matlab 2017b).
% Running unique(...) on individual frames, then again on the results drastically
% reduces the memory usage & slightly improves the execution time (@numb7rs).
uns = cell(1,size(A,4));
for nn=1:size(A,4)
	uns{nn}=unique(reshape(A(:,:,:,nn), h*w, c),'rows');
end
map=unique(cell2mat(uns'),'rows');

A = reshape(permute(A, [1 2 4 3]), h, w*n, c);

if size(map, 1) > 256
	dither_str = {'dither', 'nodither'};
	dither_str = dither_str{1+(options.dither==0)};
	if options.ncolors <= 1
	    [B, map] = rgb2ind(A, options.ncolors, dither_str);
	    if size(map, 1) > 256
	        [B, map] = rgb2ind(A, 256, dither_str);
	    end
	else
	    [B, map] = rgb2ind(A, min(round(options.ncolors), 256), dither_str);
	end
else
	if max(map(:)) > 1
	    map = double(map) / 255;
	    A = double(A) / 255;
	end
	B = rgb2ind(im2double(A), map);
end
B = reshape(B, h, w, 1, n);

% Bug fix to rgb2ind
map(B(1)+1,:) = im2double(A(1,1,:));

% Save as a gif
imwrite(B, map, options.outfile, 'LoopCount', round(options.loops(1)), 'DelayTime', options.delay);
end

%% Parse the input arguments
function [A, options] = parse_args_im2gif(A, varargin)
% Set the defaults
options = struct('outfile', '', ...
	             'dither', true, ...
	             'crop', true, ...
	             'ncolors', 256, ...
	             'loops', 65535, ...
	             'delay', 1/15);

% Go through the arguments
a = 0;
n = numel(varargin);
while a < n
	a = a + 1;
	if ischar(varargin{a}) && ~isempty(varargin{a})
	    if varargin{a}(1) == '-'
	        opt = lower(varargin{a}(2:end));
	        switch opt
	            case 'nocrop'
	                options.crop = false;
	            case 'nodither'
	                options.dither = false;
	            otherwise
	                if ~isfield(options, opt)
	                    error('Option %s not recognized', varargin{a});
	                end
	                a = a + 1;
	                if ischar(varargin{a}) && ~ischar(options.(opt))
	                    options.(opt) = str2double(varargin{a});
	                else
	                    options.(opt) = varargin{a};
	                end
	        end
	    else
	        options.outfile = varargin{a};
	    end
	end
end

if isempty(options.outfile)
	if ~ischar(A)
	    error('No output filename given.');
	end
	% Generate the output filename from the input filename
	[path, outfile] = fileparts(A);
	options.outfile = fullfile(path, [outfile '.gif']);
end

if ischar(A)
	% Read in the image
	A = imread_rgb(A);
end
end

%% Read image to uint8 rgb array
function [A, alpha] = imread_rgb(name)
% Get file info
info = imfinfo(name);
% Special case formats
switch lower(info(1).Format)
	case 'gif'
	    [A, map] = imread(name, 'frames', 'all');
	    if ~isempty(map)
	        map = uint8(map * 256 - 0.5); % Convert to uint8 for storage
	        A = reshape(map(uint32(A)+1,:), [size(A) size(map, 2)]); % Assume indexed from 0
	        A = permute(A, [1 2 5 4 3]);
	    end
	case {'tif', 'tiff'}
	    A = cell(numel(info), 1);
	    for a = 1:numel(A)
	        [A{a}, map] = imread(name, 'Index', a, 'Info', info);
	        if ~isempty(map)
	            map = uint8(map * 256 - 0.5); % Convert to uint8 for storage
	            A{a} = reshape(map(uint32(A{a})+1,:), [size(A) size(map, 2)]); % Assume indexed from 0
	        end
	        if size(A{a}, 3) == 4
	            % TIFF in CMYK colourspace - convert to RGB
	            if isfloat(A{a})
	                A{a} = A{a} * 255;
	            else
	                A{a} = single(A{a});
	            end
	            A{a} = 255 - A{a};
	            A{a}(:,:,4) = A{a}(:,:,4) / 255;
	            A{a} = uint8(A(:,:,1:3) .* A{a}(:,:,[4 4 4]));
	        end
	    end
	    A = cat(4, A{:});
	otherwise
	    [A, map, alpha] = imread(name);
	    A = A(:,:,:,1); % Keep only first frame of multi-frame files
	    if ~isempty(map)
	        map = uint8(map * 256 - 0.5); % Convert to uint8 for storage
	        A = reshape(map(uint32(A)+1,:), [size(A) size(map, 2)]); % Assume indexed from 0
	    elseif size(A, 3) == 4
	        % Assume 4th channel is an alpha matte
	        alpha = A(:,:,4);
	        A = A(:,:,1:3);
	    end
end
end

function fh = isolate_axes(ah, vis)
%ISOLATE_AXES Isolate the specified axes in a figure on their own
%
% Examples:
%   fh = isolate_axes(ah)
%   fh = isolate_axes(ah, vis)
%
% This function will create a new figure containing the axes/uipanels
% specified, and also their associated legends and colorbars. The objects
% specified must all be in the same figure, but they will generally only be
% a subset of the objects in the figure.
%
% IN:
%	ah - An array of axes and uipanel handles, which must come from the
%	     same figure.
%	vis - A boolean indicating whether the new figure should be visible.
%	      Default: false.
%
% OUT:
%	fh - The handle of the created figure.

% Copyright (C) Oliver Woodford 2011-2013

% Thank you to Rosella Blatt for reporting a bug to do with axes in GUIs
% 16/03/12: Moved copyfig to its own function. Thanks to Bob Fratantonio
%	       for pointing out that the function is also used in export_fig.m
% 12/12/12: Add support for isolating uipanels. Thanks to michael for suggesting it
% 08/10/13: Bug fix to allchildren suggested by Will Grant (many thanks!)
% 05/12/13: Bug fix to axes having different units. Thanks to Remington Reid for reporting
% 21/04/15: Bug fix for exporting uipanels with legend/colorbar on HG1 (reported by Alvaro
%	       on FEX page as a comment on 24-Apr-2014); standardized indentation & help section
% 22/04/15: Bug fix: legends and colorbars were not exported when exporting axes handle in HG2

	% Make sure we have an array of handles
	if ~all(ishandle(ah))
	    error('ah must be an array of handles');
	end
	% Check that the handles are all for axes or uipanels, and are all in the same figure
	fh = ancestor(ah(1), 'figure');
	nAx = numel(ah);
	for a = 1:nAx
	    if ~ismember(get(ah(a), 'Type'), {'axes', 'uipanel'})
	        error('All handles must be axes or uipanel handles.');
	    end
	    if ~isequal(ancestor(ah(a), 'figure'), fh)
	        error('Axes must all come from the same figure.');
	    end
	end
	% Tag the objects so we can find them in the copy
	old_tag = get(ah, 'Tag');
	if nAx == 1
	    old_tag = {old_tag};
	end
	set(ah, 'Tag', 'ObjectToCopy');
	% Create a new figure exactly the same as the old one
	fh = copyfig(fh); %copyobj(fh, 0);
	if nargin < 2 || ~vis
	    set(fh, 'Visible', 'off');
	end
	% Reset the object tags
	for a = 1:nAx
	    set(ah(a), 'Tag', old_tag{a});
	end
	% Find the objects to save
	ah = findall(fh, 'Tag', 'ObjectToCopy');
	if numel(ah) ~= nAx
	    close(fh);
	    error('Incorrect number of objects found.');
	end
	% Set the axes tags to what they should be
	for a = 1:nAx
	    set(ah(a), 'Tag', old_tag{a});
	end
	% Keep any legends and colorbars which overlap the subplots
	% Note: in HG1 these are axes objects; in HG2 they are separate objects, therefore we
	%       don't test for the type, only the tag (hopefully nobody but Matlab uses them!)
	lh = findall(fh, 'Tag', 'legend', '-or', 'Tag', 'Colorbar');
	nLeg = numel(lh);
	if nLeg > 0
	    set([ah(:); lh(:)], 'Units', 'normalized');
	    try
	        ax_pos = get(ah, 'OuterPosition'); % axes and figures have the OuterPosition property
	    catch
	        ax_pos = get(ah, 'Position'); % uipanels only have Position, not OuterPosition
	    end
	    if nAx > 1
	        ax_pos = cell2mat(ax_pos(:));
	    end
	    ax_pos(:,3:4) = ax_pos(:,3:4) + ax_pos(:,1:2);
	    try
	        leg_pos = get(lh, 'OuterPosition');
	    catch
	        leg_pos = get(lh, 'Position');  % No OuterPosition in HG2, only in HG1
	    end
	    if nLeg > 1;
	        leg_pos = cell2mat(leg_pos);
	    end
	    leg_pos(:,3:4) = leg_pos(:,3:4) + leg_pos(:,1:2);
	    ax_pos = shiftdim(ax_pos, -1);
	    % Overlap test
	    M = bsxfun(@lt, leg_pos(:,1), ax_pos(:,:,3)) & ...
	        bsxfun(@lt, leg_pos(:,2), ax_pos(:,:,4)) & ...
	        bsxfun(@gt, leg_pos(:,3), ax_pos(:,:,1)) & ...
	        bsxfun(@gt, leg_pos(:,4), ax_pos(:,:,2));
	    ah = [ah; lh(any(M, 2))];
	end
	% Get all the objects in the figure
	axs = findall(fh);
	% Delete everything except for the input objects and associated items
	delete(axs(~ismember(axs, [ah; allchildren(ah); allancestors(ah)])));
end

function ah = allchildren(ah)
	ah = findall(ah);
	if iscell(ah)
	    ah = cell2mat(ah);
	end
	ah = ah(:);
end

function ph = allancestors(ah)
	ph = [];
	for a = 1:numel(ah)
	    h = get(ah(a), 'parent');
	    while h ~= 0
	        ph = [ph; h];
	        h = get(h, 'parent');
	    end
	end
end

%PDF2EPS  Convert a pdf file to eps format using pdftops
%
% Examples:
%   pdf2eps source dest
%
% This function converts a pdf file to eps format.
%
% This function requires that you have pdftops, from the Xpdf suite of
% functions, installed on your system. This can be downloaded from:
% http://xpdfreader.com
%
% Inputs:
%   source - filename of the source pdf file to convert. The filename is
%	        assumed to already have the extension ".pdf".
%   dest - filename of the destination eps file. The filename is assumed to
%	      already have the extension ".eps".

% Copyright (C) Oliver Woodford 2009-2010, Yair Altman 2015-

% Thanks to Aldebaro Klautau for reporting a bug when saving to
% non-existant directories.

% 22/09/2018 - Xpdf website changed to xpdfreader.com

function pdf2eps(source, dest)
	% Construct the options string for pdftops
	options = ['-q -paper match -eps -level2 "' source '" "' dest '"'];

	% Convert to eps using pdftops
	[status, message] = pdftops(options);

	% Check for error
	if status
	    % Report error
	    if isempty(message)
	        error('Unable to generate eps. Check destination directory is writable.');
	    else
	        error(message);
	    end
	end

	% Fix the DSC error created by pdftops
	fid = fopen(dest, 'r+');
	if fid == -1
	    % Cannot open the file
	    return
	end
	fgetl(fid); % Get the first line
	str = fgetl(fid); % Get the second line
	if strcmp(str(1:min(13, end)), '% Produced by')
	    fseek(fid, -numel(str)-1, 'cof');
	    fwrite(fid, '%'); % Turn ' ' into '%'
	end
	fclose(fid);
end

function varargout = pdftops(cmd)
%PDFTOPS  Calls a local pdftops executable with the input command
%
% Example:
%   [status result] = pdftops(cmd)
%
% Attempts to locate a pdftops executable, finally asking the user to
% specify the directory pdftops was installed into. The resulting path is
% stored for future reference.
% 
% Once found, the executable is called with the input command string.
%
% This function requires that you have pdftops (from the Xpdf package)
% installed on your system. You can download this from: http://xpdfreader.com
%
% IN:
%   cmd - Command string to be passed into pdftops (e.g. '-help').
%
% OUT:
%   status - 0 iff command ran without problem.
%   result - Output from pdftops.

% Copyright: Oliver Woodford, 2009-2010

% Thanks to Jonas Dorn for the fix for the title of the uigetdir window on Mac OS.
% Thanks to Christoph Hertel for pointing out a bug in check_xpdf_path under linux.
% 23/01/2014 - Add full path to pdftops.txt in warning.
% 27/05/2015 - Fixed alert in case of missing pdftops; fixed code indentation
% 02/05/2016 - Added possible error explanation suggested by Michael Pacer (issue #137)
% 02/05/2016 - Search additional possible paths suggested by Jonas Stein (issue #147)
% 03/05/2016 - Display the specific error message if pdftops fails for some reason (issue #148)
% 22/09/2018 - Xpdf website changed to xpdfreader.com; improved popup logic

	% Call pdftops
	[varargout{1:nargout}] = system([xpdf_command(xpdf_path()) cmd]);
end

function path_ = xpdf_path
	% Return a valid path
	% Start with the currently set path
	path_ = user_string('pdftops');
	% Check the path works
	if check_xpdf_path(path_)
	    return
	end
	% Check whether the binary is on the path
	if ispc
	    bin = 'pdftops.exe';
	else
	    bin = 'pdftops';
	end
	if check_store_xpdf_path(bin)
	    path_ = bin;
	    return
	end
	% Search the obvious places
	if ispc
	    paths = {'C:\Program Files\xpdf\pdftops.exe', 'C:\Program Files (x86)\xpdf\pdftops.exe'};
	else
	    paths = {'/usr/bin/pdftops', '/usr/local/bin/pdftops'};
	end
	for a = 1:numel(paths)
	    path_ = paths{a};
	    if check_store_xpdf_path(path_)
	        return
	    end
	end

	% Ask the user to enter the path
	errMsg1 = 'Pdftops not found. Please locate the program, or install xpdf-tools from ';
	url1 = 'http://xpdfreader.com/download.html'; %='http://foolabs.com/xpdf';
	fprintf(2, '%s\n', [errMsg1 '<a href="matlab:web(''-browser'',''' url1 ''');">' url1 '</a>']);
	errMsg1 = [errMsg1 url1];
	%if strncmp(computer,'MAC',3) % Is a Mac
	%    % Give separate warning as the MacOS uigetdir dialogue box doesn't have a title
	%    uiwait(warndlg(errMsg1))
	%end

	% Provide an alternative possible explanation as per issue #137
	errMsg2 = 'If you have pdftops installed, perhaps Matlab is shaddowing it as described in ';
	url2 = 'https://github.com/altmany/export_fig/issues/137';
	fprintf(2, '%s\n', [errMsg2 '<a href="matlab:web(''-browser'',''' url2 ''');">issue #137</a>']);
	errMsg2 = [errMsg2 url1];

	state = 1;
	while 1
	    if state
	        option1 = 'Install pdftops';
	    else
	        option1 = 'Issue #137';
	    end
	    answer = questdlg({errMsg1,'',errMsg2},'Pdftops error',option1,'Locate pdftops','Cancel','Cancel');
	    drawnow;  % prevent a Matlab hang: http://undocumentedmatlab.com/blog/solving-a-matlab-hang-problem
	    switch answer
	        case 'Install pdftops'
	            web('-browser',url1);
	            state = 0;
	        case 'Issue #137'
	            web('-browser',url2);
	            state = 1;
	        case 'Locate pdftops'
	            base = uigetdir('/', errMsg1);
	            if isequal(base, 0)
	                % User hit cancel or closed window
	                break
	            end
	            base = [base filesep]; %#ok<AGROW>
	            bin_dir = {'', ['bin' filesep], ['lib' filesep]};
	            for a = 1:numel(bin_dir)
	                path_ = [base bin_dir{a} bin];
	                if exist(path_, 'file') == 2
	                    break
	                end
	            end
	            if check_store_xpdf_path(path_)
	                return
	            end

	        otherwise  % User hit Cancel or closed window
	            break
	    end
	end
	error('pdftops executable not found.');
end

function good = check_store_xpdf_path(path_)
	% Check the path is valid
	good = check_xpdf_path(path_);
	if ~good
	    return
	end
	% Update the current default path to the path found
	if ~user_string('pdftops', path_)
	    warning('Path to pdftops executable could not be saved. Enter it manually in %s.', fullfile(fileparts(which('user_string.m')), '.ignore', 'pdftops.txt'));
	    return
	end
end

function good = check_xpdf_path(path_)
	% Check the path is valid
	[good, message] = system([xpdf_command(path_) '-h']); %#ok<ASGLU>
	% system returns good = 1 even when the command runs
	% Look for something distinct in the help text
	good = ~isempty(strfind(message, 'PostScript')); %#ok<STREMP>

	% Display the error message if the pdftops executable exists but fails for some reason
	if ~good && exist(path_,'file')  % file exists but generates an error
	    fprintf('Error running %s:\n', path_);
	    fprintf(2,'%s\n\n',message);
	end
end

function cmd = xpdf_command(path_)
	% Initialize any required system calls before calling ghostscript
	% TODO: in Unix/Mac, find a way to determine whether to use "export" (bash) or "setenv" (csh/tcsh)
	shell_cmd = '';
	if isunix
	    % Avoids an error on Linux with outdated MATLAB lib files
	    % R20XXa/bin/glnxa64/libtiff.so.X
	    % R20XXa/sys/os/glnxa64/libstdc++.so.X
	    shell_cmd = 'export LD_LIBRARY_PATH=""; ';
	end
	if ismac
	    shell_cmd = 'export DYLD_LIBRARY_PATH=""; ';
	end
	% Construct the command string
	cmd = sprintf('%s"%s" ', shell_cmd, path_);
end

function [A, bcol] = print2array(fig, res, renderer, gs_options)
%PRINT2ARRAY  Exports a figure to an image array
%
% Examples:
%   A = print2array
%   A = print2array(figure_handle)
%   A = print2array(figure_handle, resolution)
%   A = print2array(figure_handle, resolution, renderer)
%   A = print2array(figure_handle, resolution, renderer, gs_options)
%   [A bcol] = print2array(...)
%
% This function outputs a bitmap image of the given figure, at the desired
% resolution.
%
% If renderer is '-painters' then ghostcript needs to be installed. This
% can be downloaded from: http://www.ghostscript.com
%
% IN:
%   figure_handle - The handle of the figure to be exported. Default: gcf.
%   resolution - Resolution of the output, as a factor of screen
%	            resolution. Default: 1.
%   renderer - string containing the renderer paramater to be passed to
%	          print. Default: '-opengl'.
%   gs_options - optional ghostscript options (e.g.: '-dNoOutputFonts'). If
%	            multiple options are needed, enclose in call array: {'-a','-b'}
%
% OUT:
%   A - MxNx3 uint8 image of the figure.
%   bcol - 1x3 uint8 vector of the background color

% Copyright (C) Oliver Woodford 2008-2014, Yair Altman 2015-
%{
% 05/09/11: Set EraseModes to normal when using opengl or zbuffer
%	       renderers. Thanks to Pawel Kocieniewski for reporting the issue.
% 21/09/11: Bug fix: unit8 -> uint8! Thanks to Tobias Lamour for reporting it.
% 14/11/11: Bug fix: stop using hardcopy(), as it interfered with figure size
%	       and erasemode settings. Makes it a bit slower, but more reliable.
%	       Thanks to Phil Trinh and Meelis Lootus for reporting the issues.
% 09/12/11: Pass font path to ghostscript.
% 27/01/12: Bug fix affecting painters rendering tall figures. Thanks to
%	       Ken Campbell for reporting it.
% 03/04/12: Bug fix to median input. Thanks to Andy Matthews for reporting it.
% 26/10/12: Set PaperOrientation to portrait. Thanks to Michael Watts for
%	       reporting the issue.
% 26/02/15: If temp dir is not writable, use the current folder for temp
%	       EPS/TIF files (Javier Paredes)
% 27/02/15: Display suggested workarounds to internal print() error (issue #16)
% 28/02/15: Enable users to specify optional ghostscript options (issue #36)
% 10/03/15: Fixed minor warning reported by Paul Soderlind; fixed code indentation
% 28/05/15: Fixed issue #69: patches with LineWidth==0.75 appear wide (internal bug in Matlab's print() func)
% 07/07/15: Fixed issue #83: use numeric handles in HG1
% 11/12/16: Fixed cropping issue reported by Harry D.
% 29/09/18: Fixed issue #254: error in print2array>read_tif_img
%}

	% Generate default input arguments, if needed
	if nargin < 2
	    res = 1;
	    if nargin < 1
	        fig = gcf;
	    end
	end
	% Warn if output is large
	old_mode = get(fig, 'Units');
	set(fig, 'Units', 'pixels');
	px = get(fig, 'Position');
	set(fig, 'Units', old_mode);
	npx = prod(px(3:4)*res)/1e6;
	if npx > 30
	    % 30M pixels or larger!
	    warning('MATLAB:LargeImage', 'print2array generating a %.1fM pixel image. This could be slow and might also cause memory problems.', npx);
	end
	% Retrieve the background colour
	bcol = get(fig, 'Color');
	% Set the resolution parameter
	res_str = ['-r' num2str(ceil(get(0, 'ScreenPixelsPerInch')*res))];
	% Generate temporary file name
	tmp_nam = [tempname '.tif'];
	try
	    % Ensure that the temp dir is writable (Javier Paredes 26/2/15)
	    fid = fopen(tmp_nam,'w');
	    fwrite(fid,1);
	    fclose(fid);
	    delete(tmp_nam);  % cleanup
	    isTempDirOk = true;
	catch
	    % Temp dir is not writable, so use the current folder
	    [dummy,fname,fext] = fileparts(tmp_nam); %#ok<ASGLU>
	    fpath = pwd;
	    tmp_nam = fullfile(fpath,[fname fext]);
	    isTempDirOk = false;
	end
	% Enable users to specify optional ghostscript options (issue #36)
	if nargin > 3 && ~isempty(gs_options)
	    if iscell(gs_options)
	        gs_options = sprintf(' %s',gs_options{:});
	    elseif ~ischar(gs_options)
	        error('gs_options input argument must be a string or cell-array of strings');
	    else
	        gs_options = [' ' gs_options];
	    end
	else
	    gs_options = '';
	end
	if nargin > 2 && strcmp(renderer, '-painters')
	    % First try to print directly to tif file
	    try
	        % Print the file into a temporary TIF file and read it into array A
	        [A, err, ex] = read_tif_img(fig, res_str, renderer, tmp_nam);
	        if err, rethrow(ex); end
	    catch  % error - try to print to EPS and then using Ghostscript to TIF
	        % Print to eps file
	        if isTempDirOk
	            tmp_eps = [tempname '.eps'];
	        else
	            tmp_eps = fullfile(fpath,[fname '.eps']);
	        end
	        print2eps(tmp_eps, fig, 0, renderer, '-loose');
	        try
	            % Initialize the command to export to tiff using ghostscript
	            cmd_str = ['-dEPSCrop -q -dNOPAUSE -dBATCH ' res_str ' -sDEVICE=tiff24nc'];
	            % Set the font path
	            fp = font_path_print2array();
	            if ~isempty(fp)
	                cmd_str = [cmd_str ' -sFONTPATH="' fp '"'];
	            end
	            % Add the filenames
	            cmd_str = [cmd_str ' -sOutputFile="' tmp_nam '" "' tmp_eps '"' gs_options];
	            % Execute the ghostscript command
	            ghostscript(cmd_str);
	        catch me
	            % Delete the intermediate file
	            delete(tmp_eps);
	            rethrow(me);
	        end
	        % Delete the intermediate file
	        delete(tmp_eps);
	        % Read in the generated bitmap
	        A = imread(tmp_nam);
	        % Delete the temporary bitmap file
	        delete(tmp_nam);
	    end
	    % Set border pixels to the correct colour
	    if isequal(bcol, 'none')
	        bcol = [];
	    elseif isequal(bcol, [1 1 1])
	        bcol = uint8([255 255 255]);
	    else
	        for l = 1:size(A, 2)
	            if ~all(reshape(A(:,l,:) == 255, [], 1))
	                break;
	            end
	        end
	        for r = size(A, 2):-1:l
	            if ~all(reshape(A(:,r,:) == 255, [], 1))
	                break;
	            end
	        end
	        for t = 1:size(A, 1)
	            if ~all(reshape(A(t,:,:) == 255, [], 1))
	                break;
	            end
	        end
	        for b = size(A, 1):-1:t
	            if ~all(reshape(A(b,:,:) == 255, [], 1))
	                break;
	            end
	        end
	        bcol = uint8(median(single([reshape(A(:,[l r],:), [], size(A, 3)); reshape(A([t b],:,:), [], size(A, 3))]), 1));
	        for c = 1:size(A, 3)
	            A(:,[1:l-1, r+1:end],c) = bcol(c);
	            A([1:t-1, b+1:end],:,c) = bcol(c);
	        end
	    end
	else
	    if nargin < 3
	        renderer = '-opengl';
	    end
	    % Print the file into a temporary TIF file and read it into array A
	    [A, err, ex] = read_tif_img(fig, res_str, renderer, tmp_nam);
	    % Throw any error that occurred
	    if err
	        % Display suggested workarounds to internal print() error (issue #16)
	        fprintf(2, 'An error occured with Matlab''s builtin print function.\nTry setting the figure Renderer to ''painters'' or use opengl(''software'').\n\n');
	        rethrow(ex);
	    end
	    % Set the background color
	    if isequal(bcol, 'none')
	        bcol = [];
	    else
	        bcol = bcol * 255;
	        if isequal(bcol, round(bcol))
	            bcol = uint8(bcol);
	        else
	            bcol = squeeze(A(1,1,:));
	        end
	    end
	end
	% Check the output size is correct
	if isequal(res, round(res))
	    px = round([px([4 3])*res 3]);  % round() to avoid an indexing warning below
	    if ~isequal(size(A), px)
	        % Correct the output size
	        A = A(1:min(end,px(1)),1:min(end,px(2)),:);
	    end
	end
end

% Function to create a TIF image of the figure and read it into an array
function [A, err, ex] = read_tif_img(fig, res_str, renderer, tmp_nam)
	A =  [];  % fix for issue #254
	err = false;
	ex = [];
	% Temporarily set the paper size
	old_pos_mode    = get(fig, 'PaperPositionMode');
	old_orientation = get(fig, 'PaperOrientation');
	set(fig, 'PaperPositionMode','auto', 'PaperOrientation','portrait');
	try
	    % Workaround for issue #69: patches with LineWidth==0.75 appear wide (internal bug in Matlab's print() function)
	    fp = [];  % in case we get an error below
	    fp = findall(fig, 'Type','patch', 'LineWidth',0.75);
	    set(fp, 'LineWidth',0.5);
	    % Fix issue #83: use numeric handles in HG1
	    if ~using_hg2(fig),  fig = double(fig);  end
	    % Print to tiff file
	    print(fig, renderer, res_str, '-dtiff', tmp_nam);
	    % Read in the printed file
	    A = imread(tmp_nam);
	    % Delete the temporary file
	    delete(tmp_nam);
	catch ex
	    err = true;
	end
	set(fp, 'LineWidth',0.75);  % restore original figure appearance
	% Reset the paper size
	set(fig, 'PaperPositionMode',old_pos_mode, 'PaperOrientation',old_orientation);
end

% Function to return (and create, where necessary) the font path
function fp = font_path_print2array()
	fp = user_string('gs_font_path');
	if ~isempty(fp)
	    return
	end
	% Create the path
	% Start with the default path
	fp = getenv('GS_FONTPATH');
	% Add on the typical directories for a given OS
	if ispc
	    if ~isempty(fp)
	        fp = [fp ';'];
	    end
	    fp = [fp getenv('WINDIR') filesep 'Fonts'];
	else
	    if ~isempty(fp)
	        fp = [fp ':'];
	    end
	    fp = [fp '/usr/share/fonts:/usr/local/share/fonts:/usr/share/fonts/X11:/usr/local/share/fonts/X11:/usr/share/fonts/truetype:/usr/local/share/fonts/truetype'];
	end
	user_string('gs_font_path', fp);
end

function print2eps(name, fig, export_options, varargin)
%PRINT2EPS  Prints figures to eps with improved line styles
%
% Examples:
%   print2eps filename
%   print2eps(filename, fig_handle)
%   print2eps(filename, fig_handle, export_options)
%   print2eps(filename, fig_handle, export_options, print_options)
%
% This function saves a figure as an eps file, with two improvements over
% MATLAB's print command. First, it improves the line style, making dashed
% lines more like those on screen and giving grid lines a dotted line style.
% Secondly, it substitutes original font names back into the eps file,
% where these have been changed by MATLAB, for up to 11 different fonts.
%
%IN:
%   filename - string containing the name (optionally including full or
%	          relative path) of the file the figure is to be saved as. A
%	          ".eps" extension is added if not there already. If a path is
%	          not specified, the figure is saved in the current directory.
%   fig_handle - The handle of the figure to be saved. Default: gcf().
%   export_options - array or struct of optional scalar values:
%	   bb_padding - Scalar value of amount of padding to add to border around
%	                the cropped image, in points (if >1) or percent (if <1).
%	                Can be negative as well as positive; Default: 0
%	   crop       - Cropping flag. Deafult: 0
%	   fontswap   - Whether to swap non-default fonts in figure. Default: true
%	   font_space - Character used to separate font-name terms in the EPS output
%	                e.g. "Courier New" => "Courier-New". Default: ''
%	                (available only via the struct alternative)
%	   renderer   - Renderer used to generate bounding-box. Default: 'opengl'
%	                (available only via the struct alternative)
%	   crop_amounts - 4-element vector of crop amounts: [top,right,bottom,left]
%	                (available only via the struct alternative)
%   print_options - Additional parameter strings to be passed to the print command

%{
% Copyright (C) Oliver Woodford 2008-2014, Yair Altman 2015-

% The idea of editing the EPS file to change line styles comes from Jiro
% Doke's FIXPSLINESTYLE (fex id: 17928)
% The idea of changing dash length with line width came from comments on
% fex id: 5743, but the implementation is mine :)
%}
%{
% 14/11/11: Fix a MATLAB bug rendering black or white text incorrectly.
%	       Thanks to Mathieu Morlighem for reporting the issue and
%	       obtaining a fix from TMW.
% 08/12/11: Added ability to correct fonts. Several people have requested
%	       this at one time or another, and also pointed me to printeps
%	       (fex id: 7501), so thank you to them. My implementation (which
%	       was not inspired by printeps - I'd already had the idea for my
%	       approach) goes slightly further in that it allows multiple
%	       fonts to be swapped.
% 14/12/11: Fix bug affecting font names containing spaces. Thanks to David
%	       Szwer for reporting the issue.
% 25/01/12: Add a font not to be swapped. Thanks to Anna Rafferty and Adam
%	       Jackson for reporting the issue. Also fix a bug whereby using a
%	       font alias can lead to another font being swapped in.
% 10/04/12: Make the font swapping case insensitive.
% 26/10/12: Set PaperOrientation to portrait. Thanks to Michael Watts for
%	       reporting the issue.
% 26/10/12: Fix issue to do with swapping fonts changing other fonts and
%	       sizes we don't want, due to listeners. Thanks to Malcolm Hudson
%	       for reporting the issue.
% 22/03/13: Extend font swapping to axes labels. Thanks to Rasmus Ischebeck
%	       for reporting the issue.
% 23/07/13: Bug fix to font swapping. Thanks to George for reporting the
%	       issue.
% 13/08/13: Fix MATLAB feature of not exporting white lines correctly.
%	       Thanks to Sebastian Hesslinger for reporting it.
% 24/02/15: Fix for Matlab R2014b bug (issue #31): LineWidths<0.75 are not
%	       set in the EPS (default line width is used)
% 25/02/15: Fixed issue #32: BoundingBox problem caused uncropped EPS/PDF files
% 05/03/15: Fixed issue #43: Inability to perform EPS file post-processing
% 06/03/15: Improved image padding & cropping thanks to Oscar Hartogensis
% 21/03/15: Fixed edge-case of missing handles having a 'FontName' property
% 26/03/15: Attempt to fix issue #45: white lines in subplots do not print correctly
% 27/03/15: Attempt to fix issue #44: white artifact lines appearing in patch exports
% 30/03/15: Fixed issue #52: improved performance on HG2 (R2014b+)
% 09/04/15: Comment blocks consolidation and minor code cleanup (no real code change)
% 12/04/15: Fixed issue #56: bad cropping
% 14/04/15: Workaround for issue #45: lines in image subplots are exported in invalid color
% 07/07/15: Added option to avoid font-swapping in EPS/PDF
% 07/07/15: Fixed issue #83: use numeric handles in HG1
% 22/07/15: Fixed issue #91 (thanks to Carlos Moffat)
% 28/09/15: Fixed issue #108 (thanks to JacobD10)
% 01/11/15: Fixed issue #112: optional renderer for bounding-box computation (thanks to Jes?estana Puerta)
% 21/02/16: Enabled specifying non-automated crop amounts
% 22/02/16: Better support + backward compatibility for transparency (issue #108)
% 10/06/16: Fixed issue #159: text handles get cleared by Matlab in the print() command
% 12/06/16: Improved the fix for issue #159 (in the previous commit)
% 12/06/16: Fixed issue #158: transparent patch color in PDF/EPS
% 18/09/17: Fixed issue #194: incorrect fonts in EPS/PDF output
% 18/09/17: Fixed issue #195: relaxed too-tight cropping in EPS/PDF
% 14/11/17: Workaround for issue #211: dashed/dotted lines in 3D axes appear solid
% 15/11/17: Updated issue #211: only set SortMethod='ChildOrder' in HG2, and when it looks the same onscreen; support multiple figure axes
% 18/11/17: Fixed issue #225: transparent/translucent dashed/dotted lines appear solid in EPS/PDF
% 24/03/18: Fixed issue #239: black title meshes with temporary black background figure bgcolor, causing bad cropping
%}

	options = {'-loose'};
	if nargin > 3
	    options = [options varargin];
	elseif nargin < 3
	    export_options = 0;
	    if nargin < 2
	        fig = gcf();
	    end
	end

	% Retrieve padding, crop & font-swap values
	crop_amounts = nan(1,4);  % auto-crop all 4 sides by default
	if isstruct(export_options)
	    try fontswap     = export_options.fontswap;     catch, fontswap = true;     end
	    try font_space   = export_options.font_space;   catch, font_space = '';     end
	    font_space(2:end) = '';
	    try bb_crop      = export_options.crop;         catch, bb_crop = 0;         end
	    try crop_amounts = export_options.crop_amounts; catch,                      end
	    try bb_padding   = export_options.bb_padding;   catch, bb_padding = 0;      end
	    try renderer     = export_options.rendererStr;  catch, renderer = 'opengl'; end  % fix for issue #110
	    if renderer(1)~='-',  renderer = ['-' renderer];  end
	else
	    if numel(export_options) > 2  % font-swapping
	        fontswap = export_options(3);
	    else
	        fontswap = true;
	    end
	    if numel(export_options) > 1  % cropping
	        bb_crop = export_options(2);
	    else
	        bb_crop = 0;  % scalar value, so use default bb_crop value of 0
	    end
	    if numel(export_options) > 0  % padding
	        bb_padding = export_options(1);
	    else
	        bb_padding = 0;
	    end
	    renderer = '-opengl';
	    font_space = '';
	end

	% Construct the filename
	if numel(name) < 5 || ~strcmpi(name(end-3:end), '.eps')
	    name = [name '.eps']; % Add the missing extension
	end

	% Set paper size
	old_pos_mode = get(fig, 'PaperPositionMode');
	old_orientation = get(fig, 'PaperOrientation');
	set(fig, 'PaperPositionMode', 'auto', 'PaperOrientation', 'portrait');

	% Find all the used fonts in the figure
	font_handles = findall(fig, '-property', 'FontName');
	fonts = get(font_handles, 'FontName');
	if isempty(fonts)
	    fonts = {};
	elseif ~iscell(fonts)
	    fonts = {fonts};
	end

	% Map supported font aliases onto the correct name
	fontsl = lower(fonts);
	for a = 1:numel(fonts)
	    f = fontsl{a};
	    f(f==' ') = [];
	    switch f
	        case {'times', 'timesnewroman', 'times-roman'}
	            fontsl{a} = 'times-roman';
	        case {'arial', 'helvetica'}
	            fontsl{a} = 'helvetica';
	        case {'newcenturyschoolbook', 'newcenturyschlbk'}
	            fontsl{a} = 'newcenturyschlbk';
	        otherwise
	    end
	end
	fontslu = unique(fontsl);

	% Determine the font swap table
	if fontswap
	    matlab_fonts = {'Helvetica', 'Times-Roman', 'Palatino', 'Bookman', 'Helvetica-Narrow', 'Symbol', ...
	                    'AvantGarde', 'NewCenturySchlbk', 'Courier', 'ZapfChancery', 'ZapfDingbats'};
	    matlab_fontsl = lower(matlab_fonts);
	    require_swap = find(~ismember(fontslu, matlab_fontsl));
	    unused_fonts = find(~ismember(matlab_fontsl, fontslu));
	    font_swap = cell(3, min(numel(require_swap), numel(unused_fonts)));
	    fonts_new = fonts;
	    for a = 1:size(font_swap, 2)
	        font_swap{1,a} = find(strcmp(fontslu{require_swap(a)}, fontsl));
	        font_swap{2,a} = matlab_fonts{unused_fonts(a)};
	        font_swap{3,a} = fonts{font_swap{1,a}(1)};
	        fonts_new(font_swap{1,a}) = font_swap(2,a);
	    end
	else
	    font_swap = [];
	end

	% Swap the fonts
	if ~isempty(font_swap)
	    fonts_size = get(font_handles, 'FontSize');
	    if iscell(fonts_size)
	        fonts_size = cell2mat(fonts_size);
	    end
	    M = false(size(font_handles));

	    % Loop because some changes may not stick first time, due to listeners
	    c = 0;
	    update = zeros(1000, 1);
	    for b = 1:10 % Limit number of loops to avoid infinite loop case
	        for a = 1:numel(M)
	            M(a) = ~isequal(get(font_handles(a), 'FontName'), fonts_new{a}) || ~isequal(get(font_handles(a), 'FontSize'), fonts_size(a));
	            if M(a)
	                set(font_handles(a), 'FontName', fonts_new{a}, 'FontSize', fonts_size(a));
	                c = c + 1;
	                update(c) = a;
	            end
	        end
	        if ~any(M)
	            break;
	        end
	    end

	    % Compute the order to revert fonts later, without the need of a loop
	    [update, M] = unique(update(1:c));
	    [dummy, M] = sort(M); %#ok<ASGLU>
	    update = reshape(update(M), 1, []);
	end

	% MATLAB bug fix - black and white text can come out inverted sometimes
	% Find the white and black text
	black_text_handles = findall(fig, 'Type', 'text', 'Color', [0 0 0]);
	white_text_handles = findall(fig, 'Type', 'text', 'Color', [1 1 1]);
	% Set the font colors slightly off their correct values
	set(black_text_handles, 'Color', [0 0 0] + eps);
	set(white_text_handles, 'Color', [1 1 1] - eps);

	% MATLAB bug fix - white lines can come out funny sometimes
	% Find the white lines
	white_line_handles = findall(fig, 'Type', 'line', 'Color', [1 1 1]);
	% Set the line color slightly off white
	set(white_line_handles, 'Color', [1 1 1] - 0.00001);

	% MATLAB bug fix (issue #211): dashed/dotted lines in 3D axes appear solid
	% Note: this "may limit other functionality in plotting such as hidden line/surface removal"
	% reference: Technical Support Case #02838114, https://mail.google.com/mail/u/0/#inbox/15fb7659f70e7bd8
	hAxes = findall(fig, 'Type', 'axes');
	if using_hg2 && ~isempty(hAxes)  % issue #211 presumably happens only in HG2, not HG1
	    try
	        % If there are any axes using SortMethod~='ChildOrder'
	        oldSortMethods = get(hAxes,{'SortMethod'});  % use {'SortMethod'} to ensure we get a cell array, even for single axes
	        if any(~strcmpi('ChildOrder',oldSortMethods))  % i.e., any oldSortMethods=='depth'
	            % Check if the axes look visually different onscreen when SortMethod='ChildOrder'
	            imgBefore = print2array(fig);
	            set(hAxes,'SortMethod','ChildOrder');
	            imgAfter  = print2array(fig);
	            if isequal(imgBefore, imgAfter)
	                % They look the same, so use SortMethod='ChildOrder' when generating the EPS
	            else
	                % They look different, so revert SortMethod and issue a warning message
	                warning('YMA:export_fig:issue211', ...
	                        ['You seem to be using axes that have overlapping/hidden graphic elements. ' 10 ...
	                         'Setting axes.SortMethod=''ChildOrder'' may solve potential problems in EPS/PDF export. ' 10 ...
	                         'Additional info: https://github.com/altmany/export_fig/issues/211'])
	                set(hAxes,{'SortMethod'},oldSortMethods);
	            end
	        end
	    catch err
	        % ignore
	        a=err;  %#ok<NASGU> % debug breakpoint
	    end
	end

	% Workaround for issue #45: lines in image subplots are exported in invalid color
	% In this case the -depsc driver solves the problem, but then all the other workarounds
	% below (for all the other issues) will fail, so it's better to let the user decide by
	% just issuing a warning and accepting the '-depsc' input parameter
	epsLevel2 = ~any(strcmpi(options,'-depsc'));
	if epsLevel2
	    % Use -depsc2 (EPS color level-2) if -depsc (EPS color level-3) was not specifically requested
	    options{end+1} = '-depsc2';
	    % Issue a warning if multiple images & lines were found in the figure, and HG1 with painters renderer is used
	    isPainters = any(strcmpi(options,'-painters'));
	    if isPainters && ~using_hg2 && numel(findall(fig,'Type','image'))>1 && ~isempty(findall(fig,'Type','line'))
	        warning('YMA:export_fig:issue45', ...
	                ['Multiple images & lines detected. In such cases, the lines might \n' ...
	                 'appear with an invalid color due to an internal MATLAB bug (fixed in R2014b). \n' ...
	                 'Possible workaround: add a ''-depsc'' or ''-opengl'' parameter to the export_fig command.']);
	    end
	end

	% Fix issue #83: use numeric handles in HG1
	if ~using_hg2(fig),  fig = double(fig);  end

	% Workaround for when transparency is lost through conversion fig>EPS>PDF (issue #108)
	% Replace transparent patch RGB values with an ID value (rare chance that ID color is being used already)
	if using_hg2
	    origAlphaColors = eps_maintainAlpha(fig);
	end

	% Print to eps file
	print(fig, options{:}, name);

	% Restore the original axes SortMethods (if updated)
	try set(hAxes,{'SortMethod'},oldSortMethods); catch, end

	% Do post-processing on the eps file
	try
	    % Read the EPS file into memory
	    fstrm = read_write_entire_textfile(name);
	catch
	    fstrm = '';
	end

	% Restore colors for transparent patches/lines and apply the
	% setopacityalpha setting in the EPS file (issue #108)
	if using_hg2
	    [~,fstrm,foundFlags] = eps_maintainAlpha(fig, fstrm, origAlphaColors);

	    % If some of the transparencies were not found in the EPS file, then rerun the
	    % export with only the found transparencies modified (backward compatibility)
	    if ~isempty(fstrm) && ~all(foundFlags)
	        foundIdx = find(foundFlags);
	        for objIdx = 1 : sum(foundFlags)
	            colorsIdx = foundIdx(objIdx);
	            colorsData = origAlphaColors{colorsIdx};
	            hObj     = colorsData{1};
	            propName = colorsData{2};
	            newColor = colorsData{4};
	            hObj.(propName).ColorData = newColor;
	        end
	        delete(name);
	        print(fig, options{:}, name);
	        fstrm = read_write_entire_textfile(name);
	        [~,fstrm] = eps_maintainAlpha(fig, fstrm, origAlphaColors(foundFlags));
	    end
	end

	% Fix for Matlab R2014b bug (issue #31): LineWidths<0.75 are not set in the EPS (default line width is used)
	try
	    if ~isempty(fstrm) && using_hg2(fig)
	        % Convert miter joins to line joins
	        %fstrm = regexprep(fstrm, '\n10.0 ML\n', '\n1 LJ\n');
	        % This is faster (the original regexprep could take many seconds when the axes contains many lines):
	        fstrm = strrep(fstrm, sprintf('\n10.0 ML\n'), sprintf('\n1 LJ\n'));

	        % In HG2, grid lines and axes Ruler Axles have a default LineWidth of 0.5 => replace en-bulk (assume that 1.0 LineWidth = 1.333 LW)
	        %   hAxes=gca; hAxes.YGridHandle.LineWidth, hAxes.YRuler.Axle.LineWidth
	        %fstrm = regexprep(fstrm, '(GC\n2 setlinecap\n1 LJ)\nN', '$1\n0.667 LW\nN');
	        % This is faster:
	        fstrm = strrep(fstrm, sprintf('GC\n2 setlinecap\n1 LJ\nN'), sprintf('GC\n2 setlinecap\n1 LJ\n0.667 LW\nN'));

	        % This is more accurate but *MUCH* slower (issue #52)
	        %{
	        % Modify all thin lines in the figure to have 10x LineWidths
	        hLines = findall(fig,'Type','line');
	        hThinLines = [];
	        for lineIdx = 1 : numel(hLines)
	            thisLine = hLines(lineIdx);
	            if thisLine.LineWidth < 0.75 && strcmpi(thisLine.Visible,'on')
	                hThinLines(end+1) = thisLine; %#ok<AGROW>
	                thisLine.LineWidth = thisLine.LineWidth * 10;
	            end
	        end

	        % If any thin lines were found
	        if ~isempty(hThinLines)
	            % Prepare an EPS with large-enough line widths
	            print(fig, options{:}, name);
	            % Restore the original LineWidths in the figure
	            for lineIdx = 1 : numel(hThinLines)
	                thisLine = handle(hThinLines(lineIdx));
	                thisLine.LineWidth = thisLine.LineWidth / 10;
	            end

	            % Compare the original and the new EPS files and correct the original stream's LineWidths
	            fstrm_new = read_write_entire_textfile(name);
	            idx = 500;  % skip heading with its possibly-different timestamp
	            markerStr = sprintf('10.0 ML\nN');
	            markerLen = length(markerStr);
	            while ~isempty(idx) && idx < length(fstrm)
	                lastIdx = min(length(fstrm), length(fstrm_new));
	                delta = fstrm(idx+1:lastIdx) - fstrm_new(idx+1:lastIdx);
	                idx = idx + find(delta,1);
	                if ~isempty(idx) && ...
	                        isequal(fstrm(idx-markerLen+1:idx), markerStr) && ...
	                        ~isempty(regexp(fstrm_new(idx-markerLen+1:idx+12),'10.0 ML\n[\d\.]+ LW\nN')) %#ok<RGXP1>
	                    value = str2double(regexprep(fstrm_new(idx:idx+12),' .*',''));
	                    if isnan(value), break; end  % something's wrong... - bail out
	                    newStr = sprintf('%0.3f LW\n',value/10);
	                    fstrm = [fstrm(1:idx-1) newStr fstrm(idx:end)];
	                    idx = idx + 12;
	                else
	                    break;
	                end
	            end
	        end
	        %}

	        % This is much faster although less accurate: fix all non-gray lines to have a LineWidth of 0.75 (=1 LW)
	        % Note: This will give incorrect LineWidth of 075 for lines having LineWidth<0.75, as well as for non-gray grid-lines (if present)
	        %       However, in practice these edge-cases are very rare indeed, and the difference in LineWidth should not be noticeable
	        %fstrm = regexprep(fstrm, '([CR]C\n2 setlinecap\n1 LJ)\nN', '$1\n1 LW\nN');
	        % This is faster (the original regexprep could take many seconds when the axes contains many lines):
	        fstrm = strrep(fstrm, sprintf('\n2 setlinecap\n1 LJ\nN'), sprintf('\n2 setlinecap\n1 LJ\n1 LW\nN'));
	    end
	catch err
	    fprintf(2, 'Error fixing LineWidths in EPS file: %s\n at %s:%d\n', err.message, err.stack(1).file, err.stack(1).line);
	end

	% Reset the font and line colors
	try
	    set(black_text_handles, 'Color', [0 0 0]);
	    set(white_text_handles, 'Color', [1 1 1]);
	catch
	    % Fix issue #159: redo findall() '*text_handles'
	    black_text_handles = findall(fig, 'Type', 'text', 'Color', [0 0 0]+eps);
	    white_text_handles = findall(fig, 'Type', 'text', 'Color', [1 1 1]-eps);
	    set(black_text_handles, 'Color', [0 0 0]);
	    set(white_text_handles, 'Color', [1 1 1]);
	end
	set(white_line_handles, 'Color', [1 1 1]);

	% Reset paper size
	set(fig, 'PaperPositionMode', old_pos_mode, 'PaperOrientation', old_orientation);

	% Reset the font names in the figure
	if ~isempty(font_swap)
	    for a = update
	        set(font_handles(a), 'FontName', fonts{a}, 'FontSize', fonts_size(a));
	    end
	end

	% Bail out if EPS post-processing is not possible
	if isempty(fstrm)
	    warning('Loading EPS file failed, so unable to perform post-processing. This is usually because the figure contains a large number of patch objects. Consider exporting to a bitmap format in this case.');
	    return
	end

	% Replace the font names
	if ~isempty(font_swap)
	    for a = 1:size(font_swap, 2)
	        fontName = font_swap{3,a};
	        %fontName = fontName(~isspace(font_swap{3,a}));
	        if length(fontName) > 29
	            warning('YMA:export_fig:font_name','Font name ''%s'' is longer than 29 characters. This might cause problems in some EPS/PDF readers. Consider using a different font.',fontName);
	        end
	        if isempty(font_space)
	            fontName(fontName==' ') = '';
	        else
	            fontName(fontName==' ') = char(font_space);
	        end
	        %fstrm = regexprep(fstrm, [font_swap{1,a} '-?[a-zA-Z]*\>'], fontName);
	        fstrm = regexprep(fstrm, font_swap{2,a}, fontName);
	    end
	end

	% Move the bounding box to the top of the file (HG2 only), or fix the line styles (HG1 only)
	if using_hg2(fig)
	    % Move the bounding box to the top of the file (HG2 only)
	    [s, e] = regexp(fstrm, '%%BoundingBox: [^%]*%%');
	    if numel(s) == 2
	        fstrm = fstrm([1:s(1)-1 s(2):e(2)-2 e(1)-1:s(2)-1 e(2)-1:end]);
	    end
	else
	    % Fix the line styles (HG1 only)
	    fstrm = fix_lines(fstrm);
	end

	% Apply the bounding box padding & cropping, replacing Matlab's print()'s bounding box
	if bb_crop
	    % Calculate a new bounding box based on a bitmap print using crop_border.m
	    % 1. Determine the Matlab BoundingBox and PageBoundingBox
	    [s,e] = regexp(fstrm, '%%BoundingBox: [^%]*%%'); % location BB in eps file
	    if numel(s)==2, s=s(2); e=e(2); end
	    aa = fstrm(s+15:e-3); % dimensions bb - STEP1
	    bb_matlab = cell2mat(textscan(aa,'%f32%f32%f32%f32'));  % dimensions bb - STEP2

	    [s,e] = regexp(fstrm, '%%PageBoundingBox: [^%]*%%'); % location bb in eps file
	    if numel(s)==2, s=s(2); e=e(2); end
	    aa = fstrm(s+19:e-3); % dimensions bb - STEP1
	    pagebb_matlab = cell2mat(textscan(aa,'%f32%f32%f32%f32'));  % dimensions bb - STEP2

	    % 1b. Fix issue #239: black title meshes with temporary black background figure bgcolor, causing bad cropping
	    hTitles = [];
	    if isequal(get(fig,'Color'),'none')
	        hAxes = findall(fig,'type','axes');
	        for idx = 1 : numel(hAxes)
	            hAx = hAxes(idx);
	            try
	                hTitle = hAx.Title;
	                oldColor = hTitle.Color;
	                if all(oldColor < 5*eps) || (ischar(oldColor) && lower(oldColor(1))=='k')
	                    hTitles(end+1) = hTitle; %#ok<AGROW>
	                    hTitle.Color = [0,0,.01];
	                end
	            catch
	            end
	        end
	    end

	    % 2. Create a bitmap image and use crop_borders to create the relative
	    %    bb with respect to the PageBoundingBox
	    [A, bcol] = print2array(fig, 1, renderer);
	    [aa, aa, aa, bb_rel] = crop_borders(A, bcol, bb_padding, crop_amounts); %#ok<ASGLU>

	    try set(hTitles,'Color','k'); catch, end

	    % 3. Calculate the new Bounding Box
	    pagew = pagebb_matlab(3)-pagebb_matlab(1);
	    pageh = pagebb_matlab(4)-pagebb_matlab(2);
	    %bb_new = [pagebb_matlab(1)+pagew*bb_rel(1) pagebb_matlab(2)+pageh*bb_rel(2) ...
	    %          pagebb_matlab(1)+pagew*bb_rel(3) pagebb_matlab(2)+pageh*bb_rel(4)];
	    bb_new = pagebb_matlab([1,2,1,2]) + [pagew,pageh,pagew,pageh].*bb_rel;  % clearer
	    bb_offset = (bb_new-bb_matlab) + [-2,-2,2,2];  % 2px margin so that cropping is not TOO tight (issue #195)

	    % Apply the bounding box padding
	    if bb_padding
	        if abs(bb_padding)<1
	            bb_padding = round((mean([bb_new(3)-bb_new(1) bb_new(4)-bb_new(2)])*bb_padding)/0.5)*0.5; % ADJUST BB_PADDING
	        end
	        add_padding = @(n1, n2, n3, n4) sprintf(' %.0f', str2double({n1, n2, n3, n4}) + bb_offset + bb_padding*[-1,-1,1,1]); %#ok<NASGU>
	    else
	        add_padding = @(n1, n2, n3, n4) sprintf(' %.0f', str2double({n1, n2, n3, n4}) + bb_offset); %#ok<NASGU> % fix small but noticeable bounding box shift
	    end
	    fstrm = regexprep(fstrm, '%%BoundingBox:[ ]+([-]?\d+)[ ]+([-]?\d+)[ ]+([-]?\d+)[ ]+([-]?\d+)', '%%BoundingBox:${add_padding($1, $2, $3, $4)}');
	end

	% Fix issue #44: white artifact lines appearing in patch exports
	% Note: the problem is due to the fact that Matlab's print() function exports patches
	%       as a combination of filled triangles, and a white line appears where the triangles touch
	% In the workaround below, we will modify such dual-triangles into a filled rectangle.
	% We are careful to only modify regexps that exactly match specific patterns - it's better to not
	% correct some white-line artifacts than to change the geometry of a patch, or to corrupt the EPS.
	%   e.g.: '0 -450 937 0 0 450 3 MP PP 937 0 0 -450 0 450 3 MP PP' => '0 -450 937 0 0 450 0 0 4 MP'
	fstrm = regexprep(fstrm, '\n([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) 3 MP\nPP\n\2 \1 \3 3 MP\nPP\n','\n$1 $2 $3 0 0 4 MP\nPP\n');
	fstrm = regexprep(fstrm, '\n([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) 3 MP\nPP\n\2 \3 \1 3 MP\nPP\n','\n$1 $2 $3 0 0 4 MP\nPP\n');
	fstrm = regexprep(fstrm, '\n([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) 3 MP\nPP\n\3 \1 \2 3 MP\nPP\n','\n$1 $2 $3 0 0 4 MP\nPP\n');
	fstrm = regexprep(fstrm, '\n([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) ([-\d.]+ [-\d.]+) 3 MP\nPP\n\3 \2 \1 3 MP\nPP\n','\n$1 $2 $3 0 0 4 MP\nPP\n');

	% Write out the fixed eps file
	read_write_entire_textfile(name, fstrm);
end

function [StoredColors, fstrm, foundFlags] = eps_maintainAlpha(fig, fstrm, StoredColors)
	if nargin == 1  % in: convert transparency in Matlab figure into unique RGB colors
	    hObjs = findall(fig); %findobj(fig,'Type','Area');
	    StoredColors = {};
	    propNames = {'Face','Edge'};
	    for objIdx = 1:length(hObjs)
	        hObj = hObjs(objIdx);
	        for propIdx = 1 : numel(propNames)
	            try
	                propName = propNames{propIdx};
	                if strcmp(hObj.(propName).ColorType, 'truecoloralpha')
	                    nColors = length(StoredColors);
	                    oldColor = hObj.(propName).ColorData;
	                    newColor = uint8([101; 102+floor(nColors/255); mod(nColors,255); 255]);
	                    StoredColors{end+1} = {hObj, propName, oldColor, newColor}; %#ok<AGROW>
	                    hObj.(propName).ColorData = newColor;
	                end
	            catch
	                % Never mind - ignore (either doesn't have the property or cannot change it)
	            end
	        end
	    end
	else  % restore transparency in Matlab figure by converting back from the unique RGBs
	    %Find the transparent patches
	    wasError = false;
	    nColors = length(StoredColors);
	    foundFlags = false(1,nColors);
	    for objIdx = 1 : nColors
	        colorsData = StoredColors{objIdx};
	        hObj      = colorsData{1};
	        propName  = colorsData{2};
	        origColor = colorsData{3};
	        newColor  = colorsData{4};
	        try
	            %Restore the EPS files patch color
	            colorID   = num2str(round(double(newColor(1:3)') /255,3),'%.3g %.3g %.3g'); %ID for searching
	            origRGB   = num2str(round(double(origColor(1:3)')/255,3),'%.3g %.3g %.3g'); %Replace with original color
	            origAlpha = num2str(round(double(origColor(end)) /255,3),'%.3g'); %Convert alpha value for EPS

	            %Find and replace the RGBA values within the EPS text fstrm
	            if strcmpi(propName,'Face')
	                oldStr = sprintf(['\n' colorID ' RC\n']);  % ...N\n (removed to fix issue #225)
	                newStr = sprintf(['\n' origRGB ' RC\n' origAlpha ' .setopacityalpha true\n']);  % ...N\n
	            else  %'Edge'
	                oldStr = sprintf(['\n' colorID ' RC\n']);  % ...1 LJ\n (removed to fix issue #225)
	                newStr = sprintf(['\n' origRGB ' RC\n' origAlpha ' .setopacityalpha true\n']);
	            end
	            foundFlags(objIdx) = ~isempty(strfind(fstrm, oldStr)); %#ok<STREMP>
	            fstrm = strrep(fstrm, oldStr, newStr);

	            %Restore the figure object's original color
	            hObj.(propName).ColorData = origColor;
	        catch err
	            % something is wrong - cannot restore transparent color...
	            if ~wasError
	                fprintf(2, 'Error maintaining transparency in EPS file: %s\n at %s:%d\n', err.message, err.stack(1).file, err.stack(1).line);
	                wasError = true;
	            end
	        end
	    end
	end
end

%READ_WRITE_ENTIRE_TEXTFILE Read or write a whole text file to/from memory
%
% Read or write an entire text file to/from memory, without leaving the
% file open if an error occurs.
%
% Reading:
%   fstrm = read_write_entire_textfile(fname)
% Writing:
%   read_write_entire_textfile(fname, fstrm)
%
%IN:
%   fname - Pathname of text file to be read in.
%   fstrm - String to be written to the file, including carriage returns.
%
%OUT:
%   fstrm - String read from the file. If an fstrm input is given the
%	       output is the same as that input. 

function fstrm = read_write_entire_textfile(fname, fstrm)
modes = {'rt', 'wt'};
writing = nargin > 1;
fh = fopen(fname, modes{1+writing});
if fh == -1
	error('Unable to open file %s.', fname);
end
try
	if writing
	    fwrite(fh, fstrm, 'char*1');
	else
	    fstrm = fread(fh, '*char')';
	end
catch ex
	fclose(fh);
	rethrow(ex);
end
fclose(fh);
end

function string = user_string(string_name, string)
%USER_STRING  Get/set a user specific string
%
% Examples:
%   string  = user_string(string_name)
%   isSaved = user_string(string_name, new_string)
%
% Function to get and set a string in a system or user specific file. This
% enables, for example, system specific paths to binaries to be saved.
%
% The specified string will be saved in a file named <string_name>.txt,
% either in a subfolder named .ignore under this file's folder, or in the
% user's prefdir folder (in case this file's folder is non-writable).
%
% IN:
%   string_name - String containing the name of the string required, which
%	             sets the filename storing the string: <string_name>.txt
%   new_string  - The new string to be saved in the <string_name>.txt file
%
% OUT:
%   string  - The currently saved string. Default: ''
%   isSaved - Boolean indicating whether the save was succesful

% Copyright (C) Oliver Woodford 2011-2014, Yair Altman 2015-

% This method of saving paths avoids changing .m files which might be in a
% version control system. Instead it saves the user dependent paths in
% separate files with a .txt extension, which need not be checked in to
% the version control system. Thank you to Jonas Dorn for suggesting this
% approach.

% 10/01/2013 - Access files in text, not binary mode, as latter can cause
%	          errors. Thanks to Christian for pointing this out.
% 29/05/2015 - Save file in prefdir if current folder is non-writable (issue #74)
% 09/01/2018 - Fix issue #232: if the string looks like a file/folder path, ensure it actually exists

	if ~ischar(string_name)
	    error('string_name must be a string.');
	end
	% Create the full filename
	fname = [string_name '.txt'];
	dname = fullfile(fileparts(mfilename('fullpath')), '.ignore');
	file_name = fullfile(dname, fname);
	if nargin > 1
	    % Set string
	    if ~ischar(string)
	        error('new_string must be a string.');
	    end
	    % Make sure the save directory exists
	    %dname = fileparts(file_name);
	    if ~exist(dname, 'dir')
	        % Create the directory
	        try
	            if ~mkdir(dname)
	                string = false;
	                return
	            end
	        catch
	            string = false;
	            return
	        end
	        % Make it hidden
	        try
	            fileattrib(dname, '+h');
	        catch
	        end
	    end
	    % Write the file
	    fid = fopen(file_name, 'wt');
	    if fid == -1
	        % file cannot be created/updated - use prefdir if file does not already exist
	        % (if file exists but is simply not writable, don't create a duplicate in prefdir)
	        if ~exist(file_name,'file')
	            file_name = fullfile(prefdir, fname);
	            fid = fopen(file_name, 'wt');
	        end
	        if fid == -1
	            string = false;
	            return;
	        end
	    end
	    try
	        fprintf(fid, '%s', string);
	    catch
	        fclose(fid);
	        string = false;
	        return
	    end
	    fclose(fid);
	    string = true;
	else
	    % Get string
	    fid = fopen(file_name, 'rt');
	    if fid == -1
	        % file cannot be read, try to read the file in prefdir
	        file_name = fullfile(prefdir, fname);
	        fid = fopen(file_name, 'rt');
	        if fid == -1
	            string = '';
	            return
	        end
	    end
	    string = fgetl(fid);
	    fclose(fid);

	    % Fix issue #232: if the string looks like a file/folder path, ensure it actually exists
	    if ~isempty(string) && any(string=='\' | string=='/') && ~exist(string) %#ok<EXIST>
	        string = '';
	    end
	end
end

%USING_HG2 Determine if the HG2 graphics engine is used
%
%   tf = using_hg2(fig)
%
%IN:
%   fig - handle to the figure in question.
%
%OUT:
%   tf - boolean indicating whether the HG2 graphics engine is being used
%	    (true) or not (false).

% 19/06/2015 - Suppress warning in R2015b; cache result for improved performance
% 06/06/2016 - Fixed issue #156 (bad return value in R2016b)

function tf = using_hg2(fig)
	persistent tf_cached
	if isempty(tf_cached)
	    try
	        if nargin < 1,  fig = figure('visible','off');  end
	        oldWarn = warning('off','MATLAB:graphicsversion:GraphicsVersionRemoval');
	        try
	            % This generates a [supressed] warning in R2015b:
	            tf = ~graphicsversion(fig, 'handlegraphics');
	        catch
	            tf = ~verLessThan('matlab','8.4');  % =R2014b
	        end
	        warning(oldWarn);
	    catch
	        tf = false;
	    end
	    if nargin < 1,  delete(fig);  end
	    tf_cached = tf;
	else
	    tf = tf_cached;
	end
end
%}
%switchable1

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------- END - ALTMANY EXPORT FIG - END -----------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- UNUSED MAINS BELOW -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


%{
% LambertW Investigation
function gettingfandthetat()
	syms xtrial
	syms knot_x
	syms knot_theta
	syms ytrial
	syms knot_y
	syms knot_rx
	syms knot_theta
	syms knot_ry

	f=((xtrial-knot_x)*cos(knot_theta)+(ytrial-knot_y)*sin(knot_theta))^2/knot_rx^2+((xtrial-knot_x)*sin(knot_theta)-(ytrial-knot_y)*cos(knot_theta))^2/knot_ry^2-1;
	df_x=diff(f,xtrial);
	df_y=diff(f,ytrial);
	tanthetar=simplify(df_y/df_x);
	thetar=atan(tanthetar);
	thetat=thetar+pi/2;
	thetat=mod(thetat,pi)

	%{
	syms knot_x knot_x(knotnum)
	syms knot_theta knot_theta(knotnum)
	syms knot_y knot_y(knotnum)
	syms knot_rx knot_rx(knotnum)
	syms knot_theta knot_theta(knotnum)
	syms knot_ry knot_ry(knotnum)
	%}

	f=char(f);
	f=strrep(f,'knot_x','knot_x(knotnum)');
	f=strrep(f,'knot_theta','knot_theta(knotnum)');
	f=strrep(f,'knot_y','knot_y(knotnum)');
	f=strrep(f,'knot_rx','knot_rx(knotnum)');
	f=strrep(f,'knot_theta','knot_theta(knotnum)');
	f=strrep(f,'knot_ry','knot_ry(knotnum)');
	f=strrep(f,'xtrial','xtrial_global');
	f=strrep(f,'ytrial','ytrial_global');
	disp(['f=' f ';']);

	thetat=char(thetat);
	thetat=strrep(thetat,'knot_x','knot_x(knotnum)');
	thetat=strrep(thetat,'knot_theta','knot_theta(knotnum)');
	thetat=strrep(thetat,'knot_y','knot_y(knotnum)');
	thetat=strrep(thetat,'knot_rx','knot_rx(knotnum)');
	thetat=strrep(thetat,'knot_theta','knot_theta(knotnum)');
	thetat=strrep(thetat,'knot_ry','knot_ry(knotnum)');
	thetat=strrep(thetat,'xtrial','xtrial_global');
	thetat=strrep(thetat,'ytrial','ytrial_global');
	disp(['thetat=' thetat ';']);
end

function LambertWInvestigate()
	ftl=65.5;
	ftr=3.75;
	ftt=2.79;
	fcl=-50.3;
	fcr=-6;
	fct=-6;
	fvrt=1.83/20; %replacereplacereplace
	fvrl=6.34/20; %replacereplacereplace
	fvtl=5.34/20; %replacereplacereplace
	Er=820/1; %replacereplacereplace
	Et=430/1; %replacereplacereplace
	El=13200/1; %replacereplacereplace

	kappa1=0.00001;
	kappa2=1.2;
	kappa3=0.00001;
	kappa4=1.2;
	kappa5=0.00001;
	kappa6=0.7;
	kappa7=1.2;

	Gftl=1650/1000;
	Gfcl=50000/1000;
	Gftr=300/1000;
	Gftt=Gftr;
	Gfcr=Gftr/Gftl*Gfcl;
	Gfct=Gfcr;
	GII=300/1000;

	Hld=15;
	Hrd=2;
	Htd=Hrd;

	%{
	beta0tl=65;
	beta0cl=49.9;
	beta0tr=4.5;
	beta0cr=beta0tr/beta0tl*beta0cl;
	beta0tt=beta0tr;
	beta0ct=beta0cr;
	%}

	beta0tl=abs(ftl);
	beta0cl=abs(fcl);
	beta0tr=abs(ftr);
	beta0cr=abs(fcr);
	beta0tt=abs(ftt);
	beta0ct=abs(fct);

	lccrit=El*Gftl/beta0tl^2;
	lc(1)=0.8*lccrit;
	lc(2)=lccrit;
	lc(3)=1.25*lccrit;

	zeta2=Hrd/beta0cr^2;
	zeta4=Htd/beta0ct^2;
	zeta6=Hld/beta0cl^2;
	zeta7=zeta2;

	alpha2d=0.1*abs(fcr);
	alpha2max=0.75*abs(fcr);
	alpha4d=0.1*abs(fct);
	alpha4max=0.75*abs(fct);
	alpha6d=0.5*abs(fcl);
	alpha6max=0.75*abs(fcl);
	alpha7d=0.1*abs(1/3*(fvrt+fvrl+fvtl));
	alpha7max=0.75*abs(1/3*(fvrt+fvrl+fvtl));
	
	f=ftl;
	E=El;
	epsilon=linspace(f/E-1e-3,f/E+4e-3,1001);
	for j=1:3
	    eta=lc(j)/Gftl;
	    for i=1:length(epsilon)
	        alphahp{1}{j}(i)=f*epsilon(i)+Gftl/lc(j)*(lambertw(0,-f^2*lc(j)/(E*Gftl)*exp(-f*lc(j)*epsilon(i)/Gftl)));
	        alphahp{2}{j}(i)=f*epsilon(i)+Gftl/lc(j)*(lambertw(-1,-f^2*lc(j)/(E*Gftl)*exp(-f*lc(j)*epsilon(i)/Gftl)));
	        epsilonminusepsilony(i)=epsilon(i)-f/E;
	    end
	end
	plot(epsilonminusepsilony,alphahp{1}{1},'DisplayName','l_c=0.8*l_{c,crit},0');
	hold on
	plot(epsilonminusepsilony,alphahp{2}{1},'DisplayName','l_c=0.8*l_{c,crit},-1');
	plot(epsilonminusepsilony,alphahp{1}{2},'DisplayName','l_c=1.0*l_{c,crit},0');
	plot(epsilonminusepsilony,alphahp{2}{2},'DisplayName','l_c=1.0*l_{c,crit},-1');
	plot(epsilonminusepsilony,alphahp{1}{3},'DisplayName','l_c=1.25*l_{c,crit},0');
	plot(epsilonminusepsilony,alphahp{2}{3},'DisplayName','l_c=1.25*l_{c,crit},-1');
	ylabel('\alphahp (MPa)','FontSize',15);
	xlabel('\epsilon - \epsilon_y','FontSize',15)
	grid on
	legend show
	hold off
	%{
	alphahp=linspace(-0.006*f*3/4,0.01*f*3/4,1001);
	for j=1:3
	    eta=lc(j)/Gftl;
	    for i=1:length(alphahp)
	        epsilonminusepsilony{j}(i)=alphahp(i)/f+f/E*exp(-eta*alphahp(i))-f/E;
	        depsilondalpha{j}(i)=1/f-eta*f/E*exp(-eta*alphahp(i));
	        dalphadepsilon{j}(i)=1/depsilondalpha{j}(i);
	    end
	end
	plot(epsilonminusepsilony{1},alphahp,'DisplayName','l_c=0.8*l_{c,crit}');
	hold on
	plot(epsilonminusepsilony{2},alphahp,'DisplayName','l_c=1.0*l_{c,crit}');
	plot(epsilonminusepsilony{3},alphahp,'DisplayName','l_c=1.25*l_{c,crit}');
	ylabel('\alphahp (MPa)','FontSize',15);
	xlabel('\epsilon - \epsilon_y','FontSize',15)
	grid on
	legend show
	hold off
	
	
	%{
	pause
	plot(epsilonminusepsilony,dalphadepsilon);
	hold on
	ylabel('d\alphahp/d(\epsilon - \epsilony) (MPa)','FontSize',15);
	xlabel('\epsilon - \epsilon_y','FontSize',15)
	grid on
	hold off
	%}
	lc=linspace(0.5*lccrit,1.75*lccrit,1001);
	for i=1:length(lc)
	    insidelambert(i)=-f^2*lc(i)/(E*Gftl)*exp(-f*lc(i)*(f/E)/Gftl);
	end
	plot(lc/lccrit,insidelambert)
	hold on
	xlabel('l_c/l_{c,crit}');
	ylabel('LambertW Input');
	grid on
	hold off
	%}
end


function OnePointTens3()
	TimeStampedName=['OnePointTens3' datestr(now,'yymmdd-HH.MM.SS')];
	theta=linspace(0,360,36001); %degrees
	sigmaRplot12=zeros(1,length(theta));
	sigmaTplot12=zeros(1,length(theta));
	sigmaRplot34=zeros(1,length(theta));
	sigmaTplot34=zeros(1,length(theta));
	parfor angleiter=1:length(theta)
	    [sigmaRplot12(angleiter) sigmaTplot12(angleiter)]=OnePointTens3Ronly(theta(angleiter));
	    [sigmaRplot34(angleiter) sigmaTplot34(angleiter)]=OnePointTens3Tonly(theta(angleiter));
	end
	save([TimeStampedName '.mat'])
	
	plot(sigmaRplot12,sigmaTplot12,'DisplayName','Surface 1 & 2','Color','blue');
	hold on;
	plot(sigmaRplot34,sigmaTplot34,'DisplayName','Surface 3 & 4','Color','red');
	xlabel('\sigma_R','FontSize',15);
	ylabel('\sigma_T','FontSize',15);
	legend('show');
	set(gca,'color','none');
	set(legend,'color','none');
	hold off
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [sigmaR sigmaT]=OnePointTens3Ronly(theta)
	    sigmabase(1)=2.79/2;
	    for i=1:9999
	        sigmaR=sigmabase(i)*cos(theta/180*pi);
	        sigmaT=sigmabase(i)*sin(theta/180*pi);
	        sigmatrial=[sigmaR;sigmaT;0;0;0;0];
	        F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
	        F{3}=-inf;
	        F{4}=-inf;
	        Fmax=CellMax(F);
	        if Fmax<=0
	            sigmabase(i+1)=sigmabase(i)*2;
	        else
	            sigmaminus=sigmabase(i-1);
	            sigmaplus=sigmabase(i);
	            break;
	        end
	    end
	    for i=i+1:999999
	        sigmabase(i)=0.5*(sigmaminus+sigmaplus);
	        sigmaR=sigmabase(i)*cos(theta/180*pi);
	        sigmaT=sigmabase(i)*sin(theta/180*pi);
	        sigmatrial=[sigmaR;sigmaT;0;0;0;0];
	        F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
	        F{3}=-inf;
	        F{4}=-inf;
	        Fmax=CellMax(F);
	        if abs(Fmax)<1e-6
	            break;
	        end
	        if Fmax>0
	            sigmaplus=sigmabase(i);
	        else
	            sigmaminus=sigmabase(i);
	        end
	    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [sigmaR sigmaT]=OnePointTens3Tonly(theta)
	    sigmabase(1)=2.79/2;
	    for i=1:9999
	        sigmaR=sigmabase(i)*cos(theta/180*pi);
	        sigmaT=sigmabase(i)*sin(theta/180*pi);
	        sigmatrial=[sigmaR;sigmaT;0;0;0;0];
	        F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
	        F{1}=-inf;
	        F{2}=-inf;
	        Fmax=CellMax(F);
	        if Fmax<=0
	            sigmabase(i+1)=sigmabase(i)*2;
	        else
	            sigmaminus=sigmabase(i-1);
	            sigmaplus=sigmabase(i);
	            break;
	        end
	    end
	    for i=i+1:999999
	        sigmabase(i)=0.5*(sigmaminus+sigmaplus);
	        sigmaR=sigmabase(i)*cos(theta/180*pi);
	        sigmaT=sigmabase(i)*sin(theta/180*pi);
	        sigmatrial=[sigmaR;sigmaT;0;0;0;0];
	        F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
	        F{1}=-inf;
	        F{2}=-inf;
	        Fmax=CellMax(F);
	        if abs(Fmax)<1e-6
	            break;
	        end
	        if Fmax>0
	            sigmaplus=sigmabase(i);
	        else
	            sigmaminus=sigmabase(i);
	        end
	    end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function OnePointTens2()
	ftl=65.5;
	ftr=3.75;
	ftt=2.79;
	fcl=-50.3;
	fcr=-6;
	fct=-6;
	fvrt=1.83/20; %replacereplacereplace
	fvrl=6.34/20; %replacereplacereplace
	fvtl=5.34/20; %replacereplacereplace
	
	TimeStampedName=['OnePointTens2' datestr(now,'yymmdd-HH.MM.SS')];
	theta=linspace(0,90,9001); %degrees
	sigmaouttens=zeros(1,length(theta));
	parfor angleiter=1:length(theta)
	    [sigmaouttens(angleiter)]=OnePointTens2InsideParfor(theta(angleiter),1);
	    [sigmaoutcomp(angleiter)]=OnePointTens2InsideParfor(theta(angleiter),-1);
	end
	save([TimeStampedName '.mat'])
	
	plot(theta,sigmaouttens/abs(ftl),'LineWidth',1.5,'Color','red');
	hold on;
	title('Tension Loading')
	xlabel('Angle (degrees)','FontSize',15);
	ylabel('\sigma_{load,tens}/f_{t_time,L}','FontSize',15);
	set(gca,'color','none')
	hold off;
	pause;
	
	plot(theta,sigmaoutcomp/fcl,'LineWidth',1.5,'Color','red');
	hold on;
	title('Compression Loading')
	xlabel('Angle (degrees)','FontSize',15);
	ylabel('\sigma_{load,comp}/f_{c,L}','FontSize',15);
	set(gca,'color','none')
	hold off;
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [sigmaout]=OnePointTens2InsideParfor(theta,sign)
	sigmabase(1)=sign*2.79/2;
	for i=1:9999
		sigmaL=sigmabase(i)/2+sigmabase(i)/2*cos(2*theta/180*pi);
		sigmaR=sigmabase(i)/2-sigmabase(i)/2*cos(2*theta/180*pi);
		sigmaRL=-(sigmabase(i)/2)*sin(2*theta/180*pi);
		sigmatrial=[sigmaR;0;sigmaL;0;0;sigmaRL];
		F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
		Fmax=CellMax(F);
		if Fmax<=0
			sigmabase(i+1)=sigmabase(i)*2;
		else
			sigmaminus=sigmabase(i-1);
			sigmaplus=sigmabase(i);
			break;
		end
	end
	for i=i+1:999999
		sigmabase(i)=0.5*(sigmaminus+sigmaplus);
		sigmaL=sigmabase(i)/2+sigmabase(i)/2*cos(2*theta/180*pi);
		sigmaR=sigmabase(i)/2-sigmabase(i)/2*cos(2*theta/180*pi);
		sigmaRL=-(sigmabase(i)/2)*sin(2*theta/180*pi);
		sigmatrial=[sigmaR;0;sigmaL;0;0;sigmaRL];
		F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
		Fmax=CellMax(F);
		if abs(Fmax)<1e-6
			break;
		end
		if Fmax>0
			sigmaplus=sigmabase(i);
		else
			sigmaminus=sigmabase(i);
		end
	end
	sigmaout=sigmabase(i);
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function OnePointTens1()
	TimeStampedName=['OnePointTens1' datestr(now,'yymmdd-HH.MM.SS')];
	theta=linspace(0,360,36001); %degrees
	sigmaLplot=zeros(1,length(theta));
	sigmaRplot=zeros(1,length(theta));
	parfor angleiter=1:length(theta)
	    [sigmaLplot(angleiter) sigmaRplot(angleiter)]=OnePointTens1InsideParfor(theta(angleiter));
	end
	plot(sigmaLplot,sigmaRplot,'LineWidth',2,'Color','red');
	hold on;
	xlabel('\sigma_L','FontSize',15);
	ylabel('\sigma_R','FontSize',15);
	set(gca,'color','none')
	hold off
	save([TimeStampedName '.mat'])
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [sigmaL sigmaR]=OnePointTens1InsideParfor(theta)
	sigmabase(1)=2.79/2;
	for i=1:9999
		sigmaL=sigmabase(i)*cos(theta/180*pi);
		sigmaR=sigmabase(i)*sin(theta/180*pi);
		sigmatrial=[sigmaR;0;sigmaL;0;0;0];
		F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
		Fmax=CellMax(F);
		if Fmax<=0
			sigmabase(i+1)=sigmabase(i)*2;
		else
			sigmaminus=sigmabase(i-1);
			sigmaplus=sigmabase(i);
			break;
		end
	end
	for i=i+1:999999
		sigmabase(i)=0.5*(sigmaminus+sigmaplus);
		sigmaL=sigmabase(i)*cos(theta/180*pi);
		sigmaR=sigmabase(i)*sin(theta/180*pi);
		sigmatrial=[sigmaR;0;sigmaL;0;0;0];
		F=Wood_Schmidt_EvalSigmaEff(sigmatrial,[0 0 0 0 0 0 0],[1 2 3 4 5 6 7],[1 0 0 0 0 0]);
		Fmax=CellMax(F);
		if abs(Fmax)<1e-6
			break;
		end
		if Fmax>0
			sigmaplus=sigmabase(i);
		else
			sigmaminus=sigmabase(i);
		end
	end
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function OnePointPull()
	TimeStampedName=['MatModelTestbed' datestr(now,'yymmdd-HH.MM.SS')];
	ftl=65.5;
	ftr=3.75;
	ftt=2.79;
	fcl=-50.3;
	fcr=-6;
	fct=-6;
	fvrt=1.83/20; %replacereplacereplace
	fvrl=6.34/20; %replacereplacereplace
	fvtl=5.34/20; %replacereplacereplace
	Er=820/1; %replacereplacereplace
	Et=430/1; %replacereplacereplace
	El=13200/1; %replacereplacereplace
	Grt=40/1; %replacereplacereplace
	Gtl=730/1; %replacereplacereplace
	Grl=660/1; %replacereplacereplace
	nurt=0.24;
	nutl=0.45;
	nurl=0.45;


	Comp=[1/Er -nurt/Et -nurl/El 0 0 0;
	     -nurt/Et 1/Et -nutl/El 0 0 0;
	     -nurl/El -nutl/El 1/El 0 0 0;
	     0 0 0 1/Grt 0 0;
	     0 0 0 0 1/Gtl 0;
	     0 0 0 0 0 1/Grl];
	 
	xdir=RTLtranslator('r');
	ydir=RTLtranslator('t');
	zdir=RTLtranslator('l');
	xydir=RTLtranslator('rt');
	yzdir=RTLtranslator('tl');
	xzdir=RTLtranslator('rl');
	
	Comp=MatReorder(Comp,[xdir ydir zdir xydir yzdir xzdir]);
	C=Comp^-1;
	
	%sigma_global_big=transpose([3.75 2.79 0 0 0 0]);

	%for surface 1&3
	%sigma_global_big=transpose([3.4687600422317030890440037182998,2.3237485210648975986202913190937,0,0,0,0])*0.9999;

	%for surface 1 only
	sigma_global_big=transpose([0 0 0 0 0 0]);

	%for surface 2 and 4
	%sigma_global_big=transpose([ -4.593386622447824585435682820389 -4.593386622447824585435682820389 0 0 0 0]);

	%sigma_global_big=transpose([0 0 0 0 0 0]);
	e_t_global_big=Comp*sigma_global_big;
	e_pl_global_big=transpose([0 0 0 0 0 0]);
	alphahp=[0 0 0 0 0 0 0];
	[sigmaplot2 epsilonplot2]=AnalyticalLoadDisplacementPlot;
	for i=1:9999999
	    if i==1
	        dESP=[0 0;0 0];
	    else
	        dESP=[-0.0001 0;0 0.000];
	    end
	    if i>2
	        if alphaplot(i-1)<alphaplot(i-2)
	            disp('hey!')
	        end
	    end

	    [s_sp,e_pl,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp,f_final_vect,surfacewithfmax]=Wood_Schmidt17(dESP,sigma_global_big,e_t_global_big,e_pl_global_big,alphahp);
	    s_sp_trace{i}=s_sp;
	    e_pl_trace{i}=e_pl;
	    sigma_global_big_trace{i}=sigma_global_big;
	    e_t_global_big_trace{i}=e_t_global_big;
	    e_pl_global_big_trace{i}=e_pl_global_big;
	    alpha_trace{i}=alphahp;
	    f_final_vect_trace{i}=f_final_vect;
	    surfacewithfmax_trace{i}=surfacewithfmax;
	    
	    epsilonplot(i)=e_t_global_big(1);
	    sigmaplot(i)=sigma_global_big(1);
	    alphaplot(i)=alphahp(2);
	    if abs(e_t_global_big(1))>=1
	        break;
	    end
	end
	save([TimeStampedName '.mat'])
	
	
	plot(epsilonplot2,sigmaplot2,'DisplayName','Analytical','LineWidth',2,'Color','cyan');
	hold on;
	plot(-epsilonplot,-sigmaplot,'DisplayName','Numerical','color','black');
	title('R compression');
	xlabel('\epsilon','FontSize',15);
	ylabel('\sigma','FontSize',15);
	legend('show');
	hold off
	pause

	plot(-epsilonplot,alphaplot);
	
	%printvector(sigma_global_big,'sigma_global_big')
end

%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%-------------------------------------------------------------------------------- FUNCTION SEPARATOR -----------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function [sigma epsilon]=AnalyticalLoadDisplacementPlot()
	ftl=65.5;
	ftr=3.75;
	ftt=2.79;
	fcl=-50.3;
	fcr=-6;
	fct=-6;
	fvrt=1.83/20; %replacereplacereplace
	fvrl=6.34/20; %replacereplacereplace
	fvtl=5.34/20; %replacereplacereplace
	Er=820/1; %replacereplacereplace
	Et=430/1; %replacereplacereplace
	El=13200/1; %replacereplacereplace

	kappa1=0.00001;
	kappa2=1.2;
	kappa3=0.00001;
	kappa4=1.2;
	kappa5=0.00001;
	kappa6=0.7;
	kappa7=1.2;

	Gftl=1650/1000;
	Gfcl=50000/1000;
	Gftr=300/1000;
	Gftt=Gftr;
	Gfcr=Gftr/Gftl*Gfcl;
	Gfct=Gfcr;
	GII=300/1000;

	Hld=15;
	Hrd=2;
	Htd=Hrd;

	%{
	beta0tl=65;
	beta0cl=49.9;
	beta0tr=4.5;
	beta0cr=beta0tr/beta0tl*beta0cl;
	beta0tt=beta0tr;
	beta0ct=beta0cr;
	%}

	beta0tl=abs(ftl);
	beta0cl=abs(fcl);
	beta0tr=abs(ftr);
	beta0cr=abs(fcr);
	beta0tt=abs(ftt);
	beta0ct=abs(fct);

	lccrit=El*Gftl/beta0tl;
	lc=lccrit/100;
	lc=4;

	zeta2=Hrd/beta0cr^2;
	zeta4=Htd/beta0ct^2;
	zeta6=Hld/beta0cl^2;
	zeta7=zeta2;

	alpha2d=0.1*abs(fcr);
	alpha2max=0.75*abs(fcr);
	alpha4d=0.1*abs(fct);
	alpha4max=0.75*abs(fct);
	alpha6d=0.5*abs(fcl);
	alpha6max=0.75*abs(fcl);
	alpha7d=0.1*abs(1/3*(fvrt+fvrl+fvtl));
	alpha7max=0.75*abs(1/3*(fvrt+fvrl+fvtl));

	f=abs(fcr)
	E=Er
	eta=abs(lc)/abs(Gfcr)
	kappa=kappa2
	alphad=alpha2d
	alphainf=alpha2max
	zeta=zeta2

	% before yielding
	epsilon1=linspace(0,f/E,11);
	sigma1=E.*epsilon1;

	% after yielding before densification
	epsilond=alphad/f+f/E*(1-kappa)*(exp(-eta*alphad)-1)+f/E;
	%epsilond=0.3;
	epsilon2=linspace(f/E,epsilond,101);
	for i=1:length(epsilon2)
	    sigma2(i)=f*(kappa+(1-kappa)*exp(eta*(kappa*f^2/E-f*epsilon2(i))-lambertw((kappa-1)*(eta*f^2/E)*exp(eta*(kappa*f^2/E-f*epsilon2(i))))));
	end

	% after densification
	%{{
	alphahp=linspace(alphad,0.99*alphainf,101);
	for i=1:length(alphahp)
	    q=(1-kappa)*(1-exp(-eta*alphahp(i)))-zeta*((alphahp(i)-alphad)^2/(alphainf-alphahp(i)));
	    sigma3(i)=f*(1-q);
	    epsilon3(i)=epsilond+(alphahp(i)-alphad)/f-f*((kappa-1)*(exp(-eta*alphahp(i))-exp(-eta*alphad))-zeta*(alphahp(i)-alphad)^2/(alphainf-alphahp(i)))/E;
	end
	%}}
	sigma=[sigma1 sigma2 sigma3];
	%sigma=[sigma1 sigma2];
	epsilon=[epsilon1 epsilon2 epsilon3];
	%epsilon=[epsilon1 epsilon2];
end

if CasetoRun==1 || CasetoRun==2 || CasetoRun==3 || CasetoRun==33 || CasetoRun==34 || CasetoRun==40 || CasetoRun==52 || CasetoRun==54 || CasetoRun==48 || CasetoRun==42 || CasetoRun==45 || CasetoRun==39 || CasetoRun==28 || CasetoRun==29 || CasetoRun==30 || CasetoRun==31 || CasetoRun==27 || CasetoRun==26 || CasetoRun==22 || CasetoRun==24 || CasetoRun==19 || CasetoRun==21 || CasetoRun==17
elseif CasetoRun==4
elseif CasetoRun==5 || CasetoRun==6
elseif CasetoRun==7
elseif CasetoRun==8 || CasetoRun==9
end

%}















%{
filename history:
A201808080131_radialcomp.m
A201808081235_radialcomp.m
A201808081253_surfaceswitchcheck.m
A201808081431_surfaceswitchcheck.m
A201808081443_surfaceswitchcheck.m
A201808091000_radialwithcheck.m
A201808091206_implicitintervention.m
A201808101237_implicitintervention.m
A201808101237r_implicitintervention.m
A201808131129_energyabsorbingtestbed.m
A201808141202_energyabsorbingtestbed.m
A201808141353_energyabsorbingtestbed.m
A201808141528_addingBCdamping.m
A201808161121_addingBCdamping.m
A201808161209_highdamping.m
A201808161302_negateloadweight.m
A201808161532_variablesize.m
A201808171611_lvarnotdone.m
A201808171612_lvarnotdone.m
A201808211557.m
A201808182107.m
A201808212240.m
A201808221012.m
A201808222034.m
A201808222100.m
A201808222226.m
A201808222243.m
A201808222354.m
A201808230152.m
A201808230353.m
A201808271153.m
A201808271529.m
A201808271534_prototype.m
A201808271656.m
A201808281513r.m
A201808291226.m
A201808291608.m
A201808311706.m
A201808311824.m
A201808311837.m
A201809031006.m
A201809031615.m
A201809031627.m
A201809032217.m
A201809041034.m
A201809041319.m
A201809041432.m
A201809041828.m
A201809042049.m
A201809050037.m
A201809051048.m
A201809051117.m
A201809051358.m
A201809051638.m
A201809051638r.m
A201809060946.m
A201809061129.m
A201809061228.m
A201809061533.m
A201809071154.m
A201809071234.m
A201809071300.m
A201809100120.m
A201809101209.m
A201809101224.m
A201809110935.m
A201809110959.m
A201809111400.m
A201809121500.m
A201809121519.m
A201809121708.m
A201809131706.m
A201809131722.m
A201809131726.m
A201809141041.m
A201809141214.m
A201809141319.m
A201809141634.m
A201809151714.m
A201809151902.m
A201809151902test.m
A201809151902test2.m
A201809181043errtrack.m
A201809181053.m
A201809181103.m
A201809182008.m
A201809182039.m
A201809182102.m
A201809191329.m
A201809191408.m
A201809191520.m
A201809191612.m double knots
A201809201734.m
A201809210941.m MPM beef up
A201809211059.m MPM beef up
A201809211556.m less aggressive alpha widening
A201809240925.m substepped implicit multisurface
A201809251447.m MPM beefed up max, less disp
A201809251504.m CPDI multiknot fine
A201809260947.m
A201809261239.m
A201809261253.m
A201809261323test.m
A201809261357test.m
A201809261402test.m
A201809261453test.m
A201809261512test.m
A201809261556.m
A201809261627.m
A201809261707.m
A201809261723.m
A201809261723r.m
A201809261825.m
A201809261929.m
A201809262145.m
A201809270017.m
A201809271053.m
A201809271245.m
A201809271328.m
A201809281319.m
A201809281530.m
A201809281619.m
A201810011356.m
A201810011554.m
A201810021303.m
A201810021351.m
A201810021626.m
A201810022107.m
A201810022112.m
A201810022112s.m
A201810030928.m
A201810031010.m
A201810031343.m
A201810031343r.m
A201810031419.m
A201810031602.m
A201810031602r.m
A201810031732.m
A201810031542.m
A201810051542.m
A201810051634.m
A201810081106.m
A201810081505.m
A201810081555.m
A201810081628.m
A201810081705.m
A201810080952.m
A201810081009.m
A201810091050.m
A201810091056.m
A201810091512.m
A201810101007.m
A201810101436.m
A201810101510.m
A201810101702.m
A201810111247.m
A201810121045.m
A201810142323.m
A201810151157.m
A201810151222_stacktest.m
A201810151637.m
A201810152136.m
A201810152146.m
A201810161435.m
A201810161849.m
A201810201837.m
A201810220946.m
A201810221000.m
A201810221017.m
A201810221039.m
A201810221039d.m
A201810231005a.m
A201810261503.m
A201810282119.m
A201810291550.m
A201810300950.m
A201810301007.m
A201810301254.m
A201810311918.m
A201810311918b.m
A201810312112.m
A201811011101.m
A201811011152.m
A201811011205.m
A201811011618.m
A201811011643.m
A201811012016.m
A201811020717.m
A201811042146.m
A201811042314.m
A201811051929.m
A201811061124.m
A201811062004.m
A201811062035.m
A201811062100.m
A201811070924.m
A201811071424.m
A201811071424b.m
A201811071424c.m
A201811071528.m
A201811071528b.m
A201811071953.m
A201811072003.m
A201811072003b.m
A201811072142.m
A201811081015.m
A201811081440.m
A201811081623.m
A201811091407.m
A201811091407b.m
A201811131153.m
A201811132228.m
A201811140929.m
A201811140929b.m
A201811140929c.m
A201811150053.m
A201811150938.m
A201811161454.m
A201811231516.m
A201811231516r.m
A201811231517.m
A201811262259.m
A201811270836.m
A201811301927.m
A201811301927sp.m
A201812031254.m
A201812031450.m
A201812040909.m
A201812040909r.m
A201812041055.m
A201812041219r.m
A201812041350.m
A201812041406.m
A201812041412.m
A201812041419.m
A201812041706.m
A201812041930.m
A201812042222.m
A201812050718.m
A201812051001.m
A201812051347.m
A201812071009.m
A201812071100.m
A201812091848.m
A201812091930.m
A201812092308.m
A201812092318.m
A201812100017.m
A201812101339.m
A201812101339u.m
A201812131734.m
A201812211723.m
A201812211723b.m
A201812211723c.m
A201812211723d.m
A201812311458.m
A201812311720.m
A201901020929.m
A201901021709.m
A201901032044.m
A201901041406.m
A201901041409.m
A201901041434.m
A201901082234.m
A201901082234b.m
A201901091054.m
A201901101121.m
A201901171748.m
A201901281623.m
A201901291500.m
A201901292050.m
A201901292112.m
A201901292120.m
zz1902022104.m
zz1902022104b.m
zz1902022155.m
zz1902041658.m
zz1902041931.m
zz1902050956.m
zz1902051009.m
zz1902051013.m
zz1902051022.m
zz1902051047.m
zz1902051105.m
zz1902051106.m
zz1902051116.m
zz1902051125.m
zz1902051232.m
zz1902051624.m
zz1902051851.m
zz1902051951.m
zz1902052132.m
zz1902052221.m
zz1902061151.m
zz1902061443.m
zz1902061506.m
zz1902061613.m
zz1902061935.m
zz1902061950.m successful one crack crackparticles only
zz1902062058.m start trying tracking crack surfaces
zz1902062104.m
zz1902062218.m
zz1902062247.m
zz1902111654.m
zz1902112016.m
zz1902112217.m
zz1902121052.m
zz1902121216.m
zz1902121751.m
zz1902122004.m
zz1902122103.m
zz1902122213.m
zz1902122223.m
zz1902122254.m
zz1902122304.m
zz1902130721.m
zz1902130816.m
zz1902192203.m
zz1902201635.m
zz1902201732.m
zz1902211108.m
zz1902211220.m
zz1902211232.m
zz1902211237.m
zz1902211246.m
zz1902211508.m
zz1902211610.m
zz1902211621.m
zz1902211628.m
zz1902211723.m
zz1902211734.m
zz1902211738.m
zz1902221308.m
zz1902221720.m
zz1902232223.m
zz1902232223b.m
zz1902232231.m
zz1902232329.m
zz1902251139.m
zz1902251230.m
zz1902251627.m
zz1902251724.m
zz1902251808.m
zz1902251835.m
zz1902251848.m
zz1902252014.m
zz1902252026.m
zz1902252111.m
zz1902252121.m
zz1902252322.m
zz1902252326.m
zz1902260108.m - open for 90 degs, shrink all directions
zz1902261208.m - open for 90 degs, shrink x only
zz1902261235.m - ramp shrink xy
zz1892261256.m - ramp shrink x only
zz1902261657.m - ramp shrink xy small initial (case 71)
zz1902261936.m - J central adjustable
zz1902261952.m - J central adjustable 1.4 shorter
zz1902262324.m - J central adjustable shrink xy very small initial
zz1902271135.m - field split error investigation
zz1902271233.m - field split error handled, bottom still roller, plot both with/without crack
zz1902271301.m - field split error handled, bottom fixed, plot both with/without crack (wrong bottom fixing)
zz1902271432.m - bottom fixed properly
zz1903031617.m - crack initiation stress roller bottom
zz1903031714.m - crack initiation stress roller bottom create x_crack
zz1903041235.m - fixing things up
zz1903041241.m
zz1903041253.m
zz1903041336.m
zz1903061744.m
zz1903061758.m
zz1903071256.m
zz1903071452.m
zz1903071722.m
zz1903071858.m
zz1903081146.m
zz1903081214.m
zz1903081239.m
zz1903081531.m
zz1903081755.m
zz1903081807.m
zz1903081817.m
zz1903081904.m
zz1903081930.m
zz1903111237.m - trying 9 particles
zz1903111301.m - outputting f_final_vect for cracked particles
zz1903111441.m - diagonal crack investigation (code gutted)
zz1903111747.m - proper direction identification
zz1903120006.m - retrying ParticlePull with proper h
zz1903121027.m - extracting inputs for particlepull
zz1903121056.m - extracting inputs for particlepull
zz1903121118.m - retrying ParticlePull from faulty input
zz1903121551.m - angled, it's just how it is, plot sx and sy please
zz1903121604.m - tt start simulation and tt start plotting
zz1903121618.m - investigate spurious with point pull again
zz1903121805.m - 2 particles per cell, plane stress
zz1903121825.m - plane strain, no damping
zz1903131252.m - initial discrete crack, Q propagation
zz1903131704.m - particle just cracked list
zz1903131842.m - averaging and propagating
zz1903131843.m - averaging and propagating
zz1903131844.m - averaging and propagating
zz1903150109.m - running from start again
zz1903150110.m - running from start again
zz1903150111.m
zz1903150112.m
zz1903150337.m
zz1903181513.m
zz1903181759.m
zz1903181842.m
zz1903181843.m
zz1903181844.m
zz1903181845.m
zz1903191659.m
zz1903191818.m
zz1903221549.m
zz1903221550.m
zz1903251803.m
zz1903251830.m
zz1903252115.m
zz1903252302.m
zz1903271338.m
zz1903271407.m
zz1893271700.m
zz1903271700.m
zz1903271725.m
zz1903271849.m
zz1903271954.m
zz1903272005.m
zz1903272035.m
zz1903272053.m
zz1903281506.m
zz1903281644.m
zz1903281659.m
zz1903281723.m
zz1903281731.m
zz1903281901.m
zz1903281905.m
zz1903281945.m
zz1903281945b.m - field split investigation
zz1903281945c.m - field split investigation
zz1903282057.m
zz1904011223.m
zz1904022301.m
zz1904081354.m
zz1904081718.m
zz1904081734.m
zz1904081846.m
zz1904091154.m
zz1904091344.m
zz1904091443.m
zz1904091527.m
zz1904091902.m
zz1904091908.m
zz1904091910.m
zz1904092008.m
zz1904092120.m
zz1904092203.m
zz1904092215.m
zz1904101330.m
zz1904101635.m
zz1904101705.m
zz1904101713.m
zz1904101733.m
zz1904101737.m
zz1904101807.m
zz1904101939.m
zz1904101939b.m
zz19041012002.m
zz19041012038.m
zz19041012038b.m
zz1904102104.m
zz1904102134.m
zz1904102208.m
zz1904102234.m
zz1904102347.m
zz1904111257.m
zz1904111652.m
zz1904111704.m
zz1904111735.m
zz1904111747.m
zz1904112005.m
zz1904112132.m
zz1904112132b.m
zz1904112236.m
zz1904112314.m
zz1904112315.m
zz1904121053.m
zz1904121618.m
zz1904121647.m
zz1904121926.m
zz1904122012.m
zz1904131822.m
zz1904151212.m
zz1904151212b.m
zz1904151212c.m
zz1904151212d.m
zz1904151212e.m
zz1904151614.m
zz1904151615.m
zz1904151616.m
zz1904151617.m
zz1904151618.m
zz1904151619.m
zz1904151620.m
zz1904160051.m
zz1904160112.m
zz1904160112b.m
zz1904161308.m
zz1904161309.m
zz1904161310.m
zz1904161311.m
zz1904161312.m
zz1904161313.m
zz1904161314.m
zz1904161314b.m
zz1904161314c.m
zz1904161314d.m
zz1904171323.m
zz1904171324.m
zz1904171325.m
zz1904171651.m
zz1904171652.m
zz1904171653.m
zz1904171654.m
zz1904171655.m
zz1904171656.m
zz1904172242.m
zz1904172242b.m
zz1904181331.m
zz1904181649.m
zz1904182007.m
zz1904182233.m
zz1904190010.m
zz1904191228.m
zz1904191748.m
zz1904191749.m
zz1904191750.m
zz1904191751.m
zz1904231852.m
zz1904231853.m
zz1904231854.m
zz1904231855.m
zz1904241226.m
zz1904241227.m
zz1904241227p.m
zz1904251505.m
zz1904251516.m
zz1904251700.m
zz1904251714.m
zz1904251715.m
zz1904252212.m
zz1904252318.m
zz1904252319.m
zz1904252320.m
zz1904252321.m
zz1904252322.m
zz1904252323.m
zz1904252324.m
zz1904291659.m
zz1904301319.m
zz1904302107.m
zz1905021642.m
zz1905021713.m
zz1905021756.m
zz1905021758.m
zz1905021817.m
zz1905022102.m
zz1905061348.m
zz1905061714.m
zz1905061743.m
zz1905071307.m
zz1905071308.m
zz1905071309.m %retrieving sigmainf
zz1905071310.m %retrieving sigmainf
zz1905071634.m
zz1905080010.m
zz1905080011.m
zz1905080012.m
zz1905080013.m
zz1905080014.m
zz1905080015.m
zz1905101323.m
zz1905101324.m
zz1905101325.m
zz1905101326.m
zz1905132236.m
zz1905132300.m
zz1905141832.m
zz1905141832main.m
zz1905151711.m
zz1905151712.m
zz1905161805.m
zz1905202214.m
zz1905221125.m
zz1905221151.m
zz1905221221.m %applying traction on grid
zz1905261941.m
zz1905261941b.m
zz2905271010.m
zz1906030211.m
zz1906030211c.m
zz1906030259c.m
zz1906030259.m
zz1906030306.m
zz1906261012.m
zz1906201039.m - angled crack for infinite plane added
zz1906261234.m
zz1906261337.m - main handler 122 test run
zz1906261337print.m
zz1906281235.m
zz1906281739.m
zz1906281739Coder.m
zz1906281824.m
zz1907011004.m
zz1907021736.m
zz1907041207.m
zz1907041840.m
zz1907042011.m
zz1907050925.m
zz1907051108.m
zz1907051229.m
zz1907051655.m
zz1907052055.m
zz1907080941.m
zz1907080941Coder.m
zz1907081342.m
zz1907081342Coder.m
zz1907081407.m
zz1907081634.m
zz1907081759.m
zz1907090927.m
zz1907091032.m
zz1907091056.m
zz1907091535.m
zz1907091535c.m
zz1907091853.m
zz1907101150.m
zz1907101150c.m
zz1907101610.m
zz1907101650.m
zz1907101914.m
zz1907101914b.m
zz1907102139.m
zz1907102143.m
zz1907102144.m
zz1907111327.m - working normally again
zz1907111334.m
zz1907111501.m
zz1907112014.m
zz1907112024.m
zz1907112026.m
zz1907112233.m
zz1907112321.m
zz1907121741.m
zz1907122219.m
zz1907132321.m
zz1907140138.m
zz1907141140.m
zz1907141171.m
zz1907171539.m
zz1907241133.m
zz1907241138.m
zz1908041706.m - TheFieldSplitBase3 Regular Array
zz1908051003.m - from 1001 fixed cell declaration
zz1908230916 - paralellized, back to 16
%}

%{
xyW=[	0.002826114	0.002826069	0.000110742	;
		0.036715186	0.002818485	0.000685881	;
		0.142478702	0.002708944	0.001461138	;
		0.309741132	0.00221853	0.001446592	;
		0.457879042	0.001135335	0.000440357	;
		0.002826114	0.036714599	0.000687727	;
		0.036715186	0.036616068	0.004259454	;
		0.142478702	0.035192981	0.009073948	;
		0.309741132	0.028821812	0.008983611	;
		0.457879042	0.014749598	0.002734699	;
		0.002826114	0.142476426	0.001524313	;
		0.036715186	0.142094059	0.009440868	;
		0.142478702	0.136571561	0.020111952	;
		0.309741132	0.111847299	0.019911726	;
		0.457879042	0.057237994	0.006061324	;
		0.002826114	0.309736184	0.001842738	;
		0.036715186	0.308904938	0.011413041	;
		0.142478702	0.296899321	0.024313287	;
		0.309741132	0.243150088	0.024071235	;
		0.457879042	0.124432359	0.007327519	;
		0.002826114	0.457871727	0.001096133	;
		0.036715186	0.456642927	0.006788925	;
		0.142478702	0.438895459	0.014462499	;
		0.309741132	0.359439925	0.014318516	;
		0.457879042	0.183943827	0.004358696	];

%}

%{
function outputanalysis()
	TimeStampedName='Out-zz1912181981-Case_154-Vortex';
	tt=loadsinglelong([TimeStampedName '-Master-' 'tt' '.txt']);
	tt=tt-1;
	anerror.u_sp(:,:,1)=loadmatrixfloat([TimeStampedName '-Slave-' 'anerror.u_sp' '-' int2txt(1) '.txt']);
	spCount=size(anerror.u_sp,1);
	anerror.u_sp=zeros(spCount,2,tt);
	anerror.u_sp_an=zeros(spCount,2,tt);
	anerror.u_srsserror=zeros(1,tt);
	anerror.u_srssan=zeros(1,tt);
	anerror.u_err_relative=zeros(1,tt);
	anerror.u_srss=zeros(1,tt);
	t_time=zeros(1,tt);
	tt_list=zeros(1,tt);
	for i=1:tt
		anerror.u_sp(:,:,i)=loadmatrixfloat([TimeStampedName '-Slave-' 'anerror.u_sp' '-' int2txt(i) '.txt']);
		anerror.u_sp_an(:,:,i)=loadmatrixfloat([TimeStampedName '-Slave-' 'anerror.u_sp_an' '-' int2txt(i) '.txt']);
		anerror.u_srsserror(i)=loadsinglefloat([TimeStampedName '-Slave-' 'anerror.u_srsserror' '-' int2txt(i) '.txt']);
		anerror.u_srssan(i)=loadsinglefloat([TimeStampedName '-Slave-' 'anerror.u_srssan' '-' int2txt(i) '.txt']);
		anerror.u_err_relative(i)=loadsinglefloat([TimeStampedName '-Slave-' 'anerror.u_err_relative' '-' int2txt(i) '.txt']);
	    anerror.u_srss(i)=sqrt(dot(anerror.u_sp(:,1,i),anerror.u_sp(:,1,i))+dot(anerror.u_sp(:,2,i),anerror.u_sp(:,2,i)));
		t_time(i)=loadsinglefloat([TimeStampedName '-Slave-' 't_time' '-' int2txt(i) '.txt']);
		tt_list(i)=i;
	end
	close all
	hold on
	%plot(tt_list,anerror.u_err_relative,'DisplayName','anerror.u_err_relative');
	plot(tt_list,anerror.u_srss,'DisplayName','SRSS MPM');
	plot(tt_list,anerror.u_srssan,'DisplayName','SRSS Analytical');
	plot(tt_list,anerror.u_srsserror,'DisplayName','SRSS Error');
	legend show;
	xlabel('tt_list');
	ylabel('value');
	uisave;
end

function outputanalysis161()
	clear all;
	close all;
	maxpower=4;
	anerror.t_deviation=zeros(1,maxpower+1);
	anerror.u_err_relative=zeros(1,maxpower+1);
	anerror.gridsize=zeros(1,maxpower+1);
	for ipower=0:maxpower
		anerror.t_deviation(ipower+1)=loadsinglefloat(['anerror.t_deviation' '-' int2txt(2^ipower) '.txt']);
		anerror.u_err_relative(ipower+1)=loadsinglefloat(['anerror.u_err_relative' '-' int2txt(2^ipower) '.txt']);
		anerror.gridsize(ipower+1)=loadsinglefloat(['anerror.gridsize' '-' int2txt(2^ipower) '.txt']);
	end
	
	%CPDI convergence papers square, ring, vortex(Quan)
	%start of: numbers are from graph measurements
	CPDI.square.cellsize=[0.01549214 0.030821796 0.062012481 0.124367677];
	CPDI.square.error=[1.68523E-08 2.01937E-07 2.2138E-06 2.77341E-05];
	CPDI.ring.cellsize=[0.101113835 0.049491197 0.024835285 0.012393816];
	CPDI.ring.error=[6.28092E-05 1.6521E-05 2.8851E-06 3.62748E-07];
	CPDI.vortex.cellsize=[0.125448936 0.062431094 0.03132367 0.01560976];
	CPDI.vortex.error=[0.268401913 0.055415108 0.013317962 0.01299999];
	%end of: numbers are from graph measurements
	
	%start of: infinite plane
	%source: D:\Users\Tito\Documents\Combined_2019-02-21\zz1905101323-119_InfinitePlate2x2Norms-MainHandler.mat
	CPDI.infinite.cellsize=[2.50000000000000,1.25000000000000,0.833333333333333,0.625000000000000,0.500000000000000,0.416666666666667,0.357142857142857,0.312500000000000,0.277777777777778,0.250000000000000,0.227272727272727,0.208333333333333];
	CPDI.infinite.Grelativeerror=[0.484040996167281,0.220838232255940,0.144315153519236,0.107387692586272,0.0852596700200254,0.0706326123868621,0.0602351837422849,0.0524839662956033,0.0464772398132144,0.0416927673396901,0.0377901155112371,0.0345436264261088];
	CPDI.infinite.stressnormpersigmainf=[0.274829181897473,0.175609407301199,0.126731664714007,0.0993195849476160,0.0817527492467626,0.0695176624219848,0.0605018889150845,0.0535751109323679,0.0480836951457544,0.0436222548011954,0.0399252650677765,0.0368125711633320];
	%end of: infinite plane
	
	
	
	figure1=figure;
	loglog(CPDI.square.cellsize,CPDI.square.error,'-o','DisplayName','Axis-Aligned');
	hold on
	loglog(CPDI.ring.cellsize,CPDI.ring.error,'-o','DisplayName','Ring Expansion');
	loglog(CPDI.vortex.cellsize,CPDI.vortex.error,'-o','DisplayName','Vortex: QA');
	loglog(anerror.gridsize,anerror.u_err_relative,'-o','DisplayName','Vortex: This Paper');
	loglog(CPDI.infinite.cellsize,CPDI.infinite.Grelativeerror,'-o','DisplayName','Infinite: G error');
	loglog(CPDI.infinite.cellsize,CPDI.infinite.stressnormpersigmainf,'-o','DisplayName','Infinite: stress error');
	%title('Vortex Convergence');
	ylabel('Relative Error Norm [-]');
	xlabel('Grid Size [m]');
	legend show
	%set(gca,'Xdir','reverse');
	set(figure1,'Position',[0 0 350 250]);
	uisave;
	
end
%}
function rolledfour=roll4(int_in)
	rolledfour=mod(int_in-1,4)+1;
end

function themagnitude=calcmag(vector_in)
	themagnitude=sqrt(dot(vector_in,vector_in));
end

function temp=tempfromFDS(depth,time,FDS)
	%the depth is as vector
	%the time as vector
	%temp rate will be vector, same size as depth
	%FDS.temp: index1:depth (initial configuration), index2: time
	ndmpm=length(depth);
	ndfds=length(FDS.depth);
	ntime=length(FDS.time);
	idfdsfract=zeros(1,1);
	itimefract=zeros(1,1);
	tempbefore=zeros(1,1);
	tempafter=zeros(1,1);
	temp=zeros(1,ndmpm);
	
	for idmpm=1:ndmpm
		for itime=1:ntime-1
			if time(idmpm)<FDS.time(itime+1)
				itimefract=itime+(time(idmpm)-FDS.time(itime))/(FDS.time(itime+1)-FDS.time(itime));
				break;
			end
		end
		for idfds=1:ndfds-1
			if depth(idmpm)<FDS.depth(idfds+1)
				idfdsfract=idfds+(depth(idmpm)-FDS.depth(idfds))/(FDS.depth(idfds+1)-FDS.depth(idfds));
				break;
			end
		end
		tempbefore=FDS.temp(idfds,itime)+(idfdsfract-idfds)*(FDS.temp(idfds+1,itime)-FDS.temp(idfds,itime));
		tempafter=FDS.temp(idfds,itime+1)+(idfdsfract-idfds)*(FDS.temp(idfds+1,itime+1)-FDS.temp(idfds,itime+1));
		temp(idmpm)=tempbefore+(itimefract-itime)*(tempafter-tempbefore);
	end
end

function temprate=tempratefromFDS(depth,time,FDS)
	%the depth is as vector
	%the time as vector
	%temp rate will be vector, same size as depth
	%FDS.temp: index1:depth (initial configuration), index2: time
	ndmpm=length(depth);
	ndfds=length(FDS.depth);
	ntime=length(FDS.time);
	idfdsfract=zeros(1,1);
	itimefract=zeros(1,1);
	tempbefore=zeros(1,1);
	tempafter=zeros(1,1);
	temprate=zeros(1,ndmpm);
	
	for idmpm=1:ndmpm
		for itime=1:ntime-1
			if time(idmpm)<FDS.time(itime+1)
				itimefract=itime+(time(idmpm)-FDS.time(itime))/(FDS.time(itime+1)-FDS.time(itime));
				break;
			end
		end
		for idfds=1:ndfds-1
			if depth(idmpm)<FDS.depth(idfds+1)
				idfdsfract=idfds+(depth(idmpm)-FDS.depth(idfds))/(FDS.depth(idfds+1)-FDS.depth(idfds));
				break;
			end
		end
		tempbefore=FDS.temp(idfds,itime)+(idfdsfract-idfds)*(FDS.temp(idfds+1,itime)-FDS.temp(idfds,itime));
		tempafter=FDS.temp(idfds,itime+1)+(idfdsfract-idfds)*(FDS.temp(idfds+1,itime+1)-FDS.temp(idfds,itime+1));
		temprate(idmpm)=(tempafter-tempbefore)/(FDS.time(itime+1)-FDS.time(itime));
	end
end

function density=densityfromFDS(depth,time,FDS)
	%the depth is as vector
	%the time as vector
	%density rate will be vector, same size as depth
	%FDS.density: index1:depth (initial configuration), index2: time
	ndmpm=length(depth);
	ndfds=length(FDS.depth);
	ntime=length(FDS.time);
	idfdsfract=zeros(1,1);
	itimefract=zeros(1,1);
	densitybefore=zeros(1,1);
	densityafter=zeros(1,1);
	density=zeros(1,ndmpm);
	
	for idmpm=1:ndmpm
		for itime=1:ntime-1
			if time(idmpm)<FDS.time(itime+1)
				itimefract=itime+(time(idmpm)-FDS.time(itime))/(FDS.time(itime+1)-FDS.time(itime));
				break;
			end
		end
		for idfds=1:ndfds-1
			if depth(idmpm)<FDS.depth(idfds+1)
				idfdsfract=idfds+(depth(idmpm)-FDS.depth(idfds))/(FDS.depth(idfds+1)-FDS.depth(idfds));
				break;
			end
		end
		densitybefore=FDS.density(idfds,itime)+(idfdsfract-idfds)*(FDS.density(idfds+1,itime)-FDS.density(idfds,itime));
		densityafter=FDS.density(idfds,itime+1)+(idfdsfract-idfds)*(FDS.density(idfds+1,itime+1)-FDS.density(idfds,itime+1));
		density(idmpm)=densitybefore+(itimefract-itime)*(densityafter-densitybefore);
	end
end

function densityrate=densityratefromFDS(depth,time,FDS)
	%the depth is as vector
	%the time as vector
	%density rate will be vector, same size as depth
	%FDS.density: index1:depth (initial configuration), index2: time
	ndmpm=length(depth);
	ndfds=length(FDS.depth);
	ntime=length(FDS.time);
	idfdsfract=zeros(1,1);
	itimefract=zeros(1,1);
	densitybefore=zeros(1,1);
	densityafter=zeros(1,1);
	densityrate=zeros(1,ndmpm);
	
	for idmpm=1:ndmpm
		for itime=1:ntime-1
			if time(idmpm)<FDS.time(itime+1)
				itimefract=itime+(time(idmpm)-FDS.time(itime))/(FDS.time(itime+1)-FDS.time(itime));
				break;
			end
		end
		for idfds=1:ndfds-1
			if depth(idmpm)<FDS.depth(idfds+1)
				idfdsfract=idfds+(depth(idmpm)-FDS.depth(idfds))/(FDS.depth(idfds+1)-FDS.depth(idfds));
				break;
			end
		end
		densitybefore=FDS.density(idfds,itime)+(idfdsfract-idfds)*(FDS.density(idfds+1,itime)-FDS.density(idfds,itime));
		densityafter=FDS.density(idfds,itime+1)+(idfdsfract-idfds)*(FDS.density(idfds+1,itime+1)-FDS.density(idfds,itime+1));
		densityrate(idmpm)=(densityafter-densitybefore)/(FDS.time(itime+1)-FDS.time(itime));
	end
end

function [shrinkageratex,shrinkageratey]=shrinkrateFDSnlit(depth,time,FDS,xydir)
	%shrinkage rate from FDS aNd literature
	%the depth is as vector
	%the time as vector
	%shrinkage rate will be vector, same size as depth
	%FDS.scalc(rtldir).shrinkage: index1:depth (initial configuration), index2: time
	%xydir: x and y direction in that order (expecting 1x2 matrix i.e. sized 2 horizontal vector)
	ndmpm=length(depth);
	ndfds=length(FDS.depth);
	ntime=length(FDS.time);
	idfdsfract=zeros(1,1);
	itimefract=zeros(1,1);
	shrinkagebefore=zeros(1,1);
	shrinkageafter=zeros(1,1);
	shrinkagerate=zeros(1,ndmpm);
	shrinkageratex=zeros(1,ndmpm);
	shrinkageratey=zeros(1,ndmpm);
	rtldir=zeros(1,1);
	
	for idir=1:2
		rtldir=xydir(idir);
		for idmpm=1:ndmpm
			for itime=1:ntime-1
				if time(idmpm)<FDS.time(itime+1)
					itimefract=itime+(time(idmpm)-FDS.time(itime))/(FDS.time(itime+1)-FDS.time(itime));
					break;
				end
			end
			for idfds=1:ndfds-1
				if depth(idmpm)<FDS.depth(idfds+1)
					idfdsfract=idfds+(depth(idmpm)-FDS.depth(idfds))/(FDS.depth(idfds+1)-FDS.depth(idfds));
					break;
				end
			end
			shrinkagebefore=FDS.scalc(rtldir).shrinkage(idfds,itime)+(idfdsfract-idfds)*(FDS.scalc(rtldir).shrinkage(idfds+1,itime)-FDS.scalc(rtldir).shrinkage(idfds,itime));
			shrinkageafter=FDS.scalc(rtldir).shrinkage(idfds,itime+1)+(idfdsfract-idfds)*(FDS.scalc(rtldir).shrinkage(idfds+1,itime+1)-FDS.scalc(rtldir).shrinkage(idfds,itime+1));
			shrinkagerate(idmpm)=(shrinkageafter-shrinkagebefore)/(FDS.time(itime+1)-FDS.time(itime));
		end
		if idir==1
			shrinkageratex=shrinkagerate;
		else%if idir==2, but coder will whine so we leave just else
			shrinkageratey=shrinkagerate;
		end
	end	
end

function shrinkagerate=shrinkageratefromFDS(depth,time,FDS)
	%the depth is as vector
	%the time as vector
	%shrinkage rate will be vector, same size as depth
	%FDS.Shrinkage: index1:depth (initial configuration), index2: time
	ndmpm=length(depth);
	ndfds=length(FDS.depth);
	ntime=length(FDS.time);
	idfdsfract=zeros(1,1);
	itimefract=zeros(1,1);
	shrinkagebefore=zeros(1,1);
	shrinkageafter=zeros(1,1);
	shrinkagerate=zeros(1,ndmpm);
	
	for idmpm=1:ndmpm
		for itime=1:ntime-1
			if time(idmpm)<FDS.time(itime+1)
				itimefract=itime+(time(idmpm)-FDS.time(itime))/(FDS.time(itime+1)-FDS.time(itime));
				break;
			end
		end
		for idfds=1:ndfds-1
			if depth(idmpm)<FDS.depth(idfds+1)
				idfdsfract=idfds+(depth(idmpm)-FDS.depth(idfds))/(FDS.depth(idfds+1)-FDS.depth(idfds));
				break;
			end
		end
		shrinkagebefore=FDS.shrinkage(idfds,itime)+(idfdsfract-idfds)*(FDS.shrinkage(idfds+1,itime)-FDS.shrinkage(idfds,itime));
		shrinkageafter=FDS.shrinkage(idfds,itime+1)+(idfdsfract-idfds)*(FDS.shrinkage(idfds+1,itime+1)-FDS.shrinkage(idfds,itime+1));
		shrinkagerate(idmpm)=(shrinkageafter-shrinkagebefore)/(FDS.time(itime+1)-FDS.time(itime));
	end
end

function k=kfromFDS(depth,time,FDS)
	%the depth is as vector
	%the time as vector
	%k rate will be vector, same size as depth
	%FDS.k: index1:depth (initial configuration), index2: time
	ndmpm=length(depth);
	ndfds=length(FDS.depth);
	ntime=length(FDS.time);
	idfdsfract=zeros(1,1);
	itimefract=zeros(1,1);
	kbefore=zeros(1,1);
	kafter=zeros(1,1);
	k=zeros(1,ndmpm);
	
	for idmpm=1:ndmpm
		for itime=1:ntime-1
			if time(idmpm)<FDS.time(itime+1)
				itimefract=itime+(time(idmpm)-FDS.time(itime))/(FDS.time(itime+1)-FDS.time(itime));
				break;
			end
		end
		for idfds=1:ndfds-1
			if depth(idmpm)<FDS.depth(idfds+1)
				idfdsfract=idfds+(depth(idmpm)-FDS.depth(idfds))/(FDS.depth(idfds+1)-FDS.depth(idfds));
				break;
			end
		end
		kbefore=FDS.k(idfds,itime)+(idfdsfract-idfds)*(FDS.k(idfds+1,itime)-FDS.k(idfds,itime));
		kafter=FDS.k(idfds,itime+1)+(idfdsfract-idfds)*(FDS.k(idfds+1,itime+1)-FDS.k(idfds,itime+1));
		k(idmpm)=kbefore+(itimefract-itime)*(kafter-kbefore);
	end
end

function krate=kratefromFDS(depth,time,FDS)
	%the depth is as vector
	%the time as vector
	%k rate will be vector, same size as depth
	%FDS.k: index1:depth (initial configuration), index2: time
	ndmpm=length(depth);
	ndfds=length(FDS.depth);
	ntime=length(FDS.time);
	idfdsfract=zeros(1,1);
	itimefract=zeros(1,1);
	kbefore=zeros(1,1);
	kafter=zeros(1,1);
	krate=zeros(1,ndmpm);
	
	for idmpm=1:ndmpm
		for itime=1:ntime-1
			if time(idmpm)<FDS.time(itime+1)
				itimefract=itime+(time(idmpm)-FDS.time(itime))/(FDS.time(itime+1)-FDS.time(itime));
				break;
			end
		end
		for idfds=1:ndfds-1
			if depth(idmpm)<FDS.depth(idfds+1)
				idfdsfract=idfds+(depth(idmpm)-FDS.depth(idfds))/(FDS.depth(idfds+1)-FDS.depth(idfds));
				break;
			end
		end
		kbefore=FDS.k(idfds,itime)+(idfdsfract-idfds)*(FDS.k(idfds+1,itime)-FDS.k(idfds,itime));
		kafter=FDS.k(idfds,itime+1)+(idfdsfract-idfds)*(FDS.k(idfds+1,itime+1)-FDS.k(idfds,itime+1));
		krate(idmpm)=(kafter-kbefore)/(FDS.time(itime+1)-FDS.time(itime));
	end
end

function AngleAverageCaller()
	%[D]TDL this function is a main for testing purpose only
	%move back to above angleoutfunc=angleaverage(...
	clc;
	ndata=zeros(1,1);
	ndata=5; %the number of angle inputs
	angleindeg=zeros(1,ndata); %in degrees
	weights=zeros(1,ndata);
	angleindeg(1)=178;
	angleindeg(2)=179;
	angleindeg(3)=0;
	angleindeg(4)=1;
	angleindeg(5)=2;
	%{
	angleindeg(1)=44;
	angleindeg(2)=43;
	angleindeg(3)=42;
	angleindeg(4)=41;
	angleindeg(5)=40;
	%}
	angleinrad=angleindeg*pi/180;
	weights(1)=3;
	weights(2)=2;
	weights(3)=1;
	weights(4)=2;
	weights(5)=2.9;
	angleout_deg=angleaverage(angleindeg,weights,5,5,1);
	disp(['angleout_deg=' num2str(angleout_deg) 'degrees']);
	angleout_rad=angleaverage(angleinrad,weights,5,5,2);
	disp(['angleout_rad=' num2str(angleout_rad) 'radians']);
	disp(['=' num2str(angleout_rad*180/pi) 'degrees']);
end

function angleoutfunc=angleaverage(anglein,weights,nsplit,nrepeat,degorrad)
	%this function operates assuming relevant angle is within 180 degrees
	%anglein as vector, can be degree or rad, must be clarified in degorrad.
	%weights as vector same size as anglein
	%nsplit as integer, how many splits to find the minimum
	%nrepeat as integer, how many iterations in repeating the splits
	%degorrad: process in degree or radian? 1:degree, 2:radian
	%angleoutfunc: the angle output from this function, which would be angleout.deg, i.e. the output is in degrees
	ndata=length(anglein);
	anglecur.start=zeros(1,1); %start of the scan (for 1st round of scan, start is 0, end is 180*(nsplit-1)/nsplit, afterwards it's whatever between the 3 values that yield the lowest error. whether it's degree or rad depends on anglein unit, clarified by degorrad.
	anglecur.end=zeros(1,1); %same as start, whether it's egree or rad depends on anglein unit, clarified by degorrad.
	anglecur.deg=zeros(1,nsplit);
	anglecur.rad=zeros(1,nsplit);
	anglecur.accerror=zeros(1,nsplit); %the error squared, unit depends on anglein, clarified by degorrad.
	anglecur.maxerror=zeros(1,1);
	angleout.deg=zeros(1,1); %the angle with minimum error in degrees
	angleout.rad=zeros(1,1); %the angle with minimum error in radian
	angleout.curerror=zeros(1,1); %current error (for finding minimum), unit (degree/rad) depends on anglein, clarified by degorrad.
	angleout.isplit=zeros(1,1); %the isplit where error is minimum
	wavg.sigmawval=zeros(1,1); %SIGMA weight*value
	wavg.sigmaw=zeros(1,1); %SIGMA weight
	wavg.wavg=zeros(1,1); %weighted average
	angledefault.sumweightangle=zeros(1,1);
	angledefault.sumweight=zeros(1,1);
	angledefault.avg=zeros(1,1);
	
	for idata=1:ndata
		angledefault.sumweightangle=angledefault.sumweightangle+anglein(idata)*weights(idata);
		angledefault.sumweight=angledefault.sumweight+weights(idata);
	end
	angledefault.avg=angledefault.sumweightangle/angledefault.sumweight;
	
	accerror=0;
	anglecur.start=0;
	anglecur.end=180;
	for irepeat=1:nrepeat
		for isplit=1:nsplit
			if irepeat==1
				anglecur.deg(isplit)=(isplit-1)/nsplit*180;
				anglecur.rad(isplit)=anglecur.deg(isplit)/180*pi;
			else
				if degorrad==1
					anglecur.deg(isplit)=roll180(anglecur.start+(isplit-1)/(nsplit-1)*mindiff180(anglecur.end,anglecur.start));
					anglecur.rad(isplit)=anglecur.deg(isplit)/180*pi;
				else	
					anglecur.rad(isplit)=rollpi(anglecur.start+(isplit-1)/(nsplit-1)*mindiffpi(anglecur.end,anglecur.start));
					anglecur.deg(isplit)=anglecur.rad(isplit)*180/pi;
				end
			end
			anglecur.accerror(isplit)=0;
			for idata=1:ndata
				if degorrad==1
					anglecur.accerror(isplit)=anglecur.accerror(isplit)+weights(idata)*(mindiff180(anglecur.deg(isplit),anglein(idata)))^2; %in degrees squared
				else
					anglecur.accerror(isplit)=anglecur.accerror(isplit)+weights(idata)*(mindiffpi(anglecur.rad(isplit),anglein(idata)))^2; %in rad squared
				end	
			end
		end
		for isplit=1:nsplit
			if isplit==1
				angleout.deg=anglecur.deg(isplit);
				angleout.rad=anglecur.rad(isplit);
				angleout.curerror=anglecur.accerror(isplit);
				angleout.isplit=isplit;
			elseif anglecur.accerror(isplit)<angleout.curerror
				angleout.curerror=anglecur.accerror(isplit);
				angleout.deg=anglecur.deg(isplit);
				angleout.rad=anglecur.rad(isplit);
				angleout.isplit=isplit;
			end
		end
		if degorrad==1
			anglecur.start=anglecur.deg(roll1ton(angleout.isplit-1,nsplit));
			anglecur.end=anglecur.deg(roll1ton(angleout.isplit+1,nsplit));
			anglecur.maxerror=mindiff180(anglecur.start,anglecur.end);
		else
			anglecur.start=anglecur.rad(roll1ton(angleout.isplit-1,nsplit));
			anglecur.end=anglecur.rad(roll1ton(angleout.isplit+1,nsplit));
			anglecur.maxerror=mindiffpi(anglecur.start,anglecur.end);
		end
	end
	%{
	for idata=1:ndata
		wavg.sigmawval=wavg.sigmawval+weights(idata)*anglein(idata);
		wavg.sigmaw=wavg.sigmaw+weights(idata);
	end
	wavg.wavg=wavg.sigmawval/wavg.sigmaw;
	disp(['wavg.wavg=' num2str(wavg.wavg)]);
	disp(['angleout.deg=' num2str(angleout.deg)]);
	%}
	if degorrad==1
		if mindiff180(angledefault.avg,angleout.deg)<anglecur.maxerror
			angleoutfunc=angledefault.avg;
		else
			angleoutfunc=angleout.deg;
		end
	else
		if mindiffpi(angledefault.avg,angleout.rad)<anglecur.maxerror
			angleoutfunc=angledefault.avg;
		else
			angleoutfunc=angleout.rad;
		end
	end
end

function themindiff2pi=mindiff2pi(num_in1,num_in2)
	themindiff2pi=min([roll2pi(num_in1-num_in2) roll2pi(num_in2-num_in1)]);
end

function rolled2pi=roll2pi(num_in);
	rolled2pi=mod(num_in,2*pi);
end

function themindiffpi=mindiffpi(num_in1,num_in2)
	themindiffpi=min([rollpi(num_in1-num_in2) rollpi(num_in2-num_in1)]);
end

function rolledpi=rollpi(num_in);
	rolledpi=mod(num_in,pi);
end

function rolled1ton=roll1ton(num_in,n_roll);%roll one to n, n is the input
	%this rolls from 1 to n_roll.
	%for example, if n_roll=3, then:
	%num_in=3 results in rolled1ton=3
	%num_in=4 results in rolled1ton=1
	%num_in=0 results in rolled1ton=3
	rolled1ton=mod(num_in-1,n_roll)+1;
end

function themindiff360=mindiff360(num_in1,num_in2)
	themindiff360=min([roll360(num_in1-num_in2) roll360(num_in2-num_in1)]);
end

function rolled360=roll360(num_in);
	rolled360=mod(num_in,360);
end

function themindiff180=mindiff180(num_in1,num_in2)
	themindiff180=min([roll180(num_in1-num_in2) roll180(num_in2-num_in1)]);
end

function rolled180=roll180(num_in);
	rolled180=mod(num_in,180);
end

function y=sinpropagate(xstart,xend,yend,x,derivative)
	%derivative=-1: returns int(ydx)
	%derivative=0: returns y
	%derivative=1: returns y dot
	if derivative==0
		if x<xstart
			y=0;
		elseif x>xend
			y=yend;
		else
			y=yend*(0.5-0.5*cos((x-xstart)/(xend-xstart)*pi));
		end
	elseif derivative==1
		if x<xstart
			y=0;
		elseif x>xend
			y=0;
		else
			y=(yend*pi*sin((pi*(x-xstart))/(xend-xstart)))/(2*(xend-xstart));
		end
	elseif derivative==-1
		if x<xstart
			y=0;
		elseif x>xend
			y=(yend*(x-xstart))/2-(yend*sin((pi*(x-xstart))/(xend-xstart))*(xend-xstart))/(2*pi);
		else
			y=yend*(x-xend)+(yend*(xend-xstart))/2;
		end
	else
		y=0;
	end
end

function epsilonout=strainconverter(epsilonin,conversionnum)
	%conversionnum=1: eng to log
	%conversionnum=2: log to eng
	%conversionnum=3: true to log
	%conversionnum=4: log to true
	theta=-0.5*reliableatan((epsilonin(1,1)-epsilonin(2,2))/2,-epsilonin(1,2));
	n1prime=[cos(theta) sin(theta)];
	n2prime=[cos(theta+pi/2) sin(theta+pi/2)];
	A=[n1prime;n2prime];
	epsilonin_princ=zeros(2,2);
	for idim1=1:2
	for idim2=1:2
	for idim3=1:2
	for idim4=1:2
		epsilonin_princ(idim1,idim2)=epsilonin_princ(idim1,idim2)+A(idim1,idim3)*A(idim2,idim4)*epsilonin(idim3,idim4);
	end
	end
	end
	end
	epsilonout_princ=zeros(2,2);
	for idim=1:2
		switch conversionnum
			case 1
				epsilonout_princ(idim,idim)=log(1+epsilonin_princ(idim,idim));
			case 2
				epsilonout_princ(idim,idim)=exp(epsilonin_princ(idim,idim))-1;
			case 3
				epsilonout_princ(idim,idim)=log(1/(1-epsilonin_princ(idim,idim)));
			case 4
				epsilonout_princ(idim,idim)=1-(1/exp(epsilonin_princ(idim,idim)));
			otherwise
				epsilonout_princ(idim,idim)=epsilonin_princ(idim,idim);
		end
	end

	epsilonout=zeros(2,2);
	for idim1=1:2
	for idim2=1:2
	for idim3=1:2
	for idim4=1:2
		epsilonout(idim1,idim2)=epsilonout(idim1,idim2)+A(idim3,idim1)*A(idim4,idim2)*epsilonout_princ(idim3,idim4);
	end
	end
	end
	end
end

function y_out=arbitrarybasis(x_known,y_known,x_in)
	a=zeros(1,length(x_known));
	for i=1:length(x_known)
		divider=1;
		for j=1:length(x_known)
			if i==j
				continue;
			end
			divider=divider*(x_known(i)-x_known(j));
		end
		a(i)=y_known(i)/divider;
	end


	y_out=zeros(1,length(x_in));
	for itrial=1:length(x_in)
		for i=1:length(x_known)
			term=1;
			for j=1:length(x_known)
				if i==j
					continue;
				end
				term=term*(x_in(itrial)-x_known(j));
			end
			term=term*a(i);
			y_out(itrial)=y_out(itrial)+term;
		end
	end
end

function someoutput=printstring(thepause,thestring,thename)
	fprintf('%s',[thename '=' thestring char(10)]);
	if thepause
		input_codegen(['In printstring, press enter to continue!' char(10)]);
	end
	someoutput=0;
end

function someoutput=printfloat(thepause,thefloat,thename)
	fprintf('%s',[thename '=' float2scitxt(5,thefloat) char(10)]);
	if thepause
		input_codegen(['In printfloat, press enter to continue!' char(10)]);
	end
	someoutput=0;
end

function someoutput=printtext(thepause,textinput)
	fprintf('%s',[textinput char(10)]);
	if thepause
		input_codegen(['In printtext, press enter to continue!' char(10)]);
	end
	someoutput=0;
end

function resp = input_codegen(prompt)
	%#codegen
	coder.extrinsic('input');
	if coder.target('MEX') || coder.target('MATLAB') || coder.target('Sfun')
		resp = input(prompt, 's');
	else
		%Note: FYI executable flows here.
		coder.cinclude('<stdio.h>');
		fprintf('%s',prompt);
		cresp = char(zeros(1,1024));
		coder.ceval('fgets',coder.ref(cresp(1)), 1023, coder.opaque('FILE*','stdin'));
		% Call strlen in C and trim output
		slen = int32(1);
		slen = coder.ceval('strlen',coder.rref(cresp(1)));
		resp = cresp(1:slen);
	end
end

% === START OF INPUT FILE READER === %

function ValueOutput=str2float(text)
	textchar=double(char(text));
	if length(textchar)>0
		% ReadState legend: 0: integer reading, 1: decimal reading, 2: exponential reading
		% char(48-57): numbers 0-9 X
		% char(9): tab
		% char(32): space
		% char(10): enter X
		% char(101): e X
		% char(43): + X
		% char(45): -
		% char(46): . X
		
		ReadState=0;
		CurrentNumber=0;
		CurrentExponent=0;
		CurrentDigit=0;
		NegativeSignNumber=0;
		NegativeSignExponent=0;
		DecimalDistance=0;
		for i=1:length(textchar)
			if textchar(i)==46
				ReadState=1;
				DecimalDistance=1;
			elseif textchar(i)==101 || textchar(i)==69
				ReadState=2;
				NegativeSignExponent=0;
				CurrentExponent=0;
			elseif textchar(i)==43
				if ReadState==2
					NegativeSignExponent=0;
				else
					NegativeSignNumber=0;
				end
			elseif textchar(i)==45
				if ReadState==2
					NegativeSignExponent=1;
				else
					NegativeSignNumber=1;
				end
			elseif textchar(i)>=48 && textchar(i)<=57
				CurrentDigit=textchar(i)-48;
				if ReadState==0
					CurrentNumber=CurrentNumber*10+CurrentDigit;
				elseif ReadState==1
					CurrentNumber=CurrentNumber+CurrentDigit/(10^DecimalDistance);
					DecimalDistance=DecimalDistance+1;
				elseif ReadState==2
					CurrentExponent=CurrentExponent*10+CurrentDigit;
				end				
			end
		end
		ValueOutput=((-1)^(NegativeSignNumber))*CurrentNumber*(10^(((-1)^(NegativeSignExponent))*(CurrentExponent)));
	else
		ValueOutput=0;
	end	
end

function ValueOutput=str2long(text)
	textchar=double(char(text));
	if length(textchar)>0
		% ReadState legend: 0: integer reading, 1: decimal reading, 2: exponential reading
		% char(48-57): numbers 0-9 X
		% char(9): tab
		% char(32): space
		% char(10): enter X
		% char(101): e X
		% char(43): + X
		% char(45): -
		% char(46): . X
		
		ReadState=0;
		CurrentNumber=0;
		CurrentDigit=0;
		NegativeSignNumber=0;
		DecimalDistance=0;
		for i=1:length(textchar)
			if textchar(i)==9 || textchar(i)==10
				ValueOutput=((-1)^(NegativeSignNumber))*CurrentNumber;
				ReadState=0;
				CurrentNumber=0;
				CurrentExponent=0;
				NegativeSignNumber=0;
				NegativeSignExponent=0;
			elseif textchar(i)==46
				ReadState=1;
				DecimalDistance=1;
			elseif textchar(i)==43
				NegativeSignNumber=0;
			elseif textchar(i)==45
				NegativeSignNumber=1;
			elseif textchar(i)>=48 && textchar(i)<=57
				CurrentDigit=textchar(i)-48;
				if ReadState==0
					CurrentNumber=CurrentNumber*10+CurrentDigit;
				elseif ReadState==1
					CurrentNumber=CurrentNumber+CurrentDigit/(10^DecimalDistance);
					DecimalDistance=DecimalDistance+1;
				end				
			end
		end
		ValueOutput=((-1)^(NegativeSignNumber))*CurrentNumber;
	else
		ValueOutput=0;
	end
end

function theoutput = loadvariable(vartoload)
	%char(61)='='
	%char(124)='|'
	stringmaxlength=128;
	theoutput.found=0;
	theoutput.valuetext=char(zeros(1,stringmaxlength));
	coder.varsize('theoutput.valuetext');
	theoutput.type=char(zeros(1,stringmaxlength));
	coder.varsize('theoutput.type');
	theoutput.valuetext='';
	enterchars=[10 13];
	spacechars=[9 32];
	TextFileOpen=fopen('input.txt');
	TextFileChar=fread(TextFileOpen,[1,Inf],'char');
	fclose(TextFileOpen);
	%modes:
		%0:looking for start of variable name (triggered by enter)
		%1:looking for end of variable name (triggered by space or equal sign), dumping the variable name
		%2:looking for start of variable value
		%3:looking for end of variable value
		%4:looking for start of variable type
		%5:looking for end of variable type
		%6:not doing anything, just looking for new line
	mode=0;
	varnamestart=0;
	varnameend=0;
	varname=zeros(1,stringmaxlength);
	coder.varsize('varname');
	varname=[];
	
	varvaluestart=0;
	varvalueend=0;
	varvalue=zeros(1,stringmaxlength);
	coder.varsize('varvalue');
	varvalue=[];
	
	vartypestart=0;
	vartypeend=0;
	vartype=zeros(1,stringmaxlength);
	coder.varsize('vartype');
	vartype=[];
	
	for i=1:length(TextFileChar)
		if TextFileChar(i)==37
			mode=-1; %skip until we see new line
		end
		if mode==0
			if ~ismember(TextFileChar(i),spacechars) && ~ismember(TextFileChar(i),enterchars) && TextFileChar(i)~=61
				varnamestart=i;
				mode=1;
			end
		elseif mode==1
			if ismember(TextFileChar(i),spacechars) || ismember(TextFileChar(i),enterchars) || TextFileChar(i)==61
				varnameend=i-1;
				mode=2;
				if varnamestart~=0 && varnameend~=0
					varname=TextFileChar(varnamestart:varnameend); %coder alert, needs smarter way
				else
					varname=[];
				end
				%disp(['varname=' char2str(varname)]);
				varnamestart=0;
				varnameend=0;
			end
		elseif mode==2
			if ~ismember(TextFileChar(i),spacechars) && ~ismember(TextFileChar(i),enterchars) && TextFileChar(i)~=61
				varvaluestart=i;
				mode=3;
			end
		elseif mode==3
			if ismember(TextFileChar(i),spacechars) || ismember(TextFileChar(i),enterchars) || TextFileChar(i)==124 %we added the 124 for completeness
				varvalueend=i-1;
				mode=4;
				if varvaluestart~=0 && varvalueend~=0
					varvalue=TextFileChar(varvaluestart:varvalueend); %coder alert, needs smarter way
				else
					varvalue=[];
				end
				%disp(['varvalue=' char2str(varvalue)]);
				varvaluestart=0;
				varvalueend=0;
			end
		elseif mode==4
			if ~ismember(TextFileChar(i),spacechars) && ~ismember(TextFileChar(i),enterchars) && TextFileChar(i)~=124
				vartypestart=i;
				mode=5;
			end
		elseif mode==5
			if ismember(TextFileChar(i),spacechars) || ismember(TextFileChar(i),enterchars) || TextFileChar(i)==-2 %fill this in with whatever's the next parameter
				vartypeend=i-1;
				mode=6;
				if vartypestart~=0 && vartypeend~=0
					vartype=TextFileChar(vartypestart:vartypeend); %coder alert, needs smarter way
				else
					vartype=[];
				end
				%disp(['vartype=' char2str(vartype)]);
				varvaluestart=0;
				vartypeend=0;
			end
		end
		if ismember(TextFileChar(i),enterchars) || i==length(TextFileChar)
			if CompareTexts(varname,vartoload)
				theoutput.found=1;
				theoutput.valuetext=char(varvalue);
				theoutput.type=char(vartype);
				return;
			end
			mode=0;
			varnamestart=0;
			varnameend=0;
			varname=[];
			varvaluestart=0;
			varvalueend=0;
			varvalue=[];
			vartypestart=0;
			vartypeend=0;
			vartype=[];
		end
	end
	theoutput.found=0;
	theoutput.valuetext='';
	theoutput.type='';
	%if ismember(10,enterchars)
		%disp('its in member');
	%end
end

% ===  END OF INPUT FILE READER  === %

%similar to:
%/d/users/tito/documents/Combined_2020-11-26/zz2105212306.m
